<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Maps and Sets</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
          }
          return content;
        }
      };



      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic', defaultTippyProps);



      /*
      tippy('.hl.lean .tactic', {
        allowHtml: true,

        onHide(any) { return false; },
        trigger: "click",

        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
      */
  });
}
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script type="module" src="static/search/search-init.js"></script>
    <script defer="defer" data-domain="lean-lang.org/doc/reference/latest" src="https://plausible.io/js/script.outbound-links.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="current numbered"><td class="num">18.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-basic-types" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-basic-types" checked="checked"></label><span class="number">18.</span> <span class=""><a href="Basic-Types/#basic-types">Basic Types</a></span></div>
              <table><tr class="numbered"><td class="num">18.1.</td><td><a href="Basic-Types/Natural-Numbers/#Nat">Natural Numbers</a></td></tr><tr class="numbered"><td class="num">18.2.</td><td><a href="Basic-Types/Integers/#Int">Integers</a></td></tr><tr class="numbered"><td class="num">18.3.</td><td><a href="Basic-Types/Finite-Natural-Numbers/#Fin">Finite Natural Numbers</a></td></tr><tr class="numbered"><td class="num">18.4.</td><td><a href="Basic-Types/Fixed-Precision-Integers/#fixed-ints">Fixed-Precision Integers</a></td></tr><tr class="numbered"><td class="num">18.5.</td><td><a href="Basic-Types/Bitvectors/#BitVec">Bitvectors</a></td></tr><tr class="numbered"><td class="num">18.6.</td><td><a href="Basic-Types/Floating-Point-Numbers/#Float">Floating-Point Numbers</a></td></tr><tr class="numbered"><td class="num">18.7.</td><td><a href="Basic-Types/Characters/#Char">Characters</a></td></tr><tr class="numbered"><td class="num">18.8.</td><td><a href="Basic-Types/Strings/#String">Strings</a></td></tr><tr class="numbered"><td class="num">18.9.</td><td><a href="Basic-Types/The-Unit-Type/#The-Lean-Language-Reference--Basic-Types--The-Unit-Type">The Unit Type</a></td></tr><tr class="numbered"><td class="num">18.10.</td><td><a href="Basic-Types/The-Empty-Type/#empty">The Empty Type</a></td></tr><tr class="numbered"><td class="num">18.11.</td><td><a href="Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans">Booleans</a></td></tr><tr class="numbered"><td class="num">18.12.</td><td><a href="Basic-Types/Optional-Values/#option">Optional Values</a></td></tr><tr class="numbered"><td class="num">18.13.</td><td><a href="Basic-Types/Tuples/#tuples">Tuples</a></td></tr><tr class="numbered"><td class="num">18.14.</td><td><a href="Basic-Types/Sum-Types/#sum-types">Sum Types</a></td></tr><tr class="numbered"><td class="num">18.15.</td><td><a href="Basic-Types/Linked-Lists/#List">Linked Lists</a></td></tr><tr class="numbered"><td class="num">18.16.</td><td><a href="Basic-Types/Arrays/#Array">Arrays</a></td></tr><tr class="current numbered"><td class="num">18.17.</td><td><a href="Basic-Types/Maps-and-Sets/#maps">Maps and Sets</a></td></tr><tr class="numbered"><td class="num">18.18.</td><td><a href="Basic-Types/Subtypes/#Subtype">Subtypes</a></td></tr><tr class="numbered"><td class="num">18.19.</td><td><a href="Basic-Types/Lazy-Computations/#Thunk">Lazy Computations</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-maps" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-maps" checked="checked"></label><span class="number">18.17.</span> <span class="current"><a href="Basic-Types/Maps-and-Sets/#maps">Maps and Sets</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design">Library Design</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design--Fused-Operations">Fused Operations</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="Basic-Types/Maps-and-Sets/#raw-data">Raw Data and Invariants</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design--Suitable-Operators-for-Uniqueness">Suitable Operators for Uniqueness</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Basic-Types/Maps-and-Sets/#HashMap">Hash Maps</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><code>HashMap</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Creation">Creation</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___emptyWithCapacity"><code>Std.HashMap.emptyWithCapacity</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.2.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Properties">Properties</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___size"><code>Std.HashMap.size</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___isEmpty"><code>Std.HashMap.isEmpty</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Equiv___mk"><code>Std.HashMap.Equiv</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap____FLQQ_term____m__FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">~m</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Queries">Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___contains"><code>Std.HashMap.contains</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___get"><code>Std.HashMap.get</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___get___"><code>Std.HashMap.get!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___get___-next"><code>Std.HashMap.get?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___getD"><code>Std.HashMap.getD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___getKey"><code>Std.HashMap.getKey</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___getKey___"><code>Std.HashMap.getKey!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___getKey___-next"><code>Std.HashMap.getKey?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___getKeyD"><code>Std.HashMap.getKeyD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___keys"><code>Std.HashMap.keys</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___keysArray"><code>Std.HashMap.keysArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___values"><code>Std.HashMap.values</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___valuesArray"><code>Std.HashMap.valuesArray</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.4.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Modification">Modification</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___alter"><code>Std.HashMap.alter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___modify"><code>Std.HashMap.modify</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___containsThenInsert"><code>Std.HashMap.containsThenInsert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___containsThenInsertIfNew"><code>Std.HashMap.containsThenInsertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___erase"><code>Std.HashMap.erase</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___filter"><code>Std.HashMap.filter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___filterMap"><code>Std.HashMap.filterMap</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___insert"><code>Std.HashMap.insert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___insertIfNew"><code>Std.HashMap.insertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___getThenInsertIfNew___"><code>Std.HashMap.getThenInsertIfNew?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___insertMany"><code>Std.HashMap.insertMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___insertManyIfNewUnit"><code>Std.HashMap.insertManyIfNewUnit</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___partition"><code>Std.HashMap.partition</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___union"><code>Std.HashMap.union</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.5.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Iteration">Iteration</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___map"><code>Std.HashMap.map</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___fold"><code>Std.HashMap.fold</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___foldM"><code>Std.HashMap.foldM</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___forIn"><code>Std.HashMap.forIn</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___forM"><code>Std.HashMap.forM</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.6.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Conversion">Conversion</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___ofList"><code>Std.HashMap.ofList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___toArray"><code>Std.HashMap.toArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___toList"><code>Std.HashMap.toList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___unitOfArray"><code>Std.HashMap.unitOfArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___unitOfList"><code>Std.HashMap.unitOfList</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.7.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Unbundled-Variants">Unbundled Variants</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><code>Std.HashMap.Raw</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><code>Std.HashMap.Raw.WF</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Basic-Types/Maps-and-Sets/#DHashMap">Dependent Hash Maps</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><code>DHashMap</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Creation">Creation</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___emptyWithCapacity"><code>Std.DHashMap.emptyWithCapacity</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.2.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Properties">Properties</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___size"><code>Std.DHashMap.size</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___isEmpty"><code>Std.DHashMap.isEmpty</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Equiv___mk"><code>Std.DHashMap.Equiv</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap____FLQQ_term____m__FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">~m</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Queries">Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___contains"><code>Std.DHashMap.contains</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___get"><code>Std.DHashMap.get</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___get___"><code>Std.DHashMap.get!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___get___-next"><code>Std.DHashMap.get?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___getD"><code>Std.DHashMap.getD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___getKey"><code>Std.DHashMap.getKey</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___getKey___"><code>Std.DHashMap.getKey!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___getKey___-next"><code>Std.DHashMap.getKey?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___getKeyD"><code>Std.DHashMap.getKeyD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___keys"><code>Std.DHashMap.keys</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___keysArray"><code>Std.DHashMap.keysArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___values"><code>Std.DHashMap.values</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___valuesArray"><code>Std.DHashMap.valuesArray</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.4.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Modification">Modification</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___alter"><code>Std.DHashMap.alter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___modify"><code>Std.DHashMap.modify</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___containsThenInsert"><code>Std.DHashMap.containsThenInsert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___containsThenInsertIfNew"><code>Std.DHashMap.containsThenInsertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___erase"><code>Std.DHashMap.erase</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___filter"><code>Std.DHashMap.filter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___filterMap"><code>Std.DHashMap.filterMap</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___insert"><code>Std.DHashMap.insert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___insertIfNew"><code>Std.DHashMap.insertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___getThenInsertIfNew___"><code>Std.DHashMap.getThenInsertIfNew?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___insertMany"><code>Std.DHashMap.insertMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___partition"><code>Std.DHashMap.partition</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___union"><code>Std.DHashMap.union</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.5.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Iteration">Iteration</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___map"><code>Std.DHashMap.map</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___fold"><code>Std.DHashMap.fold</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___foldM"><code>Std.DHashMap.foldM</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___forIn"><code>Std.DHashMap.forIn</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___forM"><code>Std.DHashMap.forM</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.6.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Conversion">Conversion</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___ofList"><code>Std.DHashMap.ofList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___toArray"><code>Std.DHashMap.toArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___toList"><code>Std.DHashMap.toList</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.7.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Unbundled-Variants">Unbundled Variants</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><code>Std.DHashMap.Raw</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><code>Std.DHashMap.Raw.WF</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Basic-Types/Maps-and-Sets/#ExtHashMap">Extensional Hash Maps</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><code>ExtHashMap</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Creation">Creation</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___emptyWithCapacity"><code>Std.ExtHashMap.emptyWithCapacity</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.2.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Properties">Properties</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___size"><code>Std.ExtHashMap.size</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___isEmpty"><code>Std.ExtHashMap.isEmpty</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Queries">Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___contains"><code>Std.ExtHashMap.contains</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___get"><code>Std.ExtHashMap.get</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___get___"><code>Std.ExtHashMap.get!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___get___-next"><code>Std.ExtHashMap.get?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___getD"><code>Std.ExtHashMap.getD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___getKey"><code>Std.ExtHashMap.getKey</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___getKey___"><code>Std.ExtHashMap.getKey!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___getKey___-next"><code>Std.ExtHashMap.getKey?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___getKeyD"><code>Std.ExtHashMap.getKeyD</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.4.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Modification">Modification</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___alter"><code>Std.ExtHashMap.alter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___modify"><code>Std.ExtHashMap.modify</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___containsThenInsert"><code>Std.ExtHashMap.containsThenInsert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___containsThenInsertIfNew"><code>Std.ExtHashMap.containsThenInsertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___erase"><code>Std.ExtHashMap.erase</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___filter"><code>Std.ExtHashMap.filter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___filterMap"><code>Std.ExtHashMap.filterMap</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___insert"><code>Std.ExtHashMap.insert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___insertIfNew"><code>Std.ExtHashMap.insertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___getThenInsertIfNew___"><code>Std.ExtHashMap.getThenInsertIfNew?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___insertMany"><code>Std.ExtHashMap.insertMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___insertManyIfNewUnit"><code>Std.ExtHashMap.insertManyIfNewUnit</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.5.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Iteration">Iteration</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___map"><code>Std.ExtHashMap.map</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.6.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Conversion">Conversion</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___ofList"><code>Std.ExtHashMap.ofList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___unitOfArray"><code>Std.ExtHashMap.unitOfArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___unitOfList"><code>Std.ExtHashMap.unitOfList</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="Basic-Types/Maps-and-Sets/#ExtDHashMap">Extensional Dependent Hash Maps</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><code>ExtDHashMap</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Creation">Creation</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___emptyWithCapacity"><code>Std.ExtDHashMap.emptyWithCapacity</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.2.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Properties">Properties</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___size"><code>Std.ExtDHashMap.size</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___isEmpty"><code>Std.ExtDHashMap.isEmpty</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Queries">Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___contains"><code>Std.ExtDHashMap.contains</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___get"><code>Std.ExtDHashMap.get</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___get___"><code>Std.ExtDHashMap.get!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___get___-next"><code>Std.ExtDHashMap.get?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___getD"><code>Std.ExtDHashMap.getD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___getKey"><code>Std.ExtDHashMap.getKey</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___getKey___"><code>Std.ExtDHashMap.getKey!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___getKey___-next"><code>Std.ExtDHashMap.getKey?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___getKeyD"><code>Std.ExtDHashMap.getKeyD</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.4.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Modification">Modification</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___alter"><code>Std.ExtDHashMap.alter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___modify"><code>Std.ExtDHashMap.modify</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___containsThenInsert"><code>Std.ExtDHashMap.containsThenInsert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___containsThenInsertIfNew"><code>Std.ExtDHashMap.containsThenInsertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___erase"><code>Std.ExtDHashMap.erase</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___filter"><code>Std.ExtDHashMap.filter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___filterMap"><code>Std.ExtDHashMap.filterMap</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___insert"><code>Std.ExtDHashMap.insert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___insertIfNew"><code>Std.ExtDHashMap.insertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___getThenInsertIfNew___"><code>Std.ExtDHashMap.getThenInsertIfNew?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___insertMany"><code>Std.ExtDHashMap.insertMany</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.5.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Iteration">Iteration</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___map"><code>Std.ExtDHashMap.map</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.6.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Conversion">Conversion</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___ofList"><code>Std.ExtDHashMap.ofList</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">6.</span> <a href="Basic-Types/Maps-and-Sets/#HashSet">Hash Sets</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><code>HashSet</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Creation">Creation</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___emptyWithCapacity"><code>Std.HashSet.emptyWithCapacity</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.2.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Properties">Properties</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___isEmpty"><code>Std.HashSet.isEmpty</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___size"><code>Std.HashSet.size</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Equiv___mk"><code>Std.HashSet.Equiv</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashMap____FLQQ_term____m__FLQQ_-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">~m</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Queries">Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___contains"><code>Std.HashSet.contains</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___get"><code>Std.HashSet.get</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___get___"><code>Std.HashSet.get!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___get___-next"><code>Std.HashSet.get?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___getD"><code>Std.HashSet.getD</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.4.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Modification">Modification</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___insert"><code>Std.HashSet.insert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___insertMany"><code>Std.HashSet.insertMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___erase"><code>Std.HashSet.erase</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___filter"><code>Std.HashSet.filter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___containsThenInsert"><code>Std.HashSet.containsThenInsert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___partition"><code>Std.HashSet.partition</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___union"><code>Std.HashSet.union</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.5.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Iteration">Iteration</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___all"><code>Std.HashSet.all</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___any"><code>Std.HashSet.any</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___fold"><code>Std.HashSet.fold</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___foldM"><code>Std.HashSet.foldM</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___forIn"><code>Std.HashSet.forIn</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___forM"><code>Std.HashSet.forM</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.6.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Conversion">Conversion</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___ofList"><code>Std.HashSet.ofList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___toList"><code>Std.HashSet.toList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___ofArray"><code>Std.HashSet.ofArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___toArray"><code>Std.HashSet.toArray</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">6.7.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Unbundled-Variants">Unbundled Variants</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Raw___mk"><code>Std.HashSet.Raw</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Raw___WF___mk"><code>Std.HashSet.Raw.WF</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">7.</span> <a href="Basic-Types/Maps-and-Sets/#ExtHashSet">Extensional Hash Sets</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><code>ExtHashSet</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">7.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Creation">Creation</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___emptyWithCapacity"><code>Std.ExtHashSet.emptyWithCapacity</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">7.2.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Properties">Properties</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___isEmpty"><code>Std.ExtHashSet.isEmpty</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___size"><code>Std.ExtHashSet.size</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">7.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Queries">Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___contains"><code>Std.ExtHashSet.contains</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___get"><code>Std.ExtHashSet.get</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___get___"><code>Std.ExtHashSet.get!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___get___-next"><code>Std.ExtHashSet.get?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___getD"><code>Std.ExtHashSet.getD</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">7.4.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Modification">Modification</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___insert"><code>Std.ExtHashSet.insert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___insertMany"><code>Std.ExtHashSet.insertMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___erase"><code>Std.ExtHashSet.erase</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___filter"><code>Std.ExtHashSet.filter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___containsThenInsert"><code>Std.ExtHashSet.containsThenInsert</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">7.5.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Conversion">Conversion</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___ofList"><code>Std.ExtHashSet.ofList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___ofArray"><code>Std.ExtHashSet.ofArray</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">8.</span> <a href="Basic-Types/Maps-and-Sets/#TreeMap">Tree-Based Maps</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><code>TreeMap</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">8.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Creation">Creation</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___empty"><code>Std.TreeMap.empty</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">8.2.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Properties">Properties</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><code>Std.TreeMap.size</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___isEmpty"><code>Std.TreeMap.isEmpty</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">8.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Queries">Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___contains"><code>Std.TreeMap.contains</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___get"><code>Std.TreeMap.get</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___get___"><code>Std.TreeMap.get!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___get___-next"><code>Std.TreeMap.get?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getD"><code>Std.TreeMap.getD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKey"><code>Std.TreeMap.getKey</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKey___"><code>Std.TreeMap.getKey!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKey___-next"><code>Std.TreeMap.getKey?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyD"><code>Std.TreeMap.getKeyD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___keys"><code>Std.TreeMap.keys</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___keysArray"><code>Std.TreeMap.keysArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___values"><code>Std.TreeMap.values</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___valuesArray"><code>Std.TreeMap.valuesArray</code></a></li>
                <li>
                  <span class="header head-3"><span class="level-num">8.3.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Queries--Ordering-Based-Queries">Ordering-Based Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___entryAtIdx"><code>entryAtIdx</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___entryAtIdx___"><code>entryAtIdx!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___entryAtIdx___-next"><code>entryAtIdx?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___entryAtIdxD"><code>entryAtIdxD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryGE"><code>getEntryGE</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryGE___"><code>getEntryGE!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryGE___-next"><code>getEntryGE?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryGED"><code>getEntryGED</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryGT"><code>getEntryGT</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryGT___"><code>getEntryGT!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryGT___-next"><code>getEntryGT?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryGTD"><code>getEntryGTD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryLE"><code>getEntryLE</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryLE___"><code>getEntryLE!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryLE___-next"><code>getEntryLE?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryLED"><code>getEntryLED</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryLT"><code>getEntryLT</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryLT___"><code>getEntryLT!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryLT___-next"><code>getEntryLT?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getEntryLTD"><code>getEntryLTD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getGE"><code>getGE</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getGT"><code>getGT</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyGE"><code>getKeyGE</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyGE___"><code>getKeyGE!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyGE___-next"><code>getKeyGE?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyGED"><code>getKeyGED</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyGT"><code>getKeyGT</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyGT___"><code>getKeyGT!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyGT___-next"><code>getKeyGT?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyGTD"><code>getKeyGTD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyLE"><code>getKeyLE</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyLE___"><code>getKeyLE!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyLE___-next"><code>getKeyLE?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyLED"><code>getKeyLED</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyLT"><code>getKeyLT</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyLT___"><code>getKeyLT!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyLT___-next"><code>getKeyLT?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getKeyLTD"><code>getKeyLTD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getLE"><code>getLE</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getLT"><code>getLT</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___keyAtIdx"><code>keyAtIdx</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___keyAtIdx___"><code>keyAtIdx!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___keyAtIdx___-next"><code>keyAtIdx?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___keyAtIdxD"><code>keyAtIdxD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___minEntry"><code>minEntry</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___minEntry___"><code>minEntry!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___minEntry___-next"><code>minEntry?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___minEntryD"><code>minEntryD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___minKey"><code>minKey</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___minKey___"><code>minKey!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___minKey___-next"><code>minKey?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___minKeyD"><code>minKeyD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___maxEntry"><code>maxEntry</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___maxEntry___"><code>maxEntry!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___maxEntry___-next"><code>maxEntry?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___maxEntryD"><code>maxEntryD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___maxKey"><code>maxKey</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___maxKey___"><code>maxKey!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___maxKey___-next"><code>maxKey?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___maxKeyD"><code>maxKeyD</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">8.4.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Modification">Modification</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___alter"><code>Std.TreeMap.alter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___modify"><code>Std.TreeMap.modify</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___containsThenInsert"><code>Std.TreeMap.containsThenInsert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___containsThenInsertIfNew"><code>Std.TreeMap.containsThenInsertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___erase"><code>Std.TreeMap.erase</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___eraseMany"><code>Std.TreeMap.eraseMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___filter"><code>Std.TreeMap.filter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___filterMap"><code>Std.TreeMap.filterMap</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___insert"><code>Std.TreeMap.insert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___insertIfNew"><code>Std.TreeMap.insertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___getThenInsertIfNew___"><code>Std.TreeMap.getThenInsertIfNew?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___insertMany"><code>Std.TreeMap.insertMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___insertManyIfNewUnit"><code>Std.TreeMap.insertManyIfNewUnit</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___mergeWith"><code>mergeWith</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___partition"><code>Std.TreeMap.partition</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">8.5.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Iteration">Iteration</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___map"><code>Std.TreeMap.map</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___all"><code>Std.TreeMap.all</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___any"><code>Std.TreeMap.any</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___foldl"><code>Std.TreeMap.foldl</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___foldlM"><code>Std.TreeMap.foldlM</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___foldr"><code>Std.TreeMap.foldr</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___foldrM"><code>Std.TreeMap.foldrM</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___forIn"><code>Std.TreeMap.forIn</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___forM"><code>Std.TreeMap.forM</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">8.6.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Conversion">Conversion</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___ofList"><code>Std.TreeMap.ofList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___toList"><code>Std.TreeMap.toList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___ofArray"><code>Std.TreeMap.ofArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___toArray"><code>Std.TreeMap.toArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___unitOfArray"><code>Std.TreeMap.unitOfArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___unitOfList"><code>Std.TreeMap.unitOfList</code></a></li>
                <li>
                  <span class="header head-3"><span class="level-num">8.6.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Conversion--Unbundled-Variants">Unbundled Variants</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___mk"><code>Std.TreeMap.Raw</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___WF___mk"><code>Std.TreeMap.Raw.WF</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">9.</span> <a href="Basic-Types/Maps-and-Sets/#DTreeMap">Dependent Tree-Based Maps</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><code>DTreeMap</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">9.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Creation">Creation</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___empty"><code>Std.DTreeMap.empty</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">9.2.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Properties">Properties</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___size"><code>Std.DTreeMap.size</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___isEmpty"><code>Std.DTreeMap.isEmpty</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">9.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Queries">Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___contains"><code>Std.DTreeMap.contains</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___get"><code>Std.DTreeMap.get</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___get___"><code>Std.DTreeMap.get!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___get___-next"><code>Std.DTreeMap.get?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___getD"><code>Std.DTreeMap.getD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___getKey"><code>Std.DTreeMap.getKey</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___getKey___"><code>Std.DTreeMap.getKey!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___getKey___-next"><code>Std.DTreeMap.getKey?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___getKeyD"><code>Std.DTreeMap.getKeyD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___keys"><code>Std.DTreeMap.keys</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___keysArray"><code>Std.DTreeMap.keysArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___values"><code>Std.DTreeMap.values</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___valuesArray"><code>Std.DTreeMap.valuesArray</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">9.4.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Modification">Modification</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___alter"><code>Std.DTreeMap.alter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___modify"><code>Std.DTreeMap.modify</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___containsThenInsert"><code>Std.DTreeMap.containsThenInsert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___containsThenInsertIfNew"><code>Std.DTreeMap.containsThenInsertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___erase"><code>Std.DTreeMap.erase</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___filter"><code>Std.DTreeMap.filter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___filterMap"><code>Std.DTreeMap.filterMap</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___insert"><code>Std.DTreeMap.insert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___insertIfNew"><code>Std.DTreeMap.insertIfNew</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___getThenInsertIfNew___"><code>Std.DTreeMap.getThenInsertIfNew?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___insertMany"><code>Std.DTreeMap.insertMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___partition"><code>Std.DTreeMap.partition</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">9.5.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Iteration">Iteration</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___map"><code>Std.DTreeMap.map</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___foldl"><code>Std.DTreeMap.foldl</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___foldlM"><code>Std.DTreeMap.foldlM</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___forIn"><code>Std.DTreeMap.forIn</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___forM"><code>Std.DTreeMap.forM</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">9.6.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Conversion">Conversion</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___ofList"><code>Std.DTreeMap.ofList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___toArray"><code>Std.DTreeMap.toArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___toList"><code>Std.DTreeMap.toList</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">9.7.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Unbundled-Variants">Unbundled Variants</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___mk"><code>Std.DTreeMap.Raw</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___WF___mk"><code>Std.DTreeMap.Raw.WF</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">10.</span> <a href="Basic-Types/Maps-and-Sets/#TreeSet">Tree-Based Sets</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><code>TreeSet</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">10.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Creation">Creation</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___empty"><code>Std.TreeSet.empty</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">10.2.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Properties">Properties</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___isEmpty"><code>Std.TreeSet.isEmpty</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___size"><code>Std.TreeSet.size</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">10.3.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries">Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___contains"><code>Std.TreeSet.contains</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___get"><code>Std.TreeSet.get</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___get___"><code>Std.TreeSet.get!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___get___-next"><code>Std.TreeSet.get?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getD"><code>Std.TreeSet.getD</code></a></li>
                <li>
                  <span class="header head-3"><span class="level-num">10.3.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries--Ordering-Based-Queries">Ordering-Based Queries</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___atIdx"><code>atIdx</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___atIdx___"><code>atIdx!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___atIdx___-next"><code>atIdx?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___atIdxD"><code>atIdxD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getGE___"><code>getGE!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getGE___-next"><code>getGE?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getGED"><code>getGED</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getGT___"><code>getGT!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getGT___-next"><code>getGT?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getGTD"><code>getGTD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getLE___"><code>getLE!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getLE___-next"><code>getLE?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getLED"><code>getLED</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getLT___"><code>getLT!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getLT___-next"><code>getLT?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___getLTD"><code>getLTD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___min"><code>min</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___min___"><code>min!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___min___-next"><code>min?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___minD"><code>minD</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___max"><code>max</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___max___"><code>max!</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___max___-next"><code>max?</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___maxD"><code>maxD</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">10.4.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Modification">Modification</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___insert"><code>Std.TreeSet.insert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___insertMany"><code>Std.TreeSet.insertMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___containsThenInsert"><code>Std.TreeSet.containsThenInsert</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___erase"><code>Std.TreeSet.erase</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___eraseMany"><code>Std.TreeSet.eraseMany</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___filter"><code>Std.TreeSet.filter</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___merge"><code>merge</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___partition"><code>Std.TreeSet.partition</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">10.5.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Iteration">Iteration</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___all"><code>Std.TreeSet.all</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___any"><code>Std.TreeSet.any</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___foldl"><code>Std.TreeSet.foldl</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___foldlM"><code>Std.TreeSet.foldlM</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___foldr"><code>Std.TreeSet.foldr</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___foldrM"><code>Std.TreeSet.foldrM</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___forIn"><code>Std.TreeSet.forIn</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___forM"><code>Std.TreeSet.forM</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">10.6.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion">Conversion</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___toList"><code>Std.TreeSet.toList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___ofList"><code>Std.TreeSet.ofList</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___toArray"><code>Std.TreeSet.toArray</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___ofArray"><code>Std.TreeSet.ofArray</code></a></li>
                <li>
                  <span class="header head-3"><span class="level-num">10.6.1.</span> <a href="Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion--Unbundled-Variants">Unbundled Variants</a></span></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___mk"><code>Std.TreeSet.Raw</code></a></li>
                <li>
                  <a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___WF___mk"><code>Std.TreeSet.Raw.WF</code></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Basic-Types/Arrays/#Array" rel="prev" title="18.16. Arrays"><span class="arrow">←</span><span class="where">18.16. Arrays</span></a><a class="local-button active" href="Basic-Types/Subtypes/#Subtype" rel="next" title="18.18. Subtypes"><span class="where">18.18. Subtypes</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              18.17. Maps and Sets<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=maps" title="Permalink">🔗</a></span></h1>
            <p>
              A <span id="--tech-term-map" class="def-technical-term"><em>map</em></span> is a data structure that associates keys with values.
They are also referred to as <span id="--tech-term-dictionaries" class="def-technical-term"><em>dictionaries</em></span>, <span id="--tech-term-associative-arrays" class="def-technical-term"><em>associative arrays</em></span>, or simply as hash tables.</p>
            <div class="paragraph">
              <p>
                In Lean, maps may have the following properties:</p>
              <dl><dt> Representation</dt><dd><p>
                    The in-memory representation of a map may be either a tree or a hash table.
  Tree-based representations are better when the <a href="Run-Time-Code/Reference-Counting/#reference-counting">reference</a> to the data structure is shared, because hash tables are based on <a href="Basic-Types/Arrays/#Array">arrays</a>.
  Arrays are copied in full on modification when the reference is not unique, while only the path from the root of the tree to the modified nodes must be copied on modification of a tree.
  Hash tables, on the other hand, can be more efficient when references are not shared, because non-shared arrays can be modified in constant time.
  Furthermore, tree-based maps store data in order and thus support ordered traversals of the data.</p>
                  </dd><dt> Extensionality</dt><dd><p>
                    Maps can be viewed as partial functions from keys to values.
  <span id="--tech-term-Extensional-maps" class="def-technical-term"><em>Extensional maps</em></span><span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span> are maps for which propositional equality matches this interpretation.
  This can be convenient for reasoning, but it also rules out some useful operations that would be able to distinguish between them.
  In general, extensional maps should be used only when needed for verification.</p>
                  </dd><dt> Dependent or Not</dt><dd><p>
                    A <span id="--tech-term-dependent-map" class="def-technical-term"><em>dependent map</em></span><span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span> is one in which the type of each value is determined by its corresponding key, rather than being constant.
  Dependent maps have more expressive power, but are also more difficult to use.
  They impose more requirements on their users.
  For example, many operations on <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">DHashMap</span></a></code> require <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instances rather than <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code>.</p>
                  </dd></dl></div>
            <table class="tabular"><tr><th><p>
                    Map</p>
                  </th><th><p>
                    Representation</p>
                  </th><th><p>
                    Extensional?</p>
                  </th><th><p>
                    Dependent?</p>
                  </th></tr><tr><td><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">TreeMap</span></a></code></p>
                  </td><td><p>
                    Tree</p>
                  </td><td><p>
                    No</p>
                  </td><td><p>
                    No</p>
                  </td></tr><tr><td><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">DTreeMap</span></a></code></p>
                  </td><td><p>
                    Tree</p>
                  </td><td><p>
                    No</p>
                  </td><td><p>
                    Yes</p>
                  </td></tr><tr><td><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">HashMap</span></a></code></p>
                  </td><td><p>
                    Hash Table</p>
                  </td><td><p>
                    No</p>
                  </td><td><p>
                    No</p>
                  </td></tr><tr><td><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">DHashMap</span></a></code></p>
                  </td><td><p>
                    Hash Table</p>
                  </td><td><p>
                    No</p>
                  </td><td><p>
                    Yes</p>
                  </td></tr><tr><td><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">ExtHashMap</span></a></code></p>
                  </td><td><p>
                    Hash Table</p>
                  </td><td><p>
                    Yes</p>
                  </td><td><p>
                    No</p>
                  </td></tr><tr><td><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">ExtDHashMap</span></a></code></p>
                  </td><td><p>
                    Hash Table</p>
                  </td><td><p>
                    Yes</p>
                  </td><td><p>
                    Yes</p>
                  </td></tr></table><p>
              A map can always be used as a set by setting its type of values to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></code>.
The following set types are provided:</p>
            <ul>
              <li>
                <p>
                  <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a></code> is a set based on hash tables. Its performance characteristics are like those of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a></code>: it is based on arrays and can be efficiently updated, but only when not shared.</p>
                </li>
              <li>
                <p>
                  <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a></code> is a set based on balanced trees. Its performance characteristics are like those of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a></code>.</p>
                </li>
              <li>
                <p>
                  <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a></code> is an extensional hash set type that matches the mathematical notion of finite sets: two sets are equal if they contain the same elements.</p>
                </li>
              </ul>
            <section>
              <h2 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design">
                18.17.1. Library Design</h2>
              <p>
                All the basic operations on maps and sets are fully verified.
They are proven correct with respect to simpler models implemented with lists.
At the same time, maps and sets have predictable performance.</p>
              <p>
                Some types include additional operations that are not yet fully verified.
These operations are useful, and not all programs need full verification.
Examples include <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___partition"><span class="const token" data-binding="const-Std.HashMap.partition" data-verso-hover="4664">HashMap.partition</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___filterMap"><span class="const token" data-binding="const-Std.TreeMap.filterMap" data-verso-hover="4665">TreeMap.filterMap</span></a></code>.</p>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design--Fused-Operations">
                  18.17.1.1. Fused Operations</h3>
                <p>
                  It is common to modify a table based on its pre-existing contents.
To avoid having to traverse a data structure twice, many query/modification pairs are provided in “fused” variants that perform a query while modifying a map or set.
In some cases, the result of the query affects the modification.</p>
                <p>
                  For example, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a></code> provides <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___containsThenInsert"><span class="const token" data-binding="const-Std.HashMap.containsThenInsert" data-verso-hover="4666">containsThenInsert</span></a></code>, which inserts a key-value pair into a map while signalling whether it was previously found, and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___containsThenInsertIfNew"><span class="const token" data-binding="const-Std.HashMap.containsThenInsertIfNew" data-verso-hover="4667">containsThenInsertIfNew</span></a></code>, which inserts the new mapping only if it was not previously present.
The <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___alter"><span class="const token" data-binding="const-Std.HashMap.alter" data-verso-hover="4668">alter</span></a></code> function modifies the value for a given key without having to search for the key multiple times; the alternation is performed by a function in which missing values are represented by <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.</p>
                </section>
              <section>
                <h3 id="raw-data">
                  18.17.1.2. Raw Data and Invariants<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=raw-data" title="Permalink">🔗</a></span></h3>
                <p>
                  Both hash-based and tree-based maps rely on certain internal well-formedness invariants, such as that trees are balanced and ordered.
In Lean's standard library, these data structures are represented as a pair of the underlying data with a proof that it is well formed.
This fact is mostly an internal implementation detail; however, it is relevant to users in one situation: this representation prevents them from being used in <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Nested-inductive-types">nested inductive types</a>.</p>
                <p>
                  To enable their use in nested inductive types, the standard library provides “<span id="--tech-term-raw" class="def-technical-term">raw</span>” variants of each container along with separate “unbundled” versions of their invariants.
These use the following naming convention:</p>
                <ul>
                  <li>
                    <p>
                      <code>T.Raw</code> is the version of type <code>T</code> without its invariants. For example, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">Std.HashMap.Raw</span></a></code> is a version of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a></code> without the embedded proofs.</p>
                    </li>
                  <li>
                    <p>
                      <code>T.Raw.WF</code> is the corresponding well-formedness predicate. For example, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4670">Std.HashMap.Raw.WF</span></a></code> asserts that a <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">Std.HashMap.Raw</span></a></code> is well-formed.</p>
                    </li>
                  <li>
                    <p>
                      Each operation on <code>T</code>, called <code>T.f</code>, has a corresponding operation on <code>T.Raw</code> called <code>T.Raw.f</code>. For example, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Std.HashMap.Raw.insert" data-verso-hover="4671">Std.HashMap.Raw.insert</span></code> is the version of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___insert"><span class="const token" data-binding="const-Std.HashMap.insert" data-verso-hover="323">Std.HashMap.insert</span></a></code> to be used with raw hash maps.</p>
                    </li>
                  <li>
                    <p>
                      Each operation <code>T.Raw.f</code> has an associated well-formedness lemma <code>T.Raw.WF.f</code>. For example, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Std.HashMap.Raw.WF.insert" data-verso-hover="4672">Std.HashMap.Raw.WF.insert</span></code> asserts that inserting a new key-value pair into a well-formed raw hash map results in a well-formed raw hash map.</p>
                    </li>
                  </ul>
                <p>
                  Because the vast majority of use cases do not require them, not all lemmas about raw types are imported by default with the data structures.
It is usually necessary to import <code>Std.Data.T.RawLemmas</code> (where <code>T</code> is the data structure in question).</p>
                <p>
                  A nested inductive type that occurs inside a map or set should be defined in three stages:</p>
                <ol start="1">
                  <li>
                    <p>
                      First, define a raw version of the nested inductive type that uses the raw version of the map or set type. Define any necessary operations.</p>
                    </li>
                  <li>
                    <p>
                      Next, define an inductive predicate that asserts that all maps or sets in the raw nested type are well formed. Show that the operations on the raw type preserve well-formedness.</p>
                    </li>
                  <li>
                    <p>
                      Construct an appropriate interface to the nested inductive type by defining an API that proves well-formedness properties as needed, hiding them from users.</p>
                    </li>
                  </ol>
                <details class="example"><summary class="description">Nested Inductive Types with <code>Std.HashMap</code></summary><div class="example-content">
                    <p>
                      This example requires that <code>Std.Data.HashMap.RawLemmas</code> is imported.
To keep the code shorter, the <code>Std</code> namespace is opened:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-7709" data-verso-hover="118">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Std</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The map of an adventure game may consist of a series of rooms, connected by passages.
Each room has a description, and each passage faces in a particular direction.
This can be represented as a recursive structure.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #1 of '_nested.Std.HashMap_1.mk' contains a non valid occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-7996">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="220">Maze</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-8011">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">description</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">passages</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">HashMap</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="220">Maze</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      This definition is rejected:</p>
                    <div class="error">
                      <pre>(kernel) arg #1 of '_nested.Std.HashMap_1.mk' contains a non valid occurrence of the datatypes being declared
</pre></div>
                    <p>
                      Making this work requires separating the well-formedness predicates from the structure.
The first step is to redefine the type without embedded hash map invariants:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-8422">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673" id="RawMaze___passages">RawMaze</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-8440">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="4674" id="RawMaze___passages">description</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675" id="RawMaze___passages">passages</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">Std.HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The most basic raw maze has no passages:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8567">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-RawMaze.base" data-verso-hover="4676" id="RawMaze___base">RawMaze.base</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-8617">where</span><span class="inter-text">
  </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span><span class="inter-text">
  </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∅</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      A passage to a further maze can be added to a raw maze using <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#RawMaze___insert"><span class="const token" data-binding="const-RawMaze.insert" data-verso-hover="4678">RawMaze.insert</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8768">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-RawMaze.insert" data-verso-hover="4678" id="RawMaze___insert">RawMaze.insert</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4679">maze</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="312">direction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4679">next</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4679">maze</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-8863">with</span><span class="inter-text">
    </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4679">maze</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Std.HashMap.Raw.insert" data-verso-hover="4680">insert</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="312">direction</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4679">next</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The second step is to define a well-formedness predicate for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></code> that ensures that each included hash map is well-formed.
If the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4681">passages</span></a></code> field itself is well-formed, and all raw mazes included in it are well-formed, then a raw maze is well-formed.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-9229" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682" id="RawMaze___WF">RawMaze.WF</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-RawMaze.WF.mk" data-verso-hover="4683" id="RawMaze___WF">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="312">description</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="4684">passages</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4679">v</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="4684">passages</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="312">dir</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4679">v</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4679">v</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="4684">passages</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="4684">passages</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Base mazes are well-formed, and inserting a passage to a well-formed maze into some other well-formed maze produces a well-formed maze:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-9580">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-RawMaze.base_wf" data-verso-hover="4686" id="RawMaze___base_wf">RawMaze.base_wf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">RawMaze.WF</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___base"><span class="const token" data-binding="const-RawMaze.base" data-verso-hover="4676">.base</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7648289430305445212-9667-9669"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-9667" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7648289430305445212-9667-9669"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">(</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___base"><span class="const token" data-binding="const-RawMaze.base" data-verso-hover="4676">base</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span><span class="inter-text">)</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-12799162057326366908-9672-9683"><a href="Tactic-Proofs/Tactic-Reference/#constructor"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.constructor-9672" data-verso-hover="2428">constructor</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12799162057326366908-9672-9683"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-521" checked="checked"><span for="--verso-unique-521" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.1346" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.1348" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="const token" data-binding="const-EmptyCollection.emptyCollection" data-verso-hover="4687">∅</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.1346" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1348" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.1348" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-522"><span for="--verso-unique-522" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-EmptyCollection.emptyCollection" data-verso-hover="4687">∅</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-17851791520332217141-9686-9687"><span class="unknown token" data-binding="">.</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17851791520332217141-9686-9687"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-523" checked="checked"><span for="--verso-unique-523" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.1346" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.1348" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="const token" data-binding="const-EmptyCollection.emptyCollection" data-verso-hover="4687">∅</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.1346" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1348" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.1348" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-2852423330857577585-9688-9700"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-9688" data-verso-hover="661">intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="312">v</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="4679">h</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="4688">h'</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2852423330857577585-9688-9700"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-524" checked="checked"><span for="--verso-unique-524" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="312">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.21" data-verso-hover="4679">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.24" data-verso-hover="4688">h'</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-EmptyCollection.emptyCollection" data-verso-hover="4687">∅</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.18" data-verso-hover="312">v</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="4679">h</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.21" data-verso-hover="4679">h</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span></span><span class="inter-text">
    </span><span class="tactic"><label for="tactic-state-7-9705-9747"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-9705" data-verso-hover="35">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Std.HashMap.Raw.getElem?_empty" data-verso-hover="4689">Std.HashMap.Raw.getElem?_empty</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-9743" data-verso-hover="694">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-9705-9747"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-3228601418370880214-9750-9751"><span class="unknown token" data-binding="">.</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3228601418370880214-9750-9751"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-525" checked="checked"><span for="--verso-unique-525" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-EmptyCollection.emptyCollection" data-verso-hover="4687">∅</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-9752-9778"><a href="Tactic-Proofs/Tactic-Reference/#exact"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-9752" data-verso-hover="764">exact</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Std.HashMap.Raw.WF.empty" data-verso-hover="4690">HashMap.Raw.WF.empty</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-9752-9778"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9780">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-RawMaze.insert_wf" data-verso-hover="4691" id="RawMaze___base_wf">RawMaze.insert_wf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1353" data-verso-hover="4679">next</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___insert"><span class="const token" data-binding="const-RawMaze.insert" data-verso-hover="4678">insert</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1366" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1353" data-verso-hover="4679">next</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-533947957569175148-9878-9880"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-9878" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-533947957569175148-9878-9880"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text"> → </span><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___insert"><span class="const token" data-binding="const-RawMaze.insert" data-verso-hover="4678">insert</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">)</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-16602687538032396744-9883-9915"><a href="Tactic-Proofs/The-Tactic-Language/#let"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet_-9883" data-verso-hover="2307">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16602687538032396744-9883-9915"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text"> →
  </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text"> → </span><span class="inter-text">(</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___insert"><span class="const token" data-binding="const-RawMaze.insert" data-verso-hover="4678">insert</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">)</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-1561483358836507186-9918-9955"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-9918" data-verso-hover="661">intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1561483358836507186-9918-9955"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">(</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___insert"><span class="const token" data-binding="const-RawMaze.insert" data-verso-hover="4678">insert</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">)</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-12078500651861616826-9958-9969"><a href="Tactic-Proofs/Tactic-Reference/#constructor"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.constructor-9958" data-verso-hover="2428">constructor</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12078500651861616826-9958-9969"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-529" checked="checked"><span for="--verso-unique-529" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir_1</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">),
  </span><span class="inter-text">(</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><span class="inter-text">.</span><span class="const token" data-binding="const-Std.HashMap.Raw.insert" data-verso-hover="4680">insert</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">)</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir_1</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-530"><span for="--verso-unique-530" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">(</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><span class="inter-text">.</span><span class="const token" data-binding="const-Std.HashMap.Raw.insert" data-verso-hover="4680">insert</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">)</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-10658464670899514751-9972-9973"><span class="unknown token" data-binding="">.</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10658464670899514751-9972-9973"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-531" checked="checked"><span for="--verso-unique-531" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir_1</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">),
  </span><span class="inter-text">(</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><span class="inter-text">.</span><span class="const token" data-binding="const-Std.HashMap.Raw.insert" data-verso-hover="4680">insert</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">)</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir_1</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-14470035188881526845-9974-9986"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-9974" data-verso-hover="661">intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14470035188881526845-9974-9986"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-532" checked="checked"><span for="--verso-unique-532" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">(</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><span class="inter-text">.</span><span class="const token" data-binding="const-Std.HashMap.Raw.insert" data-verso-hover="4680">insert</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">)</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span></span><span class="inter-text">
    </span><span class="tactic"><label for="tactic-state-8654579299388043456-9991-10034"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-9991" data-verso-hover="1134">rw</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Std.HashMap.Raw.getElem?_insert" data-verso-hover="4696">HashMap.Raw.getElem?_insert</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8654579299388043456-9991-10034"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-533" checked="checked"><span for="--verso-unique-533" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="628">(</span><span class="const token" data-binding="const-ite" data-verso-hover="628">if </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">(</span></a><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751"> == </span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="const token" data-binding="const-ite" data-verso-hover="628"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="628"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="const token" data-binding="const-ite" data-verso-hover="628"> </span><span class="const token" data-binding="const-ite" data-verso-hover="628">else </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><span class="const token" data-binding="const-ite" data-verso-hover="628">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span></span><span class="inter-text">
    </span><span class="tactic"><label for="tactic-state-15214250101424247120-10039-10044"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-10039" data-verso-hover="631">split</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15214250101424247120-10039-10044"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-534" checked="checked"><span for="--verso-unique-534" class="goal-name">a.isTrue</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2484" data-verso-hover="4697">h✝</span></span><span class="colon">:</span><span class="type"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">(</span></a><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751"> == </span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-535"><span for="--verso-unique-535" class="goal-name">a.isFalse</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2479" data-verso-hover="4698">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="634">¬</span></a><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">(</span></a><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751"> == </span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-15214250101424247120-10045-10048"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15214250101424247120-10045-10048"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-536" checked="checked"><span for="--verso-unique-536" class="goal-name">a.isTrue</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2484" data-verso-hover="4697">h✝</span></span><span class="colon">:</span><span class="type"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">(</span></a><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751"> == </span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-537"><span for="--verso-unique-537" class="goal-name">a.isFalse</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2479" data-verso-hover="4698">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="634">¬</span></a><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">(</span></a><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751"> == </span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-5944049845667134504-10049-10055"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-10049" data-verso-hover="379">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5944049845667134504-10049-10055"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-538" checked="checked"><span for="--verso-unique-538" class="goal-name">a.isFalse</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2479" data-verso-hover="4698">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="634">¬</span></a><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">(</span></a><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751"> == </span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3038" data-verso-hover="4699">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-10008863258090881329-10056-10059"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10008863258090881329-10056-10059"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-539" checked="checked"><span for="--verso-unique-539" class="goal-name">a.isTrue</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2484" data-verso-hover="4697">h✝</span></span><span class="colon">:</span><span class="type"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">(</span></a><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751"> == </span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3035" data-verso-hover="4700">a✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-540"><span for="--verso-unique-540" class="goal-name">a.isFalse</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2479" data-verso-hover="4698">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="634">¬</span></a><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">(</span></a><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751"> == </span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq.beq" data-verso-hover="1751">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3038" data-verso-hover="4699">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1797" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-10060-10082"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-10060" data-verso-hover="665">simp_all</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="312">dir'</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-10060-10082"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-14803596842785185906-10085-10086"><span class="unknown token" data-binding="">.</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14803596842785185906-10085-10086"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-541" checked="checked"><span for="--verso-unique-541" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1368" data-verso-hover="4679">maze</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1521" data-verso-hover="4693">wfMore</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.28419" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.28421" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1522" data-verso-hover="4694">wfPassages</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1780" data-verso-hover="4695">wfNext</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">(</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1402" data-verso-hover="312">desc</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.1403" data-verso-hover="4684">passages</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><span class="inter-text">.</span><span class="const token" data-binding="const-Std.HashMap.Raw.insert" data-verso-hover="4680">insert</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1379" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1378" data-verso-hover="4679">next</span><span class="inter-text">)</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-10087-10119"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-10087" data-verso-hover="665">simp_all</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Std.HashMap.Raw.WF.insert" data-verso-hover="4701">HashMap.Raw.WF.insert</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-10087-10119"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Finally, a more friendly interface can be defined that frees users from worrying about well-formedness.
A <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span></code> bundles up a <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></code> with a proof that it is well-formed:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-10318">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-10333">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703" id="Maze___wf">raw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-Maze.wf" data-verso-hover="4704" id="Maze___wf">wf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="4679">raw</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Maze___insert"><span class="const token" data-binding="const-Maze.base" data-verso-hover="4705">base</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Maze___insert"><span class="const token" data-binding="const-Maze.insert" data-verso-hover="4706">insert</span></a></code> operators take care of the well-formedness proof obligations:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10502">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze.base" data-verso-hover="4705" id="Maze___insert">Maze.base</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-10546">where</span><span class="inter-text">
  </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4707">raw</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___base"><span class="const token" data-binding="const-RawMaze.base" data-verso-hover="4676">.base</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span><span class="inter-text">
  </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.wf" data-verso-hover="4708">wf</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-4288071846826980499-10587-10589"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-10587" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4288071846826980499-10587-10589"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">(</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___base"><span class="const token" data-binding="const-RawMaze.base" data-verso-hover="4676">RawMaze.base</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="312">description</span><span class="inter-text">)</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-10590-10611"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-10590" data-verso-hover="691">apply</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___base_wf"><span class="const token" data-binding="const-RawMaze.base_wf" data-verso-hover="4709">RawMaze.base_wf</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-10590-10611"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10613">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze.insert" data-verso-hover="4706" id="Maze___insert">Maze.insert</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="4710">maze</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="4710">next</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-10683">where</span><span class="inter-text">
  </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4707">raw</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="4710">maze</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703">raw</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___insert"><span class="const token" data-binding="const-RawMaze.insert" data-verso-hover="4678">insert</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="4710">next</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703">raw</span></a><span class="inter-text">
  </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.wf" data-verso-hover="4711">wf</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___base_wf"><span class="const token" data-binding="const-RawMaze.insert_wf" data-verso-hover="4691">RawMaze.insert_wf</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="4710">maze</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703">raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="4710">maze</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.wf" data-verso-hover="4704">wf</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="4710">next</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.wf" data-verso-hover="4704">wf</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Users of the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span></code> API may either check the description of the current maze or attempt to go in a direction to a new maze:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10921">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze.description" data-verso-hover="4712" id="Maze___go___">Maze.description</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4710">maze</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4710">maze</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703">raw</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="4674">description</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10992">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze.go?" data-verso-hover="4713" id="Maze___go___">Maze.go?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4710">maze</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11053" data-verso-hover="51">match</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.106" data-verso-hover="4714">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4710">maze</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703">raw</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span><span class="inter-text"> </span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11053" data-verso-hover="51">with</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715">Maze.mk</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;|</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-16187133172818003259-11142-11144"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-11142" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16187133172818003259-11142-11144"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4710">maze</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.106" data-verso-hover="4716">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4710">maze</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703">raw</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span><span class="inter-text">
      </span><span class="tactic"><label for="tactic-state-9212665847620140631-11151-11174"><a href="Tactic-Proofs/The-Tactic-Language/#let"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet_-11151" data-verso-hover="2307">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.303" data-verso-hover="4679">r</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.304" data-verso-hover="4717">wf</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4710">maze</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9212665847620140631-11151-11174"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4710">maze</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.303" data-verso-hover="4679">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.304" data-verso-hover="4717">wf</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.303" data-verso-hover="4679">r</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.305" data-verso-hover="4718">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715">{ </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4707">raw</span></a><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715"> := </span><span class="var token" data-binding="var-_uniq.303" data-verso-hover="4679">r</span><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715">, </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.wf" data-verso-hover="4719">wf</span></a><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715"> := </span><span class="var token" data-binding="var-_uniq.304" data-verso-hover="4717">wf</span><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703">raw</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span><span class="inter-text">
      </span><span class="tactic"><label for="tactic-state-1655690313041298115-11181-11205"><a href="Tactic-Proofs/The-Tactic-Language/#let"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet_-11181" data-verso-hover="2307">let</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.621" data-verso-hover="4720">wfAll</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.304" data-verso-hover="4717">wf</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1655690313041298115-11181-11205"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4710">maze</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.303" data-verso-hover="4679">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.304" data-verso-hover="4717">wf</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.303" data-verso-hover="4679">r</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.619" data-verso-hover="312">description✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.620" data-verso-hover="4684">passages✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.621" data-verso-hover="4720">wfAll</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.874" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.876" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.620" data-verso-hover="4684">passages✝</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.874" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.876" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.876" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.622" data-verso-hover="4721">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.620" data-verso-hover="4684">passages✝</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.106" data-verso-hover="4722">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715">{ </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4707">raw</span></a><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715"> := </span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.619" data-verso-hover="312">description✝</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.620" data-verso-hover="4684">passages✝</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715">, </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.wf" data-verso-hover="4723">wf</span></a><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715"> := </span><span class="inter-text">⋯</span><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703">raw</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span></span></span></span><span class="inter-text">
      </span><span class="tactic"><label for="tactic-state-14180218019722699712-11212-11227"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-11212" data-verso-hover="691">apply</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.621" data-verso-hover="4720">wfAll</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14180218019722699712-11212-11227"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-546" checked="checked"><span for="--verso-unique-546" class="goal-name">a</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4710">maze</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Maze" data-verso-hover="4702">Maze</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.303" data-verso-hover="4679">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.304" data-verso-hover="4717">wf</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.303" data-verso-hover="4679">r</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.619" data-verso-hover="312">description✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.620" data-verso-hover="4684">passages✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">HashMap.Raw</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.621" data-verso-hover="4720">wfAll</span></span><span class="colon">:</span><span class="type"><span class="inter-text">∀ (</span><span class="var token" data-binding="var-_uniq.874" data-verso-hover="312">dir</span><span class="inter-text"> : </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.876" data-verso-hover="4679">v</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze" data-verso-hover="4673">RawMaze</span></a><span class="inter-text">), </span><span class="var token" data-binding="var-_uniq.620" data-verso-hover="4684">passages✝</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.874" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.876" data-verso-hover="4679">v</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.876" data-verso-hover="4679">v</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___WF"><span class="const token" data-binding="const-RawMaze.WF" data-verso-hover="4682">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.622" data-verso-hover="4721">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.620" data-verso-hover="4684">passages✝</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4685">WF</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.106" data-verso-hover="4722">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715">{ </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4707">raw</span></a><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715"> := </span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">{ </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.description" data-verso-hover="330">description</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.619" data-verso-hover="312">description✝</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692">, </span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4677">passages</span></a><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> := </span><span class="var token" data-binding="var-_uniq.620" data-verso-hover="4684">passages✝</span><span class="const token" data-binding="const-RawMaze.mk" data-verso-hover="4692"> }</span><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715">, </span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.wf" data-verso-hover="4723">wf</span></a><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715"> := </span><span class="inter-text">⋯</span><span class="const token" data-binding="const-Maze.mk" data-verso-hover="4715"> }</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Maze___wf"><span class="const token" data-binding="const-Maze.raw" data-verso-hover="4703">raw</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#RawMaze___passages"><span class="const token" data-binding="const-RawMaze.passages" data-verso-hover="4675">passages</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.620" data-verso-hover="4684">passages✝</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">[</span></a><span class="var token" data-binding="var-_uniq.10" data-verso-hover="312">dir</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1171">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="4679">m'</span></span></span></span></span></span></span><span class="inter-text">
      </span><span class="tactic"><label for="tactic-state-7-11234-11241"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-11234" data-verso-hover="691">apply</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.106" data-verso-hover="4722">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-11234-11241"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Library-Design--Suitable-Operators-for-Uniqueness">
                  18.17.1.3. Suitable Operators for Uniqueness</h3>
                <p>
                  Care should be taken when working with data structures to ensure that as many references are unique as possible, which enables Lean to use destructive mutation behind the scenes while maintaining a pure functional interface.
The map and set library provides operators that can be used to maintain uniqueness of references.
In particular, when possible, operations such as <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___alter"><span class="const token" data-binding="const-Std.HashMap.alter" data-verso-hover="4668">alter</span></a></code> or <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___modify"><span class="const token" data-binding="const-Std.HashMap.modify" data-verso-hover="4724">modify</span></a></code> should be preferred over explicitly retrieving a value, modifying it, and reinserting it.
These operations avoid creating a second reference to the value during modification.</p>
                <details class="example"><summary class="description">Modifying Values in Maps</summary><div class="example-content">
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___open"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-11953" data-verso-hover="118">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Std</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The function <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#addAlias"><span class="const token" data-binding="const-addAlias" data-verso-hover="4725">addAlias</span></a></code> is used to track aliases of a string in some data set.
One way to add an alias is to first look up the existing aliases, defaulting to the empty array, then insert the new alias, and finally save the resulting array in the map:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12234">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-addAlias" data-verso-hover="4726" id="addAlias">addAlias</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="4727">aliases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">HashMap</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="312">key</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="312">value</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">HashMap</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-12355" data-verso-hover="107">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="2764">prior</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="4727">aliases</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___getD"><span class="const token" data-binding="const-Std.HashMap.getD" data-verso-hover="4728">getD</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="312">key</span><span class="inter-text"> </span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="4727">aliases</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___insert"><span class="const token" data-binding="const-Std.HashMap.insert" data-verso-hover="4729">insert</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="312">key</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="2764">prior</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___push"><span class="const token" data-binding="const-Array.push" data-verso-hover="224">push</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="312">value</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      This implementation has poor performance characteristics.
Because the map retains a reference to the prior values, the array must be copied rather than mutated.
A better implementation explicitly erases the prior value from the map before modifying it:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12696">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-addAlias'" data-verso-hover="4730" id="addAlias___">addAlias'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="4727">aliases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">HashMap</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="312">key</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="312">value</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">HashMap</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-12818" data-verso-hover="107">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="2764">prior</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="4727">aliases</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___getD"><span class="const token" data-binding="const-Std.HashMap.getD" data-verso-hover="4728">getD</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="312">key</span><span class="inter-text"> </span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-12854" data-verso-hover="107">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86" data-verso-hover="4727">aliases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="4727">aliases</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___erase"><span class="const token" data-binding="const-Std.HashMap.erase" data-verso-hover="4731">erase</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="312">key</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.86" data-verso-hover="4727">aliases</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___insert"><span class="const token" data-binding="const-Std.HashMap.insert" data-verso-hover="4729">insert</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="312">key</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="2764">prior</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___push"><span class="const token" data-binding="const-Array.push" data-verso-hover="224">push</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="312">value</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Using <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___alter"><span class="const token" data-binding="const-Std.HashMap.alter" data-verso-hover="4668">HashMap.alter</span></a></code> is even better.
It removes the need to explicitly delete and re-insert the value:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13051">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-addAlias''" data-verso-hover="4732" id="addAlias______">addAlias''</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="4727">aliases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">HashMap</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="312">key</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="312">value</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">HashMap</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="147">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="4727">aliases</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___alter"><span class="const token" data-binding="const-Std.HashMap.alter" data-verso-hover="4733">alter</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="312">key</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-13192">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65" data-verso-hover="4734">prior?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.65" data-verso-hover="4734">prior?</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Optional-Values/#Option___getD"><span class="const token" data-binding="const-Option.getD" data-verso-hover="4119">getD</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___push"><span class="const token" data-binding="const-Array.push" data-verso-hover="224">push</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="312">value</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              </section>
            <section>
              <h2 id="HashMap">
                18.17.2. Hash Maps<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=HashMap" title="Permalink">🔗</a></span></h2>
              <p>
                The declarations in this section should be imported using <code>import Std.HashMap</code>.</p>
              <div class="namedocs" id="Std___HashMap">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.13571" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.13572" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13571" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13571" data-verso-hover="54">α</span><span class="inter-text">] :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.13571" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.13572" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13571" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13571" data-verso-hover="54">α</span><span class="inter-text">] :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div></pre><div class="text">
                  <p>
                    Hash maps.</p>
                  <p>
                    This is a simple separate-chaining hash table. The data of the hash map consists of a cached size
and an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets
is always a power of two. The hash map doubles its size upon inserting an element such that the
number of elements is more than 75% of the number of buckets.</p>
                  <p>
                    The hash table is backed by an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a></code>. Users should make sure that the hash map is used linearly to
avoid expensive copies.</p>
                  <p>
                    The hash map uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> (provided by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> typeclass) to compare keys and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable.hash" data-verso-hover="1759">hash</span></a></code> (provided by
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> typeclass) to hash them. To ensure that the operations behave as expected, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>
should be an equivalence relation and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> should imply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> (see also the
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a></code> typeclasses). Both of these conditions are automatic if the BEq
instance is lawful, i.e., if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.11749" data-verso-hover="4735">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11935" data-verso-hover="4735">b</span></code>.</p>
                  <p>
                    These hash maps contain a bundled well-formedness invariant, which means that they cannot
be used in nested inductive types. For these use cases, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.HashMap.Raw</span></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.HashMap.Raw.WF</span></code> unbundle the invariant from the hash map. When in doubt, prefer
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code> over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code>.</p>
                  <p>
                    Dependent hash maps, in which keys may occur in their values' types, are available as
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.DHashMap</span></code>.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Creation">
                  18.17.2.1. Creation</h3>
                <div class="namedocs" id="Std___HashMap___emptyWithCapacity">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.emptyWithCapacity" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.emptyWithCapacity.{u, v} {</span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14907" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.14910" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14907" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.emptyWithCapacity.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14907" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.14910" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14907" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Creates a new empty hash map. The optional parameter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.14023" data-verso-hover="4736">capacity</span></code> can be supplied to presize the
map so that it can hold the given number of mappings without reallocating. It is also possible to
use the empty collection notations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span></code> to create an empty hash map with the default
capacity.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Properties">
                  18.17.2.2. Properties</h3>
                <div class="namedocs" id="Std___HashMap___size">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.size" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.15090" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15091" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15092" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15090" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15093" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15090" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.15098" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15090" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15091" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.15090" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15091" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15092" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15090" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15093" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15090" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.15098" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15090" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15091" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                    <p>
                      The number of mappings present in the hash map</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___isEmpty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.isEmpty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.15236" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15237" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15238" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15236" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15239" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15236" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15236" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15237" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.15236" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15237" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15238" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15236" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15239" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15236" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15236" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15237" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the hash map contains no mappings.</p>
                    <p>
                      Note that if your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> instance is not reflexive or your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> instance is not
lawful, then it is possible that this function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code> even though is not possible
to get anything out of the hash map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___Equiv___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.Equiv.inner" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.Equiv.{u, v} {</span><span class="var token" data-binding="var-_uniq.15510" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15511" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15512" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15510" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15513" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15510" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.15514" data-verso-hover="4739">m₁ </span><span class="var token" data-binding="var-_uniq.15519" data-verso-hover="4739">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15510" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15511" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.Equiv.{u, v} {</span><span class="var token" data-binding="var-_uniq.15510" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15511" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15512" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15510" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15513" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15510" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.15514" data-verso-hover="4739">m₁ </span><span class="var token" data-binding="var-_uniq.15519" data-verso-hover="4739">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15510" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15511" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      Two hash maps are equivalent in the sense of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Equiv</span></code> iff
all the keys and values are equal.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Equiv___mk"><span class="const token" data-binding="const-Std.HashMap.Equiv.mk" data-verso-hover="4740">Std.HashMap.Equiv.mk</span></a><span class="inter-text">.{u, v}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.HashMap.Equiv.inner" data-verso-hover="4741">inner</span> : <span class="var token" data-binding="var-_uniq.15478" data-verso-hover="4739">m₁</span><span class="inter-text">.</span><span class="const token" data-binding="const-Std.HashMap.inner" data-verso-hover="4742">inner</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Equiv___mk"><span class="const token" data-binding="const-Std.DHashMap.Equiv" data-verso-hover="4743">Equiv</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15479" data-verso-hover="4739">m₂</span><span class="inter-text">.</span><span class="const token" data-binding="const-Std.HashMap.inner" data-verso-hover="4742">inner</span></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Equivalence</span><div class="text">
                    <p>
                      The relation <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Equiv___mk"><span class="const token" data-binding="const-Std.HashMap.Equiv" data-verso-hover="4744">HashMap.Equiv</span></a></code> can also be written with an infix operator, which is scoped to its namespace:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Std___HashMap____FLQQ_term____m__FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Std.HashMap.«term_~m_»"><code class="hover-info"><code class="docstring">Two hash maps are equivalent in the sense of `Equiv` iff
all the keys and values are equal.
</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">~m</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Queries">
                  18.17.2.3. Queries</h3>
                <div class="namedocs" id="Std___HashMap___contains">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.contains" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16344" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16345" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16346" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.16351" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16344" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.16352" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16344" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16345" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16346" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.16351" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16344" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.16352" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16343" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if there is a mapping for the given key. There is also a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>-valued version
of this: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16280" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16279" data-verso-hover="4739">m</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16279" data-verso-hover="4739">m</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___contains"><span class="const token" data-binding="const-Std.HashMap.contains" data-verso-hover="322">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16280" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>.</p>
                    <p>
                      Observe that this is different behavior than for lists: for lists, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∈</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> uses
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> for comparisons, while for hash maps, both use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___get">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.get" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16909" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16910" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16911" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.16916" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16909" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.16917" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.16918" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16917" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.16916" data-verso-hover="4739">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16909" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16909" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16910" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16911" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.16916" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16909" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.16917" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16908" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.16918" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16917" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.16916" data-verso-hover="4739">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16909" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      The notation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16659" data-verso-hover="4739">m</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.16660" data-verso-hover="45">a</span><span class="unknown token" data-binding="">]</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16659" data-verso-hover="4739">m</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.16660" data-verso-hover="45">a</span><span class="unknown token" data-binding="">]'</span><span class="var token" data-binding="var-_uniq.16661" data-verso-hover="4745">h</span></code> is preferred over calling this function directly.</p>
                    <p>
                      Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16885" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16884" data-verso-hover="4739">m</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___get___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.get!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17261" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17262" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17263" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17261" data-verso-hover="244">β</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.17269" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17261" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17270" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17261" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17261" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17262" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17263" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17261" data-verso-hover="244">β</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.17269" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17261" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17270" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17260" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17261" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      The notation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.17179" data-verso-hover="4739">m</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.17180" data-verso-hover="45">a</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">!</span></code> is preferred over calling this function directly.</p>
                    <p>
                      Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___get___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.get?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17534" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17535" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17536" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17541" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17534" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17542" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17534" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17534" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17535" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17536" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17541" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17534" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.17542" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17533" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17534" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      The notation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.17462" data-verso-hover="4739">m</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.17463" data-verso-hover="45">a</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span></code> is preferred over calling this function directly.</p>
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such mapping is present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___getD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.getD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17747" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17748" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17749" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17754" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17747" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17755" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17756" data-verso-hover="185">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17747" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17747" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17747" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17748" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17749" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17754" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17747" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.17755" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17746" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17756" data-verso-hover="185">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17747" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17747" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.17745" data-verso-hover="185">fallback</span></code> if no such mapping is present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___getKey">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.getKey" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17968" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17969" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17970" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17975" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17968" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17976" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17977" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17976" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.17975" data-verso-hover="4739">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17968" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17969" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17970" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17975" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17968" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.17976" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17977" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17976" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.17975" data-verso-hover="4739">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17967" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Retrieves the key from the mapping that matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.17938" data-verso-hover="45">a</span></code>. Ensures that such a mapping exists by
requiring a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.17938" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17937" data-verso-hover="4739">m</span></code>. The result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___getKey___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.getKey!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18200" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18201" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18202" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.18208" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18200" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.18209" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18200" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18201" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18202" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.18208" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18200" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.18209" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18199" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___getKey___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.getKey?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18378" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18379" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18380" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18385" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18378" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.18386" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18378" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18379" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18380" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18385" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18378" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.18386" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18377" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.
The result in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> case is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___getKeyD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.getKeyD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18577" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18578" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18579" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18584" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18577" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.18585" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.18586" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18577" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18578" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18579" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18584" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18577" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.18585" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.18586" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18576" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.18575" data-verso-hover="45">fallback</span></code>.
If a mapping exists the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___keys">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.keys" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.keys.{u, v} {</span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18769" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18770" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18771" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18776" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18769" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.keys.{u, v} {</span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18769" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18770" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18771" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.18776" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18769" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18768" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Returns a list of all keys present in the hash map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___keysArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.keysArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.keysArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18914" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18915" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18916" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18921" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18914" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.keysArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18914" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18915" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18916" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.18921" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18914" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18913" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Returns an array of all keys present in the hash map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___values">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.values" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.values.{u, v} {</span><span class="var token" data-binding="var-_uniq.19058" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19059" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19060" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19058" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19061" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19058" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19066" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19058" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19059" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19059" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.values.{u, v} {</span><span class="var token" data-binding="var-_uniq.19058" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19059" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19060" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19058" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19061" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19058" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.19066" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19058" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19059" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19059" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Returns a list of all values present in the hash map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___valuesArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.valuesArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.valuesArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.19203" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19204" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19205" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19203" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19206" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19203" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19211" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19203" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19204" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19204" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.valuesArray.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.19203" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19204" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19205" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19203" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19206" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19203" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.19211" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19203" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19204" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19204" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Returns an array of all values present in the hash map in some order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Modification">
                  18.17.2.4. Modification</h3>
                <div class="namedocs" id="Std___HashMap___alter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.alter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19360" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19361" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19366" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19367" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19369" data-verso-hover="4746">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19360" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19361" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19366" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19367" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19369" data-verso-hover="4746">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19358" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19359" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key,
allowing creating new values and deleting values via an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code> valued replacement function.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___modify">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.modify" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19602" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19603" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19608" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19609" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19611" data-verso-hover="4747">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19602" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19603" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19608" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19609" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19611" data-verso-hover="4747">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19600" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___containsThenInsert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.containsThenInsert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.containsThenInsert.{u, v} {</span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19831" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19832" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19833" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19838" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19831" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19839" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19840" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19831" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19831" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.containsThenInsert.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19831" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19832" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19833" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19838" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19831" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19839" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19840" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19831" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19830" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19831" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, and unconditionally inserts a value for the key.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___containsThenInsertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.containsThenInsertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.containsThenInsertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20098" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20099" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20100" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.20105" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20098" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.20106" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20107" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20098" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20098" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.containsThenInsertIfNew.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20098" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20099" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20100" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.20105" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20098" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20106" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.20107" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20098" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20097" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20098" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map and inserts a value for the key if it was not found.</p>
                    <p>
                      If the returned <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>, then the returned map is unaltered. If the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>, then
the returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___erase">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.erase" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20406" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20407" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20408" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.20413" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20406" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.20414" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20406" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20406" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20407" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20408" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.20413" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20406" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20414" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20405" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20406" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Removes the mapping for the given key if it exists.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___filter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.filter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20578" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20579" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20580" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.20584" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20578" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.20589" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20578" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20578" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20578" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20579" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20580" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.20584" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20578" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20589" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20578" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20577" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20578" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Removes all mappings of the hash map for which the given function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___filterMap">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.filterMap" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.filterMap.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20781" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20782" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.20788" data-verso-hover="4750">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20781" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20782" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.20793" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20781" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20782" data-verso-hover="4179">γ</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.filterMap.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20781" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20782" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.20788" data-verso-hover="4750">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20781" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20782" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20793" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20781" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20780" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20782" data-verso-hover="4179">γ</span></div></pre><div class="text">
                    <p>
                      Updates the values of the hash map by applying the given function to all mappings, keeping
only those mappings where the function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> value.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___insert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.insert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21059" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21060" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21061" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.21066" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21059" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21067" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21068" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21059" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21059" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21059" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21060" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21061" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.21066" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21059" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.21067" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21068" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21059" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21058" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21059" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Inserts the given mapping into the map. If there is already a mapping for the given key, then both
key and value will be replaced.</p>
                    <p>
                      Note: this replacement behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> behaves differently: it will return the set
unchanged if a matching key is already present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___insertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.insertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.insertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21369" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21370" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21371" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.21376" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21369" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21377" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21378" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21369" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21369" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.insertIfNew.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21369" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21370" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21371" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.21376" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21369" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.21377" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21378" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21369" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21368" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21369" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      If there is no mapping for the given key, inserts the given mapping into the map. Otherwise,
returns the map unaltered.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___getThenInsertIfNew___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.getThenInsertIfNew?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.getThenInsertIfNew?.{u, v} {</span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21608" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21609" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.21614" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21615" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.21616" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.getThenInsertIfNew?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21608" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21609" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.21614" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.21615" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21616" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21606" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21607" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, returning the associate value, and inserts a value for
the key if it was not found.</p>
                    <p>
                      If the returned value is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21577" data-verso-hover="4751">v</span></code>, then the returned map is unaltered. If it is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>, then the
returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">get?</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___insertMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.insertMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.insertMany.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21984" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21985" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21986" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21987" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21987" data-verso-hover="4179">ρ</span><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.21984" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.21994" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21984" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21995" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21987" data-verso-hover="4179">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21984" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.insertMany.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21984" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21985" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21986" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21987" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21987" data-verso-hover="4179">ρ</span><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.21984" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.21994" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21984" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21995" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21987" data-verso-hover="4179">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21983" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21984" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Inserts multiple mappings into the hash map by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>. If the same key appears multiple times, the last occurrence takes precedence.</p>
                    <p>
                      Note: this precedence behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertMany</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> behaves differently: it will prefer the first
appearance.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___insertManyIfNewUnit">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.insertManyIfNewUnit" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.insertManyIfNewUnit.{u, w} {</span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22385" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22386" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22387" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22387" data-verso-hover="4179">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.22394" data-verso-hover="4752">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.22395" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22387" data-verso-hover="4179">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashMap.insertManyIfNewUnit.{u, w}
  {</span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22385" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22386" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22387" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22387" data-verso-hover="4179">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.22394" data-verso-hover="4752">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.22395" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22387" data-verso-hover="4179">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22384" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div></pre><div class="text">
                    <p>
                      Inserts multiple keys with the value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code> into the hash map by iterating over the given collection
and calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>. If the same key appears multiple times, the first occurrence takes
precedence.</p>
                    <p>
                      This is mainly useful to implement <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.insertMany</span></code>, so if you are considering using this,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> might be a better fit for you.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___partition">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.partition" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.partition.{u, v} {</span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22666" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22667" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.22671" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.22676" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.partition.{u, v} {</span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22666" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22667" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.22671" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.22676" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22665" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Partition a hash map into two hash map based on a predicate.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___union">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.union" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.union.{u, v} {</span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22874" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.22877" data-verso-hover="4739">m₁ </span><span class="var token" data-binding="var-_uniq.22882" data-verso-hover="4739">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22874" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22874" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.union.{u, v} {</span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22874" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.22877" data-verso-hover="4739">m₁ </span><span class="var token" data-binding="var-_uniq.22882" data-verso-hover="4739">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22874" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22873" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22874" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Computes the union of the given hash maps, by traversing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22872" data-verso-hover="4739">m₂</span></code> and inserting its elements into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22871" data-verso-hover="4739">m₁</span></code>.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Iteration">
                  18.17.2.5. Iteration</h3>
                <div class="namedocs" id="Std___HashMap___map">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.map" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23061" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23062" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.23068" data-verso-hover="2642">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23061" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23062" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23073" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23061" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23062" data-verso-hover="4179">γ</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23061" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23062" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.23068" data-verso-hover="2642">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23061" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23062" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23073" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23061" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23060" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23062" data-verso-hover="4179">γ</span></div></pre><div class="text">
                    <p>
                      Updates the values of the hash map by applying the given function to all mappings.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___fold">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.fold" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.fold.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23246" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23247" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23248" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.23255" data-verso-hover="4753">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23246" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23256" data-verso-hover="992">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23261" data-verso-hover="4739">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23246" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.fold.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23246" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23247" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23248" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.23255" data-verso-hover="4753">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23246" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23256" data-verso-hover="992">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23261" data-verso-hover="4739">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23245" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23246" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.23249" data-verso-hover="4179">γ</span></div></pre><div class="text">
                    <p>
                      Folds the given function over the mappings in the hash map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___foldM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.foldM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.foldM.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23461" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23462" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23463" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23465" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23465" data-verso-hover="4754">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.23473" data-verso-hover="4755">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23461" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23465" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23474" data-verso-hover="992">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23479" data-verso-hover="4739">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23461" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.23465" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.foldM.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23461" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23462" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23463" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23465" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23465" data-verso-hover="4754">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.23473" data-verso-hover="4755">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23461" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23465" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23474" data-verso-hover="992">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23479" data-verso-hover="4739">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23460" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23461" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.23465" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23467" data-verso-hover="4179">γ</span></div></pre><div class="text">
                    <p>
                      Monadically computes a value by folding the given function over the mappings in the hash
map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___forIn">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.forIn" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.forIn.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23724" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23725" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23726" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23728" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23728" data-verso-hover="4754">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.23736" data-verso-hover="4756">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23724" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23728" data-verso-hover="4754">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.23737" data-verso-hover="992">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23742" data-verso-hover="4739">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23724" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.23728" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.forIn.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23724" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23725" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23726" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23728" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23728" data-verso-hover="4754">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.23736" data-verso-hover="4756">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23724" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23728" data-verso-hover="4754">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.23737" data-verso-hover="992">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23742" data-verso-hover="4739">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23723" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23724" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.23728" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23730" data-verso-hover="4179">γ</span></div></pre><div class="text">
                    <p>
                      Support for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span></code> loop construct in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> blocks.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___forM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.forM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.forM.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24021" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24022" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24023" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24025" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24025" data-verso-hover="4754">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24030" data-verso-hover="4757">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24021" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24025" data-verso-hover="4754">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24035" data-verso-hover="4739">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24021" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.24025" data-verso-hover="4754">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashMap.forM.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24021" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24022" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24023" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24025" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24025" data-verso-hover="4754">m</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.24030" data-verso-hover="4757">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24021" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24025" data-verso-hover="4754">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.24035" data-verso-hover="4739">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24020" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24021" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.24025" data-verso-hover="4754">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div></pre><div class="text">
                    <p>
                      Carries out a monadic action on each mapping in the hash map in some order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Conversion">
                  18.17.2.6. Conversion</h3>
                <div class="namedocs" id="Std___HashMap___ofList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.ofList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24231" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24234" data-verso-hover="4447">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.24231" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24231" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24231" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24234" data-verso-hover="4447">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.24231" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24230" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24231" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Creates a hash map from a list of mappings. If the same key appears multiple times, the last
occurrence takes precedence.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___toArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.toArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.toArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24382" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24383" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24384" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.24389" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24382" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.24382" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashMap.toArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24382" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24383" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24384" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.24389" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24382" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.24381" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.24382" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                    <p>
                      Transforms the hash map into an array of mappings in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___toList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.toList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.toList.{u, v} {</span><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24545" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24546" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24547" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.24552" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24545" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.24545" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashMap.toList.{u, v} {</span><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24545" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24546" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24547" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.24552" data-verso-hover="4739">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24545" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.24544" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.24545" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                    <p>
                      Transforms the hash map into a list of mappings in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___unitOfArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.unitOfArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.unitOfArray.{u} {</span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24740" data-verso-hover="303">l</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashMap.unitOfArray.{u} {</span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.24740" data-verso-hover="303">l</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24737" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div></pre><div class="text">
                    <p>
                      Creates a hash map from an array of keys, associating the value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code> with each key.</p>
                    <p>
                      This is mainly useful to implement <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.ofArray</span></code>, so if you are considering using this,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> might be a better fit for you.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___unitOfList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.unitOfList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.unitOfList.{u} {</span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24946" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashMap.unitOfList.{u} {</span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.24946" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24943" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div></pre><div class="text">
                    <p>
                      Creates a hash map from a list of keys, associating the value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code> with each key.</p>
                    <p>
                      This is mainly useful to implement <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.ofList</span></code>, so if you are considering using this,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> might be a better fit for you.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Unbundled-Variants">
                  18.17.2.7. Unbundled Variants</h3>
                <p>
                  Unbundled maps separate well-formedness proofs from data.
This is primarily useful when defining <a href="Basic-Types/Maps-and-Sets/#raw-data">nested inductive types</a>.
To use these variants, import the modules <code>Std.HashMap.Raw</code> and <code>Std.HashMap.RawLemmas</code>.</p>
                <div class="namedocs" id="Std___HashMap___Raw___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.Raw.inner" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.Raw.{u, v} (</span><span class="var token" data-binding="var-_uniq.27188" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.27189" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.Raw.{u, v} (</span><span class="var token" data-binding="var-_uniq.27188" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.27189" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div></pre><div class="text">
                    <p>
                      Hash maps without a bundled well-formedness invariant, suitable for use in nested
inductive types. The well-formedness invariant is called <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Raw.WF</span></code>. When in doubt, prefer <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>
over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code>. Lemmas about the operations on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.HashMap.Raw</span></code> are available in the
module <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.HashMap.RawLemmas</span></code>.</p>
                    <p>
                      This is a simple separate-chaining hash table. The data of the hash map consists of a cached size
and an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets
is always a power of two. The hash map doubles its size upon inserting an element such that the
number of elements is more than 75% of the number of buckets.</p>
                    <p>
                      The hash table is backed by an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a></code>. Users should make sure that the hash map is used linearly to
avoid expensive copies.</p>
                    <p>
                      The hash map uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> (provided by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> typeclass) to compare keys and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable.hash" data-verso-hover="1759">hash</span></a></code> (provided by
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> typeclass) to hash them. To ensure that the operations behave as expected, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>
should be an equivalence relation and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> should imply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> (see also the
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a></code> typeclasses). Both of these conditions are automatic if the BEq
instance is lawful, i.e., if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.25401" data-verso-hover="4758">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25587" data-verso-hover="4758">b</span></code>.</p>
                    <p>
                      Dependent hash maps, in which keys may occur in their values' types, are available as
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.Raw.DHashMap</span></code>.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.mk" data-verso-hover="4759">Std.HashMap.Raw.mk</span></a><span class="inter-text">.{u, v}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.HashMap.Raw.inner" data-verso-hover="4760">inner</span> : <a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27174" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27179" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.27175" data-verso-hover="244">β</span></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashMap___Raw___WF___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashMap.Raw.WF" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashMap.Raw.WF.{u, v} {</span><span class="var token" data-binding="var-_uniq.27863" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.27864" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27863" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27863" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.27869" data-verso-hover="4762">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">Std.HashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27863" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27864" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only"><span class="inter-text">Std.HashMap.Raw.WF.{u, v} {</span><span class="var token" data-binding="var-_uniq.27863" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.27864" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27863" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27863" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.27869" data-verso-hover="4762">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">Std.HashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27863" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27864" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      Well-formedness predicate for hash maps. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code> will not need to interact with this.
Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> will need to provide proofs of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF</span></code> to lemmas and should use lemmas
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.empty</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.insert</span></code> (which are always named exactly like the operations they are about) to
show that map operations preserve well-formedness.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF.mk" data-verso-hover="4763">Std.HashMap.Raw.WF.mk</span></a><span class="inter-text">.{u, v}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.HashMap.Raw.WF.out" data-verso-hover="4764">out</span> : <span class="var token" data-binding="var-_uniq.27838" data-verso-hover="4762">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.inner" data-verso-hover="4765">inner</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </section>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="DHashMap">
                18.17.3. Dependent Hash Maps<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=DHashMap" title="Permalink">🔗</a></span></h2>
              <p>
                The declarations in this section should be imported using <code>import Std.DHashMap</code>.</p>
              <div class="namedocs" id="Std___DHashMap">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.30244" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.30246" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.30244" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30244" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30244" data-verso-hover="54">α</span><span class="inter-text">] :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max 0 u v)</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.30244" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.30246" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.30244" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30244" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30244" data-verso-hover="54">α</span><span class="inter-text">] :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max 0 u v)</span></div></pre><div class="text">
                  <p>
                    Dependent hash maps.</p>
                  <p>
                    This is a simple separate-chaining hash table. The data of the hash map consists of a cached size
and an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets
is always a power of two. The hash map doubles its size upon inserting an element such that the
number of elements is more than 75% of the number of buckets.</p>
                  <p>
                    The hash table is backed by an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a></code>. Users should make sure that the hash map is used linearly to
avoid expensive copies.</p>
                  <p>
                    The hash map uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> (provided by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> typeclass) to compare keys and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable.hash" data-verso-hover="1759">hash</span></a></code> (provided by
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> typeclass) to hash them. To ensure that the operations behave as expected, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>
should be an equivalence relation and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> should imply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> (see also the
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a></code> typeclasses). Both of these conditions are automatic if the BEq
instance is lawful, i.e., if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.28433" data-verso-hover="4767">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28619" data-verso-hover="4767">b</span></code>.</p>
                  <p>
                    These hash maps contain a bundled well-formedness invariant, which means that they cannot
be used in nested inductive types. For these use cases, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">Std.DHashMap.Raw.WF</span></a></code> unbundle the invariant from the hash map. When in doubt, prefer
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code> over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.</p>
                  <p>
                    For a variant that is more convenient for use in proofs because of extensionalities, see
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a></code> which is defined in the module <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.ExtDHashMap</span></code>.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Creation">
                  18.17.3.1. Creation</h3>
                <div class="namedocs" id="Std___DHashMap___emptyWithCapacity">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.emptyWithCapacity" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.emptyWithCapacity.{u, v} {</span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.31597" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.31600" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31597" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.emptyWithCapacity.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.31597" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.31600" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31595" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31597" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Creates a new empty hash map. The optional parameter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.30712" data-verso-hover="4736">capacity</span></code> can be supplied to presize the
map so that it can hold the given number of mappings without reallocating. It is also possible to
use the empty collection notations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span></code> to create an empty hash map with the default
capacity.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Properties">
                  18.17.3.2. Properties</h3>
                <div class="namedocs" id="Std___DHashMap___size">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.size" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.31788" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.31789" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.31790" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.31795" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31788" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.31788" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.31789" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.31790" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.31795" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31786" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31788" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                    <p>
                      The number of mappings present in the hash map</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___isEmpty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.isEmpty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.31941" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.31942" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.31943" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.31948" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31941" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.31941" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.31942" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.31943" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.31948" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31939" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31941" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the hash map contains no mappings.</p>
                    <p>
                      Note that if your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> instance is not reflexive or your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> instance is not
lawful, then it is possible that this function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code> even though is not possible
to get anything out of the hash map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___Equiv___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.Equiv" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.Equiv.{u, v} {</span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.32219" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.32220" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.32221" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.32222" data-verso-hover="4768">m₁ </span><span class="var token" data-binding="var-_uniq.32227" data-verso-hover="4768">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32219" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.Equiv.{u, v} {</span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.32219" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.32220" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.32221" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.32222" data-verso-hover="4768">m₁ </span><span class="var token" data-binding="var-_uniq.32227" data-verso-hover="4768">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32217" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32219" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      Two hash maps are equivalent in the sense of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Equiv</span></code> iff
all the keys and values are equal.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Equiv___mk"><span class="const token" data-binding="const-Std.DHashMap.Equiv.mk" data-verso-hover="4769">Std.DHashMap.Equiv.mk</span></a><span class="inter-text">.{u, v}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.DHashMap.Equiv.inner" data-verso-hover="4770">inner</span> : <span class="var token" data-binding="var-_uniq.32188" data-verso-hover="4768">m₁</span><span class="inter-text">.</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><span class="const token" data-binding="const-Std.DHashMap.Raw.Equiv" data-verso-hover="4771">Equiv</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32189" data-verso-hover="4768">m₂</span><span class="inter-text">.</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Equivalence</span><div class="text">
                    <p>
                      The relation <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Equiv___mk"><span class="const token" data-binding="const-Std.DHashMap.Equiv" data-verso-hover="4743">DHashMap.Equiv</span></a></code> can also be written with an infix operator, which is scoped to its namespace:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Std___DHashMap____FLQQ_term____m__FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Std.DHashMap.«term_~m_»"><code class="hover-info"><code class="docstring">Two hash maps are equivalent in the sense of `Equiv` iff
all the keys and values are equal.
</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">~m</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Queries">
                  18.17.3.3. Queries</h3>
                <div class="namedocs" id="Std___DHashMap___contains">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.contains" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33067" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33068" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33069" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.33074" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33067" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.33075" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33067" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33068" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33069" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.33074" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33067" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.33075" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33065" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if there is a mapping for the given key. There is also a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>-valued version
of this: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32998" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32997" data-verso-hover="4768">m</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.32997" data-verso-hover="4768">m</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___contains"><span class="const token" data-binding="const-Std.DHashMap.contains" data-verso-hover="4772">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32998" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>.</p>
                    <p>
                      Observe that this is different behavior than for lists: for lists, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∈</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> uses
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> for comparisons, while for hash maps, both use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___get">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.get" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33433" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33434" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33435" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.33441" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33433" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.33442" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.33443" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33442" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.33441" data-verso-hover="4768">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.33433" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33442" data-verso-hover="45">a</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33433" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33434" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33435" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.33441" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33433" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.33442" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33431" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.33443" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33442" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.33441" data-verso-hover="4768">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.33433" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33442" data-verso-hover="45">a</span></div></pre><div class="text">
                    <p>
                      Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof
of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.33390" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33389" data-verso-hover="4768">m</span></code>.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___get___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.get!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33709" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33710" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33711" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.33717" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33709" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.33718" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text">)
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.33709" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33718" data-verso-hover="45">a</span><span class="inter-text">)] : </span><span class="var token" data-binding="var-_uniq.33709" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33718" data-verso-hover="45">a</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33709" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33710" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33711" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.33717" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33709" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.33718" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33707" data-verso-hover="54">α</span><span class="inter-text">)
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.33709" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33718" data-verso-hover="45">a</span><span class="inter-text">)] : </span><span class="var token" data-binding="var-_uniq.33709" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33718" data-verso-hover="45">a</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___get___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.get?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33944" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33945" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33946" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.33952" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33944" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.33953" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.33944" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33953" data-verso-hover="45">a</span><span class="inter-text">)</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33944" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.33945" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.33946" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.33952" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33944" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.33953" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33942" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.33944" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33953" data-verso-hover="45">a</span><span class="inter-text">)</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___getD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.getD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34182" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34183" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34184" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.34190" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34182" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.34191" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.34192" data-verso-hover="4773">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34182" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34191" data-verso-hover="45">a</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.34182" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34191" data-verso-hover="45">a</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34182" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34183" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34184" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.34190" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34182" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.34191" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34180" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.34192" data-verso-hover="4773">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34182" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34191" data-verso-hover="45">a</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.34182" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34191" data-verso-hover="45">a</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.34169" data-verso-hover="4773">fallback</span></code> if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___getKey">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.getKey" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34460" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34461" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34462" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.34467" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34460" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.34468" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.34469" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34468" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.34467" data-verso-hover="4768">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34460" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34461" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34462" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.34467" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34460" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.34468" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.34469" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34468" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.34467" data-verso-hover="4768">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.34458" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Retrieves the key from the mapping that matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.34427" data-verso-hover="45">a</span></code>. Ensures that such a mapping exists by
requiring a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.34427" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34426" data-verso-hover="4768">m</span></code>. The result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___getKey___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.getKey!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34699" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34700" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34701" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.34707" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34699" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.34708" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34699" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34700" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34701" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.34707" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34699" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.34708" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.34697" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___getKey___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.getKey?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34884" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34885" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34886" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.34891" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34884" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.34892" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34884" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.34885" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.34886" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.34891" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34884" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.34892" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34882" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.
The result in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> case is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___getKeyD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.getKeyD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35090" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35091" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35092" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.35097" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35090" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.35098" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.35099" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35090" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35091" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35092" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.35097" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35090" data-verso-hover="4203">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.35098" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.35099" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.35088" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.35087" data-verso-hover="45">fallback</span></code>.
If a mapping exists the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___keys">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.keys" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.keys.{u, v} {</span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35289" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35290" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35291" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.35296" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35289" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.keys.{u, v} {</span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35289" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35290" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35291" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.35296" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35289" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35287" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Returns a list of all keys present in the hash map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___keysArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.keysArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.keysArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35441" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35442" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35443" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.35448" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35441" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.keysArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35441" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35442" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35443" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.35448" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35441" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35439" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Returns an array of all keys present in the hash map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___values">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.values" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.values.{u, v} {</span><span class="var token" data-binding="var-_uniq.35591" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35592" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35591" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35593" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35591" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35594" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.35600" data-verso-hover="4774">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35591" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35599" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.35594" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35594" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.values.{u, v} {</span><span class="var token" data-binding="var-_uniq.35591" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35592" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35591" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35593" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35591" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35594" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.35600" data-verso-hover="4774">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35591" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35599" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.35594" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35594" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Returns a list of all values present in the hash map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___valuesArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.valuesArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.valuesArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.35758" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35759" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35758" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35760" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35758" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35761" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.35767" data-verso-hover="4774">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35758" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35766" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.35761" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35761" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.valuesArray.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.35758" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35759" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35758" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35760" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35758" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35761" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.35767" data-verso-hover="4774">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35758" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35766" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.35761" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35761" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Returns an array of all values present in the hash map in some order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Modification">
                  18.17.3.4. Modification</h3>
                <div class="namedocs" id="Std___DHashMap___alter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.alter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35940" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35941" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.35947" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.35948" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.35950" data-verso-hover="4775">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35948" data-verso-hover="45">a</span><span class="inter-text">) → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35948" data-verso-hover="45">a</span><span class="inter-text">)) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.35940" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.35941" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.35947" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.35948" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.35950" data-verso-hover="4775">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35948" data-verso-hover="45">a</span><span class="inter-text">) → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35948" data-verso-hover="45">a</span><span class="inter-text">)) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35937" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35939" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key,
allowing creating new values and deleting values via an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code> valued replacement function.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___modify">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.modify" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36214" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.36215" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.36221" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.36222" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.36224" data-verso-hover="4776">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36222" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36222" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36214" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.36215" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.36221" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.36222" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.36224" data-verso-hover="4776">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36222" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36222" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36211" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36213" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___containsThenInsert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.containsThenInsert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.containsThenInsert.{u, v} {</span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36473" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.36474" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36475" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.36480" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36473" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.36481" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.36482" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36473" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36481" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36473" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.containsThenInsert.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36473" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.36474" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36475" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.36480" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36473" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.36481" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.36482" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36473" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36481" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36471" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36473" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, and unconditionally inserts a value for the key.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___containsThenInsertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.containsThenInsertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.containsThenInsertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.36753" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36754" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36755" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.36760" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36753" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.36761" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.36762" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36753" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36761" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36753" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.containsThenInsertIfNew.{u,
    v}
  {</span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36753" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.36754" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.36755" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.36760" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36753" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.36761" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.36762" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36753" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36761" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36751" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36753" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map and inserts a value for the key if it was not found.</p>
                    <p>
                      If the returned <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>, then the returned map is unaltered. If the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>, then
the returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___erase">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.erase" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37074" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37075" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37076" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.37081" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37074" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.37082" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37074" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37074" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37075" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37076" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.37081" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37074" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.37082" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37072" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37074" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Removes the mapping for the given key if it exists.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___filter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.filter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37253" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37254" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37255" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.37259" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.37257" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.37253" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37257" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.37264" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37253" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37253" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37253" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37254" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37255" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.37259" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.37257" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.37253" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37257" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.37264" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37253" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37251" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37253" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Removes all mappings of the hash map for which the given function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___filterMap">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.filterMap" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.filterMap.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37478" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37480" data-verso-hover="4778">δ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.37486" data-verso-hover="4779">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.37484" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.37478" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37484" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.37480" data-verso-hover="4778">δ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37484" data-verso-hover="45">a</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.37491" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37478" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37480" data-verso-hover="4778">δ</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.filterMap.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37478" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37480" data-verso-hover="4778">δ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.37486" data-verso-hover="4779">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.37484" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.37478" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37484" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.37480" data-verso-hover="4778">δ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37484" data-verso-hover="45">a</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.37491" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37478" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37476" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37480" data-verso-hover="4778">δ</span></div></pre><div class="text">
                    <p>
                      Updates the values of the hash map by applying the given function to all mappings, keeping
only those mappings where the function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> value.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___insert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.insert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37791" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37792" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37793" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.37798" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37791" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.37799" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.37800" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37791" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37799" data-verso-hover="45">a</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37791" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37791" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.37792" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.37793" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.37798" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37791" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.37799" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.37800" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37791" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37799" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37789" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37791" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Inserts the given mapping into the map. If there is already a mapping for the given key, then both
key and value will be replaced.</p>
                    <p>
                      Note: this replacement behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> behaves differently: it will return the set
unchanged if a matching key is already present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___insertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.insertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.insertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38114" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.38115" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38116" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.38121" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38114" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.38122" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.38123" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38114" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38122" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38114" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.insertIfNew.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38114" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.38115" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38116" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.38121" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38114" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.38122" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.38123" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38114" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38122" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38112" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38114" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      If there is no mapping for the given key, inserts the given mapping into the map. Otherwise,
returns the map unaltered.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___getThenInsertIfNew___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.getThenInsertIfNew?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.getThenInsertIfNew?.{u, v} {</span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.38379" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38380" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.38386" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.38387" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.38388" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38387" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38387" data-verso-hover="45">a</span><span class="inter-text">)</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.getThenInsertIfNew?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.38379" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38380" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.38386" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.38387" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.38388" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38387" data-verso-hover="45">a</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38387" data-verso-hover="45">a</span><span class="inter-text">)</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38376" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38378" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, returning the associated value, and inserts a value for
the key if it was not found.</p>
                    <p>
                      If the returned value is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38336" data-verso-hover="4780">v</span></code>, then the returned map is unaltered. If it is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>, then the
returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">get?</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___insertMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.insertMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.insertMany.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38810" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.38811" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38812" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38813" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38813" data-verso-hover="4179">ρ</span><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.38815" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.38810" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38815" data-verso-hover="45">a</span><span class="inter-text">)] (</span><span class="var token" data-binding="var-_uniq.38821" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38810" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.38822" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38813" data-verso-hover="4179">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38810" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.insertMany.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38810" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.38811" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.38812" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.38813" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38813" data-verso-hover="4179">ρ</span><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.38815" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.38810" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38815" data-verso-hover="45">a</span><span class="inter-text">)]
  (</span><span class="var token" data-binding="var-_uniq.38821" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38810" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.38822" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.38813" data-verso-hover="4179">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38808" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38810" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Inserts multiple mappings into the hash map by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>. If the same key appears multiple times, the last occurrence takes precedence.</p>
                    <p>
                      Note: this precedence behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertMany</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> behaves differently: it will prefer the first
appearance.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___partition">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.partition" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.partition.{u, v} {</span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39179" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.39180" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.39184" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.39182" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39182" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.39189" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.partition.{u, v} {</span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39179" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.39180" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.39184" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.39182" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39182" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.39189" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39176" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39178" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Partition a hash map into two hash map based on a predicate.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___union">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.union" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.union.{u, v} {</span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39409" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.39412" data-verso-hover="4768">m₁ </span><span class="var token" data-binding="var-_uniq.39417" data-verso-hover="4768">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39409" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39409" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.union.{u, v} {</span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.39409" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.39412" data-verso-hover="4768">m₁ </span><span class="var token" data-binding="var-_uniq.39417" data-verso-hover="4768">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39409" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39407" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39409" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Computes the union of the given hash maps, by traversing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.39406" data-verso-hover="4768">m₂</span></code> and inserting its elements into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.39405" data-verso-hover="4768">m₁</span></code>.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Iteration">
                  18.17.3.5. Iteration</h3>
                <div class="namedocs" id="Std___DHashMap___map">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.map" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39603" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.39605" data-verso-hover="4778">δ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.39611" data-verso-hover="4781">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.39609" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.39603" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39609" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.39605" data-verso-hover="4778">δ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39609" data-verso-hover="45">a</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.39616" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39603" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39605" data-verso-hover="4778">δ</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.39603" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39605" data-verso-hover="4778">δ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.39611" data-verso-hover="4781">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.39609" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.39603" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39609" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.39605" data-verso-hover="4778">δ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39609" data-verso-hover="45">a</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.39616" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39603" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39601" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39605" data-verso-hover="4778">δ</span></div></pre><div class="text">
                    <p>
                      Updates the values of the hash map by applying the given function to all mappings.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___fold">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.fold" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.fold.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39823" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.39825" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39826" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.39832" data-verso-hover="4782">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span><span class="inter-text"> → (</span><span class="var token" data-binding="var-_uniq.39830" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.39823" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39830" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.39833" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.39838" data-verso-hover="4768">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39823" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.fold.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.39823" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.39825" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.39826" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.39832" data-verso-hover="4782">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span><span class="inter-text"> → (</span><span class="var token" data-binding="var-_uniq.39830" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.39823" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39830" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.39833" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.39838" data-verso-hover="4768">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39821" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39823" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.39824" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Folds the given function over the mappings in the hash map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___foldM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.foldM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.foldM.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40060" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40063" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40063" data-verso-hover="4754">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.40065" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40066" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.40072" data-verso-hover="4784">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span><span class="inter-text"> → (</span><span class="var token" data-binding="var-_uniq.40070" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.40060" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40070" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.40063" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.40073" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.40078" data-verso-hover="4768">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40060" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.40063" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.foldM.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40060" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40063" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40063" data-verso-hover="4754">m</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.40065" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40066" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.40072" data-verso-hover="4784">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span><span class="inter-text"> → (</span><span class="var token" data-binding="var-_uniq.40070" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.40060" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40070" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.40063" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.40073" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.40078" data-verso-hover="4768">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40058" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40060" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.40063" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40061" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Monadically computes a value by folding the given function over the mappings in the hash
map in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___forIn">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.forIn" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.forIn.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40345" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40348" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40348" data-verso-hover="4754">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.40350" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40351" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.40357" data-verso-hover="4785">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.40353" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.40345" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40353" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.40348" data-verso-hover="4754">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.40358" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.40363" data-verso-hover="4768">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40345" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.40348" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.forIn.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40345" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40348" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40348" data-verso-hover="4754">m</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.40350" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40351" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.40357" data-verso-hover="4785">f</span><span class="inter-text"> :
    (</span><span class="var token" data-binding="var-_uniq.40353" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.40345" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40353" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.40348" data-verso-hover="4754">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.40358" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.40363" data-verso-hover="4768">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40343" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40345" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.40348" data-verso-hover="4754">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40346" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Support for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span></code> loop construct in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> blocks.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___forM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.forM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.forM.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40664" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40666" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40666" data-verso-hover="4754">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.40668" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40669" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.40673" data-verso-hover="4786">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.40671" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.40664" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40671" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.40666" data-verso-hover="4754">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.40678" data-verso-hover="4768">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40664" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.40666" data-verso-hover="4754">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.forM.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40664" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40666" data-verso-hover="4754">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40666" data-verso-hover="4754">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.40668" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40669" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.40673" data-verso-hover="4786">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.40671" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.40664" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40671" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.40666" data-verso-hover="4754">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.40678" data-verso-hover="4768">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40662" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40664" data-verso-hover="4203">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.40666" data-verso-hover="4754">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div></pre><div class="text">
                    <p>
                      Carries out a monadic action on each mapping in the hash map in some order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Conversion">
                  18.17.3.6. Conversion</h3>
                <div class="namedocs" id="Std___DHashMap___ofList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.ofList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.40896" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.40900" data-verso-hover="4787">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.40899" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.40896" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40899" data-verso-hover="45">a</span><span class="inter-text">)) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40896" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.40896" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.40900" data-verso-hover="4787">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.40899" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.40896" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40899" data-verso-hover="45">a</span><span class="inter-text">)) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40894" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40896" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Creates a hash map from a list of mappings. If the same key appears multiple times, the last
occurrence takes precedence.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___toArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.toArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.toArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.41058" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.41059" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.41060" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.41065" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41058" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.41066" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.41058" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41066" data-verso-hover="45">a</span><span class="inter-text">)</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.toArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.41058" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.41059" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.41060" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.41065" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41058" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.41066" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.41056" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.41058" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41066" data-verso-hover="45">a</span><span class="inter-text">)</span></div></pre><div class="text">
                    <p>
                      Transforms the hash map into an array of mappings in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___toList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.toList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.toList.{u, v} {</span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.41232" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.41233" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.41234" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.41239" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41232" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.41240" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.41232" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41240" data-verso-hover="45">a</span><span class="inter-text">)</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.toList.{u, v} {</span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.41232" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.41233" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.41234" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.41239" data-verso-hover="4768">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap"><span class="const token" data-binding="const-Std.DHashMap" data-verso-hover="4656">Std.DHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41232" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.41240" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.41230" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.41232" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41240" data-verso-hover="45">a</span><span class="inter-text">)</span></div></pre><div class="text">
                    <p>
                      Transforms the hash map into a list of mappings in some order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Unbundled-Variants">
                  18.17.3.7. Unbundled Variants</h3>
                <p>
                  Unbundled maps separate well-formedness proofs from data.
This is primarily useful when defining <a href="Basic-Types/Maps-and-Sets/#raw-data">nested inductive types</a>.
To use these variants, import the modules <code>Std.DHashMap.Raw</code> and <code>Std.DHashMap.RawLemmas</code>.</p>
                <div class="namedocs" id="Std___DHashMap___Raw___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.Raw" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.Raw.{u, v} (</span><span class="var token" data-binding="var-_uniq.43462" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.43464" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.43462" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.Raw.{u, v} (</span><span class="var token" data-binding="var-_uniq.43462" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.43464" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.43462" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div></pre><div class="text">
                    <p>
                      Dependent hash maps without a bundled well-formedness invariant, suitable for use in nested
inductive types. The well-formedness invariant is called <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Raw.WF</span></code>. When in doubt, prefer <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>
over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>. Lemmas about the operations on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.DHashMap.Raw</span></code> are available in the
module <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.DHashMap.RawLemmas</span></code>.</p>
                    <p>
                      The hash table is backed by an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a></code>. Users should make sure that the hash map is used linearly to
avoid expensive copies.</p>
                    <p>
                      This is a simple separate-chaining hash table. The data of the hash map consists of a cached size
and an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets
is always a power of two. The hash map doubles its size upon inserting an element such that the
number of elements is more than 75% of the number of buckets.</p>
                    <p>
                      The hash map uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> (provided by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> typeclass) to compare keys and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable.hash" data-verso-hover="1759">hash</span></a></code> (provided by
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> typeclass) to hash them. To ensure that the operations behave as expected, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>
should be an equivalence relation and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> should imply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> (see also the
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a></code> typeclasses). Both of these conditions are automatic if the BEq
instance is lawful, i.e., if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.41686" data-verso-hover="4788">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41872" data-verso-hover="4788">b</span></code>.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.mk" data-verso-hover="4789">Std.DHashMap.Raw.mk</span></a><span class="inter-text">.{u, v}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.DHashMap.Raw.size" data-verso-hover="4790">size</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></pre><div class="docs">
                        <p>
                          The number of mappings present in the hash map</p>
                        </div>
                      </section>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4791">buckets</span> : <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.AssocList" data-verso-hover="4792">Std.DHashMap.Internal.AssocList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.43448" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.43449" data-verso-hover="4203">β</span><span class="inter-text">)</span></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DHashMap___Raw___WF___wf">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DHashMap.Raw.WF.containsThenInsertIfNew₀" title="Permalink">🔗</a></span><span class="label">inductive predicate</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DHashMap.Raw.WF.{u, v} {</span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44597" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text">] : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44597" data-verso-hover="4203">β</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only"><span class="inter-text">Std.DHashMap.Raw.WF.{u, v} {</span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44597" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text">] :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44595" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44597" data-verso-hover="4203">β</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      Well-formedness predicate for hash maps. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code> will not need to interact with
this. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code> will need to provide proofs of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF</span></code> to lemmas and should use lemmas
like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.empty</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.insert</span></code> (which are always named exactly like the operations they are about)
to show that map operations preserve well-formedness. The constructors of this type are internal
implementation details and should not be accessed by users.</p>
                    <h1>
                      Constructors</h1>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">wf.{u, v} {</span><span class="var token" data-binding="var-_uniq.44109" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44111" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44109" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44109" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44109" data-verso-hover="54">α</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.44116" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44109" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44111" data-verso-hover="4203">β</span><span class="inter-text">} :
  0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44116" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text"> →
    (∀ [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44109" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44109" data-verso-hover="54">α</span><span class="inter-text">],
        </span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw.WFImp" data-verso-hover="4795">Std.DHashMap.Internal.Raw.WFImp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44116" data-verso-hover="4793">m</span><span class="inter-text">) →
      </span><span class="var token" data-binding="var-_uniq.44116" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">emptyWithCapacity₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44137" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44139" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44137" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44137" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44137" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44142" data-verso-hover="7">c</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">} :
  (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.emptyWithCapacity" data-verso-hover="4796">Std.DHashMap.Internal.Raw₀.emptyWithCapacity</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44142" data-verso-hover="7">c</span><span class="inter-text">).</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">insert₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44151" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44153" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44151" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44151" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44151" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44158" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44151" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44153" data-verso-hover="4203">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44161" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44158" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44162" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44151" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44163" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44153" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44162" data-verso-hover="45">a</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44158" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.insert" data-verso-hover="4798">Std.DHashMap.Internal.Raw₀.insert</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44158" data-verso-hover="4793">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44161" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44162" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44163" data-verso-hover="4773">b</span><span class="inter-text">).</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">containsThenInsert₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44187" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44189" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44187" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44187" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44187" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44194" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44187" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44189" data-verso-hover="4203">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44197" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44194" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44198" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44187" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44199" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44189" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44198" data-verso-hover="45">a</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44194" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.containsThenInsert" data-verso-hover="4799">Std.DHashMap.Internal.Raw₀.containsThenInsert</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44194" data-verso-hover="4793">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44197" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44198" data-verso-hover="45">a</span><span class="inter-text">
            </span><span class="var token" data-binding="var-_uniq.44199" data-verso-hover="4773">b</span><span class="inter-text">).</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.snd" data-verso-hover="692">snd</span></a><span class="inter-text">.</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">containsThenInsertIfNew₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44223" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44225" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44223" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44223" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44223" data-verso-hover="54">α</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.44230" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44223" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44225" data-verso-hover="4203">β</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44233" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44230" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44234" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44223" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44235" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44225" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44234" data-verso-hover="45">a</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44230" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.containsThenInsertIfNew" data-verso-hover="4800">Std.DHashMap.Internal.Raw₀.containsThenInsertIfNew</span><span class="inter-text">
            </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44230" data-verso-hover="4793">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44233" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44234" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44235" data-verso-hover="4773">b</span><span class="inter-text">).</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.snd" data-verso-hover="692">snd</span></a><span class="inter-text">.</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">erase₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44259" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44261" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44259" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44259" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44259" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44266" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44259" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44261" data-verso-hover="4203">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44269" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44266" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44270" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44259" data-verso-hover="54">α</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44266" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> → (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.erase" data-verso-hover="4801">Std.DHashMap.Internal.Raw₀.erase</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44266" data-verso-hover="4793">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44269" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44270" data-verso-hover="45">a</span><span class="inter-text">).</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">insertIfNew₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44293" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44295" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44293" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44293" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44293" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44300" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44293" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44295" data-verso-hover="4203">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44303" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44300" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44304" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44293" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44305" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44295" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44304" data-verso-hover="45">a</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44300" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.insertIfNew" data-verso-hover="4802">Std.DHashMap.Internal.Raw₀.insertIfNew</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44300" data-verso-hover="4793">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44303" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44304" data-verso-hover="45">a</span><span class="inter-text">
          </span><span class="var token" data-binding="var-_uniq.44305" data-verso-hover="4773">b</span><span class="inter-text">).</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">getThenInsertIfNew?₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44329" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44331" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44329" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44329" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44329" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44329" data-verso-hover="54">α</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.44337" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44329" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44331" data-verso-hover="4203">β</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44340" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44337" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44341" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44329" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44342" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44331" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44341" data-verso-hover="45">a</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44337" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?" data-verso-hover="4803">Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44337" data-verso-hover="4793">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44340" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44341" data-verso-hover="45">a</span><span class="inter-text">
            </span><span class="var token" data-binding="var-_uniq.44342" data-verso-hover="4773">b</span><span class="inter-text">).</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.snd" data-verso-hover="692">snd</span></a><span class="inter-text">.</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">filter₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44367" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44369" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44367" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44367" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44367" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44374" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44367" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44369" data-verso-hover="4203">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44377" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44374" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44381" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.44379" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44367" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.44369" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44379" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44374" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> → (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.filter" data-verso-hover="4804">Std.DHashMap.Internal.Raw₀.filter</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44381" data-verso-hover="4777">f</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44374" data-verso-hover="4793">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44377" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text">).</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">constGetThenInsertIfNew?₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44402" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44403" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44402" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44402" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44409" data-verso-hover="4805">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44402" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44408" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.44403" data-verso-hover="244">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44412" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44409" data-verso-hover="4805">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44413" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44402" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44414" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44403" data-verso-hover="244">β</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44409" data-verso-hover="4805">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.Const.getThenInsertIfNew?" data-verso-hover="4806">Std.DHashMap.Internal.Raw₀.Const.getThenInsertIfNew?</span><span class="inter-text">
            </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44409" data-verso-hover="4805">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44412" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44413" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44414" data-verso-hover="185">b</span><span class="inter-text">).</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.snd" data-verso-hover="692">snd</span></a><span class="inter-text">.</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">modify₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44438" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44440" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44438" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44438" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44438" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44438" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44446" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44438" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44440" data-verso-hover="4203">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44449" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44446" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44450" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44438" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44452" data-verso-hover="4776">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44440" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44450" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.44440" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44450" data-verso-hover="45">a</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44446" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.modify" data-verso-hover="4807">Std.DHashMap.Internal.Raw₀.modify</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44446" data-verso-hover="4793">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44449" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44450" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44452" data-verso-hover="4776">f</span><span class="inter-text">).</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">constModify₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44477" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44478" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44477" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44477" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44484" data-verso-hover="4805">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44477" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44483" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.44478" data-verso-hover="244">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44487" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44484" data-verso-hover="4805">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44488" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44477" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44490" data-verso-hover="4747">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44478" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.44478" data-verso-hover="244">β</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44484" data-verso-hover="4805">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.Const.modify" data-verso-hover="4808">Std.DHashMap.Internal.Raw₀.Const.modify</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44484" data-verso-hover="4805">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44487" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44488" data-verso-hover="45">a</span><span class="inter-text">
          </span><span class="var token" data-binding="var-_uniq.44490" data-verso-hover="4747">f</span><span class="inter-text">).</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">alter₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44514" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44516" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44514" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44514" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44514" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44514" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44522" data-verso-hover="4793">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44514" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44516" data-verso-hover="4203">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44525" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44522" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44526" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44514" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44528" data-verso-hover="4775">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.44516" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44526" data-verso-hover="45">a</span><span class="inter-text">) → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.44516" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44526" data-verso-hover="45">a</span><span class="inter-text">)} :
  </span><span class="var token" data-binding="var-_uniq.44522" data-verso-hover="4793">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.alter" data-verso-hover="4809">Std.DHashMap.Internal.Raw₀.alter</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44522" data-verso-hover="4793">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44525" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44526" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44528" data-verso-hover="4775">f</span><span class="inter-text">).</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="inter-text">constAlter₀.{u, v} {</span><span class="var token" data-binding="var-_uniq.44553" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44554" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44553" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44553" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.44560" data-verso-hover="4805">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44553" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44559" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.44554" data-verso-hover="244">β</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44563" data-verso-hover="4797">h</span><span class="inter-text"> : 0</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44560" data-verso-hover="4805">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw.buckets" data-verso-hover="4794">buckets</span></a><span class="inter-text">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="161">size</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.44564" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.44553" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.44566" data-verso-hover="4746">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44554" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44554" data-verso-hover="244">β</span><span class="inter-text">} :
  </span><span class="var token" data-binding="var-_uniq.44560" data-verso-hover="4805">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a><span class="inter-text"> →
    (</span><span class="const token" data-binding="const-Std.DHashMap.Internal.Raw₀.Const.alter" data-verso-hover="4810">Std.DHashMap.Internal.Raw₀.Const.alter</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟨</span></a><span class="var token" data-binding="var-_uniq.44560" data-verso-hover="4805">m</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">, </span></a><span class="var token" data-binding="var-_uniq.44563" data-verso-hover="4797">h</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="470">⟩</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44564" data-verso-hover="45">a</span><span class="inter-text">
          </span><span class="var token" data-binding="var-_uniq.44566" data-verso-hover="4746">f</span><span class="inter-text">).</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="473">val</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </div>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="ExtHashMap">
                18.17.4. Extensional Hash Maps<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=ExtHashMap" title="Permalink">🔗</a></span></h2>
              <p>
                The declarations in this section should be imported using <code>import Std.ExtHashMap</code>.</p>
              <div class="namedocs" id="Std___ExtHashMap">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.50072" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.50073" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50072" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50072" data-verso-hover="54">α</span><span class="inter-text">] :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.50072" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.50073" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50072" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50072" data-verso-hover="54">α</span><span class="inter-text">] :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div></pre><div class="text">
                  <p>
                    Hash maps.</p>
                  <p>
                    This is a simple separate-chaining hash table. The data of the hash map consists of a cached size
and an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets
is always a power of two. The hash map doubles its size upon inserting an element such that the
number of elements is more than 75% of the number of buckets.</p>
                  <p>
                    The hash table is backed by an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a></code>. Users should make sure that the hash map is used linearly to
avoid expensive copies.</p>
                  <p>
                    The hash map uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> (provided by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> typeclass) to compare keys and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable.hash" data-verso-hover="1759">hash</span></a></code> (provided by
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> typeclass) to hash them. To ensure that the operations behave as expected, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>
should be an equivalence relation and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> should imply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> (see also the
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a></code> typeclasses). Both of these conditions are automatic if the BEq
instance is lawful, i.e., if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.48237" data-verso-hover="4811">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48423" data-verso-hover="4811">b</span></code>.</p>
                  <p>
                    In contrast to regular hash maps, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a></code> offers several extensionality lemmas
and therefore has more lemmas about equality of hash maps. This however also makes it lose the
ability to iterate freely over hash maps.</p>
                  <p>
                    These hash maps contain a bundled well-formedness invariant, which means that they cannot
be used in nested inductive types. For these use cases, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">Std.HashMap.Raw</span></a></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4670">Std.HashMap.Raw.WF</span></a></code> unbundle the invariant from the hash map. When in doubt, prefer
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashMap</span></code> over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code>.</p>
                  <p>
                    Dependent hash maps, in which keys may occur in their values' types, are available as
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a></code> in the module <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.ExtDHashMap</span></code>.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Creation">
                  18.17.4.1. Creation</h3>
                <div class="namedocs" id="Std___ExtHashMap___emptyWithCapacity">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.emptyWithCapacity" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.emptyWithCapacity.{u, v} {</span><span class="var token" data-binding="var-_uniq.51476" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.51477" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51476" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51476" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.51480" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51476" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51477" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.emptyWithCapacity.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.51476" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.51477" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51476" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51476" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.51480" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51476" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51477" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Creates a new empty hash map. The optional parameter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.50593" data-verso-hover="4736">capacity</span></code> can be supplied to presize the
map so that it can hold the given number of mappings without reallocating. It is also possible to
use the empty collection notations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span></code> to create an empty hash map with the default
capacity.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Properties">
                  18.17.4.2. Properties</h3>
                <div class="namedocs" id="Std___ExtHashMap___size">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.size" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.51663" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.51664" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.51665" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.51672" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51663" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.51663" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.51664" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.51665" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.51672" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51662" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51663" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                    <p>
                      The number of mappings present in the hash map</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___isEmpty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.isEmpty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.51835" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.51836" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.51837" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.51844" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51835" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.51835" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.51836" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.51837" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.51844" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51834" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.51835" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the hash map contains no mappings.</p>
                    <p>
                      Note that if your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> instance is not reflexive or your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> instance is not
lawful, then it is possible that this function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code> even though is not possible
to get anything out of the hash map.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Queries">
                  18.17.4.3. Queries</h3>
                <div class="namedocs" id="Std___ExtHashMap___contains">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.contains" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.52174" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.52175" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.52176" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.52183" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52174" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.52184" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.contains.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.52174" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.52175" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.52176" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.52183" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52174" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.52184" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.52173" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if there is a mapping for the given key. There is also a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>-valued version
of this: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.52079" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52078" data-verso-hover="4812">m</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.52078" data-verso-hover="4812">m</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap___contains"><span class="const token" data-binding="const-Std.ExtHashMap.contains" data-verso-hover="4813">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52079" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>.</p>
                    <p>
                      Observe that this is different behavior than for lists: for lists, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∈</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> uses
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> for comparisons, while for hash maps, both use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___get">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.get" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.52804" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.52805" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.52806" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.52813" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52804" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.52814" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.52815" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.52814" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.52813" data-verso-hover="4812">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.52804" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.52804" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.52805" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.52806" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.52813" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52804" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.52814" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.52803" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.52815" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.52814" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.52813" data-verso-hover="4812">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.52804" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      The notation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.52513" data-verso-hover="4812">m</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.52514" data-verso-hover="45">a</span><span class="unknown token" data-binding="">]</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.52513" data-verso-hover="4812">m</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.52514" data-verso-hover="45">a</span><span class="unknown token" data-binding="">]'</span><span class="var token" data-binding="var-_uniq.52515" data-verso-hover="4745">h</span></code> is preferred over calling this function directly.</p>
                    <p>
                      Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.52775" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52774" data-verso-hover="4812">m</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___get___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.get!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.53197" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.53198" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.53199" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53197" data-verso-hover="244">β</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.53207" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53197" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.53208" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.53197" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.53197" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.53198" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.53199" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53197" data-verso-hover="244">β</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.53207" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53197" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.53208" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.53196" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.53197" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      The notation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.53098" data-verso-hover="4812">m</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.53099" data-verso-hover="45">a</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">!</span></code> is preferred over calling this function directly.</p>
                    <p>
                      Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___get___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.get?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.53511" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.53512" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.53513" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.53520" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53511" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.53521" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53511" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.53511" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.53512" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.53513" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.53520" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53511" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.53521" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.53510" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53511" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      The notation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.53422" data-verso-hover="4812">m</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.53423" data-verso-hover="45">a</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span></code> is preferred over calling this function directly.</p>
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such mapping is present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___getD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.getD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.53748" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.53749" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.53750" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.53757" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53748" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.53758" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.53759" data-verso-hover="185">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.53748" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.53748" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.53748" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.53749" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.53750" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.53757" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53748" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.53758" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.53747" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.53759" data-verso-hover="185">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.53748" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.53748" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.53746" data-verso-hover="185">fallback</span></code> if no such mapping is present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___getKey">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.getKey" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54008" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54009" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54010" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54017" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54008" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54018" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54019" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54018" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.54017" data-verso-hover="4812">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54008" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54009" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54010" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54017" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54008" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54018" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.54019" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54018" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.54017" data-verso-hover="4812">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.54007" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Retrieves the key from the mapping that matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.53963" data-verso-hover="45">a</span></code>. Ensures that such a mapping exists by
requiring a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.53963" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53962" data-verso-hover="4812">m</span></code>. The result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___getKey___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.getKey!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54264" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54265" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54266" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54274" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54264" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54275" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54264" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54265" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54266" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54274" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54264" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54275" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.54263" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___getKey___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.getKey?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54466" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54467" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54468" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54475" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54466" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54476" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54466" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54467" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54468" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54475" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54466" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54476" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54465" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.
The result in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> case is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___getKeyD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.getKeyD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54689" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54690" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54691" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54698" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54689" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54699" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.54700" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54689" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54690" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54691" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54698" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54689" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.54699" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.54700" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.54688" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.54687" data-verso-hover="45">fallback</span></code>.
If a mapping exists the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Modification">
                  18.17.4.4. Modification</h3>
                <div class="namedocs" id="Std___ExtHashMap___alter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.alter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54918" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54919" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54926" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54927" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54929" data-verso-hover="4746">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.54918" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.54919" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.54926" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.54927" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.54929" data-verso-hover="4746">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54916" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54917" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key,
allowing creating new values and deleting values via an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code> valued replacement function.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___modify">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.modify" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55186" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.55187" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.55194" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.55195" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.55197" data-verso-hover="4747">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55186" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.55187" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.55194" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.55195" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.55197" data-verso-hover="4747">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55184" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55185" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___containsThenInsert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.containsThenInsert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.containsThenInsert.{u, v} {</span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55441" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.55442" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55443" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.55450" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55441" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.55451" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.55452" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55441" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55441" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.containsThenInsert.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55441" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55442" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.55443" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.55450" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55441" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.55451" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.55452" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55441" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55440" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55441" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, and unconditionally inserts a value for the key.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___containsThenInsertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.containsThenInsertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.containsThenInsertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55736" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.55737" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55738" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.55745" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55736" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.55746" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.55747" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55736" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55736" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.containsThenInsertIfNew.{u,
    v}
  {</span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55736" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.55737" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.55738" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.55745" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55736" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.55746" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.55747" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.55736" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55735" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55736" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map and inserts a value for the key if it was not found.</p>
                    <p>
                      If the returned <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>, then the returned map is unaltered. If the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>, then
the returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___erase">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.erase" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56068" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56069" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56070" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.56077" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56068" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.56078" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56068" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56068" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56069" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56070" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.56077" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56068" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.56078" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56067" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56068" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Removes the mapping for the given key if it exists.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___filter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.filter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56264" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56265" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56266" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.56272" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.56264" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.56277" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56264" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56264" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56264" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56265" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56266" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.56272" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.56264" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.56277" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56264" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56263" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56264" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Removes all mappings of the hash map for which the given function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___filterMap">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.filterMap" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.filterMap.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56491" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56492" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56493" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56494" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.56500" data-verso-hover="4750">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.56491" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56492" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.56505" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56491" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56492" data-verso-hover="4179">γ</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.filterMap.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56491" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56492" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56493" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56494" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.56500" data-verso-hover="4750">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.56491" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56492" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.56505" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56491" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56490" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56492" data-verso-hover="4179">γ</span></div></pre><div class="text">
                    <p>
                      Updates the values of the hash map by applying the given function to all mappings, keeping
only those mappings where the function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> value.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___insert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.insert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56813" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56814" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56815" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.56822" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56813" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.56823" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.56824" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56813" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56813" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56813" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.56814" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.56815" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.56822" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56813" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.56823" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.56824" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56813" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56813" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Inserts the given mapping into the map. If there is already a mapping for the given key, then both
key and value will be replaced.</p>
                    <p>
                      Note: this replacement behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> behaves differently: it will return the set
unchanged if a matching key is already present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___insertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.insertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.insertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57147" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57148" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.57149" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.57156" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57147" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.57157" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.57158" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57147" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57147" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.insertIfNew.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57147" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57148" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.57149" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.57156" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57147" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.57157" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.57158" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57147" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57146" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57147" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      If there is no mapping for the given key, inserts the given mapping into the map. Otherwise,
returns the map unaltered.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___getThenInsertIfNew___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.getThenInsertIfNew?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.getThenInsertIfNew?.{u, v} {</span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.57414" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57415" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.57422" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.57423" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.57424" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.getThenInsertIfNew?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57414" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.57415" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.57422" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.57423" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.57424" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57412" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57413" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, returning the associate value, and inserts a value for
the key if it was not found.</p>
                    <p>
                      If the returned value is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57381" data-verso-hover="4814">v</span></code>, then the returned map is unaltered. If it is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>, then the
returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">get?</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___insertMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.insertMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.insertMany.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57816" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.57817" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57818" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.57821" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57821" data-verso-hover="4179">ρ</span><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.57816" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.57828" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57816" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.57829" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57821" data-verso-hover="4179">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57816" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.insertMany.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57816" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.57817" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.57818" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.57821" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57821" data-verso-hover="4179">ρ</span><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.57816" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.57828" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57816" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.57829" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.57821" data-verso-hover="4179">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57815" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57816" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Inserts multiple mappings into the hash map by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>. If the same key appears multiple times, the last occurrence takes precedence.</p>
                    <p>
                      Note: this precedence behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertMany</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> behaves differently: it will prefer the first
appearance.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___insertManyIfNewUnit">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.insertManyIfNewUnit" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.insertManyIfNewUnit.{u, w} {</span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.58243" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.58244" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.58247" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58247" data-verso-hover="4179">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.58254" data-verso-hover="4815">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.58255" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.58247" data-verso-hover="4179">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.insertManyIfNewUnit.{u, w}
  {</span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.58243" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.58244" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.58247" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58247" data-verso-hover="4179">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.58254" data-verso-hover="4815">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.58255" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.58247" data-verso-hover="4179">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58242" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div></pre><div class="text">
                    <p>
                      Inserts multiple keys with the value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code> into the hash map by iterating over the given collection
and calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>. If the same key appears multiple times, the first occurrence takes
precedence.</p>
                    <p>
                      This is mainly useful to implement <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.insertMany</span></code>, so if you are considering using this,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> might be a better fit for you.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Iteration">
                  18.17.4.5. Iteration</h3>
                <div class="namedocs" id="Std___ExtHashMap___map">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.map" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.58548" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.58549" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.58550" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.58551" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.58557" data-verso-hover="2642">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.58548" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.58549" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.58562" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58548" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58549" data-verso-hover="4179">γ</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.58548" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.58549" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.58550" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.58551" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.58557" data-verso-hover="2642">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.58548" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.58549" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.58562" data-verso-hover="4812">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58548" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58547" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58549" data-verso-hover="4179">γ</span></div></pre><div class="text">
                    <p>
                      Updates the values of the hash map by applying the given function to all mappings.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Maps--Conversion">
                  18.17.4.6. Conversion</h3>
                <div class="namedocs" id="Std___ExtHashMap___ofList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.ofList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.58770" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.58773" data-verso-hover="4447">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.58770" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58770" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.58770" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.58773" data-verso-hover="4447">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.58770" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58769" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58770" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Creates a hash map from a list of mappings. If the same key appears multiple times, the last
occurrence takes precedence.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___unitOfArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.unitOfArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.unitOfArray.{u} {</span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.58953" data-verso-hover="303">l</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.unitOfArray.{u}
  {</span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.58953" data-verso-hover="303">l</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.58950" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div></pre><div class="text">
                    <p>
                      Creates a hash map from an array of keys, associating the value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code> with each key.</p>
                    <p>
                      This is mainly useful to implement <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.ofArray</span></code>, so if you are considering using this,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> might be a better fit for you.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashMap___unitOfList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashMap.unitOfList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashMap.unitOfList.{u} {</span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.59159" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtHashMap.unitOfList.{u} {</span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.59159" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.59156" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></div></pre><div class="text">
                    <p>
                      Creates a hash map from a list of keys, associating the value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code> with each key.</p>
                    <p>
                      This is mainly useful to implement <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.ofList</span></code>, so if you are considering using this,
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> might be a better fit for you.</p>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="ExtDHashMap">
                18.17.5. Extensional Dependent Hash Maps<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=ExtDHashMap" title="Permalink">🔗</a></span></h2>
              <p>
                The declarations in this section should be imported using <code>import Std.ExtDHashMap</code>.</p>
              <div class="namedocs" id="Std___ExtDHashMap">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.61349" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.61351" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.61349" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.61349" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.61349" data-verso-hover="54">α</span><span class="inter-text">] : </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.61349" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.61351" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.61349" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.61349" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.61349" data-verso-hover="54">α</span><span class="inter-text">] :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div></pre><div class="text">
                  <p>
                    Extensional dependent hash maps.</p>
                  <p>
                    This is a simple separate-chaining hash table. The data of the hash map consists of a cached size
and an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets
is always a power of two. The hash map doubles its size upon inserting an element such that the
number of elements is more than 75% of the number of buckets.</p>
                  <p>
                    The hash table is backed by an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a></code>. Users should make sure that the hash map is used linearly to
avoid expensive copies.</p>
                  <p>
                    The hash map uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> (provided by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> typeclass) to compare keys and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable.hash" data-verso-hover="1759">hash</span></a></code> (provided by
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> typeclass) to hash them. To ensure that the operations behave as expected, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>
must be an equivalence relation and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> must imply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> (see also the
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a></code> typeclasses). Both of these conditions are automatic if the BEq
instance is lawful, i.e., if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.59547" data-verso-hover="4816">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.59733" data-verso-hover="4816">b</span></code>.</p>
                  <p>
                    In contrast to regular dependent hash maps, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a></code> offers several extensionality lemmas
and therefore has more lemmas about equality of hash maps. This however also makes it lose the
ability to iterate freely over the hash map.</p>
                  <p>
                    These hash maps contain a bundled well-formedness invariant, which means that they cannot
be used in nested inductive types. For these use cases, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___mk"><span class="const token" data-binding="const-Std.DHashMap.Raw" data-verso-hover="4761">Std.DHashMap.Raw</span></a></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___DHashMap___Raw___WF___wf"><span class="const token" data-binding="const-Std.DHashMap.Raw.WF" data-verso-hover="4766">Std.DHashMap.Raw.WF</span></a></code> unbundle the invariant from the hash map. When in doubt, prefer
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code> over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Creation">
                  18.17.5.1. Creation</h3>
                <div class="namedocs" id="Std___ExtDHashMap___emptyWithCapacity">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.emptyWithCapacity" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.emptyWithCapacity.{u, v} {</span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.62698" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.62701" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62698" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.emptyWithCapacity.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.62698" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.62701" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62696" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62698" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Creates a new empty hash map. The optional parameter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.61813" data-verso-hover="4736">capacity</span></code> can be supplied to presize the
map so that it can hold the given number of mappings without reallocating. It is also possible to
use the empty collection notations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span></code> to create an empty hash map with the default
capacity.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Properties">
                  18.17.5.2. Properties</h3>
                <div class="namedocs" id="Std___ExtDHashMap___size">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.size" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.62891" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.62892" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.62893" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.62900" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62891" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.62891" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.62892" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.62893" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.62900" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62889" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62891" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                    <p>
                      The number of mappings present in the hash map</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___isEmpty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.isEmpty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63070" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.63071" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63072" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.63079" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63070" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.isEmpty.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63070" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.63071" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63072" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.63079" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63068" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63070" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the hash map contains no mappings.</p>
                    <p>
                      Note that if your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> instance is not reflexive or your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> instance is not
lawful, then it is possible that this function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code> even though is not possible
to get anything out of the hash map.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Queries">
                  18.17.5.3. Queries</h3>
                <div class="namedocs" id="Std___ExtDHashMap___contains">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.contains" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63420" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.63421" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63422" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.63429" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63420" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.63430" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.contains.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63420" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.63421" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63422" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.63429" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63420" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.63430" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63418" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if there is a mapping for the given key. There is also a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>-valued version
of this: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.63320" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63319" data-verso-hover="4817">m</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.63319" data-verso-hover="4817">m</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap___contains"><span class="const token" data-binding="const-Std.ExtDHashMap.contains" data-verso-hover="4818">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63320" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>.</p>
                    <p>
                      Observe that this is different behavior than for lists: for lists, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∈</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> uses
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> for comparisons, while for hash maps, both use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___get">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.get" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63841" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63842" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.63843" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.63849" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63841" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.63850" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.63851" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63850" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.63849" data-verso-hover="4817">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.63841" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63850" data-verso-hover="45">a</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.63841" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.63842" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.63843" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.63849" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63841" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.63850" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63839" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.63851" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.63850" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.63849" data-verso-hover="4817">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.63841" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63850" data-verso-hover="45">a</span></div></pre><div class="text">
                    <p>
                      Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof
of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.63765" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63764" data-verso-hover="4817">m</span></code>.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___get___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.get!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64117" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64118" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64119" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.64125" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64117" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.64126" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text">)
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.64117" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64126" data-verso-hover="45">a</span><span class="inter-text">)] : </span><span class="var token" data-binding="var-_uniq.64117" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64126" data-verso-hover="45">a</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64117" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64118" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64119" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.64125" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64117" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.64126" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64115" data-verso-hover="54">α</span><span class="inter-text">)
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.64117" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64126" data-verso-hover="45">a</span><span class="inter-text">)] : </span><span class="var token" data-binding="var-_uniq.64117" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64126" data-verso-hover="45">a</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___get___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.get?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64352" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64353" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64354" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.64360" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64352" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.64361" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.64352" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64361" data-verso-hover="45">a</span><span class="inter-text">)</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64352" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64353" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64354" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.64360" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64352" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.64361" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64350" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.64352" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64361" data-verso-hover="45">a</span><span class="inter-text">)</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___getD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.getD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64590" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64591" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64592" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.64598" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64590" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.64599" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.64600" data-verso-hover="4773">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64590" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64599" data-verso-hover="45">a</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.64590" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64599" data-verso-hover="45">a</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64590" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64591" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64592" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.64598" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64590" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.64599" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64588" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.64600" data-verso-hover="4773">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64590" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64599" data-verso-hover="45">a</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.64590" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64599" data-verso-hover="45">a</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.64577" data-verso-hover="4773">fallback</span></code> if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___getKey">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.getKey" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64885" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64886" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64887" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.64894" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64885" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.64895" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.64896" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64895" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.64894" data-verso-hover="4817">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64885" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.64886" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.64887" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.64894" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64885" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.64895" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.64896" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.64895" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.64894" data-verso-hover="4817">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.64883" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Retrieves the key from the mapping that matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.64837" data-verso-hover="45">a</span></code>. Ensures that such a mapping exists by
requiring a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.64837" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64836" data-verso-hover="4817">m</span></code>. The result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___getKey___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.getKey!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65148" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.65149" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65150" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.65158" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65148" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.65159" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.getKey!.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65148" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.65149" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65150" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.65158" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65148" data-verso-hover="4203">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.65159" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.65146" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___getKey___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.getKey?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65357" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.65358" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65359" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.65366" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65357" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.65367" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.getKey?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65357" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.65358" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65359" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.65366" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65357" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.65367" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65355" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.
The result in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> case is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___getKeyD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.getKeyD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65587" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.65588" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65589" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.65596" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65587" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.65597" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.65598" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.getKeyD.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65587" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.65588" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65589" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.65596" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65587" data-verso-hover="4203">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.65597" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.65598" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.65585" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.65584" data-verso-hover="45">fallback</span></code>.
If a mapping exists the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Modification">
                  18.17.5.4. Modification</h3>
                <div class="namedocs" id="Std___ExtDHashMap___alter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.alter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65821" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.65822" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.65828" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.65829" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.65831" data-verso-hover="4775">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65829" data-verso-hover="45">a</span><span class="inter-text">) → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65829" data-verso-hover="45">a</span><span class="inter-text">)) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.65821" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.65822" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.65828" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.65829" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.65831" data-verso-hover="4775">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65829" data-verso-hover="45">a</span><span class="inter-text">) → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65829" data-verso-hover="45">a</span><span class="inter-text">)) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65818" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.65820" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key,
allowing creating new values and deleting values via an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code> valued replacement function.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___modify">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.modify" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66095" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.66096" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.66102" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.66103" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.66105" data-verso-hover="4776">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66103" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66103" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66095" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.66096" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.66102" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.66103" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.66105" data-verso-hover="4776">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66103" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66103" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66092" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66094" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___containsThenInsert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.containsThenInsert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.containsThenInsert.{u, v} {</span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66358" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.66359" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66360" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.66367" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66358" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.66368" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.66369" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66358" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66368" data-verso-hover="45">a</span><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66358" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.containsThenInsert.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66358" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.66359" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66360" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.66367" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66358" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.66368" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.66369" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66358" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66368" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66356" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66358" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, and unconditionally inserts a value for the key.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___containsThenInsertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.containsThenInsertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.containsThenInsertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.66666" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66667" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66668" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.66675" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66666" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.66676" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.66677" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66666" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66676" data-verso-hover="45">a</span><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66666" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.containsThenInsertIfNew.{u,
    v}
  {</span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66666" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.66667" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.66668" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.66675" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66666" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.66676" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.66677" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.66666" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66676" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66664" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66666" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map and inserts a value for the key if it was not found.</p>
                    <p>
                      If the returned <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>, then the returned map is unaltered. If the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>, then
the returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___erase">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.erase" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67011" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67012" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67013" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.67020" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67011" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.67021" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67011" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67011" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67012" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67013" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.67020" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67011" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.67021" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67009" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67011" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Removes the mapping for the given key if it exists.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___filter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.filter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67214" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67215" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67216" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.67222" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.67220" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.67214" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67220" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.67227" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67214" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67214" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67214" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67215" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67216" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.67222" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.67220" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.67214" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67220" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.67227" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67214" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67212" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67214" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Removes all mappings of the hash map for which the given function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___filterMap">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.filterMap" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.filterMap.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67463" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67465" data-verso-hover="4778">γ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67466" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67467" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.67473" data-verso-hover="4819">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.67471" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.67463" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67471" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.67465" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67471" data-verso-hover="45">a</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.67478" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67463" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67465" data-verso-hover="4778">γ</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.filterMap.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67463" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67465" data-verso-hover="4778">γ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67466" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67467" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.67473" data-verso-hover="4819">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.67471" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.67463" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67471" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.67465" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67471" data-verso-hover="45">a</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.67478" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67463" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67461" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67465" data-verso-hover="4778">γ</span></div></pre><div class="text">
                    <p>
                      Updates the values of the hash map by applying the given function to all mappings, keeping
only those mappings where the function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> value.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___insert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.insert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67820" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67821" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67822" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.67829" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67820" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.67830" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.67831" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67820" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67830" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67820" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67820" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.67821" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.67822" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.67829" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67820" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.67830" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.67831" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.67820" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67830" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67818" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.67820" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Inserts the given mapping into the map. If there is already a mapping for the given key, then both
key and value will be replaced.</p>
                    <p>
                      Note: this replacement behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> behaves differently: it will return the set
unchanged if a matching key is already present.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___insertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.insertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.insertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68167" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.68168" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68169" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.68176" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68167" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.68177" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.68178" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68167" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68177" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68167" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.insertIfNew.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68167" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.68168" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68169" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.68176" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68167" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.68177" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.68178" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68167" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68177" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68165" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68167" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      If there is no mapping for the given key, inserts the given mapping into the map. Otherwise,
returns the map unaltered.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___getThenInsertIfNew___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.getThenInsertIfNew?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.getThenInsertIfNew?.{u, v} {</span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.68454" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68455" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.68461" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.68462" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.68463" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68462" data-verso-hover="45">a</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68462" data-verso-hover="45">a</span><span class="inter-text">)</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.getThenInsertIfNew?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.68454" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68455" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.68461" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.68462" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.68463" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68462" data-verso-hover="45">a</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68462" data-verso-hover="45">a</span><span class="inter-text">)</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68451" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68453" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, returning the associated value, and inserts a value for
the key if it was not found.</p>
                    <p>
                      If the returned value is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68411" data-verso-hover="4820">v</span></code>, then the returned map is unaltered. If it is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>, then the
returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">get?</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulBEq___mk"><span class="const token" data-binding="const-LawfulBEq" data-verso-hover="1743">LawfulBEq</span></a></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtDHashMap___insertMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.insertMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.insertMany.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68889" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.68890" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68891" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.68894" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68894" data-verso-hover="4179">ρ</span><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.68896" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.68889" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68896" data-verso-hover="45">a</span><span class="inter-text">)] (</span><span class="var token" data-binding="var-_uniq.68902" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68889" data-verso-hover="4203">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.68903" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68894" data-verso-hover="4179">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68889" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.insertMany.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68889" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.68890" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.68891" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.68894" data-verso-hover="4179">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68894" data-verso-hover="4179">ρ</span><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.68896" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.68889" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68896" data-verso-hover="45">a</span><span class="inter-text">)]
  (</span><span class="var token" data-binding="var-_uniq.68902" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68889" data-verso-hover="4203">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.68903" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.68894" data-verso-hover="4179">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68887" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68889" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Inserts multiple mappings into the hash map by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>. If the same key appears multiple times, the last occurrence takes precedence.</p>
                    <p>
                      Note: this precedence behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertMany</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> behaves differently: it will prefer the first
appearance.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Iteration">
                  18.17.5.5. Iteration</h3>
                <div class="namedocs" id="Std___ExtDHashMap___map">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.map" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.69282" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.69284" data-verso-hover="4778">γ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.69285" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.69286" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.69292" data-verso-hover="4821">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.69290" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.69282" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69290" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.69284" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69290" data-verso-hover="45">a</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.69297" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69282" data-verso-hover="4203">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69284" data-verso-hover="4778">γ</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.69282" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.69284" data-verso-hover="4778">γ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.69285" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.69286" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.69292" data-verso-hover="4821">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.69290" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.69282" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69290" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.69284" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69290" data-verso-hover="45">a</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.69297" data-verso-hover="4817">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69282" data-verso-hover="4203">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69280" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69284" data-verso-hover="4778">γ</span></div></pre><div class="text">
                    <p>
                      Updates the values of the hash map by applying the given function to all mappings.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Conversion">
                  18.17.5.6. Conversion</h3>
                <div class="namedocs" id="Std___ExtDHashMap___ofList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtDHashMap.ofList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtDHashMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.69539" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.69543" data-verso-hover="4787">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.69542" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.69539" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69542" data-verso-hover="45">a</span><span class="inter-text">)) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69539" data-verso-hover="4203">β</span></div><div class="narrow-only"><span class="inter-text">Std.ExtDHashMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.69539" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.69543" data-verso-hover="4787">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.69542" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.69539" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69542" data-verso-hover="45">a</span><span class="inter-text">)) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtDHashMap"><span class="const token" data-binding="const-Std.ExtDHashMap" data-verso-hover="4660">Std.ExtDHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69537" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69539" data-verso-hover="4203">β</span></div></pre><div class="text">
                    <p>
                      Creates a hash map from a list of mappings. If the same key appears multiple times, the last
occurrence takes precedence.</p>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="HashSet">
                18.17.6. Hash Sets<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=HashSet" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="Std___HashSet___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.mk" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.{u} (</span><span class="var token" data-binding="var-_uniq.71715" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71715" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71715" data-verso-hover="54">α</span><span class="inter-text">] : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.{u} (</span><span class="var token" data-binding="var-_uniq.71715" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71715" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71715" data-verso-hover="54">α</span><span class="inter-text">] : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div></pre><div class="text">
                  <p>
                    Hash sets.</p>
                  <p>
                    This is a simple separate-chaining hash table. The data of the hash set consists of a cached size
and an array of buckets, where each bucket is a linked list of keys. The number of buckets
is always a power of two. The hash set doubles its size upon inserting an element such that the
number of elements is more than 75% of the number of buckets.</p>
                  <p>
                    The hash table is backed by an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a></code>. Users should make sure that the hash set is used linearly to
avoid expensive copies.</p>
                  <p>
                    The hash set uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> (provided by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> typeclass) to compare elements and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable.hash" data-verso-hover="1759">hash</span></a></code> (provided by
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> typeclass) to hash them. To ensure that the operations behave as expected, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>
should be an equivalence relation and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> should imply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> (see also the
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a></code> typeclasses). Both of these conditions are automatic if the BEq
instance is lawful, i.e., if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.69894" data-verso-hover="4822">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.70080" data-verso-hover="4822">b</span></code>.</p>
                  <p>
                    These hash sets contain a bundled well-formedness invariant, which means that they cannot
be used in nested inductive types. For these use cases, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.HashSet.Raw</span></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.HashSet.Raw.WF</span></code> unbundle the invariant from the hash set. When in doubt, prefer
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code>.</p>
                  <h1>
                    Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet.mk" data-verso-hover="4823">Std.HashSet.mk</span></a><span class="inter-text">.{u}</span></pre><div class="docs"></div>
                    </section>
                  <h1>
                    Fields</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.HashSet.inner" data-verso-hover="4824">inner</span> : <a href="Basic-Types/Maps-and-Sets/#Std___HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="317">Std.HashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71696" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></pre><div class="docs">
                      <p>
                        Internal implementation detail of the hash set.</p>
                      </div>
                    </section>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Creation">
                  18.17.6.1. Creation</h3>
                <div class="namedocs" id="Std___HashSet___emptyWithCapacity">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.emptyWithCapacity" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.emptyWithCapacity.{u} {</span><span class="var token" data-binding="var-_uniq.73129" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73129" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73129" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.73132" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73129" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.emptyWithCapacity.{u}
  {</span><span class="var token" data-binding="var-_uniq.73129" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73129" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73129" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.73132" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73129" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Creates a new empty hash set. The optional parameter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.72246" data-verso-hover="4736">capacity</span></code> can be supplied to presize the
set so that it can hold the given number of elements without reallocating. It is also possible to
use the empty collection notations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span></code> to create an empty hash set with the default
capacity.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Properties">
                  18.17.6.2. Properties</h3>
                <div class="namedocs" id="Std___HashSet___isEmpty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.isEmpty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.isEmpty.{u} {</span><span class="var token" data-binding="var-_uniq.73340" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.73341" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73340" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.73342" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73340" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.73346" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73340" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashSet.isEmpty.{u} {</span><span class="var token" data-binding="var-_uniq.73340" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.73341" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73340" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.73342" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73340" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.73346" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73340" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the hash set contains no elements.</p>
                    <p>
                      Note that if your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> instance is not reflexive or your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> instance is not
lawful, then it is possible that this function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code> even though <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.73294" data-verso-hover="4825">m</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___contains"><span class="const token" data-binding="const-Std.HashSet.contains" data-verso-hover="4826">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73326" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>
for all <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.73326" data-verso-hover="45">a</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___size">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.size" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.size.{u} {</span><span class="var token" data-binding="var-_uniq.73581" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.73582" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73581" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.73583" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73581" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.73587" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73581" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashSet.size.{u} {</span><span class="var token" data-binding="var-_uniq.73581" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.73582" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73581" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.73583" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73581" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.73587" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73581" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                    <p>
                      The number of elements present in the set</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___Equiv___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.Equiv" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.Equiv.{u} {</span><span class="var token" data-binding="var-_uniq.73746" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.73747" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73746" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.73748" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73746" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.73749" data-verso-hover="4825">m₁ </span><span class="var token" data-binding="var-_uniq.73753" data-verso-hover="4825">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73746" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.Equiv.{u} {</span><span class="var token" data-binding="var-_uniq.73746" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.73747" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73746" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.73748" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73746" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.73749" data-verso-hover="4825">m₁ </span><span class="var token" data-binding="var-_uniq.73753" data-verso-hover="4825">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73746" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      Two hash sets are equivalent in the sense of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Equiv</span></code> iff all their values are equal.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Equiv___mk"><span class="const token" data-binding="const-Std.HashSet.Equiv.mk" data-verso-hover="4827">Std.HashSet.Equiv.mk</span></a><span class="inter-text">.{u}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.HashSet.Equiv.inner" data-verso-hover="4741">inner</span> : <span class="var token" data-binding="var-_uniq.73717" data-verso-hover="4825">m₁</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet.inner" data-verso-hover="4828">inner</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Equiv___mk"><span class="const token" data-binding="const-Std.HashMap.Equiv" data-verso-hover="4744">Equiv</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73718" data-verso-hover="4825">m₂</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet.inner" data-verso-hover="4828">inner</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash map</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Equivalence</span><div class="text">
                    <p>
                      The relation <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Equiv___mk"><span class="const token" data-binding="const-Std.HashSet.Equiv" data-verso-hover="4829">HashSet.Equiv</span></a></code> can also be written with an infix operator, which is scoped to its namespace:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Std___HashMap____FLQQ_term____m__FLQQ_-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Std.HashMap.«term_~m_»"><code class="hover-info"><code class="docstring">Two hash maps are equivalent in the sense of `Equiv` iff
all the keys and values are equal.
</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">~m</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Queries">
                  18.17.6.3. Queries</h3>
                <div class="namedocs" id="Std___HashSet___contains">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.contains" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.contains.{u} {</span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.74527" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.74528" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.74532" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.74533" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashSet.contains.{u} {</span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.74527" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.74528" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.74532" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.74533" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.74526" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the given key is present in the set. There is also a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>-valued version of
this: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.74473" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74472" data-verso-hover="4825">m</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.74472" data-verso-hover="4825">m</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___contains"><span class="const token" data-binding="const-Std.HashSet.contains" data-verso-hover="4826">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74473" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>.</p>
                    <p>
                      Observe that this is different behavior than for lists: for lists, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∈</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> use
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> for comparisons, while for hash sets, both use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___get">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.get" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.get.{u} {</span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.74851" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.74852" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.74853" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.74852" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.74851" data-verso-hover="4825">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.get.{u} {</span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.74851" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.74852" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.74853" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.74852" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.74851" data-verso-hover="4825">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.74845" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Retrieves the key from the set that matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.74821" data-verso-hover="45">a</span></code>. Ensures that such a key exists by requiring a proof
of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.74821" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74820" data-verso-hover="4825">m</span></code>. The result is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___get___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.get!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.get!.{u} {</span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.75044" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.75045" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.get!.{u} {</span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.75044" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.75045" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.75037" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if given key is contained and returns the key if it is, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___get___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.get?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.get?.{u} {</span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.75176" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.75177" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.75181" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.75182" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.get?.{u} {</span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.75176" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.75177" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.75181" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.75182" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75175" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if given key is contained and returns the key if it is, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.
The result in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> case is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___getD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.getD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.getD.{u} {</span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.75358" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.75359" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.75360" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.getD.{u} {</span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.75358" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.75359" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.75360" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.75352" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if given key is contained and returns the key if it is, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.75351" data-verso-hover="45">fallback</span></code>.
If they key is contained the result is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Modification">
                  18.17.6.4. Modification</h3>
                <div class="namedocs" id="Std___HashSet___insert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.insert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.insert.{u} {</span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.75573" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.75574" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.75578" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.75579" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.insert.{u} {</span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.75573" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.75574" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.75578" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.75579" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75572" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Inserts the given element into the set. If the hash set already contains an element that is
equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>) to the given element, then the hash set is returned unchanged.</p>
                    <p>
                      Note: this non-replacement behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code> behaves
differently: it will overwrite an existing mapping.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___insertMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.insertMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.insertMany.{u, v} {</span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.75930" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.75931" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.75932" data-verso-hover="244">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75932" data-verso-hover="244">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.75938" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.75939" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75932" data-verso-hover="244">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.insertMany.{u, v} {</span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.75930" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.75931" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.75932" data-verso-hover="244">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75932" data-verso-hover="244">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.75938" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.75939" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.75932" data-verso-hover="244">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75929" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Inserts multiple mappings into the hash set by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>. If the same key appears multiple times, the first occurrence takes precedence.</p>
                    <p>
                      Note: this precedence behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code>. The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertMany</span></code> function on
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DHashMap.Raw</span></code> behaves differently: it will prefer the last
appearance.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___erase">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.erase" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.erase.{u} {</span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76237" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76238" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.76242" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.76243" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.erase.{u} {</span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.76237" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76238" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.76242" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.76243" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76236" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Removes the element if it exists.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___filter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.filter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.filter.{u} {</span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76380" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76381" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.76383" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.76387" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.filter.{u} {</span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.76380" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76381" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.76383" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.76387" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76379" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Removes all elements from the hash set for which the given function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___containsThenInsert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.containsThenInsert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.containsThenInsert.{u} {</span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76565" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.76566" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.76570" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.76571" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.containsThenInsert.{u}
  {</span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76565" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.76566" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.76570" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.76571" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76564" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks whether an element is present in a set and inserts the element if it was not found.
If the hash set already contains an element that is equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>) to the given
element, then the hash set is returned unchanged.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___partition">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.partition" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.partition.{u} {</span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76779" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76780" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.76782" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.76786" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.partition.{u} {</span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.76779" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.76780" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.76782" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.76786" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76778" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Partition a hashset into two hashsets based on a predicate.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___union">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.union" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.union.{u} {</span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.76946" data-verso-hover="4825">m₁ </span><span class="var token" data-binding="var-_uniq.76950" data-verso-hover="4825">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.union.{u} {</span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.76946" data-verso-hover="4825">m₁ </span><span class="var token" data-binding="var-_uniq.76950" data-verso-hover="4825">m₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.76943" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Computes the union of the given hash sets, by traversing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.76942" data-verso-hover="4825">m₂</span></code> and inserting its elements into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.76941" data-verso-hover="4825">m₁</span></code>.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Iteration">
                  18.17.6.5. Iteration</h3>
                <div class="namedocs" id="Std___HashSet___all">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.all" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.all.{u} {</span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77101" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77102" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.77106" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77108" data-verso-hover="241">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashSet.all.{u} {</span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77101" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77102" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.77106" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77108" data-verso-hover="241">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77100" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Check if all elements satisfy the predicate, short-circuiting if a predicate fails.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___any">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.any" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.any.{u} {</span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77240" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77241" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.77245" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77247" data-verso-hover="241">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashSet.any.{u} {</span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77240" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77241" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.77245" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77247" data-verso-hover="241">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77239" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Check if any element satisfies the predicate, short-circuiting if a predicate succeeds.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___fold">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.fold" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.fold.{u, v} {</span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77381" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77382" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.77387" data-verso-hover="4404">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77388" data-verso-hover="185">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77392" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.fold.{u, v} {</span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77381" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77382" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.77387" data-verso-hover="4404">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77388" data-verso-hover="185">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.77392" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77380" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.77383" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Folds the given function over the elements of the hash set in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___foldM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.foldM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.foldM.{u, v} {</span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77566" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77567" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77569" data-verso-hover="4830">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77569" data-verso-hover="4830">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.77575" data-verso-hover="4582">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77569" data-verso-hover="4830">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.77576" data-verso-hover="185">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77580" data-verso-hover="4825">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.77569" data-verso-hover="4830">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.foldM.{u, v} {</span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77566" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77567" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77569" data-verso-hover="4830">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77569" data-verso-hover="4830">m</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.77575" data-verso-hover="4582">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77569" data-verso-hover="4830">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.77576" data-verso-hover="185">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77580" data-verso-hover="4825">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77565" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.77569" data-verso-hover="4830">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77571" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Monadically computes a value by folding the given function over the elements in the hash set in some
order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___forIn">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.forIn" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.forIn.{u, v} {</span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77799" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77800" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77802" data-verso-hover="4830">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77802" data-verso-hover="4830">m</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.77808" data-verso-hover="2821">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77802" data-verso-hover="4830">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.77809" data-verso-hover="185">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.77813" data-verso-hover="4825">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.77802" data-verso-hover="4830">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.forIn.{u, v} {</span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77799" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.77800" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.77802" data-verso-hover="4830">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77802" data-verso-hover="4830">m</span><span class="inter-text">]
  {</span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.77808" data-verso-hover="2821">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.77802" data-verso-hover="4830">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.77809" data-verso-hover="185">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.77813" data-verso-hover="4825">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77798" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.77802" data-verso-hover="4830">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77804" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Support for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span></code> loop construct in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> blocks.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___forM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.forM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.forM.{u, v} {</span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.78066" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.78067" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.78069" data-verso-hover="4830">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78069" data-verso-hover="4830">m</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.78072" data-verso-hover="4392">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.78069" data-verso-hover="4830">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.78076" data-verso-hover="4825">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.78069" data-verso-hover="4830">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div><div class="narrow-only"><span class="inter-text">Std.HashSet.forM.{u, v} {</span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.78066" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.78067" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.78069" data-verso-hover="4830">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78069" data-verso-hover="4830">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.78072" data-verso-hover="4392">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.78069" data-verso-hover="4830">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.78076" data-verso-hover="4825">b</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78065" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.78069" data-verso-hover="4830">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div></pre><div class="text">
                    <p>
                      Carries out a monadic action on each element in the hash set in some order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Conversion">
                  18.17.6.6. Conversion</h3>
                <div class="namedocs" id="Std___HashSet___ofList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.ofList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.ofList.{u} {</span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.78256" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.ofList.{u} {</span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.78256" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78253" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Creates a hash set from a list of elements. Note that unlike repeatedly calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>, if the
collection contains multiple elements that are equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>), then the last element
in the collection will be present in the returned hash set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___toList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.toList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.toList.{u} {</span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.78399" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.78400" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.78404" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.toList.{u} {</span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.78399" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.78400" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.78404" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78398" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Transforms the hash set into a list of elements in some order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___ofArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.ofArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.ofArray.{u} {</span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.78532" data-verso-hover="303">l</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.ofArray.{u} {</span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.78532" data-verso-hover="303">l</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78529" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Creates a hash set from an array of elements. Note that unlike repeatedly calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>, if the
collection contains multiple elements that are equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>), then the last element
in the collection will be present in the returned hash set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___toArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.toArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.toArray.{u} {</span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.78675" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.78676" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.78680" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.toArray.{u} {</span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.78675" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.78676" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.78680" data-verso-hover="4825">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___mk"><span class="const token" data-binding="const-Std.HashSet" data-verso-hover="4661">Std.HashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.78674" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Transforms the hash set into an array of elements in some order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Unbundled-Variants">
                  18.17.6.7. Unbundled Variants</h3>
                <p>
                  Unbundled maps separate well-formedness proofs from data.
This is primarily useful when defining <a href="Basic-Types/Maps-and-Sets/#raw-data">nested inductive types</a>.
To use these variants, import the modules <code>Std.HashSet.Raw</code> and <code>Std.HashSet.RawLemmas</code>.</p>
                <div class="namedocs" id="Std___HashSet___Raw___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.Raw" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.Raw.{u} (</span><span class="var token" data-binding="var-_uniq.80846" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.Raw.{u} (</span><span class="var token" data-binding="var-_uniq.80846" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div></pre><div class="text">
                    <p>
                      Hash sets without a bundled well-formedness invariant, suitable for use in nested
inductive types. The well-formedness invariant is called <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Raw.WF</span></code>. When in doubt, prefer <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code>
over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code>. Lemmas about the operations on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.HashSet.Raw</span></code> are available in the
module <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.HashSet.RawLemmas</span></code>.</p>
                    <p>
                      This is a simple separate-chaining hash table. The data of the hash set consists of a cached size
and an array of buckets, where each bucket is a linked list of keys. The number of buckets
is always a power of two. The hash set doubles its size upon inserting an element such that the
number of elements is more than 75% of the number of buckets.</p>
                    <p>
                      The hash table is backed by an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a></code>. Users should make sure that the hash set is used linearly to
avoid expensive copies.</p>
                    <p>
                      The hash set uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> (provided by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> typeclass) to compare elements and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable.hash" data-verso-hover="1759">hash</span></a></code> (provided by
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> typeclass) to hash them. To ensure that the operations behave as expected, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>
should be an equivalence relation and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> should imply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> (see also the
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a></code> typeclasses). Both of these conditions are automatic if the BEq
instance is lawful, i.e., if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.79076" data-verso-hover="4831">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.79262" data-verso-hover="4831">b</span></code>.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Raw___mk"><span class="const token" data-binding="const-Std.HashSet.Raw.mk" data-verso-hover="4832">Std.HashSet.Raw.mk</span></a><span class="inter-text">.{u}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.HashSet.Raw.inner" data-verso-hover="4833">inner</span> : <a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___mk"><span class="const token" data-binding="const-Std.HashMap.Raw" data-verso-hover="4669">Std.HashMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.80837" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash set.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="Std___HashSet___Raw___WF___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.HashSet.Raw.WF" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.HashSet.Raw.WF.{u} {</span><span class="var token" data-binding="var-_uniq.81423" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.81423" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.81423" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.81427" data-verso-hover="4834">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Raw___mk"><span class="const token" data-binding="const-Std.HashSet.Raw" data-verso-hover="4835">Std.HashSet.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.81423" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only"><span class="inter-text">Std.HashSet.Raw.WF.{u} {</span><span class="var token" data-binding="var-_uniq.81423" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.81423" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.81423" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.81427" data-verso-hover="4834">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Raw___mk"><span class="const token" data-binding="const-Std.HashSet.Raw" data-verso-hover="4835">Std.HashSet.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.81423" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      Well-formedness predicate for hash sets. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> will not need to interact with this.
Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code> will need to provide proofs of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF</span></code> to lemmas and should use lemmas like
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.empty</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.insert</span></code> (which are always named exactly like the operations they are about) to
show that set operations preserve well-formedness.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashSet.Raw.WF.mk" data-verso-hover="4836">Std.HashSet.Raw.WF.mk</span></a><span class="inter-text">.{u}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.HashSet.Raw.WF.out" data-verso-hover="4837">out</span> : <span class="var token" data-binding="var-_uniq.81401" data-verso-hover="4834">m</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Raw___mk"><span class="const token" data-binding="const-Std.HashSet.Raw.inner" data-verso-hover="4838">inner</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashMap.Raw.WF" data-verso-hover="4670">WF</span></a></pre><div class="docs">
                        <p>
                          Internal implementation detail of the hash set</p>
                        </div>
                      </section>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="ExtHashSet">
                18.17.7. Extensional Hash Sets<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=ExtHashSet" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="Std___ExtHashSet___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.{u} (</span><span class="var token" data-binding="var-_uniq.83763" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.83763" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.83763" data-verso-hover="54">α</span><span class="inter-text">] : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.{u} (</span><span class="var token" data-binding="var-_uniq.83763" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.83763" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.83763" data-verso-hover="54">α</span><span class="inter-text">] : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div></pre><div class="text">
                  <p>
                    Hash sets.</p>
                  <p>
                    This is a simple separate-chaining hash table. The data of the hash set consists of a cached size
and an array of buckets, where each bucket is a linked list of keys. The number of buckets
is always a power of two. The hash set doubles its size upon inserting an element such that the
number of elements is more than 75% of the number of buckets.</p>
                  <p>
                    The hash table is backed by an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a></code>. Users should make sure that the hash set is used linearly to
avoid expensive copies.</p>
                  <p>
                    The hash set uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> (provided by the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> typeclass) to compare elements and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable.hash" data-verso-hover="1759">hash</span></a></code> (provided by
the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> typeclass) to hash them. To ensure that the operations behave as expected, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>
should be an equivalence relation and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> should imply <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hash</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> (see also the
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a></code> typeclasses). Both of these conditions are automatic if the BEq
instance is lawful, i.e., if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">==</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span></code> implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.81939" data-verso-hover="4839">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.82125" data-verso-hover="4839">b</span></code>.</p>
                  <p>
                    In contrast to regular hash sets, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a></code> offers several extensionality lemmas
and therefore has more lemmas about equality of hash maps. This however also makes it lose the
ability to iterate freely over hash sets.</p>
                  <p>
                    These hash sets contain a bundled well-formedness invariant, which means that they cannot
be used in nested inductive types. For these use cases, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Raw___mk"><span class="const token" data-binding="const-Std.HashSet.Raw" data-verso-hover="4835">Std.HashSet.Raw</span></a></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___HashSet___Raw___WF___mk"><span class="const token" data-binding="const-Std.HashSet.Raw.WF" data-verso-hover="4840">Std.HashSet.Raw.WF</span></a></code> unbundle the invariant from the hash set. When in doubt, prefer
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashSet</span></code> over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">HashSet.Raw</span></code>.</p>
                  <h1>
                    Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet.mk" data-verso-hover="4841">Std.ExtHashSet.mk</span></a><span class="inter-text">.{u}</span></pre><div class="docs"></div>
                    </section>
                  <h1>
                    Fields</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.ExtHashSet.inner" data-verso-hover="4842">inner</span> : <a href="Basic-Types/Maps-and-Sets/#Std___ExtHashMap"><span class="const token" data-binding="const-Std.ExtHashMap" data-verso-hover="4659">Std.ExtHashMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.83744" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></pre><div class="docs">
                      <p>
                        Internal implementation detail of the hash set.</p>
                      </div>
                    </section>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Creation">
                  18.17.7.1. Creation</h3>
                <div class="namedocs" id="Std___ExtHashSet___emptyWithCapacity">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.emptyWithCapacity" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.emptyWithCapacity.{u} {</span><span class="var token" data-binding="var-_uniq.85231" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85231" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85231" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.85234" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85231" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.emptyWithCapacity.{u}
  {</span><span class="var token" data-binding="var-_uniq.85231" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85231" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85231" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.85234" data-verso-hover="4736">capacity</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> := 8) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85231" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Creates a new empty hash set. The optional parameter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.84348" data-verso-hover="4736">capacity</span></code> can be supplied to presize the
set so that it can hold the given number of elements without reallocating. It is also possible to
use the empty collection notations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span></code> to create an empty hash set with the default
capacity.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Properties">
                  18.17.7.2. Properties</h3>
                <div class="namedocs" id="Std___ExtHashSet___isEmpty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.isEmpty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.isEmpty.{u} {</span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.85469" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.85470" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.85476" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.isEmpty.{u} {</span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.85469" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.85470" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.85476" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85468" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the hash set contains no elements.</p>
                    <p>
                      Note that if your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a></code> instance is not reflexive or your <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a></code> instance is not
lawful, then it is possible that this function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code> even though <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.85400" data-verso-hover="4843">m</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___contains"><span class="const token" data-binding="const-Std.ExtHashSet.contains" data-verso-hover="4844">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85450" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>
for all <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.85450" data-verso-hover="45">a</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___size">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.size" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.size.{u} {</span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.85734" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.85735" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.85741" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.size.{u} {</span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.85734" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.85735" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.85741" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85733" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                    <p>
                      The number of elements present in the set</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Queries">
                  18.17.7.3. Queries</h3>
                <div class="namedocs" id="Std___ExtHashSet___contains">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.contains" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.contains.{u} {</span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.85959" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.85960" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.85966" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.85967" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.contains.{u} {</span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.85959" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.85960" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.85966" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.85967" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.85958" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the given key is present in the set. There is also a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>-valued version of
this: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.85874" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85873" data-verso-hover="4843">m</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.85873" data-verso-hover="4843">m</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___contains"><span class="const token" data-binding="const-Std.ExtHashSet.contains" data-verso-hover="4844">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85874" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>.</p>
                    <p>
                      Observe that this is different behavior than for lists: for lists, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∈</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> use
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> for comparisons, while for hash sets, both use <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___get">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.get" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.get.{u} {</span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86317" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86318" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.86324" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.86325" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.86326" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86325" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.86324" data-verso-hover="4843">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.get.{u} {</span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.86317" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86318" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.86324" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.86325" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.86326" data-verso-hover="4745">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86325" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.86324" data-verso-hover="4843">m</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.86316" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Retrieves the key from the set that matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.86277" data-verso-hover="45">a</span></code>. Ensures that such a key exists by requiring a proof
of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.86277" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86276" data-verso-hover="4843">m</span></code>. The result is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___get___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.get!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.get!.{u} {</span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86551" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86552" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.86559" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.86560" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.get!.{u} {</span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.86551" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86552" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.86559" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.86560" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.86550" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if given key is contained and returns the key if it is, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___get___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.get?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.get?.{u} {</span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86731" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86732" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.86738" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.86739" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.get?.{u} {</span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.86731" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86732" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.86738" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.86739" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86730" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if given key is contained and returns the key if it is, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.
The result in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> case is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___getD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.getD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.getD.{u} {</span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86932" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86933" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.86939" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.86940" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.86941" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.getD.{u} {</span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.86932" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.86933" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.86939" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.86940" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.86941" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.86931" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if given key is contained and returns the key if it is, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.86930" data-verso-hover="45">fallback</span></code>.
If they key is contained the result is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Modification">
                  18.17.7.4. Modification</h3>
                <div class="namedocs" id="Std___ExtHashSet___insert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.insert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.insert.{u} {</span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.87196" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.87197" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.87203" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.87204" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.insert.{u} {</span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.87196" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.87197" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.87203" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.87204" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87195" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Inserts the given element into the set. If the hash set already contains an element that is
equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>) to the given element, then the hash set is returned unchanged.</p>
                    <p>
                      Note: this non-replacement behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashSet.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DExtHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DExtHashMap.Raw</span></code> behaves
differently: it will overwrite an existing mapping.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___insertMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.insertMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.insertMany.{u, v} {</span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.87579" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.87580" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.87583" data-verso-hover="244">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87583" data-verso-hover="244">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.87589" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.87590" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.87583" data-verso-hover="244">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.insertMany.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.87579" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.87580" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">] {</span><span class="var token" data-binding="var-_uniq.87583" data-verso-hover="244">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87583" data-verso-hover="244">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.87589" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.87590" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.87583" data-verso-hover="244">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87578" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Inserts multiple mappings into the hash set by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>. If the same key appears multiple times, the first occurrence takes precedence.</p>
                    <p>
                      Note: this precedence behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashSet.Raw</span></code>. The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertMany</span></code> function on
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DExtHashMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">ExtHashMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DExtHashMap.Raw</span></code> behaves differently: it will prefer the last
appearance.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___erase">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.erase" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.erase.{u} {</span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.87910" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.87911" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.87917" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.87918" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.erase.{u} {</span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.87910" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.87911" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.87917" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.87918" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87909" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Removes the element if it exists.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___filter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.filter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.filter.{u} {</span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.88077" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.88078" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.88082" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.88086" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.filter.{u} {</span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.88077" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.88078" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.88082" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.88086" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88076" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Removes all elements from the hash set for which the given function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___containsThenInsert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.containsThenInsert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.containsThenInsert.{u} {</span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.88288" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.88289" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.88295" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.88296" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.containsThenInsert.{u}
  {</span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.88288" data-verso-hover="4737">x✝</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.88289" data-verso-hover="4738">x✝¹</span><span class="inter-text"> : </span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#EquivBEq___mk"><span class="const token" data-binding="const-EquivBEq" data-verso-hover="1754">EquivBEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">]
  [</span><a href="Type-Classes/Basic-Classes/#LawfulHashable___mk"><span class="const token" data-binding="const-LawfulHashable" data-verso-hover="1760">LawfulHashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.88295" data-verso-hover="4843">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.88296" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88287" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks whether an element is present in a set and inserts the element if it was not found.
If the hash set already contains an element that is equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>) to the given
element, then the hash set is returned unchanged.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Conversion">
                  18.17.7.5. Conversion</h3>
                <div class="namedocs" id="Std___ExtHashSet___ofList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.ofList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.ofList.{u} {</span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.88533" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.ofList.{u} {</span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.88533" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88530" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Creates a hash set from a list of elements. Note that unlike repeatedly calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>, if the
collection contains multiple elements that are equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>), then the last element
in the collection will be present in the returned hash set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___ExtHashSet___ofArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.ExtHashSet.ofArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.ExtHashSet.ofArray.{u} {</span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.88686" data-verso-hover="303">l</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.ExtHashSet.ofArray.{u} {</span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#BEq___mk"><span class="const token" data-binding="const-BEq" data-verso-hover="1341">BEq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span><span class="inter-text">] [</span><a href="Type-Classes/Basic-Classes/#Hashable___mk"><span class="const token" data-binding="const-Hashable" data-verso-hover="1701">Hashable</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.88686" data-verso-hover="303">l</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___ExtHashSet___mk"><span class="const token" data-binding="const-Std.ExtHashSet" data-verso-hover="4663">Std.ExtHashSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88683" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Creates a hash set from an array of elements. Note that unlike repeatedly calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>, if the
collection contains multiple elements that are equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code>), then the last element
in the collection will be present in the returned hash set.</p>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="TreeMap">
                18.17.8. Tree-Based Maps<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=TreeMap" title="Permalink">🔗</a></span></h2>
              <p>
                The declarations in this section should be imported using <code>import Std.TreeMap</code>.</p>
              <div class="namedocs" id="Std___TreeMap">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.232" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.233" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.237" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.232" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.232" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.232" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.233" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.237" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.232" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.232" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div></pre><div class="text">
                  <p>
                    Tree maps.</p>
                  <p>
                    A tree map stores an assignment of keys to values. It depends on a comparator function that
defines an ordering on the keys and provides efficient order-dependent queries, such as retrieval
of the minimum or maximum.</p>
                  <p>
                    To ensure that the operations behave as expected, the comparator function <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="4845">cmp</span></code> should satisfy
certain laws that ensure a consistent ordering:</p>
                  <ul>
                    <li>
                      <p>
                        If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is greater than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
and vice versa (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">OrientedCmp</span></code> typeclass).</p>
                      </li>
                    <li>
                      <p>
                        If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is, in turn, less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code> (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TransCmp</span></code> typeclass).</p>
                      </li>
                    </ul>
                  <p>
                    Keys for which <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.149" data-verso-hover="4845">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.158" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.164" data-verso-hover="45">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.eq" data-verso-hover="1774">Ordering.eq</span></a></code> are considered the same, i.e., there can be only one entry
with key either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.158" data-verso-hover="45">a</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.164" data-verso-hover="45">b</span></code> in a tree map. Looking up either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.158" data-verso-hover="45">a</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.164" data-verso-hover="45">b</span></code> always yields the same entry,
if any is present.</p>
                  <p>
                    To avoid expensive copies, users should make sure that the tree map is used linearly.</p>
                  <p>
                    Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary
search tree with efficient order statistic lookups.</p>
                  <p>
                    These tree maps contain a bundled well-formedness invariant, which means that they cannot
be used in nested inductive types. For these use cases, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw" data-verso-hover="4846">Std.TreeMap.Raw</span></a></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw.WF" data-verso-hover="4847">Std.TreeMap.Raw.WF</span></a></code> unbundle the invariant from the tree map. When in doubt, prefer
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap</span></code> over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap.Raw</span></code>.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Creation">
                  18.17.8.1. Creation</h3>
                <div class="namedocs" id="Std___TreeMap___empty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.empty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.empty.{u, v} {</span><span class="var token" data-binding="var-_uniq.2422" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.2423" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.2427" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2422" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2422" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2422" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2423" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2427" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.empty.{u, v} {</span><span class="var token" data-binding="var-_uniq.2422" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.2423" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.2427" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2422" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2422" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2422" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2423" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2427" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Creates a new empty tree map. It is also possible and recommended to
use the empty collection notations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span></code> to create an empty tree map. <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="35">simp</span></a></code> replaces
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">empty</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code>.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Properties">
                  18.17.8.2. Properties</h3>
                <div class="namedocs" id="Std___TreeMap___size">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.size" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.2623" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.2627" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.2633" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2623" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2627" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.2623" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.2627" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.2633" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2623" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2627" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                    <p>
                      Returns the number of mappings present in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___isEmpty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.isEmpty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.2756" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.2757" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.2761" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2756" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2756" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.2767" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2756" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2757" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2761" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.2756" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.2757" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.2761" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2756" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2756" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.2767" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2756" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2757" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2761" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the tree map contains no mappings.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Queries">
                  18.17.8.3. Queries</h3>
                <div class="namedocs" id="Std___TreeMap___contains">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.contains" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.3616" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.3620" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.3626" data-verso-hover="4849">l</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3616" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3620" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.3627" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.3616" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.3620" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.3626" data-verso-hover="4849">l</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3616" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3620" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.3627" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3615" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if there is a mapping for the given key <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2905" data-verso-hover="45">a</span></code> or a key that is equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2905" data-verso-hover="45">a</span></code> according
to the comparator <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2903" data-verso-hover="4848">cmp</span></code>. There is also a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>-valued version
of this: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t.contains</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>.</p>
                    <p>
                      Observe that this is different behavior than for lists: for lists, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∈</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> uses
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> for equality checks, while for tree maps, both use the given comparator <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3601" data-verso-hover="4848">cmp</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___get">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.get" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.3991" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.3995" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.4001" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3991" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3995" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4002" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.4003" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4002" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.4001" data-verso-hover="4849">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.3991" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.3991" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.3995" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4001" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3991" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3995" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4002" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3990" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.4003" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4002" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.4001" data-verso-hover="4849">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.3991" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Given a proof that a mapping for the given key is present, retrieves the mapping for the given key.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___get___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.get!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4209" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4213" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.4219" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4209" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4213" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4220" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text">)
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4209" data-verso-hover="244">β</span><span class="inter-text">] : </span><span class="var token" data-binding="var-_uniq.4209" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4209" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4213" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4219" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4209" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4213" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4220" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4208" data-verso-hover="54">α</span><span class="inter-text">)
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4209" data-verso-hover="244">β</span><span class="inter-text">] : </span><span class="var token" data-binding="var-_uniq.4209" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___get___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.get?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4411" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4415" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.4421" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4411" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4415" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4422" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4411" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4411" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4415" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4421" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4411" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4415" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4422" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4410" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4411" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___getD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4622" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4626" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.4632" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4622" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4626" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4633" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.4634" data-verso-hover="185">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4622" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.4622" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4622" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4626" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4632" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4622" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4626" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4633" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4621" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.4634" data-verso-hover="185">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4622" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.4622" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4605" data-verso-hover="185">fallback</span></code> if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___getKey">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKey" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5507" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5511" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.5517" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5507" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5511" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5518" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.5519" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5518" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.5517" data-verso-hover="4849">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5507" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5511" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.5517" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5507" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5511" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5518" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.5519" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5518" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.5517" data-verso-hover="4849">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5506" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Retrieves the key from the mapping that matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4831" data-verso-hover="45">a</span></code>. Ensures that such a mapping exists by
requiring a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span></code>. The result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___getKey___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKey!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5725" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5729" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.5736" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5725" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5729" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.5737" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5725" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5729" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.5736" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5725" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5729" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.5737" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5724" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___getKey___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKey?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5898" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5902" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.5908" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5898" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5902" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5909" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5898" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5902" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.5908" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5898" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5902" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5909" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5897" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.
The result in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> case is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___getKeyD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6092" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6096" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.6102" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6092" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6096" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6103" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.6104" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6092" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6096" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6102" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6092" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6096" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.6103" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.6104" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6091" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.6090" data-verso-hover="45">fallback</span></code>.
If a mapping exists the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___keys">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.keys" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.keys.{u, v} {</span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6279" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6283" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.6289" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6279" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6283" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.keys.{u, v} {</span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6279" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6283" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6289" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6279" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6283" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6278" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Returns a list of all keys present in the tree map in ascending  order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___keysArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.keysArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.keysArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6419" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6423" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.6429" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6419" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6423" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.keysArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6419" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6423" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6429" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6419" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6423" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6418" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Returns an array of all keys present in the tree map in ascending  order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___values">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.values" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.values.{u, v} {</span><span class="var token" data-binding="var-_uniq.6558" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6559" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6563" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6558" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6558" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.6569" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6558" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6559" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6563" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6559" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.values.{u, v} {</span><span class="var token" data-binding="var-_uniq.6558" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6559" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6563" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6558" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6558" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6569" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6558" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6559" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6563" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6559" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Returns a list of all values present in the tree map in ascending  order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___valuesArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.valuesArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.valuesArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.6698" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6699" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6703" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6698" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6698" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.6709" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6698" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6699" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6703" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6699" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.valuesArray.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.6698" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6699" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6703" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6698" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6698" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6709" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6698" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6699" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6703" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6699" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Returns an array of all values present in the tree map in ascending  order.</p>
                    </div>
                  </div>
                <section>
                  <h4 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Queries--Ordering-Based-Queries">
                    18.17.8.3.1. Ordering-Based Queries</h4>
                  <div class="namedocs" id="Std___TreeMap___entryAtIdx">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.entryAtIdx" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.entryAtIdx.{u, v} {</span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6841" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6845" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.6851" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6841" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6845" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6852" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.6857" data-verso-hover="4851">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6852" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.6851" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.6841" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.entryAtIdx.{u, v} {</span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6841" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6845" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6851" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6841" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6845" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6852" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.6857" data-verso-hover="4851">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6852" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.6851" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6840" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.6841" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Returns the key-value pair with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.6838" data-verso-hover="7">n</span></code>-th smallest key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___entryAtIdx___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.entryAtIdx!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.entryAtIdx!.{u, v} {</span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7078" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.7085" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7078" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.7086" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.entryAtIdx!.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7078" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.7085" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7078" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7086" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.7073" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Returns the key-value pair with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7054" data-verso-hover="7">n</span></code>-th smallest key, or panics if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7054" data-verso-hover="7">n</span></code> is at least <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7053" data-verso-hover="4849">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___entryAtIdx___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.entryAtIdx?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.entryAtIdx?.{u, v} {</span><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7339" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7343" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.7349" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7339" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7343" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7350" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7339" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.entryAtIdx?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7339" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7343" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7349" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7339" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7343" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7350" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7339" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                      <p>
                        Returns the key-value pair with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7318" data-verso-hover="7">n</span></code>-th smallest key, or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7318" data-verso-hover="7">n</span></code> is at least <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7317" data-verso-hover="4849">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___entryAtIdxD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.entryAtIdxD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.entryAtIdxD.{u, v} {</span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7602" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.7612" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7602" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7613" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.7614" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7602" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7602" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.entryAtIdxD.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7602" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7612" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7602" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7613" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.7614" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7602" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7601" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7602" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Returns the key-value pair with the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7581" data-verso-hover="7">n</span></code>-th smallest key, or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7582" data-verso-hover="4200">fallback</span></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7581" data-verso-hover="7">n</span></code> is at least <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7580" data-verso-hover="4849">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryGE">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryGE" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryGE.{u, v} {</span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.7879" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.7880" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7883" data-verso-hover="4854">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.7881" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.7881" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.7879" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7881" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7880" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isGE"><span class="const token" data-binding="const-Ordering.isGE" data-verso-hover="4855">isGE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryGE.{u, v} {</span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.7879" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7880" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.7883" data-verso-hover="4854">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.7881" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.7881" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.7879" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7881" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7880" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isGE"><span class="const token" data-binding="const-Ordering.isGE" data-verso-hover="4855">isGE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.7865" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Given a proof that such a mapping exists, retrieves the key-value pair with the smallest key that is
greater than or equal to the given key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryGE___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryGE!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryGE!.{u, v} {</span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8132" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8136" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8132" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.8143" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8132" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8136" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.8144" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8132" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryGE!.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8132" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8136" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8132" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.8143" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8132" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8136" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8144" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.8131" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8132" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key that is greater than or equal to the
given key, panicking if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryGE___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryGE?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryGE?.{u, v} {</span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8331" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8335" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.8341" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8331" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8335" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8342" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8331" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryGE?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8331" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8335" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8341" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8331" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8335" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8342" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.8330" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8331" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key that is greater than or equal to the
given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryGED">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryGED" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryGED.{u, v} {</span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8528" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8532" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.8538" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8528" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8532" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8539" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.8540" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8528" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8528" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryGED.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8528" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8532" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8538" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8528" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8532" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8539" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.8540" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8528" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8527" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8528" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key that is greater than or equal to the
given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8526" data-verso-hover="4200">fallback</span></code> if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryGT">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryGT" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryGT.{u, v} {</span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8744" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8748" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8748" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.8757" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8744" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8748" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.8758" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8760" data-verso-hover="4856">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.8759" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.8759" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.8757" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.8748" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8759" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8758" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.gt" data-verso-hover="1771">Ordering.gt</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8744" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryGT.{u, v} {</span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8744" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8748" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8748" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.8757" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8744" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8748" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8758" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.8760" data-verso-hover="4856">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.8759" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.8759" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.8757" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.8748" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8759" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8758" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.gt" data-verso-hover="1771">Ordering.gt</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.8743" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.8744" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Given a proof that such a mapping exists, retrieves the key-value pair with the smallest key that is
greater than the given key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryGT___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryGT!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryGT!.{u, v} {</span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9005" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9009" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9005" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.9016" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9005" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9009" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.9017" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9005" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryGT!.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9005" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9009" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9005" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.9016" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9005" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9009" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9017" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.9004" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9005" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key that is greater than the given key,
panicking if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryGT___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryGT?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryGT?.{u, v} {</span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9204" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9208" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.9214" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9204" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9208" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9215" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9204" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryGT?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9204" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9208" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.9214" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9204" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9208" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9215" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.9203" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9204" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key that is greater than the given key,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryGTD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryGTD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryGTD.{u, v} {</span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9401" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9405" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.9411" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9401" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9405" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.9413" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9401" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9401" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryGTD.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9401" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9405" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.9411" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9401" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9405" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.9413" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9401" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.9400" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9401" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key that is greater than the given key,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9399" data-verso-hover="4200">fallback</span></code> if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryLE">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryLE" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryLE.{u, v} {</span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9617" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9621" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9621" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.9630" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9617" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9621" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.9631" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9634" data-verso-hover="4857">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.9632" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.9632" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.9630" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.9621" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9632" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9631" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isLE"><span class="const token" data-binding="const-Ordering.isLE" data-verso-hover="1791">isLE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9617" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryLE.{u, v} {</span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9617" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9621" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9621" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.9630" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9617" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9621" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9631" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.9634" data-verso-hover="4857">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.9632" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.9632" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.9630" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.9621" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9632" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9631" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isLE"><span class="const token" data-binding="const-Ordering.isLE" data-verso-hover="1791">isLE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.9616" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9617" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Given a proof that such a mapping exists, retrieves the key-value pair with the largest key that is
less than or equal to the given key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryLE___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryLE!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryLE!.{u, v} {</span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9883" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9887" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9883" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.9894" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9883" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9887" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.9895" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9883" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryLE!.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9883" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9887" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9883" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.9894" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9883" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9887" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9895" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.9882" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.9883" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the largest key that is less than or equal to the
given key, panicking if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryLE___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryLE?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryLE?.{u, v} {</span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10082" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10086" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.10092" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10082" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10086" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10093" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10082" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryLE?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10082" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10086" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10092" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10082" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10086" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10093" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.10081" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10082" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the largest key that is less than or equal to the
given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryLED">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryLED" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryLED.{u, v} {</span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10279" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10283" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.10289" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10279" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10283" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10290" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.10291" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10279" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10279" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryLED.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10279" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10283" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10289" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10279" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10283" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10290" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.10291" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10279" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.10278" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10279" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the largest key that is less than or equal to the
given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10277" data-verso-hover="4200">fallback</span></code> if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryLT">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryLT" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryLT.{u, v} {</span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10495" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10499" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10499" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.10508" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10495" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10499" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.10509" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10511" data-verso-hover="4858">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.10510" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.10510" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.10508" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.10499" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10510" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10509" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.lt" data-verso-hover="1595">Ordering.lt</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10495" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryLT.{u, v} {</span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10495" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10499" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10499" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.10508" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10495" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10499" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10509" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.10511" data-verso-hover="4858">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.10510" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.10510" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.10508" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.10499" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10510" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10509" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.lt" data-verso-hover="1595">Ordering.lt</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.10494" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10495" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Given a proof that such a mapping exists, retrieves the key-value pair with the smallest key that is
less than the given key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryLT___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryLT!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryLT!.{u, v} {</span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10756" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10760" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10756" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.10767" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10756" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10760" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.10768" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10756" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryLT!.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10756" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10760" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10756" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.10767" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10756" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10760" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10768" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.10755" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10756" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key that is less than the given key,
panicking if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryLT___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryLT?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryLT?.{u, v} {</span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10955" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10959" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.10965" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10955" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10959" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10966" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10955" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryLT?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10955" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10959" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10965" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10955" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10959" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10966" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.10954" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.10955" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key that is less than the given key,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getEntryLTD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getEntryLTD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getEntryLTD.{u, v} {</span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11152" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11156" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.11162" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11152" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11156" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11163" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11164" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.11152" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.11152" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getEntryLTD.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11152" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11156" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.11162" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11152" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11156" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11163" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11164" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.11152" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11151" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.11152" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key that is less than the given key,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.11150" data-verso-hover="4200">fallback</span></code> if no such pair exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getGE">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getGE" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getGE.{u} {</span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11370" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11370" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.11378" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11370" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11379" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11382" data-verso-hover="4854">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.11380" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.11380" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.11378" data-verso-hover="4859">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.11370" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11380" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11379" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isGE"><span class="const token" data-binding="const-Ordering.isGE" data-verso-hover="4855">isGE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getGE.{u} {</span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11370" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11370" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.11378" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11370" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11379" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11382" data-verso-hover="4854">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.11380" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.11380" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.11378" data-verso-hover="4859">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.11370" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11380" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11379" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isGE"><span class="const token" data-binding="const-Ordering.isGE" data-verso-hover="4855">isGE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.11366" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that such an element exists, retrieves the smallest element that is
greater than or equal to the given element.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getGT">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getGT" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getGT.{u} {</span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11605" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11605" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.11613" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11605" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11614" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11616" data-verso-hover="4856">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.11615" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.11615" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.11613" data-verso-hover="4859">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.11605" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11615" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11614" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.gt" data-verso-hover="1771">Ordering.gt</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getGT.{u} {</span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11605" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11605" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.11613" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11605" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11614" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11616" data-verso-hover="4856">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.11615" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.11615" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.11613" data-verso-hover="4859">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.11605" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11615" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11614" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.gt" data-verso-hover="1771">Ordering.gt</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.11601" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that such an element exists, retrieves the smallest element that is
greater than the given element.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyGE">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyGE" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyGE.{u, v} {</span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11833" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11837" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11837" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.11846" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11833" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11837" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11847" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11850" data-verso-hover="4854">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.11846" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.11837" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11847" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isGE"><span class="const token" data-binding="const-Ordering.isGE" data-verso-hover="4855">isGE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyGE.{u, v} {</span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11833" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11837" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11837" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.11846" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11833" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11837" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11847" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11850" data-verso-hover="4854">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.11846" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.11837" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11847" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isGE"><span class="const token" data-binding="const-Ordering.isGE" data-verso-hover="4855">isGE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.11832" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that such a mapping exists, retrieves the smallest key that is
greater than or equal to the given key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyGE___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyGE!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyGE!.{u, v} {</span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12089" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12093" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.12100" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12089" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12093" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12101" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyGE!.{u, v} {</span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12089" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12093" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.12100" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12089" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12093" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12101" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key that is greater than or equal to the
given key, panicking if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyGE___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyGE?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyGE?.{u, v} {</span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12260" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12264" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.12270" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12260" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12264" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.12271" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyGE?.{u, v} {</span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12260" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12264" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.12270" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12260" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12264" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.12271" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12259" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key that is greater than or equal to the
given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyGED">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyGED" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyGED.{u, v} {</span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12439" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12443" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.12449" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12439" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12443" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.12450" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.12451" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyGED.{u, v} {</span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12439" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12443" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.12449" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12439" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12443" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12450" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.12451" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12438" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key that is greater than or equal to the
given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.12437" data-verso-hover="45">fallback</span></code> if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyGT">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyGT" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyGT.{u, v} {</span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12629" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.12642" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12629" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12643" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.12645" data-verso-hover="4856">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.12644" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.12644" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.12642" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12644" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12643" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.gt" data-verso-hover="1771">Ordering.gt</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyGT.{u, v} {</span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12629" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.12642" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12629" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.12643" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12645" data-verso-hover="4856">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.12644" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.12644" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.12642" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12644" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12643" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.gt" data-verso-hover="1771">Ordering.gt</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.12628" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that such a mapping exists, retrieves the smallest key that is
greater than the given key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyGT___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyGT!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyGT!.{u, v} {</span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12880" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12884" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.12891" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12880" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12884" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12892" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyGT!.{u, v} {</span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12880" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12884" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.12891" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12880" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12884" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12892" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12879" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key that is greater than the given key,
panicking if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyGT___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyGT?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyGT?.{u, v} {</span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13051" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13055" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.13061" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13051" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13055" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.13062" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyGT?.{u, v} {</span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13051" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13055" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.13061" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13051" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13055" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.13062" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13050" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key that is greater than the given key,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyGTD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyGTD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyGTD.{u, v} {</span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13230" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13234" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.13240" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13230" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13234" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.13241" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.13242" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyGTD.{u, v} {</span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13230" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13234" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.13240" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13230" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13234" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.13241" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.13242" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.13229" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key that is greater than the given key,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.13228" data-verso-hover="45">fallback</span></code> if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyLE">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyLE" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyLE.{u, v} {</span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13420" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13424" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13424" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.13433" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13420" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13424" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.13434" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.13437" data-verso-hover="4857">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.13435" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.13435" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.13433" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.13424" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13435" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13434" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isLE"><span class="const token" data-binding="const-Ordering.isLE" data-verso-hover="1791">isLE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyLE.{u, v} {</span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13420" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13424" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13424" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.13433" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13420" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13424" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.13434" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.13437" data-verso-hover="4857">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.13435" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.13435" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.13433" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.13424" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13435" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13434" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isLE"><span class="const token" data-binding="const-Ordering.isLE" data-verso-hover="1791">isLE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.13419" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that such a mapping exists, retrieves the largest key that is
less than or equal to the given key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyLE___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyLE!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyLE!.{u, v} {</span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13676" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13680" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.13687" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13676" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13680" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.13688" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyLE!.{u, v} {</span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13676" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13680" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.13687" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13676" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13680" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.13688" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.13675" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest key that is less than or equal to the
given key, panicking if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyLE___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyLE?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyLE?.{u, v} {</span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13847" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13851" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.13857" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13847" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13851" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.13858" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyLE?.{u, v} {</span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.13847" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.13851" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.13857" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13847" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13851" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.13858" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13846" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest key that is less than or equal to the
given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyLED">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyLED" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyLED.{u, v} {</span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14026" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14030" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.14036" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14026" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14030" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.14037" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.14038" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyLED.{u, v} {</span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14026" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14030" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.14036" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14026" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14030" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.14037" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.14038" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.14025" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest key that is less than or equal to the
given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.14024" data-verso-hover="45">fallback</span></code> if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyLT">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyLT" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyLT.{u, v} {</span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14216" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14220" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14220" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.14229" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14216" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14220" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.14230" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.14232" data-verso-hover="4858">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.14231" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.14231" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.14229" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.14220" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14231" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14230" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.lt" data-verso-hover="1595">Ordering.lt</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyLT.{u, v} {</span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14216" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14220" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14220" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.14229" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14216" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14220" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.14230" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.14232" data-verso-hover="4858">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.14231" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.14231" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.14229" data-verso-hover="4849">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.14220" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14231" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14230" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.lt" data-verso-hover="1595">Ordering.lt</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.14215" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that such a mapping exists, retrieves the smallest key that is
less than the given key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyLT___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyLT!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyLT!.{u, v} {</span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14467" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14471" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.14478" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14467" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14471" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.14479" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyLT!.{u, v} {</span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14467" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14471" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.14478" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14467" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14471" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.14479" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.14466" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key that is less than the given key,
panicking if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyLT___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyLT?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyLT?.{u, v} {</span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14638" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14642" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.14648" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14638" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14642" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.14649" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyLT?.{u, v} {</span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14638" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14642" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.14648" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14638" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14642" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.14649" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14637" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key that is less than the given key,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getKeyLTD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getKeyLTD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getKeyLTD.{u, v} {</span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14817" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14821" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.14827" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14817" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14821" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.14828" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.14829" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getKeyLTD.{u, v} {</span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14817" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14821" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.14827" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14817" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14821" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.14828" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.14829" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.14816" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key that is less than the given key,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.14815" data-verso-hover="45">fallback</span></code> if no such key exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getLE">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getLE" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getLE.{u} {</span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15009" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15009" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.15017" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15009" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.15018" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.15021" data-verso-hover="4857">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.15019" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.15019" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.15017" data-verso-hover="4859">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.15009" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15019" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15018" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isLE"><span class="const token" data-binding="const-Ordering.isLE" data-verso-hover="1791">isLE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getLE.{u} {</span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15009" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15009" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.15017" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15009" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.15018" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.15021" data-verso-hover="4857">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.15019" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.15019" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.15017" data-verso-hover="4859">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="inter-text">(</span><span class="var token" data-binding="var-_uniq.15009" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15019" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15018" data-verso-hover="45">k</span><span class="inter-text">).</span><a href="Type-Classes/Basic-Classes/#Ordering___isLE"><span class="const token" data-binding="const-Ordering.isLE" data-verso-hover="1791">isLE</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.15005" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that such an element exists, retrieves the largest element that is
less than or equal to the given element.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___getLT">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getLT" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getLT.{u} {</span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4848">cmp</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.15252" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.15253" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.15255" data-verso-hover="4858">h</span><span class="inter-text"> : </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.15254" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.15254" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.15252" data-verso-hover="4859">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15254" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15253" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.lt" data-verso-hover="1595">Ordering.lt</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getLT.{u} {</span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.TransCmp" data-verso-hover="4853">Std.TransCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.15252" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.15253" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.15255" data-verso-hover="4858">h</span><span class="inter-text"> :
    </span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170"> </span></a><span class="var token" data-binding="var-_uniq.15254" data-verso-hover="45">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1170">, </span></a><span class="var token" data-binding="var-_uniq.15254" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.15252" data-verso-hover="4859">t</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="113"> ∧ </span></a><span class="var token" data-binding="var-_uniq.15244" data-verso-hover="4848">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15254" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15253" data-verso-hover="45">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.lt" data-verso-hover="1595">Ordering.lt</span></a><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.15240" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that such an element exists, retrieves the smallest element that is
less than the given element.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___keyAtIdx">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.keyAtIdx" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.keyAtIdx.{u, v} {</span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15471" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15475" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.15481" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15471" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15475" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.15482" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.15487" data-verso-hover="4851">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15482" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.15481" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.keyAtIdx.{u, v} {</span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15471" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15475" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.15481" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15471" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15475" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.15482" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.15487" data-verso-hover="4851">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15482" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.15481" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.15470" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Returns the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15468" data-verso-hover="7">n</span></code>-th smallest key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___keyAtIdx___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.keyAtIdx!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.keyAtIdx!.{u, v} {</span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15694" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15698" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.15705" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15694" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15698" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.15706" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.keyAtIdx!.{u, v} {</span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15694" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15698" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.15705" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15694" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15698" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.15706" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.15693" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Returns the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15674" data-verso-hover="7">n</span></code>-th smallest key, or panics if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15674" data-verso-hover="7">n</span></code> is at least <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15673" data-verso-hover="4849">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___keyAtIdx___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.keyAtIdx?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.keyAtIdx?.{u, v} {</span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15931" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15935" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.15941" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15931" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15935" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.15942" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.keyAtIdx?.{u, v} {</span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.15931" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.15935" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.15941" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15931" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15935" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.15942" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15930" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Returns the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15910" data-verso-hover="7">n</span></code>-th smallest key, or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15910" data-verso-hover="7">n</span></code> is at least <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.15909" data-verso-hover="4849">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___keyAtIdxD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.keyAtIdxD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.keyAtIdxD.{u, v} {</span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16176" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16180" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.16186" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16176" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16180" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.16187" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.16188" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.keyAtIdxD.{u, v} {</span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16176" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16180" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.16186" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16176" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16180" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.16187" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.16188" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16175" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Returns the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16155" data-verso-hover="7">n</span></code>-th smallest key, or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16156" data-verso-hover="45">fallback</span></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16155" data-verso-hover="7">n</span></code> is at least <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16154" data-verso-hover="4849">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___size"><span class="const token" data-binding="const-Std.TreeMap.size" data-verso-hover="4852">size</span></a></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___minEntry">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.minEntry" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.minEntry.{u, v} {</span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16418" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16422" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.16428" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16418" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16422" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.16433" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16428" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___isEmpty"><span class="const token" data-binding="const-Std.TreeMap.isEmpty" data-verso-hover="4861">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16418" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.minEntry.{u, v} {</span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16418" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16422" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.16428" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16418" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16422" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.16433" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16428" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___isEmpty"><span class="const token" data-binding="const-Std.TreeMap.isEmpty" data-verso-hover="4861">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16417" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16418" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Given a proof that the tree map is not empty, retrieves the key-value pair with the smallest key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___minEntry___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.minEntry!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.minEntry!.{u, v} {</span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16597" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16601" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16597" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.16608" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16597" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16601" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16597" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.minEntry!.{u, v} {</span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16597" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16601" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16597" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.16608" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16597" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16601" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16596" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16597" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key in the tree map, panicking if the map is
empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___minEntry___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.minEntry?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.minEntry?.{u, v} {</span><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16779" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16783" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.16789" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16779" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16783" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16779" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.minEntry?.{u, v} {</span><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16779" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16783" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.16789" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16779" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16783" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.16778" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16779" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key in the tree map, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if the
map is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___minEntryD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.minEntryD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.minEntryD.{u, v} {</span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16959" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16963" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.16969" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16959" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16963" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.16970" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16959" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16959" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.minEntryD.{u, v} {</span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.16959" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.16963" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.16969" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16959" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16963" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.16970" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16959" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.16958" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.16959" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the smallest key in the tree map, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.16957" data-verso-hover="4200">fallback</span></code> if
the tree map is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___minKey">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.minKey" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.minKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17157" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17161" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17167" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17157" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17161" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.17172" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17167" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___isEmpty"><span class="const token" data-binding="const-Std.TreeMap.isEmpty" data-verso-hover="4861">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.minKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17157" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17161" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.17167" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17157" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17161" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.17172" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17167" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___isEmpty"><span class="const token" data-binding="const-Std.TreeMap.isEmpty" data-verso-hover="4861">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17156" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that the tree map is not empty, retrieves the smallest key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___minKey___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.minKey!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.minKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17326" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17330" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.17337" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17326" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17330" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.minKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17326" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17330" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.17337" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17326" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17330" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17325" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key in the tree map, panicking if the map is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___minKey___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.minKey?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.minKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17474" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17478" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17484" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17474" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17478" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.minKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17474" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17478" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.17484" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17474" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17478" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17473" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key in the tree map, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if the map is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___minKeyD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.minKeyD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.minKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17630" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17634" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17640" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17630" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17634" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.17641" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.minKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17630" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17634" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.17640" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17630" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17634" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.17641" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17629" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest key in the tree map, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.17628" data-verso-hover="45">fallback</span></code> if the tree map is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___maxEntry">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.maxEntry" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.maxEntry.{u, v} {</span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17802" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17806" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.17812" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17802" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17806" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.17817" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17812" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___isEmpty"><span class="const token" data-binding="const-Std.TreeMap.isEmpty" data-verso-hover="4861">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.17802" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.maxEntry.{u, v} {</span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17802" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17806" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.17812" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17802" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17806" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.17817" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17812" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___isEmpty"><span class="const token" data-binding="const-Std.TreeMap.isEmpty" data-verso-hover="4861">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17801" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.17802" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Given a proof that the tree map is not empty, retrieves the key-value pair with the largest key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___maxEntry___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.maxEntry!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.maxEntry!.{u, v} {</span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17981" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17985" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.17981" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.17992" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17981" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17985" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.17981" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.maxEntry!.{u, v} {</span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.17981" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.17985" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.17981" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.17992" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17981" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17985" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.17980" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.17981" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the largest key in the tree map, panicking if the map is
empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___maxEntry___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.maxEntry?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.maxEntry?.{u, v} {</span><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18163" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18167" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18173" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18163" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18167" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.18163" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.maxEntry?.{u, v} {</span><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18163" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18167" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.18173" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18163" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18167" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.18162" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.18163" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the largest key in the tree map, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if the
map is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___maxEntryD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.maxEntryD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.maxEntryD.{u, v} {</span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18343" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18347" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18353" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18343" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18347" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.18354" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.18343" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.18343" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.maxEntryD.{u, v} {</span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18343" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18347" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.18353" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18343" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18347" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.18354" data-verso-hover="4200">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.18343" data-verso-hover="244">β</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18342" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.18343" data-verso-hover="244">β</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the key-value pair with the largest key in the tree map, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.18341" data-verso-hover="4200">fallback</span></code> if
the tree map is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___maxKey">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.maxKey" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.maxKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18541" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18545" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18551" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18541" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18545" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.18556" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18551" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___isEmpty"><span class="const token" data-binding="const-Std.TreeMap.isEmpty" data-verso-hover="4861">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.maxKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18541" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18545" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.18551" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18541" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18545" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.18556" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18551" data-verso-hover="4849">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___isEmpty"><span class="const token" data-binding="const-Std.TreeMap.isEmpty" data-verso-hover="4861">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18540" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that the tree map is not empty, retrieves the largest key.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___maxKey___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.maxKey!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.maxKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18710" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18714" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.18721" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18710" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18714" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.maxKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18710" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18714" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.18721" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18710" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18714" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.18709" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest key in the tree map, panicking if the map is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___maxKey___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.maxKey?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.maxKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18858" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18862" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.18868" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18858" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18862" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.maxKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.18858" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.18862" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.18868" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18858" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18862" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18857" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest key in the tree map, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if the map is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___maxKeyD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.maxKeyD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.maxKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19014" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19018" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19024" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19014" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19018" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19025" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.maxKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19014" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19018" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.19024" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19014" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19018" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19025" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.19013" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest key in the tree map, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.19012" data-verso-hover="45">fallback</span></code> if the tree map is empty.</p>
                      </div>
                    </div>
                  </section>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Modification">
                  18.17.8.4. Modification</h3>
                <div class="namedocs" id="Std___TreeMap___alter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.alter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19198" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19204" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19198" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19205" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19207" data-verso-hover="4746">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19198" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19198" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.19204" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19198" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19205" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19207" data-verso-hover="4746">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19193" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19194" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19198" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key,
allowing creating new values and deleting values via an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code> valued replacement function.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___modify">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.modify" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19441" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19447" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19441" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19448" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19450" data-verso-hover="4747">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19441" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19441" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.19447" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19441" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19448" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19450" data-verso-hover="4747">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19436" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19437" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19441" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___containsThenInsert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.containsThenInsert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.containsThenInsert.{u, v} {</span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19668" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19672" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19678" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19668" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19672" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19679" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19680" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19668" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19668" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19672" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.containsThenInsert.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19668" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19672" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.19678" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19668" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19672" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19679" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19680" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19668" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19667" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19668" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19672" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map and unconditionally inserts a value for the key.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___containsThenInsertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.containsThenInsertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.containsThenInsertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19929" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19933" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.19939" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19929" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19933" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19940" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19941" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19929" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19929" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19933" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.containsThenInsertIfNew.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.19929" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.19933" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.19939" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19929" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19933" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.19940" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.19941" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.19929" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19928" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19929" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19933" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map and inserts a value for the key if it was not found.
If the returned <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>, then the returned map is unaltered. If the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>,
then the returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___erase">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.erase" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20235" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20239" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.20245" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20235" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20239" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.20246" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20235" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20239" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20235" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20239" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.20245" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20235" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20239" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.20246" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20234" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20235" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20239" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Removes the mapping for the given key if it exists.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___eraseMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.eraseMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.eraseMany.{u, v, u_1} {</span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20420" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20424" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20425" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20425" data-verso-hover="43">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.20433" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20420" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20424" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.20434" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20425" data-verso-hover="43">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20420" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20424" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.eraseMany.{u, v, u_1}
  {</span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20420" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20424" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20425" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20425" data-verso-hover="43">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.20433" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20420" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20424" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20434" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20425" data-verso-hover="43">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20419" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20420" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20424" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Erases multiple mappings from the tree map by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">erase</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___filter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.filter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20646" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20650" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.20654" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20646" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20660" data-verso-hover="4849">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20646" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20650" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20646" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20650" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20646" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20650" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.20654" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20646" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20660" data-verso-hover="4849">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20646" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20650" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20645" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20646" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20650" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Removes all mappings of the map for which the given function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___filterMap">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.filterMap" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.filterMap.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20851" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20852" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20856" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.20860" data-verso-hover="4750">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20851" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20852" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20866" data-verso-hover="4849">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20851" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20856" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20852" data-verso-hover="4179">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20856" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.filterMap.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20851" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.20852" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.20856" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.20860" data-verso-hover="4750">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.20851" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20852" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.20866" data-verso-hover="4849">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20851" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20856" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20850" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20852" data-verso-hover="4179">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20856" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Updates the values of the map by applying the given function to all mappings, keeping
only those mappings where the function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> value.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___insert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.insert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21080" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21084" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.21090" data-verso-hover="4849">l</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21080" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21084" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21091" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21092" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21080" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21080" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21084" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21080" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21084" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.21090" data-verso-hover="4849">l</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21080" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21084" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21091" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.21092" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21080" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21079" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21080" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21084" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Inserts the given mapping into the map. If there is already a mapping for the given key, then both
key and value will be replaced.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___insertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.insertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.insertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21277" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21281" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.21287" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21277" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21281" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21288" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21289" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21277" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21277" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21281" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.insertIfNew.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21277" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21281" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.21287" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21277" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21281" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21288" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.21289" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21277" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21276" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21277" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21281" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      If there is no mapping for the given key, inserts the given mapping into the map. Otherwise,
returns the map unaltered.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___getThenInsertIfNew___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.getThenInsertIfNew?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.getThenInsertIfNew?.{u, v} {</span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21534" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.21540" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21534" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21541" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21542" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21534" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.getThenInsertIfNew?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21534" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.21540" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21534" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21541" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.21542" data-verso-hover="185">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21529" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21530" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21534" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, returning the associated value, and inserts a value for
the key if it was not found.</p>
                    <p>
                      If the returned value is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21486" data-verso-hover="4862">v</span></code>, then the returned map is unaltered. If it is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>, then the
returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">get?</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___insertMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.insertMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.insertMany.{u, v, u_1} {</span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21931" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21935" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21936" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21936" data-verso-hover="43">ρ</span><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.21931" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.21944" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21931" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21935" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21945" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21936" data-verso-hover="43">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21931" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21935" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.insertMany.{u, v, u_1}
  {</span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21931" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.21935" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.21936" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21936" data-verso-hover="43">ρ</span><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.21931" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.21944" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21931" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21935" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.21945" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.21936" data-verso-hover="43">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21930" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21931" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21935" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Inserts multiple mappings into the tree map by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>. If the same key appears multiple times, the last occurrence takes precedence.</p>
                    <p>
                      Note: this precedence behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertMany</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet.Raw</span></code> behaves differently: it will prefer the first
appearance.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___insertManyIfNewUnit">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.insertManyIfNewUnit" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.insertManyIfNewUnit.{u, u_1} {</span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22303" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22304" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22304" data-verso-hover="43">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.22312" data-verso-hover="4863">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22303" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.22313" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22304" data-verso-hover="43">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22303" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.insertManyIfNewUnit.{u, u_1}
  {</span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22303" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22304" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22304" data-verso-hover="43">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.22312" data-verso-hover="4863">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22303" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.22313" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22304" data-verso-hover="43">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22299" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22303" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Inserts multiple elements into the tree map by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>. If the same key appears multiple times, the first occurrence takes precedence.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___mergeWith">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.mergeWith" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.mergeWith.{u, v} {</span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22557" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.22563" data-verso-hover="4864">mergeFn</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.22564" data-verso-hover="4849">t₁ </span><span class="var token" data-binding="var-_uniq.22570" data-verso-hover="4849">t₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22557" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22557" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.mergeWith.{u, v} {</span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.22557" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.22563" data-verso-hover="4864">mergeFn</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.22564" data-verso-hover="4849">t₁ </span><span class="var token" data-binding="var-_uniq.22570" data-verso-hover="4849">t₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22557" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22552" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22553" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22557" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Returns a map that contains all mappings of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22506" data-verso-hover="4849">t₁</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22507" data-verso-hover="4849">t₂</span></code>. In case that both maps contain the
same key <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">k</span></code> with respect to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22504" data-verso-hover="4848">cmp</span></code>, the provided function is used to determine the new value from
the respective values in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22506" data-verso-hover="4849">t₁</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22507" data-verso-hover="4849">t₂</span></code>.</p>
                    <p>
                      This function ensures that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22523" data-verso-hover="4849">t₁</span></code> is used linearly. It also uses the individual values in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22523" data-verso-hover="4849">t₁</span></code>
linearly if the merge function uses the second argument (i.e. the first of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22520" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span></code>) linearly.
Hence, as long as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22523" data-verso-hover="4849">t₁</span></code> is unshared, the performance characteristics follow the following imperative
description: Iterate over all mappings in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22524" data-verso-hover="4849">t₂</span></code>, inserting them into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22523" data-verso-hover="4849">t₁</span></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22523" data-verso-hover="4849">t₁</span></code> does not contain a
conflicting mapping yet. If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22523" data-verso-hover="4849">t₁</span></code> does contain a conflicting mapping, use the given merge function to
merge the mapping in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22524" data-verso-hover="4849">t₂</span></code> into the mapping in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22523" data-verso-hover="4849">t₁</span></code>. Then return <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22523" data-verso-hover="4849">t₁</span></code>.</p>
                    <p>
                      Hence, the runtime of this method scales logarithmically in the size of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22550" data-verso-hover="4849">t₁</span></code> and linearly in the size of
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22551" data-verso-hover="4849">t₂</span></code> as long as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.22550" data-verso-hover="4849">t₁</span></code> is unshared.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___partition">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.partition" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.partition.{u, v} {</span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23167" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.23171" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23177" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23167" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23167" data-verso-hover="4848">cmp</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23167" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.partition.{u, v} {</span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23167" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.23171" data-verso-hover="4749">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23177" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23167" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23167" data-verso-hover="4848">cmp</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> ×
    </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23162" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23163" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23167" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Partitions a tree map into two tree maps based on a predicate.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Iteration">
                  18.17.8.5. Iteration</h3>
                <div class="namedocs" id="Std___TreeMap___map">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.map" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23382" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23383" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23387" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.23391" data-verso-hover="2642">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23382" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23383" data-verso-hover="4179">γ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23397" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23382" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23387" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23383" data-verso-hover="4179">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23387" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23382" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23383" data-verso-hover="4179">γ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23387" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.23391" data-verso-hover="2642">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23382" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23383" data-verso-hover="4179">γ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23397" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23382" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23387" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23381" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23383" data-verso-hover="4179">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23387" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Updates the values of the map by applying the given function to all mappings.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___all">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.all" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.all.{u, v} {</span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23585" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23589" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.23595" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23585" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23589" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23599" data-verso-hover="4749">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23585" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.all.{u, v} {</span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23585" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23589" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.23595" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23585" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23589" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23599" data-verso-hover="4749">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23584" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23585" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Check if all elements satisfy the predicate, short-circuiting if a predicate fails.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___any">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.any" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.any.{u, v} {</span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23749" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23753" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.23759" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23749" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23753" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23763" data-verso-hover="4749">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23749" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.any.{u, v} {</span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23749" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23753" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.23759" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23749" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23753" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23763" data-verso-hover="4749">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23748" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23749" data-verso-hover="244">β</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Check if any element satisfes the predicate, short-circuiting if a predicate fails.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___foldl">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.foldl" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.foldl.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23915" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23919" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.23926" data-verso-hover="4865">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23915" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23927" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23933" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23915" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23919" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.foldl.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23915" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.23919" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.23926" data-verso-hover="4865">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23915" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.23927" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.23933" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23914" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23915" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23919" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.23920" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Folds the given function over the mappings in the map in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___foldlM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.foldlM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.foldlM.{u, v, w, w₂} {</span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24125" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24129" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24132" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24132" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24139" data-verso-hover="4867">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24125" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24132" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24140" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24146" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24125" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24129" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.24132" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.foldlM.{u, v, w, w₂}
  {</span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24125" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24129" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24132" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24132" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24139" data-verso-hover="4867">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24125" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24132" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24140" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.24146" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24124" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24125" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24129" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.24132" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24130" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Folds the given monadic function over the mappings in the map in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___foldr">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.foldr" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.foldr.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24375" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24379" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.24386" data-verso-hover="4868">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24375" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24387" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.24393" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24375" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24379" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.foldr.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24375" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24379" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.24386" data-verso-hover="4868">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24375" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.24387" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24393" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24374" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24375" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24379" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.24380" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Folds the given function over the mappings in the map in descending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___foldrM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.foldrM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.foldrM.{u, v, w, w₂} {</span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24585" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24589" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24592" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24592" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24599" data-verso-hover="4869">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24585" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24592" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24600" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24606" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24585" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24589" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.24592" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.foldrM.{u, v, w, w₂}
  {</span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24585" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24589" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24592" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24592" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24599" data-verso-hover="4869">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24585" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24592" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24600" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.24606" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24584" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24585" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24589" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.24592" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24590" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Folds the given monadic function over the mappings in the map in descending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___forIn">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.forIn" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.forIn.{u, v, w, w₂} {</span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24837" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24841" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24844" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24844" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24851" data-verso-hover="4870">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24837" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24844" data-verso-hover="4866">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.24852" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.24858" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24837" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24841" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.24844" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.forIn.{u, v, w, w₂}
  {</span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24837" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24841" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.24844" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24844" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.24851" data-verso-hover="4870">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24837" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.24844" data-verso-hover="4866">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.24852" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.24858" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24836" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24837" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24841" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.24844" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24842" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Support for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span></code> loop construct in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> blocks. Iteration happens in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___forM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.forM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.forM.{u, v, w, w₂} {</span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.25129" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.25133" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.25135" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25135" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.25140" data-verso-hover="4757">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25129" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25135" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.25146" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25129" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25133" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.25135" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.forM.{u, v, w, w₂}
  {</span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.25129" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.25133" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.25135" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25135" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.25140" data-verso-hover="4757">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25129" data-verso-hover="244">β</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25135" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.25146" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25128" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25129" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25133" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.25135" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div></pre><div class="text">
                    <p>
                      Carries out a monadic action on each mapping in the tree map in ascending order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Conversion">
                  18.17.8.6. Conversion</h3>
                <div class="namedocs" id="Std___TreeMap___ofList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.ofList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.25336" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.25337" data-verso-hover="4447">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.25336" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.25341" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25336" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25341" data-verso-hover="4845">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.25336" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.25337" data-verso-hover="4447">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.25336" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.25341" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25335" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25336" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25341" data-verso-hover="4845">cmp</span></div></pre><div class="text">
                    <p>
                      Transforms a list of mappings into a tree map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___toList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.toList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.toList.{u, v} {</span><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.25496" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.25500" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.25506" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25496" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25500" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.25496" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.toList.{u, v} {</span><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.25496" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.25500" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.25506" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25496" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25500" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.25495" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.25496" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                    <p>
                      Transforms the tree map into a list of mappings in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___ofArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.ofArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.ofArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.25656" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.25657" data-verso-hover="4601">a</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.25656" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.25661" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25656" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25661" data-verso-hover="4845">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.ofArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.25656" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.25657" data-verso-hover="4601">a</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.25656" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.25661" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25655" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25656" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25661" data-verso-hover="4845">cmp</span></div></pre><div class="text">
                    <p>
                      Transforms a list of mappings into a tree map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___toArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.toArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.toArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.25816" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.25820" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.25826" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25816" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25820" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.25816" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.toArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.25816" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.25820" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.25826" data-verso-hover="4849">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25816" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25820" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">(</span></a><span class="var token" data-binding="var-_uniq.25815" data-verso-hover="54">α</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><span class="var token" data-binding="var-_uniq.25816" data-verso-hover="244">β</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189">)</span></a></div></pre><div class="text">
                    <p>
                      Transforms the tree map into a list of mappings in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___unitOfArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.unitOfArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.unitOfArray.{u} {</span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.25975" data-verso-hover="303">a</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.25979" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25979" data-verso-hover="4845">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.unitOfArray.{u} {</span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.25975" data-verso-hover="303">a</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.25979" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25974" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25979" data-verso-hover="4845">cmp</span></div></pre><div class="text">
                    <p>
                      Transforms an array of keys into a tree map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeMap___unitOfList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.unitOfList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.unitOfList.{u} {</span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.26102" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.26106" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26106" data-verso-hover="4845">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.unitOfList.{u} {</span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.26102" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.26106" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap"><span class="const token" data-binding="const-Std.TreeMap" data-verso-hover="4657">Std.TreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26101" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26106" data-verso-hover="4845">cmp</span></div></pre><div class="text">
                    <p>
                      Transforms a list of keys into a tree map.</p>
                    </div>
                  </div>
                <section>
                  <h4 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Conversion--Unbundled-Variants">
                    18.17.8.6.1. Unbundled Variants</h4>
                  <p>
                    Unbundled maps separate well-formedness proofs from data.
This is primarily useful when defining <a href="Basic-Types/Maps-and-Sets/#raw-data">nested inductive types</a>.
To use these variants, import the module <code>Std.TreeMap.Raw</code>.</p>
                  <div class="namedocs" id="Std___TreeMap___Raw___mk">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.Raw" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.Raw.{u, v} (</span><span class="var token" data-binding="var-_uniq.26505" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.26506" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.26510" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.26505" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.26505" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.Raw.{u, v} (</span><span class="var token" data-binding="var-_uniq.26505" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.26506" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.26510" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.26505" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.26505" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div></pre><div class="text">
                      <p>
                        Tree maps without a bundled well-formedness invariant, suitable for use in nested
inductive types. The well-formedness invariant is called <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Raw.WF</span></code>. When in doubt, prefer <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap</span></code>
over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap.Raw</span></code>. Lemmas about the operations on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw" data-verso-hover="4846">Std.TreeMap.Raw</span></a></code> are available in the
module <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.TreeMap.Raw.Lemmas</span></code>.</p>
                      <p>
                        A tree map stores an assignment of keys to values. It depends on a comparator function that
defines an ordering on the keys and provides efficient order-dependent queries, such as retrieval
of the minimum or maximum.</p>
                      <p>
                        To ensure that the operations behave as expected, the comparator function <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.26319" data-verso-hover="4845">cmp</span></code> should satisfy
certain laws that ensure a consistent ordering:</p>
                      <ul>
                        <li>
                          <p>
                            If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is greater than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
and vice versa (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">OrientedCmp</span></code> typeclass).</p>
                          </li>
                        <li>
                          <p>
                            If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is, in turn, less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code> (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TransCmp</span></code> typeclass).</p>
                          </li>
                        </ul>
                      <p>
                        Keys for which <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.26439" data-verso-hover="4845">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26448" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26454" data-verso-hover="45">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.eq" data-verso-hover="1774">Ordering.eq</span></a></code> are considered the same, i.e., there can be only one entry
with key either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.26448" data-verso-hover="45">a</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.26454" data-verso-hover="45">b</span></code> in a tree map. Looking up either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.26448" data-verso-hover="45">a</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.26454" data-verso-hover="45">b</span></code> always yields the same entry,
if any is present.</p>
                      <p>
                        To avoid expensive copies, users should make sure that the tree map is used linearly.</p>
                      <p>
                        Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary
search tree with efficient order statistic lookups.</p>
                      <h1>
                        Constructor</h1>
                      <section class="subdocs">
                        <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw.mk" data-verso-hover="4871">Std.TreeMap.Raw.mk</span></a><span class="inter-text">.{u, v}</span></pre><div class="docs"></div>
                        </section>
                      <h1>
                        Fields</h1>
                      <section class="subdocs">
                        <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.TreeMap.Raw.inner" data-verso-hover="4872">inner</span> : <a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw" data-verso-hover="4873">Std.DTreeMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26473" data-verso-hover="54">α</span><span class="inter-text"> (</span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26484" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.26474" data-verso-hover="244">β</span><span class="inter-text">) </span><span class="var token" data-binding="var-_uniq.26475" data-verso-hover="4845">cmp</span></pre><div class="docs">
                          <p>
                            Internal implementation detail of the tree map.</p>
                          </div>
                        </section>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeMap___Raw___WF___mk">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeMap.Raw.WF.mk" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeMap.Raw.WF.{u, v} {</span><span class="var token" data-binding="var-_uniq.27387" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.27388" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.27392" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.27387" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.27387" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.27398" data-verso-hover="4874">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw" data-verso-hover="4846">Std.TreeMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27387" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27388" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27392" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only"><span class="inter-text">Std.TreeMap.Raw.WF.{u, v} {</span><span class="var token" data-binding="var-_uniq.27387" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.27388" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.27392" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.27387" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.27387" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.27398" data-verso-hover="4874">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw" data-verso-hover="4846">Std.TreeMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27387" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27388" data-verso-hover="244">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27392" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                      <p>
                        Well-formedness predicate for tree maps. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap</span></code> will not need to interact with
this. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap.Raw</span></code> will need to provide proofs of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF</span></code> to lemmas and should use lemmas
like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.empty</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.insert</span></code> (which are always named exactly like the operations they are about)
to show that map operations preserve well-formedness. The constructors of this type are internal
implementation details and should not be accessed by users.</p>
                      <h1>
                        Constructor</h1>
                      <section class="subdocs">
                        <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw.WF.mk" data-verso-hover="4875">Std.TreeMap.Raw.WF.mk</span></a><span class="inter-text">.{u, v}</span></pre><div class="docs"></div>
                        </section>
                      <h1>
                        Fields</h1>
                      <section class="subdocs">
                        <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.TreeMap.Raw.WF.out" data-verso-hover="4876">out</span> : <span class="var token" data-binding="var-_uniq.27360" data-verso-hover="4874">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw.inner" data-verso-hover="4877">inner</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw.WF" data-verso-hover="4878">WF</span></a></pre><div class="docs">
                          <p>
                            Internal implementation detail of the tree map.</p>
                          </div>
                        </section>
                      </div>
                    </div>
                  </section>
                </section>
              </section>
            <section>
              <h2 id="DTreeMap">
                18.17.9. Dependent Tree-Based Maps<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=DTreeMap" title="Permalink">🔗</a></span></h2>
              <p>
                The declarations in this section should be imported using <code>import Std.DTreeMap</code>.</p>
              <div class="namedocs" id="Std___DTreeMap">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.89077" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.89079" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.89077" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.89083" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.89077" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.89077" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.{u, v} (</span><span class="var token" data-binding="var-_uniq.89077" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.89079" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.89077" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.89083" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.89077" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.89077" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div></pre><div class="text">
                  <p>
                    Dependent tree maps.</p>
                  <p>
                    A tree map stores an assignment of keys to values. It depends on a comparator function that
defines an ordering on the keys and provides efficient order-dependent queries, such as retrieval
of the minimum or maximum.</p>
                  <p>
                    To ensure that the operations behave as expected, the comparator function <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.88852" data-verso-hover="4845">cmp</span></code> should satisfy
certain laws that ensure a consistent ordering:</p>
                  <ul>
                    <li>
                      <p>
                        If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is greater than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
and vice versa (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">OrientedCmp</span></code> typeclass).</p>
                      </li>
                    <li>
                      <p>
                        If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is, in turn, less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code> (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TransCmp</span></code> typeclass).</p>
                      </li>
                    </ul>
                  <p>
                    Keys for which <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.88972" data-verso-hover="4845">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88981" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88987" data-verso-hover="45">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.eq" data-verso-hover="1774">Ordering.eq</span></a></code> are considered the same, i.e., there can be only one entry
with key either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.88981" data-verso-hover="45">a</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.88987" data-verso-hover="45">b</span></code> in a tree map. Looking up either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.88981" data-verso-hover="45">a</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.88987" data-verso-hover="45">b</span></code> always yields the same entry,
if any is present. The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-MonadState.get" data-verso-hover="818">get</span></code> operations of the <em>dependent</em> tree map additionally require a
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to ensure that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.88972" data-verso-hover="4845">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88981" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88987" data-verso-hover="45">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.eq" data-verso-hover="1774">.eq</span></a></code> always implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.88981" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88987" data-verso-hover="45">b</span></code>, so that their
respective value types are equal.</p>
                  <p>
                    To avoid expensive copies, users should make sure that the tree map is used linearly.</p>
                  <p>
                    Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary
search tree with efficient order statistic lookups.</p>
                  <p>
                    These tree maps contain a bundled well-formedness invariant, which means that they cannot
be used in nested inductive types. For these use cases, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw" data-verso-hover="4873">Std.DTreeMap.Raw</span></a></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw.WF" data-verso-hover="4878">Std.DTreeMap.Raw.WF</span></a></code> unbundle the invariant from the tree map. When in doubt, prefer
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap</span></code> over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap.Raw</span></code>.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Creation">
                  18.17.9.1. Creation</h3>
                <div class="namedocs" id="Std___DTreeMap___empty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.empty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.empty.{u, v} {</span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.91549" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.91553" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91549" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91553" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.empty.{u, v} {</span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.91549" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.91553" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91547" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91549" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91553" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Creates a new empty tree map. It is also possible and recommended to
use the empty collection notations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span></code> to create an empty tree map. <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="35">simp</span></a></code> replaces
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">empty</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code>.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Properties">
                  18.17.9.2. Properties</h3>
                <div class="namedocs" id="Std___DTreeMap___size">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.size" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.91756" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.91760" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.91766" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91756" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91760" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.size.{u, v} {</span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.91756" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.91760" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.91766" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91754" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91756" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91760" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                    <p>
                      Returns the number of mappings present in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___isEmpty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.isEmpty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.91897" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.91901" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.91907" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91897" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91901" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.isEmpty.{u, v} {</span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.91897" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.91901" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.91907" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91895" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91897" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91901" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the tree map contains no mappings.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Queries">
                  18.17.9.3. Queries</h3>
                <div class="namedocs" id="Std___DTreeMap___contains">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.contains" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.92126" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.92130" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.92136" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92126" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92130" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.92137" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.contains.{u, v} {</span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.92126" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.92130" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.92136" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92126" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92130" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.92137" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92124" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if there is a mapping for the given key <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.92051" data-verso-hover="45">a</span></code> or a key that is equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.92051" data-verso-hover="45">a</span></code> according
to the comparator <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.92049" data-verso-hover="4848">cmp</span></code>. There is also a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>-valued version
of this: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.92051" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92050" data-verso-hover="4879">t</span></code> is equivalent to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.92050" data-verso-hover="4879">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___contains"><span class="const token" data-binding="const-Std.DTreeMap.contains" data-verso-hover="4880">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92051" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>.</p>
                    <p>
                      Observe that this is different behavior than for lists: for lists, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∈</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> uses
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> for equality checks, while for tree maps, both use the given comparator <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.92110" data-verso-hover="4848">cmp</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___get">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.get" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.92527" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.92531" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92531" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.92540" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92527" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92531" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.92541" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.92542" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92541" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.92540" data-verso-hover="4879">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.92527" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92541" data-verso-hover="45">a</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.get.{u, v} {</span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.92527" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.92531" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92531" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.92540" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92527" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92531" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.92541" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92525" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.92542" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92541" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.92540" data-verso-hover="4879">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.92527" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92541" data-verso-hover="45">a</span></div></pre><div class="text">
                    <p>
                      Given a proof that a mapping for the given key is present, retrieves the mapping for the given key.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___get___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.get!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.92773" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.92777" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92777" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.92786" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92773" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92777" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.92787" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text">) [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.92773" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92787" data-verso-hover="45">a</span><span class="inter-text">)] : </span><span class="var token" data-binding="var-_uniq.92773" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92787" data-verso-hover="45">a</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.get!.{u, v} {</span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.92773" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.92777" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92777" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.92786" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92773" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92777" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.92787" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.92771" data-verso-hover="54">α</span><span class="inter-text">)
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.92773" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92787" data-verso-hover="45">a</span><span class="inter-text">)] : </span><span class="var token" data-binding="var-_uniq.92773" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92787" data-verso-hover="45">a</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___get___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.get?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.93009" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.93013" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93013" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.93022" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93009" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93013" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.93023" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.93009" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93023" data-verso-hover="45">a</span><span class="inter-text">)</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.get?.{u, v} {</span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.93009" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.93013" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93013" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.93022" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93009" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93013" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.93023" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93007" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.93009" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93023" data-verso-hover="45">a</span><span class="inter-text">)</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___getD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.getD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.93248" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.93252" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93252" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.93261" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93248" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93252" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.93262" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.93263" data-verso-hover="4773">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93248" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93262" data-verso-hover="45">a</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.93248" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93262" data-verso-hover="45">a</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.getD.{u, v} {</span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.93248" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.93252" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93252" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.93261" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93248" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93252" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.93262" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93246" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.93263" data-verso-hover="4773">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.93248" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93262" data-verso-hover="45">a</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.93248" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93262" data-verso-hover="45">a</span></div></pre><div class="text">
                    <p>
                      Tries to retrieve the mapping for the given key, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.93229" data-verso-hover="4773">fallback</span></code> if no such mapping is present.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___getKey">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.getKey" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.94285" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94289" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.94295" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94285" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94289" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.94296" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.94297" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94296" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.94295" data-verso-hover="4879">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.getKey.{u, v} {</span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94285" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94289" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.94295" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94285" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94289" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.94296" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.94297" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94296" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.94295" data-verso-hover="4879">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.94283" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Retrieves the key from the mapping that matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.93488" data-verso-hover="45">a</span></code>. Ensures that such a mapping exists by
requiring a proof of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span></code>. The result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___getKey___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.getKey!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.94510" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94514" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.94521" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94510" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94514" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.94522" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.getKey!.{u, v} {</span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94510" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94514" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.94521" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94510" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94514" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.94522" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.94508" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___getKey___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.getKey?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.94690" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94694" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.94700" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94690" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94694" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.94701" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.getKey?.{u, v} {</span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94690" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94694" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.94700" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94690" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94694" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.94701" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94688" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.
The result in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> case is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___getKeyD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.getKeyD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.94891" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94895" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.94901" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94891" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94895" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.94902" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.94903" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.getKeyD.{u, v} {</span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94891" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.94895" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.94901" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94891" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94895" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.94902" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.94903" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.94889" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if a mapping for the given key exists and returns the key if it does, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.94888" data-verso-hover="45">fallback</span></code>.
If a mapping exists the result is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___keys">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.keys" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.keys.{u, v} {</span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.95085" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95089" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.95095" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95085" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95089" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.keys.{u, v} {</span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95085" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95089" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.95095" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95085" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95089" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95083" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Returns a list of all keys present in the tree map in ascending  order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___keysArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.keysArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.keysArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.95232" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95236" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.95242" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95232" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95236" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.keysArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95232" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95236" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.95242" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95232" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95236" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95230" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Returns an array of all keys present in the tree map in ascending  order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___values">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.values" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.values.{u, v} {</span><span class="var token" data-binding="var-_uniq.95377" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.95381" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95377" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95377" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95382" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.95389" data-verso-hover="4882">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95377" data-verso-hover="54">α</span><span class="inter-text"> (</span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95388" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.95382" data-verso-hover="244">β</span><span class="inter-text">) </span><span class="var token" data-binding="var-_uniq.95381" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95382" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.values.{u, v} {</span><span class="var token" data-binding="var-_uniq.95377" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95381" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95377" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95377" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.95382" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.95389" data-verso-hover="4882">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95377" data-verso-hover="54">α</span><span class="inter-text"> (</span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95388" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.95382" data-verso-hover="244">β</span><span class="inter-text">) </span><span class="var token" data-binding="var-_uniq.95381" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95382" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Returns a list of all values present in the tree map in ascending  order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___valuesArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.valuesArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.valuesArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.95539" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.95543" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95539" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95539" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95544" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.95551" data-verso-hover="4882">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95539" data-verso-hover="54">α</span><span class="inter-text"> (</span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95550" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.95544" data-verso-hover="244">β</span><span class="inter-text">) </span><span class="var token" data-binding="var-_uniq.95543" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95544" data-verso-hover="244">β</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.valuesArray.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.95539" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.95543" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95539" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95539" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95544" data-verso-hover="244">β</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.95551" data-verso-hover="4882">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95539" data-verso-hover="54">α</span><span class="inter-text"> (</span><span class="keyword token" data-binding="">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95550" data-verso-hover="45">x</span><span class="inter-text"> =&gt; </span><span class="var token" data-binding="var-_uniq.95544" data-verso-hover="244">β</span><span class="inter-text">) </span><span class="var token" data-binding="var-_uniq.95543" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95544" data-verso-hover="244">β</span></div></pre><div class="text">
                    <p>
                      Returns an array of all values present in the tree map in ascending  order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Modification">
                  18.17.9.4. Modification</h3>
                <div class="namedocs" id="Std___DTreeMap___alter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.alter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95718" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95718" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.95727" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95718" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.95728" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.95730" data-verso-hover="4775">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95728" data-verso-hover="45">a</span><span class="inter-text">) → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95728" data-verso-hover="45">a</span><span class="inter-text">)) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95718" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.alter.{u, v} {</span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95718" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95718" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.95727" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95718" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.95728" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.95730" data-verso-hover="4775">f</span><span class="inter-text"> : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95728" data-verso-hover="45">a</span><span class="inter-text">) → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95728" data-verso-hover="45">a</span><span class="inter-text">)) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95712" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95714" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95718" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key,
allowing creating new values and deleting values via an <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code> valued replacement function.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___modify">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.modify" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95995" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95995" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.96004" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95995" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.96005" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.96007" data-verso-hover="4776">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96005" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96005" data-verso-hover="45">a</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95995" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.modify.{u, v} {</span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.95995" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95995" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.96004" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95995" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.96005" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.96007" data-verso-hover="4776">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96005" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96005" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95989" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95991" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95995" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Modifies in place the value associated with a given key.</p>
                    <p>
                      This function ensures that the value is used linearly.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___containsThenInsert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.containsThenInsert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.containsThenInsert.{u, v} {</span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.96254" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.96258" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.96264" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96254" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96258" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.96265" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.96266" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96254" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96265" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96254" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96258" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.containsThenInsert.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.96254" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.96258" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.96264" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96254" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96258" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.96265" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.96266" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96254" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96265" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96252" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96254" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96258" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map and unconditionally inserts a value for the key.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___containsThenInsertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.containsThenInsertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.containsThenInsertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.96532" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.96538" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96532" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.96539" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.96540" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96539" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96532" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.containsThenInsertIfNew.{u,
    v}
  {</span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.96532" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.96538" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96532" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.96539" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.96540" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96539" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96532" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map and inserts a value for the key if it was not found.
If the returned <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>, then the returned map is unaltered. If the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>,
then the returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___erase">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.erase" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.96847" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.96851" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.96857" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96847" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96851" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.96858" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96847" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96851" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.erase.{u, v} {</span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.96847" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.96851" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.96857" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96847" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96851" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.96858" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96845" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96847" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96851" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Removes the mapping for the given key if it exists.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___filter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.filter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.97028" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97032" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.97036" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.97034" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.97028" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97034" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.97042" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97028" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97032" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97028" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97032" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.filter.{u, v} {</span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97028" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97032" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.97036" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.97034" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.97028" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97034" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.97042" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97028" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97032" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97026" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97028" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97032" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Removes all mappings of the map for which the given function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___filterMap">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.filterMap" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.filterMap.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.97255" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97257" data-verso-hover="4778">γ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.97261" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.97265" data-verso-hover="4819">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.97263" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.97255" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97263" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.97257" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97263" data-verso-hover="45">a</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.97271" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97255" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97261" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97257" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97261" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.filterMap.{u, v, w}
  {</span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.97255" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97257" data-verso-hover="4778">γ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97261" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.97265" data-verso-hover="4819">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.97263" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.97255" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97263" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.97257" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97263" data-verso-hover="45">a</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.97271" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97255" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97261" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97253" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97257" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97261" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Updates the values of the map by applying the given function to all mappings, keeping
only those mappings where the function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> value.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___insert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.insert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.97519" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97523" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.97529" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97519" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97523" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.97530" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.97531" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97519" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97530" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97519" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97523" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.insert.{u, v} {</span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97519" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97523" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.97529" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97519" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97523" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.97530" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.97531" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97519" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97530" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97517" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97519" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97523" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Inserts the given mapping into the map. If there is already a mapping for the given key, then both
key and value will be replaced.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___insertIfNew">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.insertIfNew" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.insertIfNew.{u, v} {</span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.97729" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97733" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.97739" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97729" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97733" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.97740" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.97741" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97729" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97740" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97729" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97733" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.insertIfNew.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.97729" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.97733" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.97739" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97729" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97733" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.97740" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.97741" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97729" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97740" data-verso-hover="45">a</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97727" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97729" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97733" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      If there is no mapping for the given key, inserts the given mapping into the map. Otherwise,
returns the map unaltered.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___getThenInsertIfNew___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.getThenInsertIfNew?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.getThenInsertIfNew?.{u, v} {</span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.98003" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98003" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.98012" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98003" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.98013" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.98014" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98013" data-verso-hover="45">a</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98013" data-verso-hover="45">a</span><span class="inter-text">)</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98003" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.getThenInsertIfNew?.{u, v}
  {</span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.98003" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><span class="const token" data-binding="const-Std.LawfulEqCmp" data-verso-hover="4881">Std.LawfulEqCmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98003" data-verso-hover="4848">cmp</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.98012" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98003" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.98013" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.98014" data-verso-hover="4773">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98013" data-verso-hover="45">a</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> (</span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98013" data-verso-hover="45">a</span><span class="inter-text">)</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97997" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97999" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98003" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Checks whether a key is present in a map, returning the associated value, and inserts a value for
the key if it was not found.</p>
                    <p>
                      If the returned value is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97952" data-verso-hover="4883">v</span></code>, then the returned map is unaltered. If it is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>, then the
returned map has a new value inserted.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">get?</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertIfNew</span></code>.</p>
                    <p>
                      Uses the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to cast the retrieved value to the correct type.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___insertMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.insertMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.insertMany.{u, v, u_1} {</span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.98432" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.98436" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.98437" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98437" data-verso-hover="43">ρ</span><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.98439" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.98432" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98439" data-verso-hover="45">a</span><span class="inter-text">)]
  (</span><span class="var token" data-binding="var-_uniq.98446" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98432" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98436" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.98447" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98437" data-verso-hover="43">ρ</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98432" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98436" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.insertMany.{u, v, u_1}
  {</span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.98432" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.98436" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.98437" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98437" data-verso-hover="43">ρ</span><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.98439" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.98432" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98439" data-verso-hover="45">a</span><span class="inter-text">)]
  (</span><span class="var token" data-binding="var-_uniq.98446" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98432" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98436" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.98447" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98437" data-verso-hover="43">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98430" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98432" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98436" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Inserts multiple mappings into the tree map by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>. If the same key appears multiple times, the last occurrence takes precedence.</p>
                    <p>
                      Note: this precedence behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertMany</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet.Raw</span></code> behaves differently: it will prefer the first
appearance.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___partition">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.partition" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.partition.{u, v} {</span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.98806" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.98810" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.98808" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98808" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.98816" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98806" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98806" data-verso-hover="4848">cmp</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98806" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.partition.{u, v} {</span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.98806" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.98810" data-verso-hover="4777">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.98808" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98808" data-verso-hover="45">a</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.98816" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98806" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98806" data-verso-hover="4848">cmp</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> ×
    </span></a><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98800" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98802" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.98806" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Partitions a tree map into two tree maps based on a predicate.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Iteration">
                  18.17.9.5. Iteration</h3>
                <div class="namedocs" id="Std___DTreeMap___map">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.map" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99043" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99045" data-verso-hover="4778">γ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99049" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.99053" data-verso-hover="4821">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.99051" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.99043" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99051" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99045" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99051" data-verso-hover="45">a</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.99059" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99043" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99049" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99045" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99049" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.map.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99043" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99045" data-verso-hover="4778">γ</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99049" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.99053" data-verso-hover="4821">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.99051" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.99043" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99051" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99045" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99051" data-verso-hover="45">a</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.99059" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99043" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99049" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99041" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99045" data-verso-hover="4778">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99049" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Updates the values of the map by applying the given function to all mappings.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___foldl">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.foldl" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.foldl.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99283" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99287" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.99294" data-verso-hover="4782">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span><span class="inter-text"> → (</span><span class="var token" data-binding="var-_uniq.99292" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.99283" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99292" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.99295" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.99301" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99283" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99287" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.foldl.{u, v, w} {</span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99283" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99287" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.99294" data-verso-hover="4782">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span><span class="inter-text"> → (</span><span class="var token" data-binding="var-_uniq.99292" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.99283" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99292" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.99295" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.99301" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99281" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99283" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99287" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.99288" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Folds the given function over the mappings in the map in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___foldlM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.foldlM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.foldlM.{u, v, w, w₂} {</span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99515" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99519" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99522" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99522" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.99529" data-verso-hover="4784">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span><span class="inter-text"> → (</span><span class="var token" data-binding="var-_uniq.99527" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.99515" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99527" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99522" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.99530" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.99536" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99515" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99519" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.99522" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.foldlM.{u, v, w, w₂}
  {</span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99515" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99519" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99522" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99522" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.99529" data-verso-hover="4784">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span><span class="inter-text"> → (</span><span class="var token" data-binding="var-_uniq.99527" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.99515" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99527" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99522" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.99530" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.99536" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99513" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99515" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99519" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.99522" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99520" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Folds the given monadic function over the mappings in the map in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___forIn">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.forIn" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.forIn.{u, v, w, w₂} {</span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99789" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99793" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99796" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99796" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.99803" data-verso-hover="4785">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.99799" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.99789" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99799" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99796" data-verso-hover="4866">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.99804" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.99810" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99789" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99793" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.99796" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.forIn.{u, v, w, w₂}
  {</span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99789" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99793" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.99796" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99796" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.99803" data-verso-hover="4785">f</span><span class="inter-text"> :
    (</span><span class="var token" data-binding="var-_uniq.99799" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.99789" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99799" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.99796" data-verso-hover="4866">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.99804" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.99810" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99787" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99789" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99793" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.99796" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99794" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Support for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span></code> loop construct in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> blocks. Iteration happens in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___forM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.forM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.forM.{u, v, w, w₂} {</span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.100103" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100107" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.100109" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100109" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.100114" data-verso-hover="4786">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.100112" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.100103" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100112" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100109" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.100120" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100103" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100107" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.100109" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.forM.{u, v, w, w₂}
  {</span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.100103" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100107" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100109" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100109" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.100114" data-verso-hover="4786">f</span><span class="inter-text"> : (</span><span class="var token" data-binding="var-_uniq.100112" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text">) → </span><span class="var token" data-binding="var-_uniq.100103" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100112" data-verso-hover="45">a</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100109" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.100120" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100101" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100103" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100107" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.100109" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div></pre><div class="text">
                    <p>
                      Carries out a monadic action on each mapping in the tree map in ascending order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Conversion">
                  18.17.9.6. Conversion</h3>
                <div class="namedocs" id="Std___DTreeMap___ofList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.ofList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.100332" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.100334" data-verso-hover="4787">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.100333" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.100332" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100333" data-verso-hover="45">a</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.100338" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100332" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100338" data-verso-hover="4845">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.ofList.{u, v} {</span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100332" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.100334" data-verso-hover="4787">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.100333" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.100332" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100333" data-verso-hover="45">a</span><span class="inter-text">))
  (</span><span class="var token" data-binding="var-_uniq.100338" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100330" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100332" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100338" data-verso-hover="4845">cmp</span></div></pre><div class="text">
                    <p>
                      Transforms a list of mappings into a tree map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___toArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.toArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.toArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.100503" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100507" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.100513" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100503" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100507" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.100514" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.100503" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100514" data-verso-hover="45">a</span><span class="inter-text">)</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.toArray.{u, v} {</span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100503" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100507" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.100513" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100503" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100507" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.100514" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100501" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.100503" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100514" data-verso-hover="45">a</span><span class="inter-text">)</span></div></pre><div class="text">
                    <p>
                      Transforms the tree map into a list of mappings in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___toList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.toList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.toList.{u, v} {</span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.100672" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100676" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.100682" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100672" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100676" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.100683" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.100672" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100683" data-verso-hover="45">a</span><span class="inter-text">)</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.toList.{u, v} {</span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100672" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.100676" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.100682" data-verso-hover="4879">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap"><span class="const token" data-binding="const-Std.DTreeMap" data-verso-hover="4658">Std.DTreeMap</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100672" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100676" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> ((</span><span class="var token" data-binding="var-_uniq.100683" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.100670" data-verso-hover="54">α</span><span class="inter-text">) × </span><span class="var token" data-binding="var-_uniq.100672" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100683" data-verso-hover="45">a</span><span class="inter-text">)</span></div></pre><div class="text">
                    <p>
                      Transforms the tree map into a list of mappings in ascending order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Unbundled-Variants">
                  18.17.9.7. Unbundled Variants</h3>
                <p>
                  Unbundled maps separate well-formedness proofs from data.
This is primarily useful when defining <a href="Basic-Types/Maps-and-Sets/#raw-data">nested inductive types</a>.
To use these variants, import the module <code>Std.DTreeMap.Raw</code>.</p>
                <div class="namedocs" id="Std___DTreeMap___Raw___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.Raw.inner" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.Raw.{u, v} (</span><span class="var token" data-binding="var-_uniq.101510" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.101512" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.101510" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.101516" data-verso-hover="4845">_cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.101510" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.101510" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.Raw.{u, v} (</span><span class="var token" data-binding="var-_uniq.101510" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.101512" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.101510" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.101516" data-verso-hover="4845">_cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.101510" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.101510" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type (max u v)</span></div></pre><div class="text">
                    <p>
                      Dependent tree maps without a bundled well-formedness invariant, suitable for use in nested
inductive types. The well-formedness invariant is called <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Raw.WF</span></code>. When in doubt, prefer <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap</span></code>
over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap.Raw</span></code>. Lemmas about the operations on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw" data-verso-hover="4873">Std.DTreeMap.Raw</span></a></code> are available in the
module <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.DTreeMap.Raw.Lemmas</span></code>.</p>
                    <p>
                      A tree map stores an assignment of keys to values. It depends on a comparator function that
defines an ordering on the keys and provides efficient order-dependent queries, such as retrieval
of the minimum or maximum.</p>
                    <p>
                      To ensure that the operations behave as expected, the comparator function <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">cmp</span></code> should satisfy
certain laws that ensure a consistent ordering:</p>
                    <ul>
                      <li>
                        <p>
                          If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is greater than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
and vice versa (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">OrientedCmp</span></code> typeclass).</p>
                        </li>
                      <li>
                        <p>
                          If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is, in turn, less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code> (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TransCmp</span></code> typeclass).</p>
                        </li>
                      </ul>
                    <p>
                      Keys for which <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">cmp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.eq" data-verso-hover="1774">Ordering.eq</span></a></code> are considered the same, i.e., there can be only one entry
with key either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.101225" data-verso-hover="4884">a</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.101359" data-verso-hover="4885">b</span></code> in a tree map. Looking up either <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.101225" data-verso-hover="4884">a</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.101359" data-verso-hover="4885">b</span></code> always yields the same entry,
if any is present. The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-MonadState.get" data-verso-hover="818">get</span></code> operations of the <em>dependent</em> tree map additionally require a
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">LawfulEqCmp</span></code> instance to ensure that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">cmp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">.eq</span></code> always implies <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.101225" data-verso-hover="4886">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.101359" data-verso-hover="4886">b</span></code>, so that their
respective value types are equal.</p>
                    <p>
                      To avoid expensive copies, users should make sure that the tree map is used linearly.</p>
                    <p>
                      Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary
search tree with efficient order statistic lookups.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw.mk" data-verso-hover="4887">Std.DTreeMap.Raw.mk</span></a><span class="inter-text">.{u, v}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.DTreeMap.Raw.inner" data-verso-hover="4888">inner</span> : <span class="const token" data-binding="const-Std.DTreeMap.Internal.Impl" data-verso-hover="4889">Std.DTreeMap.Internal.Impl</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.101485" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.101486" data-verso-hover="4203">β</span></pre><div class="docs">
                        <p>
                          Internal implementation detail of the tree map.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="Std___DTreeMap___Raw___WF___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.DTreeMap.Raw.WF.out" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.DTreeMap.Raw.WF.{u, v} {</span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.102424" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.102428" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.102434" data-verso-hover="4890">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw" data-verso-hover="4873">Std.DTreeMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.102424" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.102428" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only"><span class="inter-text">Std.DTreeMap.Raw.WF.{u, v} {</span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.102424" data-verso-hover="4203">β</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type v</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.102428" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.102434" data-verso-hover="4890">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw" data-verso-hover="4873">Std.DTreeMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.102422" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.102424" data-verso-hover="4203">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.102428" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                    <p>
                      Well-formedness predicate for tree maps. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap</span></code> will not need to interact with
this. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap.Raw</span></code> will need to provide proofs of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF</span></code> to lemmas and should use lemmas
like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.empty</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.insert</span></code> (which are always named exactly like the operations they are about)
to show that map operations preserve well-formedness. The constructors of this type are internal
implementation details and should not be accessed by users.</p>
                    <h1>
                      Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw.WF.mk" data-verso-hover="4891">Std.DTreeMap.Raw.WF.mk</span></a><span class="inter-text">.{u, v}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Fields</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.DTreeMap.Raw.WF.out" data-verso-hover="4876">out</span> : <span class="var token" data-binding="var-_uniq.102394" data-verso-hover="4890">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___DTreeMap___Raw___mk"><span class="const token" data-binding="const-Std.DTreeMap.Raw.inner" data-verso-hover="4892">inner</span></a><span class="inter-text">.</span><span class="const token" data-binding="const-Std.DTreeMap.Internal.Impl.WF" data-verso-hover="4893">WF</span></pre><div class="docs">
                        <p>
                          Internal implementation detail of the tree map.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="TreeSet">
                18.17.10. Tree-Based Sets<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=TreeSet" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="Std___TreeSet">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.{u} (</span><span class="var token" data-binding="var-_uniq.203" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.207" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.203" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.203" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.{u} (</span><span class="var token" data-binding="var-_uniq.203" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.207" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.203" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.203" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div></pre><div class="text">
                  <p>
                    Tree sets.</p>
                  <p>
                    A tree set stores elements of a certain type in a certain order. It depends on a comparator function
that defines an ordering on the keys and provides efficient order-dependent queries, such as
retrieval of the minimum or maximum.</p>
                  <p>
                    To ensure that the operations behave as expected, the comparator function <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4845">cmp</span></code> should satisfy
certain laws that ensure a consistent ordering:</p>
                  <ul>
                    <li>
                      <p>
                        If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is greater than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
and vice versa (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">OrientedCmp</span></code> typeclass).</p>
                      </li>
                    <li>
                      <p>
                        If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is, in turn, less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code> (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TransCmp</span></code> typeclass).</p>
                      </li>
                    </ul>
                  <p>
                    Keys for which <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.128" data-verso-hover="4845">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.143" data-verso-hover="45">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.eq" data-verso-hover="1774">Ordering.eq</span></a></code> are considered the same, i.e., there can be only one of them
be contained in a single tree set at the same time.</p>
                  <p>
                    To avoid expensive copies, users should make sure that the tree set is used linearly.</p>
                  <p>
                    Internally, the tree sets are represented as size-bounded trees, a type of self-balancing binary
search tree with efficient order statistic lookups.</p>
                  <p>
                    These tree sets contain a bundled well-formedness invariant, which means that they cannot
be used in nested inductive types. For these use cases, <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___mk"><span class="const token" data-binding="const-Std.TreeSet.Raw" data-verso-hover="4894">Std.TreeSet.Raw</span></a></code> and
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___WF___mk"><span class="const token" data-binding="const-Std.TreeSet.Raw.WF" data-verso-hover="4895">Std.TreeSet.Raw.WF</span></a></code> unbundle the invariant from the tree set. When in doubt, prefer
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet</span></code> over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet.Raw</span></code>.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Creation">
                  18.17.10.1. Creation</h3>
                <div class="namedocs" id="Std___TreeSet___empty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.empty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.empty.{u} {</span><span class="var token" data-binding="var-_uniq.2308" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.2312" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2308" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2308" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2308" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2312" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.empty.{u} {</span><span class="var token" data-binding="var-_uniq.2308" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.2312" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2308" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2308" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2308" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2312" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Creates a new empty tree set. It is also possible and recommended to
use the empty collection notations <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span></code> to create an empty tree set. <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-0" data-verso-hover="35">simp</span></a></code> replaces
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">empty</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∅</span></code>.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Properties">
                  18.17.10.2. Properties</h3>
                <div class="namedocs" id="Std___TreeSet___isEmpty">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.isEmpty" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.isEmpty.{u} {</span><span class="var token" data-binding="var-_uniq.2486" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.2490" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2486" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2486" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.2495" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2486" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2490" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.isEmpty.{u} {</span><span class="var token" data-binding="var-_uniq.2486" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.2490" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2486" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2486" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.2495" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2486" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2490" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if the tree set contains no mappings.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___size">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.size" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.size.{u} {</span><span class="var token" data-binding="var-_uniq.2613" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.2617" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2613" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2613" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2613" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2617" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.size.{u} {</span><span class="var token" data-binding="var-_uniq.2613" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.2617" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.2613" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.2613" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.2622" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2613" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2617" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></div></pre><div class="text">
                    <p>
                      Returns the number of mappings present in the map.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries">
                  18.17.10.3. Queries</h3>
                <div class="namedocs" id="Std___TreeSet___contains">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.contains" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.contains.{u} {</span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.3438" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.3443" data-verso-hover="4859">l</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3438" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.3444" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.contains.{u} {</span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.3438" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.3443" data-verso-hover="4859">l</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3438" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.3444" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.3434" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2725" data-verso-hover="45">a</span></code>, or an element equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2725" data-verso-hover="45">a</span></code> according to the comparator <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2723" data-verso-hover="4848">cmp</span></code>, is contained
in the set. There is also a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>-valued version of this: <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">t</span></code> is equivalent to
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">t.contains</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>.</p>
                    <p>
                      Observe that this is different behavior than for lists: for lists, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">∈</span></code> uses <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">=</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> uses
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">==</span></code> for equality checks, while for tree sets, both use the given comparator <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3420" data-verso-hover="4848">cmp</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___get">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.get" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.get.{u} {</span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4446" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4451" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4446" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4452" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4453" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4452" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.4451" data-verso-hover="4859">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.get.{u} {</span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4446" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4451" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4446" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4452" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.4453" data-verso-hover="4850">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4452" data-verso-hover="45">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1015"> ∈ </span><span class="var token" data-binding="var-_uniq.4451" data-verso-hover="4859">t</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Retrieves the key from the set that matches <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3767" data-verso-hover="45">a</span></code>. Ensures that such a key exists by requiring a proof
of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span></code>. The result is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___get___">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.get!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.get!.{u} {</span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4642" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.4648" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4642" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4649" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.get!.{u} {</span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4642" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.4648" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4642" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4649" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.4638" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if given key is contained and returns the key if it is, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___get___-next">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.get?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.get?.{u} {</span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4793" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4798" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4793" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4799" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.get?.{u} {</span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4793" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4798" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4793" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4799" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4789" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if given key is contained and returns the key if it is, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code>.
The result in the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a></code> case is guaranteed to be pointer equal to the key in the map.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___getD">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getD.{u} {</span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.4965" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4970" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4965" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.4971" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.4972" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getD.{u} {</span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.4965" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.4970" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4965" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.4971" data-verso-hover="45">a </span><span class="var token" data-binding="var-_uniq.4972" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.4961" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Checks if given key is contained and returns the key if it is, otherwise <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4960" data-verso-hover="45">fallback</span></code>.
If they key is contained the result is guaranteed to be pointer equal to the key in the set.</p>
                    </div>
                  </div>
                <section>
                  <h4 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries--Ordering-Based-Queries">
                    18.17.10.3.1. Ordering-Based Queries</h4>
                  <div class="namedocs" id="Std___TreeSet___atIdx">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.atIdx" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.atIdx.{u} {</span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5132" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.5137" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5132" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5138" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5142" data-verso-hover="4851">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5138" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.5137" data-verso-hover="4859">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___size"><span class="const token" data-binding="const-Std.TreeSet.size" data-verso-hover="4896">size</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.atIdx.{u} {</span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5132" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.5137" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5132" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5138" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.5142" data-verso-hover="4851">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5138" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="629"> &lt; </span></a><span class="var token" data-binding="var-_uniq.5137" data-verso-hover="4859">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___size"><span class="const token" data-binding="const-Std.TreeSet.size" data-verso-hover="4896">size</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5128" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Returns the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5126" data-verso-hover="7">n</span></code>-th smallest element.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___atIdx___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.atIdx!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.atIdx!.{u} {</span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5328" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.5334" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5328" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5335" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.atIdx!.{u} {</span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5328" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.5334" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5328" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5335" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5324" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Returns the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5309" data-verso-hover="7">n</span></code>-th smallest element, or panics if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5309" data-verso-hover="7">n</span></code> is at least <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5308" data-verso-hover="4859">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___size"><span class="const token" data-binding="const-Std.TreeSet.size" data-verso-hover="4896">size</span></a></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___atIdx___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.atIdx?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.atIdx?.{u} {</span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5539" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.5544" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5539" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5545" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.atIdx?.{u} {</span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5539" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.5544" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5539" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5545" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5535" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Returns the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5519" data-verso-hover="7">n</span></code>-th smallest element, or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5519" data-verso-hover="7">n</span></code> is at least <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5518" data-verso-hover="4859">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___size"><span class="const token" data-binding="const-Std.TreeSet.size" data-verso-hover="4896">size</span></a></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___atIdxD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.atIdxD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.atIdxD.{u} {</span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5758" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.5763" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5758" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5764" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5765" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.atIdxD.{u} {</span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5758" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.5763" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5758" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5764" data-verso-hover="7">n</span><span class="inter-text"> : </span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.5765" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5754" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Returns the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5738" data-verso-hover="7">n</span></code>-th smallest element, or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5739" data-verso-hover="45">fallback</span></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5738" data-verso-hover="7">n</span></code> is at least <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5737" data-verso-hover="4859">t</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___size"><span class="const token" data-binding="const-Std.TreeSet.size" data-verso-hover="4896">size</span></a></code>.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getGE___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getGE!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getGE!.{u} {</span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.5979" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.5985" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5979" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5986" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getGE!.{u} {</span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.5979" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.5985" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5979" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.5986" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.5975" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element that is greater than or equal to the
given element, panicking if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getGE___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getGE?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getGE?.{u} {</span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6128" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6133" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6128" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6134" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getGE?.{u} {</span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6128" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6133" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6128" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6134" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6124" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element that is greater than or equal to the
given element, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getGED">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getGED" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getGED.{u} {</span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6285" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6290" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6285" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6291" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.6292" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getGED.{u} {</span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6285" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6290" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6285" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.6291" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.6292" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6281" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element that is greater than or equal to the
given element, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.6280" data-verso-hover="45">fallback</span></code> if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getGT___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getGT!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getGT!.{u} {</span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6452" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.6458" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6452" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6459" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getGT!.{u} {</span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6452" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.6458" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6452" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6459" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6448" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element that is greater than the given element,
panicking if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getGT___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getGT?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getGT?.{u} {</span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6601" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6606" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6601" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6607" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getGT?.{u} {</span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6601" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6606" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6601" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6607" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6597" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element that is greater than the given element,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getGTD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getGTD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getGTD.{u} {</span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6758" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6763" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6758" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6764" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.6765" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getGTD.{u} {</span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6758" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.6763" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6758" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.6764" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.6765" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6754" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element that is greater than the given element,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.6753" data-verso-hover="45">fallback</span></code> if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getLE___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getLE!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getLE!.{u} {</span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.6925" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.6931" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6925" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6932" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getLE!.{u} {</span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.6925" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.6931" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6925" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.6932" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.6921" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest element that is less than or equal to the
given element, panicking if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getLE___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getLE?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getLE?.{u} {</span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7079" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7080" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getLE?.{u} {</span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7079" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7074" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7080" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7070" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest element that is less than or equal to the
given element, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getLED">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getLED" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getLED.{u} {</span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7231" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7236" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7231" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7237" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getLED.{u} {</span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7231" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7236" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7231" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.7237" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.7238" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7227" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest element that is less than or equal to the
given element, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7226" data-verso-hover="45">fallback</span></code> if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getLT___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getLT!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getLT!.{u} {</span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7398" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.7404" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7398" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7405" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getLT!.{u} {</span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7398" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.7404" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7398" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7405" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7394" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element that is less than the given element,
panicking if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getLT___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getLT?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getLT?.{u} {</span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7547" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7552" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7547" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7553" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getLT?.{u} {</span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7547" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7552" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7547" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7553" data-verso-hover="45">k</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7543" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element that is less than the given element,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___getLTD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.getLTD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.getLTD.{u} {</span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7704" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7709" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7704" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7710" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.7711" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.getLTD.{u} {</span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7704" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7709" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7704" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.7710" data-verso-hover="45">k </span><span class="var token" data-binding="var-_uniq.7711" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7700" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element that is less than the given element,
returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.7699" data-verso-hover="45">fallback</span></code> if no such element exists.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___min">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.min" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.min.{u} {</span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7875" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.7879" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7875" data-verso-hover="4859">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___isEmpty"><span class="const token" data-binding="const-Std.TreeSet.isEmpty" data-verso-hover="4897">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.min.{u} {</span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.7875" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7870" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.7879" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.7875" data-verso-hover="4859">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___isEmpty"><span class="const token" data-binding="const-Std.TreeSet.isEmpty" data-verso-hover="4897">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.7866" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that the tree set is not empty, retrieves the smallest element.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___min___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.min!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.min!.{u} {</span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8016" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.8022" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8016" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.min!.{u} {</span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8016" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.8022" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8016" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8012" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element of the tree set, panicking if the set is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___min___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.min?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.min?.{u} {</span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8142" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8147" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8142" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.min?.{u} {</span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8142" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8147" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8142" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8138" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element of the tree set, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if the set is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___minD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.minD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.minD.{u} {</span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8276" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8281" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8276" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8282" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.minD.{u} {</span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8276" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8281" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8276" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8282" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.8272" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the smallest element of the tree set, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8271" data-verso-hover="45">fallback</span></code> if the tree set is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___max">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.max" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.max.{u} {</span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8426" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8431" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8426" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8435" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8431" data-verso-hover="4859">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___isEmpty"><span class="const token" data-binding="const-Std.TreeSet.isEmpty" data-verso-hover="4897">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.max.{u} {</span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8426" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8431" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8426" data-verso-hover="4848">cmp</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.8435" data-verso-hover="4860">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8431" data-verso-hover="4859">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___isEmpty"><span class="const token" data-binding="const-Std.TreeSet.isEmpty" data-verso-hover="4897">isEmpty</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8422" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Given a proof that the tree set is not empty, retrieves the largest element.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___max___">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.max!" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.max!.{u} {</span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8572" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.8578" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8572" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.max!.{u} {</span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8572" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} [</span><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="173">Inhabited</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.8578" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8572" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8568" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest element of the tree set, panicking if the set is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___max___-next">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.max?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.max?.{u} {</span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8698" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8703" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8698" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.max?.{u} {</span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8698" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8703" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8698" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8694" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest element of the tree set, returning <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a></code> if the set is empty.</p>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___maxD">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.maxD" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.maxD.{u} {</span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.8832" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8837" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8832" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8838" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.maxD.{u} {</span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.8832" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.8837" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8832" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.8838" data-verso-hover="45">fallback</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><span class="var token" data-binding="var-_uniq.8828" data-verso-hover="54">α</span></div></pre><div class="text">
                      <p>
                        Tries to retrieve the largest element of the tree set, returning <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8827" data-verso-hover="45">fallback</span></code> if the tree set is empty.</p>
                      </div>
                    </div>
                  </section>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Modification">
                  18.17.10.4. Modification</h3>
                <div class="namedocs" id="Std___TreeSet___insert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.insert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.insert.{u} {</span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9050" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.9055" data-verso-hover="4859">l</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9050" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9056" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9050" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.insert.{u} {</span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9050" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.9055" data-verso-hover="4859">l</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9050" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9056" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9046" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9050" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Inserts the given element into the set. If the tree set already contains an element that is
equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.8975" data-verso-hover="4848">cmp</span></code>) to the given element, then the tree set is returned unchanged.</p>
                    <p>
                      Note: this non-replacement behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet.Raw</span></code>.
The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code> function on <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap.Raw</span></code> behaves
differently: it will overwrite an existing mapping.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___insertMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.insertMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.insertMany.{u, u_1} {</span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9416" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9417" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9417" data-verso-hover="43">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.9424" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9416" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9425" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9417" data-verso-hover="43">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9416" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.insertMany.{u, u_1}
  {</span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9416" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9417" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9417" data-verso-hover="43">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.9424" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9416" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9425" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9417" data-verso-hover="43">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9416" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Inserts multiple elements into the tree set by iterating over the given collection and calling
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>. If the same element (with respect to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9328" data-verso-hover="4848">cmp</span></code>) appears multiple times, the first occurrence
takes precedence.</p>
                    <p>
                      Note: this precedence behavior is true for <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet.Raw</span></code>. The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">insertMany</span></code> function on
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeMap.Raw</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">DTreeMap.Raw</span></code> behaves differently: it will prefer the last
appearance.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___containsThenInsert">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.containsThenInsert" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.containsThenInsert.{u} {</span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9773" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.9778" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9773" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9779" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9773" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.containsThenInsert.{u}
  {</span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9773" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.9778" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9773" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.9779" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9769" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9773" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Checks whether an element is present in a set and inserts the element if it was not found.
If the tree set already contains an element that is equal (with regard to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.9743" data-verso-hover="4848">cmp</span></code> to the given
element, then the tree set is returned unchanged.</p>
                    <p>
                      Equivalent to (but potentially faster than) calling <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">contains</span></code> followed by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Insert.insert" data-verso-hover="4748">insert</span></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___erase">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.erase" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.erase.{u} {</span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.9995" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10000" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9995" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10001" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9995" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.erase.{u} {</span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.9995" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10000" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9995" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10001" data-verso-hover="45">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9991" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9995" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Removes the given key if it exists.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___eraseMany">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.eraseMany" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.eraseMany.{u, u_1} {</span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10142" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10143" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10143" data-verso-hover="43">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.10150" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10142" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10151" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10143" data-verso-hover="43">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10142" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.eraseMany.{u, u_1}
  {</span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10142" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10143" data-verso-hover="43">ρ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2786">ForIn</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id"><span class="const token" data-binding="const-Id" data-verso-hover="2668">Id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10143" data-verso-hover="43">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.10150" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10142" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10151" data-verso-hover="2810">l</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10143" data-verso-hover="43">ρ</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10138" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10142" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Erases multiple items from the tree set by iterating over the given collection and calling erase.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___filter">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.filter" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.filter.{u} {</span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10323" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10325" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10330" data-verso-hover="4859">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10323" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10323" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.filter.{u} {</span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10323" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.10325" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.10330" data-verso-hover="4859">m</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10323" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10319" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10323" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Removes all elements from the tree set for which the given function returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___merge">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.merge" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.merge.{u} {</span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10496" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10497" data-verso-hover="4859">t₁ </span><span class="var token" data-binding="var-_uniq.10502" data-verso-hover="4859">t₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10496" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10496" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.merge.{u} {</span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10496" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10497" data-verso-hover="4859">t₁ </span><span class="var token" data-binding="var-_uniq.10502" data-verso-hover="4859">t₂</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10496" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10492" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10496" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Returns a set that contains all mappings of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10482" data-verso-hover="4859">t₁</span></code> and `t₂.</p>
                    <p>
                      This function ensures that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10486" data-verso-hover="4859">t₁</span></code> is used linearly.
Hence, as long as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10486" data-verso-hover="4859">t₁</span></code> is unshared, the performance characteristics follow the following imperative
description: Iterate over all mappings in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10487" data-verso-hover="4859">t₂</span></code>, inserting them into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10486" data-verso-hover="4859">t₁</span></code>.</p>
                    <p>
                      Hence, the runtime of this method scales logarithmically in the size of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10490" data-verso-hover="4859">t₁</span></code> and linearly in the
size of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10491" data-verso-hover="4859">t₂</span></code> as long as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.10490" data-verso-hover="4859">t₁</span></code> is unshared.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___partition">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.partition" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.partition.{u} {</span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10816" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10818" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10823" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10816" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10816" data-verso-hover="4848">cmp</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10816" data-verso-hover="4848">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.partition.{u} {</span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10816" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.10818" data-verso-hover="241">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.10823" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10816" data-verso-hover="4848">cmp</span><span class="inter-text">) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10816" data-verso-hover="4848">cmp</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="189"> × </span></a><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10812" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10816" data-verso-hover="4848">cmp</span></div></pre><div class="text">
                    <p>
                      Partitions a tree set into two tree sets based on a predicate.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Iteration">
                  18.17.10.5. Iteration</h3>
                <div class="namedocs" id="Std___TreeSet___all">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.all" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.all.{u} {</span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.10990" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10995" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10990" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10997" data-verso-hover="241">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.all.{u} {</span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.10990" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.10995" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10990" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.10997" data-verso-hover="241">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.10986" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Check if any element satisfies the predicate, short-circuiting if a predicate succeeds.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___any">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.any" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.any.{u} {</span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11124" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.11129" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11124" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11131" data-verso-hover="241">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) : </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.any.{u} {</span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11124" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.11129" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11124" data-verso-hover="4848">cmp</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11131" data-verso-hover="241">p</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11120" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a><span class="inter-text">) :
  </span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="155">Bool</span></a></div></pre><div class="text">
                    <p>
                      Check if all elements satisfy the predicate, short-circuiting if a predicate fails.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___foldl">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.foldl" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.foldl.{u, w} {</span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11260" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.11265" data-verso-hover="4898">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11266" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11271" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11260" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.foldl.{u, w} {</span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11260" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.11265" data-verso-hover="4898">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11266" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11271" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11260" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Folds the given function over the elements of the tree set in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___foldlM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.foldlM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.foldlM.{u, u_1, u_2} {</span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11440" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11442" data-verso-hover="2818">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_2</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11442" data-verso-hover="2818">m</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.11448" data-verso-hover="4899">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11442" data-verso-hover="2818">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11449" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11454" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11440" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11442" data-verso-hover="2818">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.foldlM.{u, u_1, u_2}
  {</span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11440" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11442" data-verso-hover="2818">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_2</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11442" data-verso-hover="2818">m</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.11448" data-verso-hover="4899">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11442" data-verso-hover="2818">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11449" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11454" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11440" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11442" data-verso-hover="2818">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11443" data-verso-hover="43">δ</span></div></pre><div class="text">
                    <p>
                      Monadically computes a value by folding the given function over the elements in the tree set in
ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___foldr">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.foldr" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.foldr.{u, w} {</span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11666" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.11671" data-verso-hover="4900">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11672" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11677" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11666" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.foldr.{u, w} {</span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11666" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.11671" data-verso-hover="4900">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11672" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11677" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11662" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11666" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11667" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Folds the given function over the elements of the tree set in descending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___foldrM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.foldrM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.foldrM.{u, u_1, u_2} {</span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11846" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="2818">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_2</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="2818">m</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.11854" data-verso-hover="4901">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="2818">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11855" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11860" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11846" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="2818">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.foldrM.{u, u_1, u_2}
  {</span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11846" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="2818">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_2</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u_1</span><span class="inter-text">}
  [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="2818">m</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.11854" data-verso-hover="4901">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="2818">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.11855" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.11860" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11842" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11846" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.11848" data-verso-hover="2818">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11849" data-verso-hover="43">δ</span></div></pre><div class="text">
                    <p>
                      Monadically computes a value by folding the given function over the elements in the tree set in
descending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___forIn">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.forIn" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.forIn.{u, w, w₂} {</span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12074" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12077" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12077" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.12082" data-verso-hover="4902">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12077" data-verso-hover="4866">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.12083" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span><span class="inter-text">) (</span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12074" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12077" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.forIn.{u, w, w₂} {</span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12074" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12077" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12077" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.12082" data-verso-hover="4902">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12077" data-verso-hover="4866">m</span><span class="inter-text"> (</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2806">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span><span class="inter-text">)) (</span><span class="var token" data-binding="var-_uniq.12083" data-verso-hover="4783">init</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12088" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12070" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12074" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12077" data-verso-hover="4866">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12075" data-verso-hover="4179">δ</span></div></pre><div class="text">
                    <p>
                      Support for the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span></code> loop construct in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> blocks. The iteration happens in ascending
order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___forM">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.forM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.forM.{u, w, w₂} {</span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12342" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12344" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12344" data-verso-hover="4866">m</span><span class="inter-text">] (</span><span class="var token" data-binding="var-_uniq.12347" data-verso-hover="4392">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12344" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12352" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12342" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12344" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.forM.{u, w, w₂} {</span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12342" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12344" data-verso-hover="4866">m</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type w</span><span class="inter-text"> → </span><span class="sort token" data-binding="" data-verso-hover="49">Type w₂</span><span class="inter-text">} [</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="239">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12344" data-verso-hover="4866">m</span><span class="inter-text">]
  (</span><span class="var token" data-binding="var-_uniq.12347" data-verso-hover="4392">f</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12344" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12352" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12338" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12342" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="var token" data-binding="var-_uniq.12344" data-verso-hover="4866">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="145">PUnit</span></a></div></pre><div class="text">
                    <p>
                      Carries out a monadic action on each element in the tree set in ascending order.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion">
                  18.17.10.6. Conversion</h3>
                <div class="namedocs" id="Std___TreeSet___toList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.toList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.toList.{u} {</span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12517" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.12522" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12517" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.toList.{u} {</span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12517" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.12522" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12517" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12513" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Transforms the tree set into a list of elements in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___ofList">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.ofList" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.ofList.{u} {</span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.12634" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12638" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12638" data-verso-hover="4845">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.ofList.{u} {</span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.12634" data-verso-hover="50">l</span><span class="inter-text"> : </span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12638" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12633" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12638" data-verso-hover="4845">cmp</span></div></pre><div class="text">
                    <p>
                      Transforms a list into a tree set.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___toArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.toArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.toArray.{u} {</span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.12757" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.12762" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12757" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.toArray.{u} {</span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.12757" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.12762" data-verso-hover="4859">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12757" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12753" data-verso-hover="54">α</span></div></pre><div class="text">
                    <p>
                      Transforms the tree set into an array of elements in ascending order.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Std___TreeSet___ofArray">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.ofArray" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.ofArray.{u} {</span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} (</span><span class="var token" data-binding="var-_uniq.12874" data-verso-hover="303">a</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12878" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12878" data-verso-hover="4845">cmp</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.ofArray.{u} {</span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.12874" data-verso-hover="303">a</span><span class="inter-text"> : </span><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="159">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.12878" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet"><span class="const token" data-binding="const-Std.TreeSet" data-verso-hover="4662">Std.TreeSet</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12873" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12878" data-verso-hover="4845">cmp</span></div></pre><div class="text">
                    <p>
                      Transforms an array into a tree set.</p>
                    </div>
                  </div>
                <section>
                  <h4 id="The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Conversion--Unbundled-Variants">
                    18.17.10.6.1. Unbundled Variants</h4>
                  <p>
                    Unbundled sets separate well-formedness proofs from data.
This is primarily useful when defining <a href="Basic-Types/Maps-and-Sets/#raw-data">nested inductive types</a>.
To use these variants, import the module <code>Std.TreeSet.Raw</code>.</p>
                  <div class="namedocs" id="Std___TreeSet___Raw___mk">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.Raw" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.Raw.{u} (</span><span class="var token" data-binding="var-_uniq.13258" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.13262" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13258" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13258" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by exact compare) : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.Raw.{u} (</span><span class="var token" data-binding="var-_uniq.13258" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">)
  (</span><span class="var token" data-binding="var-_uniq.13262" data-verso-hover="4845">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13258" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13258" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text"> := by
    exact compare) :
  </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span></div></pre><div class="text">
                      <p>
                        Tree sets without a bundled well-formedness invariant, suitable for use in nested
inductive types. The well-formedness invariant is called <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Raw.WF</span></code>. When in doubt, prefer <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet</span></code>
over <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet.Raw</span></code>. Lemmas about the operations on <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___mk"><span class="const token" data-binding="const-Std.TreeSet.Raw" data-verso-hover="4894">Std.TreeSet.Raw</span></a></code> are available in the
module <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Std.Data.TreeSet.Raw.Lemmas</span></code>.</p>
                      <p>
                        A tree set stores elements of a certain type in a certain order. It depends on a comparator function
that defines an ordering on the keys and provides efficient order-dependent queries, such as
retrieval of the minimum or maximum.</p>
                      <p>
                        To ensure that the operations behave as expected, the comparator function <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.13082" data-verso-hover="4845">cmp</span></code> should satisfy
certain laws that ensure a consistent ordering:</p>
                      <ul>
                        <li>
                          <p>
                            If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is greater than (or equal) to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
and vice versa (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">OrientedCmp</span></code> typeclass).</p>
                          </li>
                        <li>
                          <p>
                            If <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> is, in turn, less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>
is less than or equal to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">c</span></code> (see the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TransCmp</span></code> typeclass).</p>
                          </li>
                        </ul>
                      <p>
                        Keys for which <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.13200" data-verso-hover="4845">cmp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13209" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13215" data-verso-hover="45">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering.eq" data-verso-hover="1774">Ordering.eq</span></a></code> are considered the same, i.e only one of them
can be contained in a single tree set at the same time.</p>
                      <p>
                        To avoid expensive copies, users should make sure that the tree set is used linearly.</p>
                      <p>
                        Internally, the tree sets are represented as size-bounded trees, a type of self-balancing binary
search tree with efficient order statistic lookups.</p>
                      <h1>
                        Constructor</h1>
                      <section class="subdocs">
                        <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___mk"><span class="const token" data-binding="const-Std.TreeSet.Raw.mk" data-verso-hover="4903">Std.TreeSet.Raw.mk</span></a><span class="inter-text">.{u}</span></pre><div class="docs"></div>
                        </section>
                      <h1>
                        Fields</h1>
                      <section class="subdocs">
                        <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.TreeSet.Raw.inner" data-verso-hover="4904">inner</span> : <a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw" data-verso-hover="4846">Std.TreeMap.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13231" data-verso-hover="54">α</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13232" data-verso-hover="4845">cmp</span></pre><div class="docs">
                          <p>
                            Internal implementation detail of the tree set.</p>
                          </div>
                        </section>
                      </div>
                    </div>
                  <div class="namedocs" id="Std___TreeSet___Raw___WF___mk">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Std.TreeSet.Raw.WF.out" title="Permalink">🔗</a></span><span class="label">structure</span><pre class="signature hl lean block"><div class="wide-only"><span class="inter-text">Std.TreeSet.Raw.WF.{u} {</span><span class="var token" data-binding="var-_uniq.13998" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">} {</span><span class="var token" data-binding="var-_uniq.14002" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13998" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13998" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.14007" data-verso-hover="4905">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___mk"><span class="const token" data-binding="const-Std.TreeSet.Raw" data-verso-hover="4894">Std.TreeSet.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13998" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14002" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div><div class="narrow-only"><span class="inter-text">Std.TreeSet.Raw.WF.{u} {</span><span class="var token" data-binding="var-_uniq.13998" data-verso-hover="54">α</span><span class="inter-text"> : </span><span class="sort token" data-binding="" data-verso-hover="49">Type u</span><span class="inter-text">}
  {</span><span class="var token" data-binding="var-_uniq.14002" data-verso-hover="4848">cmp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.13998" data-verso-hover="54">α</span><span class="inter-text"> → </span><span class="var token" data-binding="var-_uniq.13998" data-verso-hover="54">α</span><span class="inter-text"> → </span><a href="Type-Classes/Basic-Classes/#Ordering___lt"><span class="const token" data-binding="const-Ordering" data-verso-hover="1761">Ordering</span></a><span class="inter-text">}
  (</span><span class="var token" data-binding="var-_uniq.14007" data-verso-hover="4905">t</span><span class="inter-text"> : </span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___mk"><span class="const token" data-binding="const-Std.TreeSet.Raw" data-verso-hover="4894">Std.TreeSet.Raw</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13998" data-verso-hover="54">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14002" data-verso-hover="4848">cmp</span><span class="inter-text">) : </span><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></div></pre><div class="text">
                      <p>
                        Well-formedness predicate for tree sets. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet</span></code> will not need to interact with
this. Users of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">TreeSet.Raw</span></code> will need to provide proofs of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF</span></code> to lemmas and should use lemmas
like <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.empty</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">WF.insert</span></code> (which are always named exactly like the operations they are about)
to show that set operations preserve well-formedness. The constructors of this type are internal
implementation details and should not be accessed by users.</p>
                      <h1>
                        Constructor</h1>
                      <section class="subdocs">
                        <pre class="name-and-type hl lean"><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___WF___mk"><span class="const token" data-binding="const-Std.TreeSet.Raw.WF.mk" data-verso-hover="4906">Std.TreeSet.Raw.WF.mk</span></a><span class="inter-text">.{u}</span></pre><div class="docs"></div>
                        </section>
                      <h1>
                        Fields</h1>
                      <section class="subdocs">
                        <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Std.TreeSet.Raw.WF.out" data-verso-hover="4876">out</span> : <span class="var token" data-binding="var-_uniq.13974" data-verso-hover="4905">t</span><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeSet___Raw___mk"><span class="const token" data-binding="const-Std.TreeSet.Raw.inner" data-verso-hover="4907">inner</span></a><span class="inter-text">.</span><a href="Basic-Types/Maps-and-Sets/#Std___TreeMap___Raw___WF___mk"><span class="const token" data-binding="const-Std.TreeMap.Raw.WF" data-verso-hover="4847">WF</span></a></pre><div class="docs">
                          <p>
                            Internal implementation detail of the tree map.</p>
                          </div>
                        </section>
                      </div>
                    </div>
                  </section>
                </section>
              </section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="Basic-Types/Arrays/#Array" rel="prev" title="18.16. Arrays"><span class="arrow">←</span><span class="where">18.16. Arrays</span></a><a class="local-button active" href="Basic-Types/Subtypes/#Subtype" rel="next" title="18.18. Subtypes"><span class="where">18.18. Subtypes</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

