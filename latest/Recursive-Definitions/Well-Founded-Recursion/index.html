<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Well-Founded Recursion</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 5%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
dl.toml-table-field-spec {
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
div.planned {
  font-style: italic;
}
div.planned .label {
  font-size: large;
  text-align: center;
  font-family: var(--verso-structure-font-family);
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: larger;
  margin-top: 0;
  margin-left: 1.5em;
  margin-right: 1.5em;
  margin-bottom: 0.5em;
  display: inline-block;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>.example {
  padding: 1.5em;
  border: 1px solid #98B2C0;
  border-radius: 0.5em;
  margin-bottom: 0.75em;
  margin-top: 0.75em;
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example p:last-child {margin-bottom:0;}
.example .description::before {
  content: "Example: ";
}
.example[open] .description {
  margin-bottom: 1em;
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 2px #99b3c0;
  background-color: #99b3c0;
  padding-left: 1px;
  padding-right: 1px;
  padding-bottom: 1px;
  padding-top: 1.5rem;
  margin-bottom: 1rem;
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  background-color: white;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 1.5rem;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: 1.5rem !important;
  margin-right: 1.5rem;
}

.namedocs .label {
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  right: 0.5rem;
  top: 0.5rem;
}

/* Sticking content into the right margin is not good on narrow screens,
   so move the label to the left to make space for the permalink widget. */

@media screen and (max-width: 700px) {
  .namedocs:has(.permalink-widget.block) .label {
    right: 1.5rem;
  }
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold;
}

.namedocs > .text .constructor {
  padding-left: 0.5rem;
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: 1.5rem;
}
.namedocs .text > :last-child {
  margin-bottom: 1.5rem;
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files/#The-Lean-Language-Reference--Source-Files">Source Files</a></td></tr><tr class="current numbered"><td class="num">6.</td><td><a href="Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="Output-from-Lean/#The-Lean-Language-Reference--Output-from-Lean">Output from Lean</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Elan/#elan">Elan</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-recursive-definitions" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-recursive-definitions" checked="checked"></label><span class="number">6.</span> <span class=""><a href="Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></span></div>
              <table><tr class="numbered"><td class="num">6.1.</td><td><a href="Recursive-Definitions/Mutual-Recursion/#mutual-syntax">Mutual Recursion</a></td></tr><tr class="numbered"><td class="num">6.2.</td><td><a href="Recursive-Definitions/Structural-Recursion/#structural-recursion">Structural Recursion</a></td></tr><tr class="current numbered"><td class="num">6.3.</td><td><a href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion">Well-Founded Recursion</a></td></tr><tr class="numbered"><td class="num">6.4.</td><td><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint">Partial Fixpoint Recursion</a></td></tr><tr class="numbered"><td class="num">6.5.</td><td><a href="Recursive-Definitions/Partial-and-Unsafe-Recursive-Definitions/#partial-unsafe">Partial and Unsafe Recursive Definitions</a></td></tr><tr class="numbered"><td class="num">6.6.</td><td><a href="Recursive-Definitions/Controlling-Reduction/#The-Lean-Language-Reference--Recursive-Definitions--Controlling-Reduction">Controlling Reduction</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-well-founded-recursion" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-well-founded-recursion" checked="checked"></label><span class="number">6.3.</span> <span class="current"><a href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion">Well-Founded Recursion</a></span></div>
              <ol>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#Lean___Parser___Termination___terminationBy-next-next-next"><span class="syntax"><span class="keyword">termination_by</span><span class="ws"> </span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#wf-rel">Well-Founded Relations</a></span></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><code>WellFoundedRelation</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#The-Lean-Language-Reference--Recursive-Definitions--Well-Founded-Recursion--Termination-proofs">Termination proofs</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#The-Lean-Language-Reference--Recursive-Definitions--Well-Founded-Recursion--Default-Termination-Proof-Tactic">Default Termination Proof Tactic</a></span></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><code class="tactic-name">decreasing_tactic</code></a></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_trivial"><code class="tactic-name">decreasing_trivial</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#inferring-well-founded-recursion">Inferring Well-Founded Recursion</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#mutual-well-founded-recursion">Mutual Well-Founded Recursion</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">6.</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-preprocessing">Preprocessing Function Definitions</a></span></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#Lean___Parser___Attr___wf_preprocess"><span class="syntax"><span class="keyword">wf_preprocess</span></span></a></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><code>wfParam</code></a></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#trace___Elab___definition___wf"><code>trace.Elab.definition.wf</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">7.</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#The-Lean-Language-Reference--Recursive-Definitions--Well-Founded-Recursion--Theory-and-Construction">Theory and Construction</a></span></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><code>fix</code></a></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#invImage"><code>invImage</code></a></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___intro"><code>WellFounded</code></a></li>
                <li>
                  <a href="Recursive-Definitions/Well-Founded-Recursion/#Acc___intro"><code>Acc</code></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Recursive-Definitions/Structural-Recursion/#structural-recursion" rel="prev" title="6.2. Structural Recursion"><span class="arrow">←</span><span class="where">6.2. Structural Recursion</span></a><a class="local-button active" href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint" rel="next" title="6.4. Partial Fixpoint Recursion"><span class="where">6.4. Partial Fixpoint Recursion</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              6.3. Well-Founded Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=well-founded-recursion" title="Permalink">🔗</a></span></h1>
            <p>
              Functions defined by <span id="--tech-term-well-founded-recursion-next"><em>well-founded recursion</em></span> are those in which each recursive call has arguments that are <em>smaller</em> (in a <a href="Recursive-Definitions/Well-Founded-Recursion/#wf-rel">suitable sense</a>) than the functions' parameters.
In contrast to <a href="Recursive-Definitions/Structural-Recursion/#structural-recursion">structural recursion</a>, in which recursive definitions must satisfy particular <em>syntactic</em> requirements, definitions that use well-founded recursion employ <em>semantic</em> arguments.
This allows a larger class of recursive definitions to be accepted.
Furthermore, when Lean's automation fails to construct a termination proof, it is possible to specify one manually.</p>
            <p>
              All definitions are treated identically by the Lean compiler.
In Lean's logic, definitions that use well-founded recursion typically do not reduce <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally</a>.
The reductions do hold as propositional equalities, however, and Lean automatically proves them.
This does not typically make it more difficult to prove properties of definitions that use well-founded recursion, because the propositional reductions can be used to reason about the behavior of the function.
It does mean, however, that using these functions in types typically does not work well.
Even when the reduction behavior happens to hold definitionally, it is often much slower than structurally recursive definitions in the kernel, which must unfold the termination proof along with the definition.
When possible, recursive function that are intended for use in types or in other situations where definitional equality is important should be defined with structural recursion.</p>
            <p>
              To explicitly use well-founded recursion, a function or theorem definition can be annotated with a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause that specifies the <span id="--tech-term-measure-next"><em>measure</em></span> by which the function terminates.
The measure should be a term that decreases at each recursive call; it may be one of the function's parameters or a tuple of the parameters, but it may also be any other term.
The measure's type must be equipped with a <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-relation">well-founded relation</a>, which determines what it means for the measure to decrease.</p>
            <div class="namedocs" id="Lean___Parser___Termination___terminationBy-next-next">
              <span class="label">syntax</span><span class="title">Explicit Well-Founded Recursion</span><div class="text">
                <p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause introduces the termination argument.</p>
                <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Termination___terminationBy-next-next-next"><span class="nonterminal documented" data-kind="Lean.Parser.Termination.terminationBy"><code class="hover-info"><code class="docstring">Specify a termination measure for recursive functions.
```
termination_by a - b
```
indicates that termination of the currently defined recursive function follows
because the difference between the arguments `a` and `b` decreases.

If the function takes further argument after the colon, you can name them as follows:
```
def example (a : Nat) : Nat → Nat → Nat :=
termination_by b c =&gt; a - b
```

By default, a `termination_by` clause will cause the function to be constructed using well-founded
recursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the `termination_by` clause must be one of the function's parameters.

If omitted, a termination measure will be inferred. If written as `termination_by?`,
the inferrred termination measure will be suggested.

</code></code>terminationBy</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.terminationBy"><code class="hover-info"><code class="docstring">Specify a termination measure for recursive functions.
```
termination_by a - b
```
indicates that termination of the currently defined recursive function follows
because the difference between the arguments `a` and `b` decreases.

If the function takes further argument after the colon, you can name them as follows:
```
def example (a : Nat) : Nat → Nat → Nat :=
termination_by b c =&gt; a - b
```

By default, a `termination_by` clause will cause the function to be constructed using well-founded
recursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the `termination_by` clause must be one of the function's parameters.

If omitted, a termination measure will be inferred. If written as `termination_by?`,
the inferrred termination measure will be suggested.

</code></code><span class="keyword">termination_by</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span> </span><span class="keyword">=&gt;</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                  The identifiers before the optional <code>=&gt;</code> can bring function parameters into scope that are not
already bound in the declaration header, and the mandatory term must indicate one of the function's parameters, whether introduced in the header or locally in the clause.</p>
                </div>
              </div>
            <details class="example"><summary class="description">Division by Iterated Subtraction</summary><p>
                Division can be specified as the number of times the divisor can be subtracted from the dividend.
This operation cannot be elaborated using structural recursion because subtraction is not pattern matching.
The value of <code>n</code> does decrease with each recursive call, so well-founded recursion can be used to justify the definition of division by iterated subtraction.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3580">def</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3611" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3611" data-verso-hover="81">then</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3611" data-verso-hover="81">else</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3634" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3634" data-verso-hover="81">then</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3634" data-verso-hover="81">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-3675" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.163" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code></details><section>
              <h2 id="wf-rel">
                6.3.1. Well-Founded Relations<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=wf-rel" title="Permalink">🔗</a></span></h2>
              <p>
                A relation <code>≺</code> is a <span id="--tech-term-well-founded-relation"><em>well-founded relation</em></span> if there exists no infinitely descending chain</p>
              <p>
                <code class="math display"> x_0 ≻ x_1 ≻ \cdots</code></p>
              <p>
                In Lean, types that are equipped with a canonical well-founded relation are instances of the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="1132">WellFoundedRelation</span></a></code> type class.</p>
              <div class="namedocs" id="WellFoundedRelation___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=WellFoundedRelation.wf" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block">WellFoundedRelation.{u} (<span class="var token" data-binding="var-_uniq.19" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>) :
  <span class="sort token" data-binding="" data-verso-hover="96">Sort (max 1 u)</span></pre><div class="text">
                  <h1>
                    Instance Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.mk" data-verso-hover="1133">WellFoundedRelation.mk</span></a>.{u}</pre><div class="docs"></div>
                    </section>
                  <h1>
                    Methods</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="1134">rel</span> : <span class="var token" data-binding="var-_uniq.4" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.4" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></pre><div class="docs"></div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-WellFoundedRelation.wf" data-verso-hover="1135">wf</span> : <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="1136">WellFounded</span></a> <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="1137">WellFoundedRelation.rel</span></a></pre><div class="docs"></div>
                    </section>
                  </div>
                </div>
              <p>
                The most important instances are:</p>
              <ul>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>, ordered by <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span></code>.</p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="116">Prod</span></a></code>, ordered lexicographically: <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.126" data-verso-hover="46">a₁</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.130" data-verso-hover="112">b₁</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">≺</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="46">a₂</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.132" data-verso-hover="112">b₂</span><span class="unknown token" data-binding="">)</span></code> if and only if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.186" data-verso-hover="46">a₁</span> <span class="unknown token" data-binding="">≺</span> <span class="var token" data-binding="var-_uniq.188" data-verso-hover="46">a₂</span></code> or <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.220" data-verso-hover="46">a₁</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.222" data-verso-hover="46">a₂</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.253" data-verso-hover="112">b₁</span> <span class="unknown token" data-binding="">≺</span> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="112">b₂</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Every type that is an instance of the <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a></code> type class, which provides a method <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">SizeOf.sizeOf</span></a></code>, has a well-founded relation.
  For these types, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.358" data-verso-hover="1139">x₁</span> <span class="unknown token" data-binding="">≺</span> <span class="var token" data-binding="var-_uniq.360" data-verso-hover="1139">x₂</span></code> if and only if <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.396" data-verso-hover="1139">x₁</span> <span class="unknown token" data-binding="">&lt;</span> <a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.398" data-verso-hover="1139">x₂</span></code>. For <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Inductive-types">inductive types</a>, a <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a></code> instance is automatically derived by Lean.</p>
                  </li>
                </ul>
              <p>
                Note that there exists a low-priority instance <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-instSizeOfDefault" data-verso-hover="1140">instSizeOfDefault</span></code> that provides a <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a></code> instance for any type, and always returns <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">0</span></code>.
This instance cannot be used to prove that a function terminates using well-founded recursion because <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">&lt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code> is false.</p>
              <details class="example"><summary class="description">Default Size Instance</summary><p>
                  Function types in general do not have a well-founded relation that's useful for termination proofs.
<a href="Type-Classes/Instance-Synthesis/#instance-synth">Instance synthesis</a> thus selects <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-instSizeOfDefault" data-verso-hover="1140">instSizeOfDefault</span></code> and the corresponding well-founded relation.
If the measure is a function, the default <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a></code> instance is selected and the proof cannot succeed.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5884">def</span> <span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="const token" data-binding="const-fooInst" data-verso-hover="1141" id="fooInst">fooInst</span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1142">b</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#fooInst"><span class="const token" data-binding="const-fooInst" data-verso-hover="1141">fooInst</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1142">b</span> <span class="unknown token" data-binding="">∘</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="1142">b</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-5944" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="1142">b</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-5961" data-verso-hover="1055">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-760021752356068850-5977-6062"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-5977" data-verso-hover="1143">guard_target</span></a> <span class="unknown token" data-binding="">=</span>
    <span class="unknown token" data-binding="">@</span><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-instSizeOfDefault" data-verso-hover="1140">instSizeOfDefault</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span> <span class="unknown token" data-binding="">∘</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;</span> <a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-760021752356068850-5977-6062"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <a href="The-Type-System/Functions/#Function___comp"><span class="const token" data-binding="const-Function.comp" data-verso-hover="108">(</span></a><span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span><a href="The-Type-System/Functions/#Function___comp"><span class="const token" data-binding="const-Function.comp" data-verso-hover="108"> ∘ </span></a><span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span><a href="The-Type-System/Functions/#Function___comp"><span class="const token" data-binding="const-Function.comp" data-verso-hover="108">)</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-18106933795060064560-6065-6099"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-6065" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-6070">only</span> <span class="unknown token" data-binding="">[</span><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-default.sizeOf" data-verso-hover="1144">default.sizeOf</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18106933795060064560-6065-6099"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-18106933795060064560-6102-6122"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-6102" data-verso-hover="1143">guard_target</span></a> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">&lt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18106933795060064560-6102-6122"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-11062093090351597211-6125-6129"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-6125" data-verso-hover="36">simp</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11062093090351597211-6125-6129"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-11062093090351597211-6132-6152"><a href="Tactic-Proofs/Tactic-Reference/#guard_target"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.guardTarget-6132" data-verso-hover="1143">guard_target</span></a> <span class="unknown token" data-binding="">=</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11062093090351597211-6132-6152"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.98" data-verso-hover="1142">b</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-6155-6160"><a href="Tactic-Proofs/Tactic-Reference/#sorry"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-6155" data-verso-hover="11">sorry</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-6155-6160"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></details></section>
            <section>
              <h2 id="The-Lean-Language-Reference--Recursive-Definitions--Well-Founded-Recursion--Termination-proofs">
                6.3.2. Termination proofs</h2>
              <p>
                Once a <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a> is specified and its <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-relation">well-founded relation</a> is determined, Lean determines the termination proof obligation for every recursive call.</p>
              <p>
                The proof obligation for each recursive call is of the form <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.606" data-verso-hover="1145">g</span> <span class="var token" data-binding="var-_uniq.611" data-verso-hover="46">a₁</span> <span class="var token" data-binding="var-_uniq.615" data-verso-hover="1146">a₂</span> <span class="unknown token" data-binding="">…</span> <span class="unknown token" data-binding="">≺</span> <span class="var token" data-binding="var-_uniq.606" data-verso-hover="1145">g</span> <span class="var token" data-binding="var-_uniq.613" data-verso-hover="46">p₁</span> <span class="var token" data-binding="var-_uniq.617" data-verso-hover="1147">p₂</span> <span class="unknown token" data-binding="">…</span></code>, where:</p>
              <ul>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.668" data-verso-hover="1145">g</span></code> is the measure as a function of the parameters,</p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="1137">≺</span></a></code> is the inferred well-founded relation,</p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.842" data-verso-hover="46">a₁</span></code> <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.899" data-verso-hover="1146">a₂</span></code> <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">…</span></code> are the arguments of the recursive call and</p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1003" data-verso-hover="46">p₁</span></code> <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1060" data-verso-hover="1147">p₂</span></code> <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">…</span></code> are the parameters of the function definition.</p>
                  </li>
                </ul>
              <p>
                The context of the proof obligation is the local context of the recursive call.
In particular, local assumptions (such as those introduced by <code>if h : _</code>, <code>match h : _ with </code> or <code>have</code>) are available.
If a function parameter is the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of a pattern match (e.g. by a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression), then this parameter is refined to the matched pattern in the proof obligation.</p>
              <p>
                The overall termination proof obligation consists of one goal for each recursive call.
By default, the tactic <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1148">decreasing_trivial</span></a></code> is used to prove each proof obligation.
A custom tactic script can be provided using the optional <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause, which comes after the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause.
This tactic script is run once, with one goal for each proof obligation, rather than separately on each proof obligation.</p>
              <details class="example"><summary class="description">Termination Proof Obligations</summary><p>
                  The following recursive definition of the Fibonacci numbers has two recursive calls, which results in two goals in the termination proof.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8413">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="1149">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-8436" data-verso-hover="1150">if</span></a> <span class="var token" data-binding="var-_uniq.52" data-verso-hover="1151">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">≤</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-8436" data-verso-hover="1150">then</span></a>
    <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-8436" data-verso-hover="1150">else</span></a>
    <span class="const token" data-binding="const-fib" data-verso-hover="1149">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="1149">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-8499" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.318" data-verso-hover="7">n</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
h : ¬n ≤ 1
⊢ n - 1 &lt; n

n : Nat
h : ¬n ≤ 1
⊢ n - 2 &lt; n</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-8516" data-verso-hover="1055">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-7367854249404495145-8532-8536"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-8532" data-verso-hover="1152">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7367854249404495145-8532-8536"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.472" data-verso-hover="1153">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.472" data-verso-hover="1153">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                  <div class="tactic-state">
                    <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1244" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1247" data-verso-hover="1153">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1244" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1244" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1244" data-verso-hover="7">n</span></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1244" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1247" data-verso-hover="1153">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1244" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1244" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1244" data-verso-hover="7">n</span></span></span></span></div>
                  </div>
                <p>
                  Here, the <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a> is simply the parameter itself, and the well-founded order is the less-than relation on natural numbers.
The first proof goal requires the user to prove that the argument of the first recursive call, namely <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1257" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span></code>, is strictly smaller than the function's parameter, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1292" data-verso-hover="7">n</span></code>.</p>
                <p>
                  Both termination proofs can be easily discharged using the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="" data-verso-hover="320">omega</span></a></code> tactic.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9335">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="1149">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-9358" data-verso-hover="1150">if</span></a> <span class="var token" data-binding="var-_uniq.52" data-verso-hover="1151">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">≤</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-9358" data-verso-hover="1150">then</span></a>
    <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-9358" data-verso-hover="1150">else</span></a>
    <span class="const token" data-binding="const-fib" data-verso-hover="1149">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="1149">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-9421" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.318" data-verso-hover="7">n</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-9438" data-verso-hover="1055">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-8740102980480763946-9454-9456"><span class="unknown token" data-binding="">·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8740102980480763946-9454-9456"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.472" data-verso-hover="1153">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-9457-9462"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-9457" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-9457-9462"><span class="tactic-state">All goals completed! 🐙</span></span>
  <span class="tactic"><label for="tactic-state-13406293866509077640-9465-9467"><span class="unknown token" data-binding="">·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13406293866509077640-9465-9467"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.472" data-verso-hover="1153">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.470" data-verso-hover="7">n</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-9468-9473"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-9468" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-9468-9473"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></details><details class="example"><summary class="description">Refined Parameters</summary><p>
                  If a parameter of the function is the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of a pattern match, then the proof obligations mention the refined parameter.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9773">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="1053">fib</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.45" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-fib" data-verso-hover="1053">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.45" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="1053">fib</span> <span class="var token" data-binding="var-_uniq.45" data-verso-hover="7">n</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-9853" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="7">n</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
⊢ n + 1 &lt; n.succ.succ

n : Nat
⊢ n &lt; n.succ.succ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-9875" data-verso-hover="1055">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-11080608632938736847-9891-9895"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-9891" data-verso-hover="1152">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11080608632938736847-9891-9895"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.328" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.328" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.328" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.328" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.328" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.328" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                  <div class="tactic-state">
                    <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1365" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1365" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1365" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1365" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1365" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1365" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></div>
                  </div>
                </details><div class="paragraph">
                <p>
                  Additionally, the context is enriched with additional assumptions that can make it easier to prove termination.
Some examples include:</p>
                <ul>
                  <li>
                    <p>
                      In the branches of an <a href="Terms/Conditionals/#if-then-else">if-then-else</a> expression, a hypothesis that asserts the current branch's condition is added, much as if the dependent if-then-else syntax had been used.</p>
                    </li>
                  <li>
                    <p>
                      In the function argument to certain higher-order functions, the context of the function's body is enriched with assumptions about the argument.</p>
                    </li>
                  </ul>
                <p>
                  This list is not exhaustive, and the mechanism is extensible.
It is described in detail in <a href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-preprocessing">the section on preprocessing</a>.</p>
                </div>
              <details class="example"><summary class="description">Enriched Proof Obligation Contexts</summary><p>
                  Here, the <span class="hl lean keyword-of"><code class="hover-info"><code>termIfThenElse : term</code><span class="sep"></span><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></code><a href="Terms/Conditionals/#termIfThenElse"><code class="kw">if</code></a></span> does not add a local assumption about the condition (that is, whether <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1380" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">≤</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span></code>) to the local contexts in the branches.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11247">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="1149">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11270" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">≤</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11270" data-verso-hover="81">then</span></a>
    <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11270" data-verso-hover="81">else</span></a>
    <span class="const token" data-binding="const-fib" data-verso-hover="1149">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="1149">fib</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-11329" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.287" data-verso-hover="7">n</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
h✝ : ¬n ≤ 1
⊢ n - 1 &lt; n

n : Nat
h✝ : ¬n ≤ 1
⊢ n - 2 &lt; n</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-11346" data-verso-hover="1055">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-7552629000743906833-11362-11366"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-11362" data-verso-hover="1152">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7552629000743906833-11362-11366"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.525" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.527" data-verso-hover="1153">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.525" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.525" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.525" data-verso-hover="7">n</span></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.525" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.527" data-verso-hover="1153">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.525" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.525" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.525" data-verso-hover="7">n</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><p>
                  Nevertheless, the assumptions are available in the context of the termination proof:</p>
                <div class="hl lean tactic-view">
                  <div class="tactic-state">
                    <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1531" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1534" data-verso-hover="1153">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1531" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1531" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>1<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1531" data-verso-hover="7">n</span></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1531" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1534" data-verso-hover="1153">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1531" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1531" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>2<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1531" data-verso-hover="7">n</span></span></span></span></div>
                  </div>
                <p>
                  Termination proof obligations in body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span>​<code>…</code>​<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">in</code></span> loop are also enriched, in this case with a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Std.Range" data-verso-hover="1154">Std.Range</span></code> membership hypothesis:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12135">def</span> <span class="const token" data-binding="const-f" data-verso-hover="1155">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="84">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id___run"><span class="const token" data-binding="const-Id.run" data-verso-hover="1156">Id.run</span></a> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-12174">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-12179">let</span> <span class="keyword token" data-binding="kw-occ-null-12183">mut</span> <span class="var token" data-binding="var-_uniq.174" data-verso-hover="7">s</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="84">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___sum"><span class="const token" data-binding="const-Array.sum" data-verso-hover="1157">sum</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-12201" data-verso-hover="1158">for</span> <span class="var token" data-binding="var-_uniq.168" data-verso-hover="7">i</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-12205">in</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="84">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="87">size</span></a><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-12201" data-verso-hover="1158">do</span>
    <span class="var token" data-binding="var-_uniq.174" data-verso-hover="7">s</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.174" data-verso-hover="7">s</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-f" data-verso-hover="1155">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="84">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___take"><span class="const token" data-binding="const-Array.take" data-verso-hover="1159">take</span></a> <span class="var token" data-binding="var-_uniq.168" data-verso-hover="7">i</span><span class="unknown token" data-binding="">)</span>
  <a href="Functors___-Monads-and--do--Notation/#Pure___mk"><span class="const token" data-binding="const-Pure.pure" data-verso-hover="1160">pure</span></a> <span class="var token" data-binding="var-_uniq.174" data-verso-hover="7">s</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-12260" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.366" data-verso-hover="84">xs</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
xs : Array Nat
i : Nat
h✝ : i ∈ { stop := xs.size, step_pos := Nat.zero_lt_one }
⊢ sizeOf (xs.take i) &lt; sizeOf xs</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-12278" data-verso-hover="1055">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-2351124317699488419-12294-12298"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-12294" data-verso-hover="1152">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2351124317699488419-12294-12298"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.845" data-verso-hover="84">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.848" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.849" data-verso-hover="1161">h✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.848" data-verso-hover="7">i</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162">{ </span><span class="const token" data-binding="const-Std.Range.stop" data-verso-hover="295">stop</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> := </span><span class="var token" data-binding="var-_uniq.845" data-verso-hover="84">xs</span>.<a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="87">size</span></a><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162">, </span><span class="const token" data-binding="const-Std.Range.step_pos" data-verso-hover="1163">step_pos</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> := </span><span class="const token" data-binding="const-Nat.zero_lt_one" data-verso-hover="1164">Nat.zero_lt_one</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> }</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> (<span class="var token" data-binding="var-_uniq.845" data-verso-hover="84">xs</span>.<a href="Basic-Types/Arrays/#Array___take"><span class="const token" data-binding="const-Array.take" data-verso-hover="1159">take</span></a> <span class="var token" data-binding="var-_uniq.848" data-verso-hover="7">i</span>)<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.845" data-verso-hover="84">xs</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                  <div class="tactic-state">
                    <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1649" data-verso-hover="84">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1650" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1651" data-verso-hover="1161">h✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1650" data-verso-hover="7">i</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162">{ </span><span class="const token" data-binding="const-Std.Range.stop" data-verso-hover="295">stop</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> := </span><span class="var token" data-binding="var-_uniq.1649" data-verso-hover="84">xs</span>.<a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="87">size</span></a><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162">, </span><span class="const token" data-binding="const-Std.Range.step_pos" data-verso-hover="1163">step_pos</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> := </span><span class="const token" data-binding="const-Nat.zero_lt_one" data-verso-hover="1164">Nat.zero_lt_one</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> }</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> (<span class="var token" data-binding="var-_uniq.1649" data-verso-hover="84">xs</span>.<a href="Basic-Types/Arrays/#Array___take"><span class="const token" data-binding="const-Array.take" data-verso-hover="1159">take</span></a> <span class="var token" data-binding="var-_uniq.1650" data-verso-hover="7">i</span>)<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.1649" data-verso-hover="84">xs</span></span></span></span></div>
                  </div>
                <p>
                  Similarly, in the following (contrived) example, the termination proof contains an additional assumption showing that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1655" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">∈</span> <span class="var token" data-binding="var-_uniq.1658" data-verso-hover="874">xs</span></code>.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12944">def</span> <span class="const token" data-binding="const-f" data-verso-hover="1165">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="874">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Basic-Types/Linked-Lists/#List___sum"><span class="const token" data-binding="const-List.sum" data-verso-hover="1166">List.sum</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="874">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-13005">fun</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-f" data-verso-hover="1165">f</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-13023" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.66" data-verso-hover="874">xs</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
xs : List Nat
x : Nat
h✝ : x ∈ xs
⊢ sizeOf [] &lt; sizeOf xs</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-13041" data-verso-hover="1055">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-11275694611165446969-13057-13061"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-13057" data-verso-hover="1152">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11275694611165446969-13057-13061"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.307" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.308" data-verso-hover="874">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.339" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.340" data-verso-hover="1167">h✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.339" data-verso-hover="7">x</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="var token" data-binding="var-_uniq.308" data-verso-hover="874">xs</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">]</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.308" data-verso-hover="874">xs</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                  <div class="tactic-state">
                    <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1745" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1746" data-verso-hover="874">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1747" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1748" data-verso-hover="1167">h✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1747" data-verso-hover="7">x</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="var token" data-binding="var-_uniq.1746" data-verso-hover="874">xs</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">]</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.1746" data-verso-hover="874">xs</span></span></span></span></div>
                  </div>
                <p>
                  This feature requires special setup for the higher-order function under which the recursive call is nested, as described in <a href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-preprocessing">the section on preprocessing</a>.
In the following definition, identical to the one above except using a custom, equivalent function instead of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">List.map</span></a></code>, the proof obligation context is not enriched:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13892">def</span> <span class="const token" data-binding="const-List.myMap" data-verso-hover="1168" id="f-next-next">List.myMap</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">@</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">List.map</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13920">def</span> <span class="const token" data-binding="const-f" data-verso-hover="1165">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="874">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Basic-Types/Linked-Lists/#List___sum"><span class="const token" data-binding="const-List.sum" data-verso-hover="1166">List.sum</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="874">xs</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#f-next-next"><span class="const token" data-binding="const-List.myMap" data-verso-hover="1168">myMap</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-13983">fun</span> <span class="var token" data-binding="var-_uniq.61" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-f" data-verso-hover="1165">f</span> <span class="var token" data-binding="var-_uniq.61" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-14001" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.83" data-verso-hover="874">xs</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
n : Nat
xs : List Nat
x : Nat
⊢ sizeOf [] &lt; sizeOf xs</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-14019" data-verso-hover="1055">decreasing_by</span></span>
  <span class="tactic"><label for="tactic-state-16651359421629891047-14035-14039"><a href="Tactic-Proofs/Tactic-Reference/#skip"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-14035" data-verso-hover="1152">skip</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16651359421629891047-14035-14039"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.212" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.213" data-verso-hover="874">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.218" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">]</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.213" data-verso-hover="874">xs</span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="hl lean tactic-view">
                  <div class="tactic-state">
                    <span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1792" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1793" data-verso-hover="874">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1794" data-verso-hover="7">x</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">]</span></a><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.1793" data-verso-hover="874">xs</span></span></span></span></div>
                  </div>
                </details></section>
            <section>
              <h2 id="The-Lean-Language-Reference--Recursive-Definitions--Well-Founded-Recursion--Default-Termination-Proof-Tactic">
                6.3.3. Default Termination Proof Tactic</h2>
              <p>
                If no <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause is given, then the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1169">decreasing_tactic</span></a></code> is used implicitly, and applied to each proof obligation separately.</p>
              <div class="namedocs" id="decreasing_tactic">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=tacticDecreasing_tactic" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1169">decreasing_tactic</span></a></pre><div class="text">
                  <p>
                    The tactic <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1169">decreasing_tactic</span></a></code> mainly deals with lexicographic ordering of tuples, applying <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right" data-verso-hover="1170">Prod.Lex.right</span></code> if the left components of the product are <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally equal</a>, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.left" data-verso-hover="1171">Prod.Lex.left</span></code> otherwise.
After preprocessing tuples this way, it calls the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1148">decreasing_trivial</span></a></code> tactic.</p>
                  </div>
                </div>
              <div class="namedocs" id="decreasing_trivial">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.tactic&name=tacticDecreasing_trivial" title="Permalink">🔗</a></span><span class="label">tactic</span><pre class="signature hl lean block"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1148">decreasing_trivial</span></a></pre><div class="text">
                  <p>
                    Extensible helper tactic for <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="kw-occ-tacticDecreasing_tactic-0" data-verso-hover="1169">decreasing_tactic</span></a></code>. This handles the "base case"
reasoning after applying lexicographic order lemmas.
It can be extended by adding more macro definitions, e.g.</p>
                  <pre>macro_rules | `(tactic| decreasing_trivial) =&gt; `(tactic| linarith)
</pre><p>
                    The tactic <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1148">decreasing_trivial</span></a></code> is an extensible tactic that applies a few common heuristics to solve a termination goal.
In particular, it tries the following tactics and theorems:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#simp_arith"><span class="keyword token" data-binding="" data-verso-hover="613">simp_arith</span></a></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#assumption"><span class="keyword token" data-binding="" data-verso-hover="1172">assumption</span></a></code></p>
                      </li>
                    <li>
                      <p>
                        theorems <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.sub_succ_lt_self" data-verso-hover="1173">Nat.sub_succ_lt_self</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.pred_lt_of_lt" data-verso-hover="1174">Nat.pred_lt_of_lt</span></code>, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.pred_lt" data-verso-hover="1175">Nat.pred_lt</span></code>, which handle common arithmetic goals</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="" data-verso-hover="320">omega</span></a></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1176">array_get_dec</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1177">array_mem_dec</span></code>, which prove that the size of array elements is less than the size of the array</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1178">sizeOf_list_dec</span></code> that the size of list elements is less than the size of the list</p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String.Iterator.sizeOf_next_lt_of_hasNext" data-verso-hover="1179">String.Iterator.sizeOf_next_lt_of_hasNext</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String.Iterator.sizeOf_next_lt_of_atEnd" data-verso-hover="1180">String.Iterator.sizeOf_next_lt_of_atEnd</span></code>, to handle iteration through a string using  <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span></p>
                      </li>
                    </ul>
                  <p>
                    This tactic is intended to be extended with further heuristics using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span>.</p>
                  </div>
                </div>
              <details class="example"><summary class="description">No Backtracking of Lexicographic Order</summary><p>
                  A classic example of a recursive function that needs a more complex <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a> is the Ackermann function:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-16502">def</span> <span class="const token" data-binding="const-ack" data-verso-hover="1181">ack</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span>     <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span>     <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>     <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1181">ack</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="1182">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1181">ack</span> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-ack" data-verso-hover="1181">ack</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-16628" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.393" data-verso-hover="7">m</span> <span class="var token" data-binding="var-_uniq.396" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.393" data-verso-hover="7">m</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.396" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  The measure is a tuple, so every recursive call has to be on arguments that are lexicographically smaller than the parameters.
The default <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1169">decreasing_tactic</span></a></code> can handle this.</p>
                <p>
                  In particular, note that the third recursive call has a second argument that is smaller than the second parameter and a first argument that is definitionally equal to the first parameter.
This allowed  <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1169">decreasing_tactic</span></a></code> to apply <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right" data-verso-hover="1170">Prod.Lex.right</span></code>.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right" data-verso-hover="1170">Prod.Lex.right</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="114">β</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="423">ra</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1183">rb</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="114">β</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="114">β</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="112">b₁</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="112">b₂</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="114">β</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1184">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1183">rb</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="112">b₁</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="112">b₂</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1185">Prod.Lex</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="423">ra</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1183">rb</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="46">a</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="112">b₁</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="46">a</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="112">b₂</span><span class="unknown token" data-binding="">)</span></code><p>
                  It fails, however, with the following modified function definition, where the third recursive call's first argument is provably smaller or equal to the first parameter, but not syntactically equal:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-17548">def</span> <span class="const token" data-binding="const-synack" data-verso-hover="1186">synack</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span>     <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span>     <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>     <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-synack" data-verso-hover="1186">synack</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="1182">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-synack" data-verso-hover="1186">synack</span> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
case h
m n : Nat
⊢ m / 2 + 1 &lt; m + 1</code></span></span><span class="const token" data-binding="const-synack" data-verso-hover="1186">synack</span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">/</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-17690" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.452" data-verso-hover="1187">m</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.452" data-verso-hover="1187">m</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
case h
m n : Nat
⊢ m / 2 + 1 &lt; m + 1
</pre></div>
                <p>
                  Because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right" data-verso-hover="1170">Prod.Lex.right</span></code> is not applicable, the tactic used <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.left" data-verso-hover="1171">Prod.Lex.left</span></code>, which resulted in the unprovable goal above.</p>
                <p>
                  This function definition may require a manual proof that uses the more general theorem <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right'" data-verso-hover="1188">Prod.Lex.right'</span></code>, which allows the first component of the tuple (which must be of type <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>) to be less or equal instead of strictly equal:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right'" data-verso-hover="1188">Prod.Lex.right'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">β</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1183">rb</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">β</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">β</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">a₂</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="112">b₂</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">β</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="7">a₁</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="112">b₁</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">β</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1189">h₁</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="7">a₁</span> <span class="unknown token" data-binding="">≤</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">a₂</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1184">h₂</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1183">rb</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="112">b₁</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="112">b₂</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1185">Prod.Lex</span> <a href="Basic-Types/Natural-Numbers/#Nat___lt"><span class="const token" data-binding="const-Nat.lt" data-verso-hover="1190">Nat.lt</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1183">rb</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="7">a₁</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="112">b₁</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">a₂</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="112">b₂</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18690">def</span> <span class="const token" data-binding="const-synack" data-verso-hover="1186">synack</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-synack" data-verso-hover="1186">synack</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="1182">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-synack" data-verso-hover="1186">synack</span> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-synack" data-verso-hover="1186">synack</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">/</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18820" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.452" data-verso-hover="1187">m</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.452" data-verso-hover="1187">m</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-18849" data-verso-hover="1055">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-5256949344744798622-18865-18867"><span class="unknown token" data-binding="">·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5256949344744798622-18865-18867"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.728" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1185">Prod.Lex</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4258" data-verso-hover="7">a₁</span> <span class="var token" data-binding="var-_uniq.4259" data-verso-hover="7">a₂</span> =&gt; <span class="var token" data-binding="var-_uniq.4258" data-verso-hover="7">a₁</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.4259" data-verso-hover="7">a₂</span>) (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4265" data-verso-hover="7">a₁</span> <span class="var token" data-binding="var-_uniq.4266" data-verso-hover="7">a₂</span> =&gt; <span class="var token" data-binding="var-_uniq.4265" data-verso-hover="7">a₁</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.4266" data-verso-hover="7">a₂</span>) <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a><span class="var token" data-binding="var-_uniq.728" data-verso-hover="7">m</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a> <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a><span class="var token" data-binding="var-_uniq.728" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>0<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-1170895891791390755-18868-18887"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-18868" data-verso-hover="583">apply</span></a> <span class="const token" data-binding="const-Prod.Lex.left" data-verso-hover="1171">Prod.Lex.left</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1170895891791390755-18868-18887"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-118" checked="checked"><span for="--verso-unique-118" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.728" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.728" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.728" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-7-18892-18897"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-18892" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-18892-18897"><span class="tactic-state">All goals completed! 🐙</span></span>
  -- the next goal corresponds to the third recursive call
  <span class="tactic"><label for="tactic-state-6342584442760281432-18959-18961"><span class="unknown token" data-binding="">·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6342584442760281432-18959-18961"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1185">Prod.Lex</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4258" data-verso-hover="7">a₁</span> <span class="var token" data-binding="var-_uniq.4259" data-verso-hover="7">a₂</span> =&gt; <span class="var token" data-binding="var-_uniq.4258" data-verso-hover="7">a₁</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.4259" data-verso-hover="7">a₂</span>) (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4265" data-verso-hover="7">a₁</span> <span class="var token" data-binding="var-_uniq.4266" data-verso-hover="7">a₂</span> =&gt; <span class="var token" data-binding="var-_uniq.4265" data-verso-hover="7">a₁</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.4266" data-verso-hover="7">a₂</span>) <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#HDiv___mk"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1191"> / </span></a>2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a> <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-15886104154316822186-18962-18983"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-18962" data-verso-hover="583">apply</span></a> <span class="const token" data-binding="const-Prod.Lex.right'" data-verso-hover="1188">Prod.Lex.right'</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15886104154316822186-18962-18983"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-120" checked="checked"><span for="--verso-unique-120" class="goal-name">h₁</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#HDiv___mk"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1191"> / </span></a>2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-121"><span for="--verso-unique-121" class="goal-name">h₂</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-14252804663745214691-18988-18990"><span class="unknown token" data-binding="">·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14252804663745214691-18988-18990"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-122" checked="checked"><span for="--verso-unique-122" class="goal-name">h₁</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#HDiv___mk"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1191"> / </span></a>2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-18991-18996"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-18991" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-18991-18996"><span class="tactic-state">All goals completed! 🐙</span></span>
    <span class="tactic"><label for="tactic-state-14514951775625085534-19001-19003"><span class="unknown token" data-binding="">·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14514951775625085534-19001-19003"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-123" checked="checked"><span for="--verso-unique-123" class="goal-name">h₂</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-19004-19009"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-19004" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19004-19009"><span class="tactic-state">All goals completed! 🐙</span></span>
  <span class="tactic"><label for="tactic-state-63234615250509350-19012-19014"><span class="unknown token" data-binding="">·</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-63234615250509350-19012-19014"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.735" data-verso-hover="1192">x✝</span></span><span class="colon">:</span><span class="type">(<span class="var token" data-binding="var-_uniq.4252" data-verso-hover="1193">y</span> : (_ : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) ×' <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) →
  (<a href="Recursive-Definitions/Well-Founded-Recursion/#invImage"><span class="const token" data-binding="const-invImage" data-verso-hover="1194">invImage</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4255" data-verso-hover="1193">x</span> =&gt; <span class="const token" data-binding="const-PSigma.casesOn" data-verso-hover="1195">PSigma.casesOn</span> <span class="var token" data-binding="var-_uniq.4255" data-verso-hover="1193">x</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4272" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.4273" data-verso-hover="7">a_1</span> =&gt; <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a><span class="var token" data-binding="var-_uniq.4272" data-verso-hover="7">a</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a><span class="var token" data-binding="var-_uniq.4273" data-verso-hover="7">a_1</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a>) <span class="const token" data-binding="const-Prod.instWellFoundedRelation" data-verso-hover="1196">Prod.instWellFoundedRelation</span>).1 <span class="var token" data-binding="var-_uniq.4252" data-verso-hover="1193">y</span> ⟨<span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>, <span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>⟩ → <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Prod.Lex" data-verso-hover="1185">Prod.Lex</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4258" data-verso-hover="7">a₁</span> <span class="var token" data-binding="var-_uniq.4259" data-verso-hover="7">a₂</span> =&gt; <span class="var token" data-binding="var-_uniq.4258" data-verso-hover="7">a₁</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.4259" data-verso-hover="7">a₂</span>) (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4265" data-verso-hover="7">a₁</span> <span class="var token" data-binding="var-_uniq.4266" data-verso-hover="7">a₂</span> =&gt; <span class="var token" data-binding="var-_uniq.4265" data-verso-hover="7">a₁</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.4266" data-verso-hover="7">a₂</span>) <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a><span class="var token" data-binding="var-_uniq.735" data-verso-hover="1192">x✝</span> ⟨<span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#HDiv___mk"><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="1191"> / </span></a>2<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1, <span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span>⟩ ⋯<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a> <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-13890125691953174313-19015-19034"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-19015" data-verso-hover="583">apply</span></a> <span class="const token" data-binding="const-Prod.Lex.left" data-verso-hover="1171">Prod.Lex.left</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13890125691953174313-19015-19034"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-125" checked="checked"><span for="--verso-unique-125" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.735" data-verso-hover="1192">x✝</span></span><span class="colon">:</span><span class="type">(<span class="var token" data-binding="var-_uniq.4252" data-verso-hover="1193">y</span> : (_ : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) ×' <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) →
  (<a href="Recursive-Definitions/Well-Founded-Recursion/#invImage"><span class="const token" data-binding="const-invImage" data-verso-hover="1194">invImage</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4255" data-verso-hover="1193">x</span> =&gt; <span class="const token" data-binding="const-PSigma.casesOn" data-verso-hover="1195">PSigma.casesOn</span> <span class="var token" data-binding="var-_uniq.4255" data-verso-hover="1193">x</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4272" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.4273" data-verso-hover="7">a_1</span> =&gt; <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a><span class="var token" data-binding="var-_uniq.4272" data-verso-hover="7">a</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a><span class="var token" data-binding="var-_uniq.4273" data-verso-hover="7">a_1</span><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a>) <span class="const token" data-binding="const-Prod.instWellFoundedRelation" data-verso-hover="1196">Prod.instWellFoundedRelation</span>).1 <span class="var token" data-binding="var-_uniq.4252" data-verso-hover="1193">y</span> ⟨<span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>, <span class="var token" data-binding="var-_uniq.734" data-verso-hover="7">n</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>⟩ → <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.733" data-verso-hover="7">m</span>.<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a></span></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-7-19039-19044"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-19039" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19039-19044"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                  The <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1169">decreasing_tactic</span></a></code> tactic does not use the stronger <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod.Lex.right'" data-verso-hover="1188">Prod.Lex.right'</span></code> because it would require backtracking on failure.</p>
                </details></section>
            <section>
              <h2 id="inferring-well-founded-recursion">
                6.3.4. Inferring Well-Founded Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inferring-well-founded-recursion" title="Permalink">🔗</a></span></h2>
              <p>
                If a recursive function definition does not indicate a termination <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a>, Lean will attempt to discover one automatically.
If neither <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> nor <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> is provided, Lean will try to <a href="Recursive-Definitions/Structural-Recursion/#inferring-structural-recursion">infer structural recursion</a> before attempting well-founded recursion.
If a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause is present, only well-founded recursion is attempted.</p>
              <p>
                To infer a suitable termination <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a>, Lean considers multiple <span id="--tech-term-basic-termination-measures"><em>basic termination measures</em></span>, which are termination measures of type <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>, and then tries all tuples of these measures.</p>
              <p>
                The basic termination measures considered are:</p>
              <ul>
                <li>
                  <p>
                    all parameters whose type have a non-trivial <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a></code> instance</p>
                  </li>
                <li>
                  <p>
                    the expression <code>e₂ - e₁</code> whenever the local context of a recursive call has an assumption of type <code>e₁ &lt; e₂</code> or <code>e₁ ≤ e₂</code>, where <code>e₁</code> and <code>e₂</code> are of type <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> and depend only on the function's parameters. <span class="marginalia"><span class="note">This approach is based on work by <span class="citation">Panagiotis Manolios and Daron Vroon, 2006. <a href="https://doi.org/10.1007/11817963_36">“Termination Analysis with Calling Context Graphs”</a>. In <em>Proceedings of the International Conference on Computer Aided Verification (CAV 2006).</em> (LNCS 4144)</span>.</span></span></p>
                  </li>
                <li>
                  <p>
                    in a mutual group, an additional basic measure is used to distinguish between recursive calls to other functions in the group and recursive calls to the function being defined (for details, see <a href="Recursive-Definitions/Well-Founded-Recursion/#mutual-well-founded-recursion">the section on mutual well-founded recursion</a>)</p>
                  </li>
                </ul>
              <p>
                <span id="--tech-term-Candidate-measures"><em>Candidate measures</em></span> are basic measures or tuples of basic measures.
If any of the candidate measures allow all proof obligations to be discharged by the termination proof tactic (that is, the tactic specified by <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span>, or <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1148">decreasing_trivial</span></a></code> if there is no <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause), then an arbitrary such candidate measure is selected as the automatic termination measure.</p>
              <p>
                A <code class="plain-keyword">termination_by?</code> clause causes the inferred termination annotation to be shown.
It can be automatically added to the source file using the offered suggestion or code action.</p>
              <p>
                To avoid the combinatorial explosion of trying all tuples of measures, Lean first tabulates all <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-basic-termination-measures">basic termination measures</a>, determining whether the basic measure is decreasing, strictly decreasing, or non-decreasing.
A decreasing measure is smaller for at least one recursive call and never increases at any recursive call, while a strictly decreasing measure is smaller at all recursive calls.
A non-decreasing measure is one that the termination tactic could not show to be decreasing or strictly decreasing.
A suitable tuple is chosen based on the table.<span class="marginalia"><span class="note">This approach is based on <span class="citation">Lukas Bulwahn, Alexander Krauss,  and Tobias Nipkow, 2007. <a href="https://doi.org/10.1007/978-3-540-74591-4_5">“Finding Lexicographic Orders for Termination Proofs in Isabelle/HOL”</a>. In <em>Proceedings of the International Conference on Theorem Proving in Higher Order Logics (TPHOLS 2007).</em> (LNTCS 4732)</span>.</span></span>
This table shows up in the error message when no automatic measure could be found.</p>
              <details class="example"><summary class="description">Termination failure</summary><p>
                  If there is no <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause, Lean attempts to infer a measure for well-founded recursion.
If it fails, then it prints the table mentioned above.
In this example, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause simply prevents Lean from also attempting structural recursion; this keeps the error message specific.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
           n m l
1) 30:6-25 = = =
2) 31:6-23 = &lt; _
3) 32:6-23 &lt; _ _
Please use `termination_by` to specify a decreasing measure.</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-985">def</span></span> <span class="const token" data-binding="const-f" data-verso-hover="1197">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">m</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">l</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.190" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.191" data-verso-hover="7">m</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">l</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span>
      <span class="const token" data-binding="const-f" data-verso-hover="1197">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.191" data-verso-hover="7">m</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">l</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
      <span class="const token" data-binding="const-f" data-verso-hover="1197">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.191" data-verso-hover="7">m</span><span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">l</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
      <span class="const token" data-binding="const-f" data-verso-hover="1197">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>   <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.191" data-verso-hover="7">m</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">l</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___sum"><span class="const token" data-binding="const-List.sum" data-verso-hover="1166">sum</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-1137" data-verso-hover="1055">decreasing_by</span> <a href="Tactic-Proofs/The-Tactic-Language/#all_goals"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.allGoals-1151" data-verso-hover="319">all_goals</span></a> <a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="kw-occ-tacticDecreasing_tactic-1161" data-verso-hover="1169">decreasing_tactic</span></a>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
           n m l
1) 30:6-25 = = =
2) 31:6-23 = &lt; _
3) 32:6-23 &lt; _ _
Please use `termination_by` to specify a decreasing measure.
</pre></div>
                <p>
                  The three recursive calls are identified by their source positions.
This message conveys the following facts:</p>
                <ul>
                  <li>
                    <p>
                      In the first recursive call, all arguments are (provably) equal to the parameters</p>
                    </li>
                  <li>
                    <p>
                      In the second recursive call, the first argument is equal to the first parameter and the second argument is provably smaller than the second parameter.
  The third parameter was not checked for this recursive call, because it was not necessary to determine that no suitable termination argument exists.</p>
                    </li>
                  <li>
                    <p>
                      In the third recursive call, the first argument decreases strictly, and the other arguments were not checked.</p>
                    </li>
                  </ul>
                <p>
                  When termination proofs fail in this manner, a good technique to discover the problem is to explicitly indicate the expected termination argument using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span>.
This will surface the messages from the failing tactic.</p>
                </details><details class="example"><summary class="description">Array Indexing</summary><p>
                  The purpose of considering expressions of the form <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2097" data-verso-hover="7">e₂</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.2095" data-verso-hover="7">e₁</span></code> as measures is to support the common idiom of counting up to some upper bound, in particular when traversing arrays in possibly interesting ways.
In the following function, which performs binary search on a sorted array, this heuristic helps Lean to find the <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2146" data-verso-hover="7">j</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.2144" data-verso-hover="7">i</span></code> measure.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22653">def</span> <span class="const token" data-binding="const-binarySearch" data-verso-hover="1198" id="binarySearch">binarySearch</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="265">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="71">Int</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1199">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="71">Int</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="const token" data-binding="const-binarySearch.go" data-verso-hover="1200">go</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1199">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="87">size</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.whereDecls-22728">where</span>
  <span class="const token" data-binding="const-binarySearch.go" data-verso-hover="1200">go</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="7">i</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="1201">hj</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span> <span class="unknown token" data-binding="">≤</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1199">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="87">size</span></a> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-22771">by</span> <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-22777" data-verso-hover="320">omega</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
    <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-22791" data-verso-hover="1150">if</span></a> <span class="var token" data-binding="var-_uniq.68" data-verso-hover="1202">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-22791" data-verso-hover="1150">then</span></a>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-22815" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.157" data-verso-hover="7">mid</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">/</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-22844" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.215" data-verso-hover="1203">y</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1199">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.157" data-verso-hover="7">mid</span><span class="unknown token" data-binding="">]</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22867" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="265">x</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.215" data-verso-hover="1203">y</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22867" data-verso-hover="81">then</span></a>
        <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.157" data-verso-hover="7">mid</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22867" data-verso-hover="81">else</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22909" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="265">x</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.215" data-verso-hover="1203">y</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22909" data-verso-hover="81">then</span></a>
        <span class="const token" data-binding="const-binarySearch.go" data-verso-hover="1200">go</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="7">i</span> <span class="var token" data-binding="var-_uniq.157" data-verso-hover="7">mid</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-22909" data-verso-hover="81">else</span></a>
        <span class="const token" data-binding="const-binarySearch.go" data-verso-hover="1200">go</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.157" data-verso-hover="7">mid</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="7">j</span>
    <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-22791" data-verso-hover="1150">else</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  <span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: termination_by (j, j - i)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy?-22996" data-verso-hover="1039">termination_by?</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                  The fact that the inferred termination argument uses some arbitrary measure, rather than an optimal or minimal one, is visible in the inferred measure, which contains a redundant <code>j</code>:</p>
                <div class="information">
                  <pre>Try this: termination_by (j, j - i)
</pre></div>
                </details><details class="example"><summary class="description">Termination Proof Tactics During Inference</summary><p>
                  The tactic indicated by <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> is used slightly differently when inferring the termination <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a> than it is in the actual termination proof.</p>
                <ul>
                  <li>
                    <p>
                      During inference, it is applied to a <em>single</em> goal, attempting to prove <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521">&lt;</span></a></code> or <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305">≤</span></a></code> on <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>.</p>
                    </li>
                  <li>
                    <p>
                      During the termination proof, it is applied to many simultaneous goals (one per recursive call), and the goals may involve the lexicographic ordering of pairs.</p>
                    </li>
                  </ul>
                <p>
                  A consequence is that a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> block that addresses goals individually and which works successfully with an explicit termination argument can cause inference of the termination measure to fail:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
             x1 x2
1) 629:16-23  ?  ?
2) 630:27-40  _  _
3) 630:20-41  _  _
Please use `termination_by` to specify a decreasing measure.</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-24145">def</span></span> <span class="const token" data-binding="const-ack" data-verso-hover="1181">ack</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1181">ack</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="1182">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1181">ack</span> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-ack" data-verso-hover="1181">ack</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-24259" data-verso-hover="1055">decreasing_by</span>
  <span class="unknown token" data-binding="">·</span> <a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-24278" data-verso-hover="583">apply</span></a> <span class="unknown token" data-binding="">Prod.Lex.left</span>
    <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-24302" data-verso-hover="320">omega</span></a>
  <span class="unknown token" data-binding="">·</span> <a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-24313" data-verso-hover="583">apply</span></a> <span class="unknown token" data-binding="">Prod.Lex.right</span>
    <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-24338" data-verso-hover="320">omega</span></a>
  <span class="unknown token" data-binding="">·</span> <a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-24349" data-verso-hover="583">apply</span></a> <span class="unknown token" data-binding="">Prod.Lex.left</span>
    <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-24373" data-verso-hover="320">omega</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                  It is advisable to always include a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause whenever an explicit <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> proof is given.</p>
                </details><details class="example"><summary class="description">Inference too powerful</summary><p>
                  Because <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="" data-verso-hover="1169">decreasing_tactic</span></a></code> avoids the need to backtrack by being incomplete with regard to lexicographic ordering, Lean may infer a termination <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a> that leads to goals that the tactic cannot prove.
In this case, the error message is the one that results from the failing tactic rather than the one that results from being unable to find a measure.
This is what happens in <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#notAck"><span class="const token" data-binding="const-notAck" data-verso-hover="1204">notAck</span></a></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25079">def</span> <span class="const token" data-binding="const-notAck" data-verso-hover="1204" id="notAck">notAck</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#notAck"><span class="const token" data-binding="const-notAck" data-verso-hover="1204">notAck</span></a> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">m</span> <span class="typed token" data-binding="" data-verso-hover="1182">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#notAck"><span class="const token" data-binding="const-notAck" data-verso-hover="1204">notAck</span></a> <span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">(</span><a href="Recursive-Definitions/Well-Founded-Recursion/#notAck"><span class="const token" data-binding="const-notAck" data-verso-hover="1204">notAck</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.248" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">/</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.249" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-25209" data-verso-hover="1055">decreasing_by</span> <a href="Tactic-Proofs/The-Tactic-Language/#all_goals"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.allGoals-25223" data-verso-hover="319">all_goals</span></a> <span class="tactic"><label for="tactic-state-7-25233-25250"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
case h
m n : Nat
⊢ m / 2 + 1 &lt; m + 1</code></span></span><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_tactic"><span class="keyword token" data-binding="kw-occ-tacticDecreasing_tactic-25233" data-verso-hover="1169">decreasing_tactic</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-25233-25250"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
case h
m n : Nat
⊢ m / 2 + 1 &lt; m + 1
</pre></div>
                <p>
                  In this case, explicitly stating the termination <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a> helps.</p>
                </details></section>
            <section>
              <h2 id="mutual-well-founded-recursion">
                6.3.5. Mutual Well-Founded Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-well-founded-recursion" title="Permalink">🔗</a></span></h2>
              <p>
                Lean supports the definition of <a class="technical-term" href="Recursive-Definitions/Mutual-Recursion/#--tech-term-mutually-recursive">mutually recursive</a> functions using <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-recursion-next">well-founded recursion</a>.
Mutual recursion may be introduced using a <a class="technical-term" href="Recursive-Definitions/Mutual-Recursion/#--tech-term-mutual-block">mutual block</a>, but it also results from <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.letrec : term</code></code><code class="kw">let rec</code></span> expressions and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">where</code></span> blocks.
The rules for mutual well-founded recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the <a href="Recursive-Definitions/Mutual-Recursion/#mutual-syntax">elaboration steps</a> for mutual groups.</p>
              <p>
                If any function in the mutual group has a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> clause, well-founded recursion is attempted.
If a termination <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a> is specified using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> for <em>any</em> function in the mutual group, then <em>all</em> functions in the group must specify a termination measure, and they have to have the same type.</p>
              <p>
                If no termination argument is specified, the termination argument is <a href="Recursive-Definitions/Well-Founded-Recursion/#inferring-well-founded-recursion">inferred, as described above</a>. In the case of mutual recursion, a third class of basic measures is considered during inference, namely for each function in the mutual group the measure that is <code>1</code> for that function and <code>0</code> for the others. This allows Lean to order the functions so that some calls from one function to another are allowed even if the parameters do not decrease.</p>
              <details class="example"><summary class="description">Mutual recursion without parameter decrease</summary><p>
                  In the following mutual function definitions, the parameter does not decrease in the call from <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-g" data-verso-hover="1205">g</span></code> to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-f" data-verso-hover="1206">f</span></code>.
Nonetheless, the definition is accepted due to the ordering imposed on the functions themselves by the additional basic measure.</p>
                <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-27546">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-27555">def</span> <span class="const token" data-binding="const-f" data-verso-hover="1206">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
    <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.101" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-g" data-verso-hover="1205">g</span> <span class="var token" data-binding="var-_uniq.101" data-verso-hover="7">n</span>
  <span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: termination_by n =&gt; (n, 0)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy?-27613" data-verso-hover="1039">termination_by?</span></span>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-27632">def</span> <span class="const token" data-binding="const-g" data-verso-hover="1205">g</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-f" data-verso-hover="1206">f</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="1203">1</span>
  <span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: termination_by (n, 1)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy?-27669" data-verso-hover="1039">termination_by?</span></span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-27546">end</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                  The inferred termination argument for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-f" data-verso-hover="1206">f</span></code> is:</p>
                <div class="information">
                  <pre>Try this: termination_by n =&gt; (n, 0)
</pre></div>
                <p>
                  The inferred termination argument for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-g" data-verso-hover="1205">g</span></code> is:</p>
                <div class="information">
                  <pre>Try this: termination_by (n, 1)
</pre></div>
                </details></section>
            <section>
              <h2 id="well-founded-preprocessing">
                6.3.6. Preprocessing Function Definitions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=well-founded-preprocessing" title="Permalink">🔗</a></span></h2>
              <p>
                Lean <em>preprocesses</em> the function's body before determining the proof obligations at each call site, transforming it into an equivalent definition that may include additional information.
This preprocessing step is primarily used to enrich the local context with additional assumptions that may be necessary in order to solve the termination proof obligations, freeing users from the need to perform equivalent transformations by hand.
Preprocessing uses the <a href="The-Simplifier/#the-simplifier">simplifier</a> and is extensible by the user.</p>
              <div class="paragraph">
                <p>
                  The preprocessing happens in three steps:</p>
                <ol start="1">
                  <li>
                    <p>
                      Lean annotates occurrences of a function's parameter, or a subterm of a parameter, with the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code> <a class="technical-term" href="Type-Classes/Class-Declarations/#--tech-term-gadgets">gadget</a>.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="165">α</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="165">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="165">α</span></code><p>
                      More precisely, every occurrence of the function's parameters is wrapped in <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code>.
    Whenever a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression has <em>any</em> discriminant wrapped in <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code>, the gadget is removed and every occurrence of a pattern match variable (regardless of whether it comes from the discriminant with the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code> gadget) is wrapped in <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code>.
    The <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code> gadget is additionally floated out of <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-projection-function">projection function</a> applications.</p>
                    </li>
                  <li>
                    <p>
                      The annotated function body is simplified using <a href="The-Simplifier/#the-simplifier">the simplifier</a>, using only simplification rules from the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1208">wf_preprocess</span></code> <a class="technical-term" href="The-Simplifier/Simp-sets/#--tech-term-Custom-simp-sets">custom simp set</a>.</p>
                    </li>
                  <li>
                    <p>
                      Finally, any left-over <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code> markers are removed.</p>
                    </li>
                  </ol>
                <p>
                  Annotating function parameters that are used for well-founded recursion allows the preprocessing simplification rules to distinguish between parameters and other terms.</p>
                </div>
              <div class="namedocs" id="attr-next">
                <span class="label">syntax</span><span class="title">Preprocessing Simp Set for Well-Founded Recursion</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___wf_preprocess"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Attr.wf_preprocess"><code class="hover-info"><code class="docstring">Theorems tagged with the `wf_preprocess` attribute are used during the processing of functions defined
by well-founded recursion. They are applied to the function's body to add additional hypotheses,
such as replacing `if c then _ else _` with `if h : c then _ else _` or `xs.map` with
`xs.attach.map`. Also see `wfParam`.
</code></code><span class="keyword">wf_preprocess</span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                    Theorems tagged with the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Lean___Parser___Attr___wf_preprocess"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.wf_preprocess-0" data-verso-hover="1209">wf_preprocess</span></a></code> attribute are used during the processing of functions defined
by well-founded recursion. They are applied to the function's body to add additional hypotheses,
such as replacing <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacIfThenElse-0" data-verso-hover="1210">if</span></a> <span class="unknown token" data-binding="">c</span> <a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacIfThenElse-0" data-verso-hover="1210">then</span></a> <span class="unknown token" data-binding="">_</span> <a href="Tactic-Proofs/The-Tactic-Language/#if-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacIfThenElse-0" data-verso-hover="1210">else</span></a> <span class="unknown token" data-binding="">_</span></code> with <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Tactic-Proofs/The-Tactic-Language/#if-h-___-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacDepIfThenElse-0" data-verso-hover="1211">if</span></a> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">c</span> <a href="Tactic-Proofs/The-Tactic-Language/#if-h-___-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacDepIfThenElse-0" data-verso-hover="1211">then</span></a> <span class="unknown token" data-binding="">_</span> <a href="Tactic-Proofs/The-Tactic-Language/#if-h-___-_________-then-_________-else-_________"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacDepIfThenElse-0" data-verso-hover="1211">else</span></a> <span class="unknown token" data-binding="">_</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">xs.map</span></code> with
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">xs.attach.map</span></code>. Also see <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="wfParam">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=wfParam" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block">wfParam.{u} {<span class="var token" data-binding="var-_uniq.2237" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>} (<span class="var token" data-binding="var-_uniq.2238" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2237" data-verso-hover="95">α</span>) : <span class="var token" data-binding="var-_uniq.2237" data-verso-hover="95">α</span></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code> gadget is used internally during the construction of recursive functions by
wellfounded recursion, to keep track of the parameter for which the automatic introduction
of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Linked-Lists/#List___attach"><span class="const token" data-binding="const-List.attach" data-verso-hover="1212">List.attach</span></a></code> (or similar) is plausible.</p>
                  </div>
                </div>
              <p>
                Some rewrite rules in the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1208">wf_preprocess</span></code> simp set apply generally, without heeding the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code> marker.
In particular, the theorem <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ite_eq_dite" data-verso-hover="1213">ite_eq_dite</span></code> is used to extend the context of an <a href="Terms/Conditionals/#if-then-else">if-then-else</a> expression branch with an assumption about the condition:<span class="marginalia"><span class="note">This assumption's name should be an inaccessible name based on <code>h</code>, as is indicated by using <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1214">binderNameHint</span></a></code> with the term <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code>. Binder name hints are described in the <a href="Tactic-Proofs/Naming-Bound-Variables/#bound-variable-name-hints">tactic language reference</a>.</span></span></p>
              <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-ite_eq_dite" data-verso-hover="1213">ite_eq_dite</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">P</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="95">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-30470" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="46">b</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="95">α</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="391">Decidable</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">P</span><span class="unknown token" data-binding="">]</span>  <span class="unknown token" data-binding="">:</span>
  <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-30509" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">P</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-30509" data-verso-hover="81">then</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="46">a</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-30509" data-verso-hover="81">else</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="46">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-30533" data-verso-hover="1150">if</span></a> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="135">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">P</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-30533" data-verso-hover="1150">then</span></a>
    <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1214">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="135">h</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="46">a</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-30533" data-verso-hover="1150">else</span></a>
    <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1214">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="1215">h</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="46">b</span></code><div class="paragraph">
                <p>
                  Other rewrite rules use the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code> marker to restrict their applicability; they are used only when a function (like <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">List.map</span></a></code>) is applied to a parameter or subterm of a parameter, but not otherwise.
This is typically done in two steps:</p>
                <ol start="1">
                  <li>
                    <p>
                      A theorem such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.map_wfParam" data-verso-hover="1216">List.map_wfParam</span></code> recognizes a call of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">List.map</span></a></code> on a function parameter (or subterm), and uses <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___attach"><span class="const token" data-binding="const-List.attach" data-verso-hover="1212">List.attach</span></a></code> to enrich the type of the list elements with the assertion that they are indeed elements of that list:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-List.map_wfParam" data-verso-hover="1216">List.map_wfParam</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="114">β</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="unknown token" data-binding="">(</span><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">map</span></a> <span class="var token" data-binding="var-_uniq.21" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___attach"><span class="const token" data-binding="const-List.attach" data-verso-hover="1212">attach</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___unattach"><span class="const token" data-binding="const-List.unattach" data-verso-hover="1217">unattach</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">map</span></a> <span class="var token" data-binding="var-_uniq.21" data-verso-hover="107">f</span></code></li>
                  <li>
                    <p>
                      A theorem such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.map_unattach" data-verso-hover="1218">List.map_unattach</span></code> makes that assertion available to the function parameter of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">List.map</span></a></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-List.map_unattach" data-verso-hover="1218">List.map_unattach</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="397">P</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="1219">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="unknown token" data-binding="">{</span> <span class="var token" data-binding="var-_uniq.34" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">//</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="397">P</span> <span class="var token" data-binding="var-_uniq.34" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.41" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="114">β</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="var token" data-binding="var-_uniq.37" data-verso-hover="1219">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___unattach"><span class="const token" data-binding="const-List.unattach" data-verso-hover="1217">unattach</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">map</span></a> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.37" data-verso-hover="1219">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">map</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-31640">fun</span> <span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.136" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.137" data-verso-hover="1220">h</span><span class="unknown token" data-binding="">⟩</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1214">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.136" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">&lt;|</span>
    <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1214">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.137" data-verso-hover="1220">h</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;|</span>
    <span class="var token" data-binding="var-_uniq.41" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">(</span><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a> <span class="var token" data-binding="var-_uniq.136" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span></code><p>
                      This theorem uses the <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1214">binderNameHint</span></a></code> gadget to preserve a user-chosen binder name, should <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2614" data-verso-hover="107">f</span></code> be a lambda expression.</p>
                    </li>
                  </ol>
                <p>
                  By separating the introduction of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___attach"><span class="const token" data-binding="const-List.attach" data-verso-hover="1212">List.attach</span></a></code> from the propagation of the introduced assumption, the desired the <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2687" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">∈</span> <span class="var token" data-binding="var-_uniq.2677" data-verso-hover="51">xs</span></code> assumption is made available to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2732" data-verso-hover="107">f</span></code> even in chains such as <code>(xs.reverse.filter p).map f</code>.</p>
                </div>
              <p>
                This preprocessing can be disabled by setting the option <code class="hl lean inline" data-lean-context="examples"><span class="option token" data-binding="option-wf.preprocess" data-verso-hover="1221">wf.preprocess</span></code> to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a></code>.
To see the preprocessed function definition, before and after the removal of <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a></code> markers, set the option <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#trace___Elab___definition___wf"><span class="option token" data-binding="option-trace.Elab.definition.wf" data-verso-hover="1222">trace.Elab.definition.wf</span></a></code> to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code>.</p>
              <div class="namedocs" id="trace___Elab___definition___wf">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.option&name=trace.Elab.definition.wf" title="Permalink">🔗</a></span><span class="label">option</span><pre class="signature hl lean block">trace.Elab.definition.wf</pre><div class="text">
                  <p>
                    Default value: <code class="hl lean inline"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a></code></p>
                  <p>
                    enable/disable tracing for the given module and submodules</p>
                  </div>
                </div>
              <details class="example"><summary class="description">Preprocessing for a custom data type</summary><p>
                  This example demonstrates what is necessary to enable automatic well-founded recursion for a custom container type.
The structure type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span></code> is a homogeneous pair: it contains precisely two elements, both of which have the same type.
It can be thought of as being similar to a list or array that always contains precisely two elements.</p>
                <p>
                  As a container, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span></code> can support a <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a></code> operation.
To support well-founded recursion in which recursive calls occur in the body of a function being mapped over a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span></code>, some additional definitions are required, including a membership predicate, a theorem that relates the size of a member to the size of the containing pair, helpers to introduce and eliminate assumptions about membership, <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1208">wf_preprocess</span></code> rules to insert these helpers, and an extension to the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1148">decreasing_trivial</span></a></code> tactic.
Each of these steps makes it easier to work with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span></code>, but none are strictly necessary; there's no need to immediately implement all steps for every type.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="doc-comment token" data-binding="">/-- A homogeneous pair -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-1710">structure</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-1731" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-1739">where</span>
  <span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
  <span class="const token" data-binding="const-Pair.snd" data-verso-hover="291">snd</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>

<span class="doc-comment token" data-binding="">/-- Mapping a function over the elements of a pair -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1822">def</span> <span class="const token" data-binding="const-Pair.map" data-verso-hover="1224" id="Pair___fst">Pair.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.405" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.395" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.401" data-verso-hover="114">β</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.408" data-verso-hover="1225">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.395" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.401" data-verso-hover="114">β</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-1875">where</span>
  <span class="const token" data-binding="const-Pair.fst" data-verso-hover="1226">fst</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.405" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.408" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span>
  <span class="const token" data-binding="const-Pair.snd" data-verso-hover="1226">snd</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.405" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.408" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="291">snd</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Defining a nested inductive data type of binary trees that uses <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span></code> and attempting to define its <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">map</span></code> function demonstrates the need for preprocessing rules.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="doc-comment token" data-binding="">/-- A binary tree defined using `Pair` -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-2154" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-2175" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-2183">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1229">leaf</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.node" data-verso-hover="1230" id="Tree___node">node</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
<span class="unknown token" data-binding=""></span></code><p>
                  A straightforward definition of the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">map</span></code> function fails:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2388">def</span> <span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">Tree.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="114">β</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="114">β</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1229">leaf</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1229">leaf</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="1231">p</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1231">p</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2491">fun</span> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="1097">t'</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
α : Type u_1
p : Pair (Tree α)
t' : Tree α
⊢ sizeOf t' &lt; 1 + sizeOf p</code></span></span><span class="var token" data-binding="var-_uniq.74" data-verso-hover="1097">t'</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">map</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-2512" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.156" data-verso-hover="1097">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.156" data-verso-hover="1097">t</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
α : Type u_1
p : Pair (Tree α)
t' : Tree α
⊢ sizeOf t' &lt; 1 + sizeOf p
</pre></div>
                <div class="paragraph">
                  <p>
                    Clearly the proof obligation is not solvable, because nothing connects <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1097">t'</span></code> to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.46" data-verso-hover="1231">p</span></code>.</p>
                  </div>
                <p>
                  The standard idiom to enable this kind of function definition is to have a function that enriches each element of a collection with a proof that they are, in fact, elements of the collection.
Stating this property requires a membership predicate.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-3402" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Pair.Mem" data-verso-hover="1232" id="Pair___Mem___snd">Pair.Mem</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1225">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span> <span class="keyword token" data-binding="kw-occ-null-3449">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Pair.Mem.fst" data-verso-hover="1233" id="Pair___Mem___snd">fst</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem" data-verso-hover="1232">Mem</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1225">p</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Pair.Mem.snd" data-verso-hover="1234" id="Pair___Mem___snd">snd</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem" data-verso-hover="1232">Mem</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1225">p</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="291">snd</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-3500">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Membership" data-verso-hover="1235">Membership</span> <span class="var token" data-binding="var-_uniq.66" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.66" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-3535">where</span>
  <span class="const token" data-binding="const-Membership.mem" data-verso-hover="1236">mem</span> <span class="unknown token" data-binding="">:=</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem" data-verso-hover="1232">Pair.Mem</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                  Every inductive type automatically has a <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a></code> instance.
An element of a collection should be smaller than the collection, but this fact must be proved before it can be used to construct a termination proof:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-3790">theorem</span> <span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1237" id="Pair___sizeOf_lt_of_mem">Pair.sizeOf_lt_of_mem</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span><span class="unknown token" data-binding="">]</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.61" data-verso-hover="1238">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">∈</span> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">&lt;</span> <a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-11162777865742542912-3907-3909"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3907" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11162777865742542912-3907-3909"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1239">inst✝</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.61" data-verso-hover="1238">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="46">x</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-2905430778187623168-3912-3919"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-3912" data-verso-hover="317">cases</span></a> <span class="var token" data-binding="var-_uniq.61" data-verso-hover="1238">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2905430778187623168-3912-3919"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-127" checked="checked"><span for="--verso-unique-127" class="goal-name">fst</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1239">inst✝</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span>.<span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-128"><span for="--verso-unique-128" class="goal-name">snd</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1239">inst✝</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span>.<span class="const token" data-binding="const-Pair.snd" data-verso-hover="291">snd</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-2905430778187623168-3920-3923"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2905430778187623168-3920-3923"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-129" checked="checked"><span for="--verso-unique-129" class="goal-name">fst</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1239">inst✝</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span>.<span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-130"><span for="--verso-unique-130" class="goal-name">snd</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1239">inst✝</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span>.<span class="const token" data-binding="const-Pair.snd" data-verso-hover="291">snd</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-1649387713332237444-3924-3931"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-3924" data-verso-hover="317">cases</span></a> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="1225">p</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1649387713332237444-3924-3931"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-131" checked="checked"><span for="--verso-unique-131" class="goal-name">snd.mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1239">inst✝</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fst✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">snd✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="818">fst</span> := <span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="818">snd</span> := <span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">snd✝</span> }.<span class="const token" data-binding="const-Pair.snd" data-verso-hover="291">snd</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="818">fst</span> := <span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="818">snd</span> := <span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">snd✝</span> }</span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-11597370642967046733-3932-3935"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11597370642967046733-3932-3935"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-132" checked="checked"><span for="--verso-unique-132" class="goal-name">fst.mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1239">inst✝</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.233" data-verso-hover="46">fst✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.234" data-verso-hover="46">snd✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="818">fst</span> := <span class="var token" data-binding="var-_uniq.233" data-verso-hover="46">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="818">snd</span> := <span class="var token" data-binding="var-_uniq.234" data-verso-hover="46">snd✝</span> }.<span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="818">fst</span> := <span class="var token" data-binding="var-_uniq.233" data-verso-hover="46">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="818">snd</span> := <span class="var token" data-binding="var-_uniq.234" data-verso-hover="46">snd✝</span> }</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-133"><span for="--verso-unique-133" class="goal-name">snd.mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1239">inst✝</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fst✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">snd✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="818">fst</span> := <span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="818">snd</span> := <span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">snd✝</span> }.<span class="const token" data-binding="const-Pair.snd" data-verso-hover="291">snd</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="818">fst</span> := <span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="818">snd</span> := <span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">snd✝</span> }</span></span></span></span></span></span> <span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-11220709837769981134-3937-3941"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-3937" data-verso-hover="36">simp</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11220709837769981134-3937-3941"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-134" checked="checked"><span for="--verso-unique-134" class="goal-name">snd.mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1239">inst✝</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fst✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.273" data-verso-hover="46">snd✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">fst✝</span></span></span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-3943-3948"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-3943" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3943-3948"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  The next step is to define <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240">attach</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">unattach</span></a></code> functions that enrich the elements of the pair with a proof that they are elements of the pair, or remove said proof.
Here, the type of <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">Pair.unattach</span></a></code> is more general and can be used with any <a href="Basic-Types/Subtypes/#Subtype">subtype</a>; this is a typical pattern.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4305">def</span> <span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240" id="Pair___attach">Pair.attach</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1225">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">//</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">∈</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">}</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-4362">where</span>
  <span class="const token" data-binding="const-Pair.fst" data-verso-hover="1242">fst</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="396">⟨</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span><span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="396">,</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem.fst" data-verso-hover="1233">.fst</span></a><span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="396">⟩</span>
  <span class="const token" data-binding="const-Pair.snd" data-verso-hover="1242">snd</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="396">⟨</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="291">snd</span><span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="396">,</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___Mem___snd"><span class="const token" data-binding="const-Pair.Mem.snd" data-verso-hover="1234">.snd</span></a><span class="unknown token" data-binding="const-Subtype.mk" data-verso-hover="396">⟩</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4423">def</span> <span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241" id="Pair___attach">Pair.unattach</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.84" data-verso-hover="397">P</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.80" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span>
    <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.80" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">//</span> <span class="var token" data-binding="var-_uniq.84" data-verso-hover="397">P</span> <span class="var token" data-binding="var-_uniq.91" data-verso-hover="46">x</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.80" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">Pair.map</span></a> <a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="399">Subtype.val</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                  <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">Tree.map</span></code> can now be defined by using <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240">Pair.attach</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___sizeOf_lt_of_mem"><span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1237">Pair.sizeOf_lt_of_mem</span></a></code> explicitly:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4674">def</span> <span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">Tree.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="114">β</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="114">β</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1229">leaf</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1229">leaf</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="1231">p</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1231">p</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240">attach</span></a><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-4784">fun</span> <span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.113" data-verso-hover="1097">t'</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">⟩</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.113" data-verso-hover="1097">t'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">map</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-4814" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="1097">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="1097">t</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-4836" data-verso-hover="1055">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-2670246467126758636-4852-4889"><a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-4852" data-verso-hover="1243">have</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___sizeOf_lt_of_mem"><span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1237">Pair.sizeOf_lt_of_mem</span></a> <span class="unknown token" data-binding="">‹</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">›</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2670246467126758636-4852-4889"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.396" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.471" data-verso-hover="1231">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> (<span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.396" data-verso-hover="44">α</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.492" data-verso-hover="1097">t'</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.396" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.493" data-verso-hover="1244">property✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.492" data-verso-hover="1097">t'</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="var token" data-binding="var-_uniq.471" data-verso-hover="1231">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1118" data-verso-hover="1245">this</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.492" data-verso-hover="1097">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.471" data-verso-hover="1231">p</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.492" data-verso-hover="1097">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> (<a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="var token" data-binding="var-_uniq.471" data-verso-hover="1231">p</span>)</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-13514754877619840520-4892-4907"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-4892" data-verso-hover="557">simp_all</span></a> <span class="unknown token" data-binding="">+</span><a href="The-Simplifier/Configuring-Simplification/#Lean___Meta___Simp___Config___mk"><span class="const token" data-binding="const-Lean.Meta.Simp.Config.arith" data-verso-hover="554">arith</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13514754877619840520-4892-4907"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.396" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.471" data-verso-hover="1231">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> (<span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.396" data-verso-hover="44">α</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.492" data-verso-hover="1097">t'</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.396" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.493" data-verso-hover="1244">property✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.492" data-verso-hover="1097">t'</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="var token" data-binding="var-_uniq.471" data-verso-hover="1231">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1118" data-verso-hover="1245">this</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.492" data-verso-hover="1097">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.471" data-verso-hover="1231">p</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.492" data-verso-hover="1097">t'</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.471" data-verso-hover="1231">p</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-4910-4915"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-4910" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-4910-4915"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                  This transformation can be made fully automatic.
The preprocessing feature of well-founded recursion can be used to automate the introduction of the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240">Pair.attach</span></a></code> function.
This is done in two stages.
First, when <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">Pair.map</span></a></code> is applied to one of the function's parameters, it is rewritten to an <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240">attach</span></a></code>/<code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">unattach</span></a></code> composition.
Then, when a function is mapped over the result of <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">Pair.unattach</span></a></code>, the function is rewritten to accept the proof of membership and bring it into scope.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">@[</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Lean___Parser___Attr___wf_preprocess"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.wf_preprocess-5467" data-verso-hover="1209">wf_preprocess</span></a><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-5482">theorem</span> <span class="const token" data-binding="const-Pair.map_wfParam" data-verso-hover="1246" id="Pair___map_unattach">Pair.map_wfParam</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="114">β</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1225">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">(</span><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1225">p</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240">attach</span></a><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">unattach</span></a><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5729436896319997653-5590-5592"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-5590" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5729436896319997653-5590-5592"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.59" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.60" data-verso-hover="114">β</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_2</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.59" data-verso-hover="44">α</span> → <span class="var token" data-binding="var-_uniq.60" data-verso-hover="114">β</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1225">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="var token" data-binding="var-_uniq.59" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> (<a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1225">p</span>)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1225">p</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240">attach</span></a>.<a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">unattach</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-4911540998890294763-5595-5602"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-5595" data-verso-hover="317">cases</span></a> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="1225">p</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4911540998890294763-5595-5602"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-138" checked="checked"><span for="--verso-unique-138" class="goal-name">mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.59" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.60" data-verso-hover="114">β</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_2</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.59" data-verso-hover="44">α</span> → <span class="var token" data-binding="var-_uniq.60" data-verso-hover="114">β</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.89" data-verso-hover="46">fst✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.59" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.90" data-verso-hover="46">snd✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.59" data-verso-hover="44">α</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> (<a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a> { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="818">fst</span> := <span class="var token" data-binding="var-_uniq.89" data-verso-hover="46">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="818">snd</span> := <span class="var token" data-binding="var-_uniq.90" data-verso-hover="46">snd✝</span> })<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="818">fst</span> := <span class="var token" data-binding="var-_uniq.89" data-verso-hover="46">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="818">snd</span> := <span class="var token" data-binding="var-_uniq.90" data-verso-hover="46">snd✝</span> }.<a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240">attach</span></a>.<a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">unattach</span></a></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-5605-5657"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-5605" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a><span class="unknown token" data-binding="">,</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.attach" data-verso-hover="1240">Pair.attach</span></a><span class="unknown token" data-binding="">,</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">Pair.unattach</span></a><span class="unknown token" data-binding="">,</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">Pair.map</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-5605-5657"><span class="tactic-state">All goals completed! 🐙</span></span>

<span class="unknown token" data-binding="">@[</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Lean___Parser___Attr___wf_preprocess"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.wf_preprocess-5661" data-verso-hover="1209">wf_preprocess</span></a><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-5676">theorem</span> <span class="const token" data-binding="const-Pair.map_unattach" data-verso-hover="1247" id="Pair___map_unattach">Pair.map_unattach</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.953" data-verso-hover="397">P</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.931" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.961" data-verso-hover="1248">p</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="395">Subtype</span></a> <span class="var token" data-binding="var-_uniq.953" data-verso-hover="397">P</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.931" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.949" data-verso-hover="114">β</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.961" data-verso-hover="1248">p</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">unattach</span></a><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">=</span>
    <span class="var token" data-binding="var-_uniq.961" data-verso-hover="1248">p</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-5798">fun</span> <span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.1056" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.1057" data-verso-hover="1220">h</span><span class="unknown token" data-binding="">⟩</span> <span class="unknown token" data-binding="">=&gt;</span>
      <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1214">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.1056" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">&lt;|</span>
      <span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">(</span><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a> <span class="var token" data-binding="var-_uniq.1056" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14294400990389434444-5867-5869"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-5867" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14294400990389434444-5867-5869"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1122" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1123" data-verso-hover="114">β</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_2</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.953" data-verso-hover="397">P</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1122" data-verso-hover="44">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.961" data-verso-hover="1248">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> (<a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="395">Subtype</span></a> <span class="var token" data-binding="var-_uniq.953" data-verso-hover="397">P</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1122" data-verso-hover="44">α</span> → <span class="var token" data-binding="var-_uniq.1123" data-verso-hover="114">β</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.961" data-verso-hover="1248">p</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">unattach</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a>
    (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1806" data-verso-hover="1249">x</span> =&gt;
      <span class="keyword token" data-binding="">match</span> <span class="var token" data-binding="var-_uniq.1806" data-verso-hover="1249">x</span> <span class="keyword token" data-binding="">with</span>
      | ⟨<span class="var token" data-binding="var-_uniq.1814" data-verso-hover="46">x</span>, <span class="var token" data-binding="var-_uniq.1815" data-verso-hover="1220">h</span>⟩ =&gt; <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1214">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.1809" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> (<span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> (<a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a> <span class="var token" data-binding="var-_uniq.1809" data-verso-hover="46">x</span>)))
    <span class="var token" data-binding="var-_uniq.961" data-verso-hover="1248">p</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-4989055143807985100-5872-5879"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-5872" data-verso-hover="317">cases</span></a> <span class="var token" data-binding="var-_uniq.961" data-verso-hover="1248">p</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4989055143807985100-5872-5879"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-140" checked="checked"><span for="--verso-unique-140" class="goal-name">mk</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1122" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1123" data-verso-hover="114">β</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_2</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.953" data-verso-hover="397">P</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1122" data-verso-hover="44">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1122" data-verso-hover="44">α</span> → <span class="var token" data-binding="var-_uniq.1123" data-verso-hover="114">β</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1153" data-verso-hover="1249">fst✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="395">Subtype</span></a> <span class="var token" data-binding="var-_uniq.953" data-verso-hover="397">P</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1154" data-verso-hover="1249">snd✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="395">Subtype</span></a> <span class="var token" data-binding="var-_uniq.953" data-verso-hover="397">P</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="1250">fst</span> := <span class="var token" data-binding="var-_uniq.1153" data-verso-hover="1249">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="1250">snd</span> := <span class="var token" data-binding="var-_uniq.1154" data-verso-hover="1249">snd✝</span> }.<a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">unattach</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a>
    (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1809" data-verso-hover="1249">x</span> =&gt;
      <span class="keyword token" data-binding="">match</span> <span class="var token" data-binding="var-_uniq.1809" data-verso-hover="1249">x</span> <span class="keyword token" data-binding="">with</span>
      | ⟨<span class="var token" data-binding="var-_uniq.1817" data-verso-hover="46">x</span>, <span class="var token" data-binding="var-_uniq.1818" data-verso-hover="1220">h</span>⟩ =&gt; <a href="Tactic-Proofs/Naming-Bound-Variables/#binderNameHint"><span class="const token" data-binding="const-binderNameHint" data-verso-hover="1214">binderNameHint</span></a> <span class="var token" data-binding="var-_uniq.1812" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> (<span class="var token" data-binding="var-_uniq.965" data-verso-hover="107">f</span> (<a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a> <span class="var token" data-binding="var-_uniq.1812" data-verso-hover="46">x</span>)))
    { <span class="const token" data-binding="const-Pair.fst" data-verso-hover="1250">fst</span> := <span class="var token" data-binding="var-_uniq.1153" data-verso-hover="1249">fst✝</span>, <span class="const token" data-binding="const-Pair.snd" data-verso-hover="1250">snd</span> := <span class="var token" data-binding="var-_uniq.1154" data-verso-hover="1249">snd✝</span> }</span></span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-5881-5920"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-5881" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><a href="Recursive-Definitions/Well-Founded-Recursion/#wfParam"><span class="const token" data-binding="const-wfParam" data-verso-hover="1207">wfParam</span></a><span class="unknown token" data-binding="">,</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___attach"><span class="const token" data-binding="const-Pair.unattach" data-verso-hover="1241">Pair.unattach</span></a><span class="unknown token" data-binding="">,</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">Pair.map</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-5881-5920"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                  Now the function body can be written without extra considerations, and the membership assumption is still available to the termination proof.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6093">def</span> <span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">Tree.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="114">β</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="114">β</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1229">leaf</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1229">leaf</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="1231">p</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1231">p</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-6196">fun</span> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="1097">t'</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="1097">t'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">map</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="107">f</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-6217" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.156" data-verso-hover="1097">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.156" data-verso-hover="1097">t</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-6239" data-verso-hover="1055">decreasing_by</span>
  <span class="tactic"><label for="tactic-state-4070206675141189674-6255-6292"><a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-6255" data-verso-hover="1243">have</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___sizeOf_lt_of_mem"><span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1237">Pair.sizeOf_lt_of_mem</span></a> <span class="unknown token" data-binding="">‹</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">›</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4070206675141189674-6255-6292"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.530" data-verso-hover="1231">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> (<span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">α</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.549" data-verso-hover="1097">t'</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.550" data-verso-hover="1244">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.549" data-verso-hover="1097">t'</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="var token" data-binding="var-_uniq.530" data-verso-hover="1231">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1175" data-verso-hover="1245">this</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.549" data-verso-hover="1097">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.530" data-verso-hover="1231">p</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.549" data-verso-hover="1097">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> (<a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="var token" data-binding="var-_uniq.530" data-verso-hover="1231">p</span>)</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-10890549830165128960-6295-6303"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-6295" data-verso-hover="557">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10890549830165128960-6295-6303"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.530" data-verso-hover="1231">p</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Pair" data-verso-hover="1223">Pair</span> (<span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">α</span>)</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.549" data-verso-hover="1097">t'</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.455" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.550" data-verso-hover="1244">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.549" data-verso-hover="1097">t'</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="var token" data-binding="var-_uniq.530" data-verso-hover="1231">p</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1175" data-verso-hover="1245">this</span></span><span class="colon">:</span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.549" data-verso-hover="1097">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.530" data-verso-hover="1231">p</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.549" data-verso-hover="1097">t'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="1138">sizeOf</span></a> <span class="var token" data-binding="var-_uniq.530" data-verso-hover="1231">p</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-6306-6311"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-6306" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-6306-6311"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                  The proof can be made fully automatic by adding <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___sizeOf_lt_of_mem"><span class="const token" data-binding="const-Pair.sizeOf_lt_of_mem" data-verso-hover="1237">sizeOf_lt_of_mem</span></a></code> to the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_trivial"><span class="keyword token" data-binding="" data-verso-hover="1148">decreasing_trivial</span></a></code> tactic, as is done for similar built-in theorems.</p>
                <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro-6507">macro</span></a> <span class="literal string token" data-binding="" data-verso-hover="1251">"sizeOf_pair_dec"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="1252">tactic</span> <span class="unknown token" data-binding="">=&gt;</span>
  <span class="unknown token" data-binding="">`(tactic|</span> <a href="Tactic-Proofs/The-Tactic-Language/#with_reducible"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.withReducible-6555" data-verso-hover="1253">with_reducible</span></a>
    <a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-6574" data-verso-hover="1243">have</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">Pair.sizeOf_lt_of_mem</span> <span class="unknown token" data-binding="">‹</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">›</span>
    <a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-6616" data-verso-hover="320">omega</span></a>
    <a href="Tactic-Proofs/Tactic-Reference/#done"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.done-6626" data-verso-hover="1254">done</span></a><span class="unknown token" data-binding="">)</span>

<a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-6633">macro_rules</span></a> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">`(tactic|</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#decreasing_trivial"><span class="keyword token" data-binding="kw-occ-tacticDecreasing_trivial-6657" data-verso-hover="1148">decreasing_trivial</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">`(tactic|</span> <span class="keyword token" data-binding="kw-occ-tacticSizeOf_pair_dec-6690">sizeOf_pair_dec</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6708">def</span> <span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">Tree.map</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1127" data-verso-hover="107">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.1117" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.1123" data-verso-hover="114">β</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.1117" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1228">Tree</span> <span class="var token" data-binding="var-_uniq.1123" data-verso-hover="114">β</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1229">leaf</span> <span class="var token" data-binding="var-_uniq.1154" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1229">leaf</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1127" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.1154" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="var token" data-binding="var-_uniq.1172" data-verso-hover="1231">p</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Recursive-Definitions/Well-Founded-Recursion/#Tree___node"><span class="const token" data-binding="const-Tree.node" data-verso-hover="1230">node</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1172" data-verso-hover="1231">p</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#Pair___fst"><span class="const token" data-binding="const-Pair.map" data-verso-hover="1224">map</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-6811">fun</span> <span class="var token" data-binding="var-_uniq.1186" data-verso-hover="1097">t'</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1186" data-verso-hover="1097">t'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Tree.map" data-verso-hover="1227">map</span> <span class="var token" data-binding="var-_uniq.1127" data-verso-hover="107">f</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-6832" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.1268" data-verso-hover="1097">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1268" data-verso-hover="1097">t</span>
<span class="unknown token" data-binding=""></span></code><p>
                  To keep the example short, the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">sizeOf_pair_dec</span></code> tactic is tailored to this particular recursion pattern and isn't really general enough for a general-purpose container library.
It does, however, demonstrate that libraries can be just as convenient in practice as the container types in the standard library.</p>
                </details></section>
            <section>
              <h2 id="The-Lean-Language-Reference--Recursive-Definitions--Well-Founded-Recursion--Theory-and-Construction">
                6.3.7. Theory and Construction</h2>
              <p>
                This section gives a very brief glimpse into the mathematical constructions that underlie termination proofs via <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-recursion-next">well-founded recursion</a>, which may surface occasionally.
The elaboration of functions defined by well-founded recursion is based on the <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">WellFounded.fix</span></a></code> operator.</p>
              <div class="namedocs" id="WellFounded___fix">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=WellFounded.fix" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block">WellFounded.fix.{u, v} {<span class="var token" data-binding="var-_uniq.2756" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>}
  {<span class="var token" data-binding="var-_uniq.2758" data-verso-hover="97">C</span> : <span class="var token" data-binding="var-_uniq.2756" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="96">Sort v</span>} {<span class="var token" data-binding="var-_uniq.2762" data-verso-hover="423">r</span> : <span class="var token" data-binding="var-_uniq.2756" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.2756" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>}
  (<span class="var token" data-binding="var-_uniq.2763" data-verso-hover="1256">hwf</span> : <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="1136">WellFounded</span></a> <span class="var token" data-binding="var-_uniq.2762" data-verso-hover="423">r</span>)
  (<span class="var token" data-binding="var-_uniq.2770" data-verso-hover="1257">F</span> : (<span class="var token" data-binding="var-_uniq.2765" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.2756" data-verso-hover="95">α</span>) → ((<span class="var token" data-binding="var-_uniq.2768" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.2756" data-verso-hover="95">α</span>) → <span class="var token" data-binding="var-_uniq.2762" data-verso-hover="423">r</span> <span class="var token" data-binding="var-_uniq.2768" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.2765" data-verso-hover="46">x</span> → <span class="var token" data-binding="var-_uniq.2758" data-verso-hover="97">C</span> <span class="var token" data-binding="var-_uniq.2768" data-verso-hover="46">y</span>) → <span class="var token" data-binding="var-_uniq.2758" data-verso-hover="97">C</span> <span class="var token" data-binding="var-_uniq.2765" data-verso-hover="46">x</span>)
  (<span class="var token" data-binding="var-_uniq.2771" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.2756" data-verso-hover="95">α</span>) : <span class="var token" data-binding="var-_uniq.2758" data-verso-hover="97">C</span> <span class="var token" data-binding="var-_uniq.2771" data-verso-hover="46">x</span></pre><div class="text"></div>
                </div>
              <p>
                The type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2773" data-verso-hover="55">α</span></code> is instantiated with the function's (varying) parameters, packed into one type using <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Tuples/#PSigma___mk"><span class="const token" data-binding="const-PSigma" data-verso-hover="1258">PSigma</span></a></code>.
The <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="1136">WellFounded</span></a></code> relation is constructed from the termination <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-measure-next">measure</a> via <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#invImage"><span class="const token" data-binding="const-invImage" data-verso-hover="1194">invImage</span></a></code>.</p>
              <div class="namedocs" id="invImage">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=invImage" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block">invImage.{u_1, u_2} {<span class="var token" data-binding="var-_uniq.2793" data-verso-hover="165">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u_1</span>}
  {<span class="var token" data-binding="var-_uniq.2794" data-verso-hover="223">β</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u_2</span>} (<span class="var token" data-binding="var-_uniq.2796" data-verso-hover="107">f</span> : <span class="var token" data-binding="var-_uniq.2793" data-verso-hover="165">α</span> → <span class="var token" data-binding="var-_uniq.2794" data-verso-hover="223">β</span>)
  (<span class="var token" data-binding="var-_uniq.2797" data-verso-hover="1259">h</span> : <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="1132">WellFoundedRelation</span></a> <span class="var token" data-binding="var-_uniq.2794" data-verso-hover="223">β</span>) :
  <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="1132">WellFoundedRelation</span></a> <span class="var token" data-binding="var-_uniq.2793" data-verso-hover="165">α</span></pre><div class="text"></div>
                </div>
              <p>
                The function's body is passed to <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">WellFounded.fix</span></a></code>, with parameters suitably packed and unpacked, and recursive calls are replaced with a call to the value provided by <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">WellFounded.fix</span></a></code>.
The termination proofs generated by the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">decreasing_by</code></span> tactics are inserted in the right place.</p>
              <p>
                Finally, the equational and unfolding theorems for the recursive function are proved from <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-WellFounded.fix_eq" data-verso-hover="1260">WellFounded.fix_eq</span></code>.
These theorems hide the details of packing and unpacking arguments and describe the function's behavior in terms of the original definition.</p>
              <p>
                In the case of mutual recursion, an equivalent non-mutual function is constructed by combining the function's arguments using <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Sum-Types/#PSum___inl"><span class="const token" data-binding="const-PSum" data-verso-hover="1261">PSum</span></a></code>, and pattern-matching on that sum type in the result type and the body.</p>
              <p>
                The definition of <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="1136">WellFounded</span></a></code> builds on the notion of <em>accessible elements</em> of the relation:</p>
              <div class="namedocs" id="WellFounded___intro">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=WellFounded" title="Permalink">🔗</a></span><span class="label">inductive predicate</span><pre class="signature hl lean block">WellFounded.{u} {<span class="var token" data-binding="var-_uniq.2921" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>}
  (<span class="var token" data-binding="var-_uniq.2925" data-verso-hover="423">r</span> : <span class="var token" data-binding="var-_uniq.2921" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.2921" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>) : <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></pre><div class="text">
                  <p>
                    A relation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2895" data-verso-hover="423">r</span></code> is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="1136">WellFounded</span></a></code> if all elements of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2894" data-verso-hover="95">α</span></code> are accessible within <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2895" data-verso-hover="423">r</span></code>.
If a relation is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="1136">WellFounded</span></a></code>, it does not allow for an infinite descent along the relation.</p>
                  <p>
                    If the arguments of the recursive calls in a function definition decrease according to
a well founded relation, then the function terminates.
Well-founded relations are sometimes called <em>Artinian</em> or said to satisfy the “descending chain condition”.</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">intro.{u} {<span class="var token" data-binding="var-_uniq.2912" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>} {<span class="var token" data-binding="var-_uniq.2916" data-verso-hover="423">r</span> : <span class="var token" data-binding="var-_uniq.2912" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.2912" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>}
  (<span class="var token" data-binding="var-_uniq.2918" data-verso-hover="1262">h</span> : ∀ (<span class="var token" data-binding="var-_uniq.2917" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.2912" data-verso-hover="95">α</span>), <a href="Recursive-Definitions/Well-Founded-Recursion/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1263">Acc</span></a> <span class="var token" data-binding="var-_uniq.2916" data-verso-hover="423">r</span> <span class="var token" data-binding="var-_uniq.2917" data-verso-hover="46">a</span>) : <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___intro"><span class="const token" data-binding="const-WellFounded" data-verso-hover="1136">WellFounded</span></a> <span class="var token" data-binding="var-_uniq.2916" data-verso-hover="423">r</span></pre><div class="docs"></div>
                    </div>
                  </div>
                </div>
              <div class="namedocs" id="Acc___intro">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Acc.intro" title="Permalink">🔗</a></span><span class="label">inductive predicate</span><pre class="signature hl lean block">Acc.{u} {<span class="var token" data-binding="var-_uniq.3011" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>} (<span class="var token" data-binding="var-_uniq.3015" data-verso-hover="423">r</span> : <span class="var token" data-binding="var-_uniq.3011" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.3011" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>) :
  <span class="var token" data-binding="var-_uniq.3011" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1263">Acc</span></a></code> is the accessibility predicate. Given some relation <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2927" data-verso-hover="423">r</span></code> (e.g. <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">&lt;</span></code>) and a value <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2966" data-verso-hover="1264">x</span></code>,
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Well-Founded-Recursion/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1263">Acc</span></a> <span class="var token" data-binding="var-_uniq.2927" data-verso-hover="423">r</span> <span class="var token" data-binding="var-_uniq.2966" data-verso-hover="46">x</span></code> means that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2966" data-verso-hover="46">x</span></code> is accessible through <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.2927" data-verso-hover="423">r</span></code>:</p>
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">x</span></code> is accessible if there exists no infinite sequence <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">...</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">y₂</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">y₁</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">y₀</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">x</span></code>.</p>
                  <h1>
                    Constructors</h1>
                  <div class="constructor">
                    <pre class="name-and-type hl lean">intro.{u} {<span class="var token" data-binding="var-_uniq.2998" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>} {<span class="var token" data-binding="var-_uniq.3002" data-verso-hover="423">r</span> : <span class="var token" data-binding="var-_uniq.2998" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.2998" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>} (<span class="var token" data-binding="var-_uniq.3003" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.2998" data-verso-hover="95">α</span>)
  (<span class="var token" data-binding="var-_uniq.3007" data-verso-hover="1265">h</span> : ∀ (<span class="var token" data-binding="var-_uniq.3005" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.2998" data-verso-hover="95">α</span>), <span class="var token" data-binding="var-_uniq.3002" data-verso-hover="423">r</span> <span class="var token" data-binding="var-_uniq.3005" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.3003" data-verso-hover="46">x</span> → <a href="Recursive-Definitions/Well-Founded-Recursion/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1263">Acc</span></a> <span class="var token" data-binding="var-_uniq.3002" data-verso-hover="423">r</span> <span class="var token" data-binding="var-_uniq.3005" data-verso-hover="46">y</span>) : <a href="Recursive-Definitions/Well-Founded-Recursion/#Acc___intro"><span class="const token" data-binding="const-Acc" data-verso-hover="1263">Acc</span></a> <span class="var token" data-binding="var-_uniq.3002" data-verso-hover="423">r</span> <span class="var token" data-binding="var-_uniq.3003" data-verso-hover="46">x</span></pre><div class="docs">
                      <p>
                        A value is accessible if for all <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3037" data-verso-hover="1266">y</span></code> such that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3022" data-verso-hover="423">r</span> <span class="var token" data-binding="var-_uniq.3037" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.3023" data-verso-hover="46">x</span></code>, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3037" data-verso-hover="46">y</span></code> is also accessible.
Note that if there exists no <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3037" data-verso-hover="46">y</span></code> such that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3022" data-verso-hover="423">r</span> <span class="var token" data-binding="var-_uniq.3037" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.3023" data-verso-hover="46">x</span></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3023" data-verso-hover="46">x</span></code> is accessible. Such an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3023" data-verso-hover="46">x</span></code> is called a
<em>base case</em>.</p>
                      </div>
                    </div>
                  </div>
                </div>
              <details class="example"><summary class="description">Division by Iterated Subtraction: Termination Proof</summary><p>
                  The definition of division by iterated subtraction can be written explicitly using well-founded recursion.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-34391">noncomputable</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34405">def</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="unknown token" data-binding="">(</span><a href="Type-Classes/Instance-Synthesis/#inferInstanceAs"><span class="const token" data-binding="const-inferInstanceAs" data-verso-hover="1267">inferInstanceAs</span></a> <span class="unknown token" data-binding="">(</span><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation" data-verso-hover="1132">WellFoundedRelation</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.wf" data-verso-hover="1268">wf</span></a><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a>
    <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-34492">fun</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="1269">r</span> <span class="unknown token" data-binding="">=&gt;</span>
      <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34509" data-verso-hover="1150">if</span></a> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="7">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34509" data-verso-hover="1150">then</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
      <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34509" data-verso-hover="1150">else</span></a> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34540" data-verso-hover="1150">if</span></a> <span class="var token" data-binding="var-_uniq.126" data-verso-hover="1270">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34540" data-verso-hover="1150">then</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
      <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-34540" data-verso-hover="1150">else</span></a> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.47" data-verso-hover="1269">r</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;|</span> <span class="tactic"><label for="tactic-state-6123568496740839887-34589-34591"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-34589" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6123568496740839887-34589-34591"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.47" data-verso-hover="1269">r</span></span><span class="colon">:</span><span class="type">(<span class="var token" data-binding="var-_uniq.700" data-verso-hover="7">y</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) → <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="1137">WellFoundedRelation.rel</span></a> <span class="var token" data-binding="var-_uniq.700" data-verso-hover="7">y</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> → <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.87" data-verso-hover="1271">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.126" data-verso-hover="1272">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="1137">WellFoundedRelation.rel</span></a> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span></span></span></span></span>
        <span class="tactic"><label for="tactic-state-562362637243721925-34600-34616"><a href="Tactic-Proofs/Tactic-Reference/#show"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticShow_-34600" data-verso-hover="1274">show</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-562362637243721925-34600-34616"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.47" data-verso-hover="1269">r</span></span><span class="colon">:</span><span class="type">(<span class="var token" data-binding="var-_uniq.700" data-verso-hover="7">y</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>) → <a href="Recursive-Definitions/Well-Founded-Recursion/#WellFoundedRelation___mk"><span class="const token" data-binding="const-WellFoundedRelation.rel" data-verso-hover="1137">WellFoundedRelation.rel</span></a> <span class="var token" data-binding="var-_uniq.700" data-verso-hover="7">y</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span> → <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.87" data-verso-hover="1271">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.126" data-verso-hover="1272">h</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.44" data-verso-hover="7">n</span></span></span></span></span></span>
        <span class="tactic"><label for="tactic-state-7-34625-34630"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-34625" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-34625-34630"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
    <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                  The definition must be marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">noncomputable</code></span> because well-founded recursion is not supported by the compiler.
Like <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-recursor">recursors</a>, it is part of Lean's logic.</p>
                <p>
                  The definition of division should satisfy the following equations:</p>
                <ul>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3041" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3043" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3043" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.3041" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3043" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code></p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3092" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3094" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3094" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.3092" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.3092" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3094" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code></p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">∀</span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3125" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3127" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3127" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">≠</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">¬</span> <span class="var token" data-binding="var-_uniq.3127" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.3125" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.3125" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.3127" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3125" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.3127" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.3127" data-verso-hover="7">k</span></code></p>
                    </li>
                  </ul>
                <p>
                  This reduction behavior does not hold <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally</a>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-35248">theorem</span> <span class="const token" data-binding="const-div.eq0" data-verso-hover="1275">div.eq0</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">n</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-16048844254252543128-35281-35283"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35281" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16048844254252543128-35281-35283"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span> <span class="tactic"><label for="tactic-state-16048844254252543128-35284-35287"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">tactic 'rfl' failed, the left-hand side
  div n 0
is not definitionally equal to the right-hand side
  0
n : Nat
⊢ div n 0 = 0</code></span></span><a href="Tactic-Proofs/Tactic-Reference/#rfl"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-35284" data-verso-hover="14">rfl</span></a></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16048844254252543128-35284-35287"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>tactic 'rfl' failed, the left-hand side
  div n 0
is not definitionally equal to the right-hand side
  0
n : Nat
⊢ div n 0 = 0
</pre></div>
                <p>
                  However, using <code>WellFounded.fix_eq</code> to unfold the well-founded recursion, the three equations can be proved to hold:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-35571">theorem</span> <span class="const token" data-binding="const-div.eq0" data-verso-hover="1275">div.eq0</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">n</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-16048844254252543128-35604-35606"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35604" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16048844254252543128-35604-35606"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-9272815418967193455-35609-35619"><a href="Tactic-Proofs/Tactic-Reference/#unfold"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-35609" data-verso-hover="662">unfold</span></a> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9272815418967193455-35609-35619"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.114" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : 0<span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.114" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a>0<a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-35622-35646"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-35622" data-verso-hover="583">apply</span></a> <span class="const token" data-binding="const-WellFounded.fix_eq" data-verso-hover="1260">WellFounded.fix_eq</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-35622-35646"><span class="tactic-state">All goals completed! 🐙</span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-35648">theorem</span> <span class="const token" data-binding="const-div.eq1" data-verso-hover="1277" id="div___eq2">div.eq1</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.97" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.97" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-11373898136684331310-35691-35693"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35691" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11373898136684331310-35691-35693"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span> → <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-5524542083330933753-35696-35703"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-35696" data-verso-hover="553">intro</span></a> <span class="var token" data-binding="var-_uniq.156" data-verso-hover="1270">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5524542083330933753-35696-35703"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.156" data-verso-hover="1270">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-5281802905599946919-35706-35716"><a href="Tactic-Proofs/Tactic-Reference/#unfold"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-35706" data-verso-hover="662">unfold</span></a> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5281802905599946919-35706-35716"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.156" data-verso-hover="1270">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1527" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1529" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.1527" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.1529" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1527" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-3841901739452284216-35719-35742"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-35719" data-verso-hover="1278">rw</span></a> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-WellFounded.fix_eq" data-verso-hover="1260">WellFounded.fix_eq</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3841901739452284216-35719-35742"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.156" data-verso-hover="1270">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">(<span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0
  <span class="keyword token" data-binding="">else</span>
    <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0
    <span class="keyword token" data-binding="">else</span>
      1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> +
        </span></a>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1528" data-verso-hover="7">y</span> <span class="var token" data-binding="var-_uniq.1530" data-verso-hover="1279">x</span> =&gt; <span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1553" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1555" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.1553" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.1555" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1553" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <span class="var token" data-binding="var-_uniq.1528" data-verso-hover="7">y</span>)
          <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-6448636935334857555-35745-35808"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-35745" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-35750">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-gt_iff_lt" data-verso-hover="1280">gt_iff_lt</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-dite_eq_ite" data-verso-hover="1281">dite_eq_ite</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-ite_eq_left_iff" data-verso-hover="1282">ite_eq_left_iff</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-Nat.not_lt" data-verso-hover="1283">Nat.not_lt</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6448636935334857555-35745-35808"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.156" data-verso-hover="1270">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 →
  <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span> → 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1542" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1544" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1542" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.1544" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1542" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-14433569818633920701-35811-35817"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-35811" data-verso-hover="309">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14433569818633920701-35811-35817"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.156" data-verso-hover="1270">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1418" data-verso-hover="1271">a✝¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1419" data-verso-hover="1284">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1539" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1541" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1539" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.1541" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1539" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.154" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-35819-35824"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-35819" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-35819-35824"><span class="tactic-state">All goals completed! 🐙</span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-35826">theorem</span> <span class="const token" data-binding="const-div.eq2" data-verso-hover="1285" id="div___eq2">div.eq2</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">¬</span> <span class="var token" data-binding="var-_uniq.1512" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">¬</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1512" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&gt;</span> <span class="var token" data-binding="var-_uniq.1541" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
    <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.1541" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1512" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1541" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.1512" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.1512" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12080849374528670257-35911-35913"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-35911" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12080849374528670257-35911-35913"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 → <a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span> → <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-9087902931092027910-35916-35922"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-35916" data-verso-hover="309">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9087902931092027910-35916-35922"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1694" data-verso-hover="1271">a✝¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1695" data-verso-hover="1272">a✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div" data-verso-hover="1131">div</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-3915808598307981313-35925-35935"><a href="Tactic-Proofs/Tactic-Reference/#unfold"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-35925" data-verso-hover="662">unfold</span></a> <span class="const token" data-binding="const-div" data-verso-hover="1131">div</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3915808598307981313-35925-35935"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1694" data-verso-hover="1271">a✝¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1695" data-verso-hover="1272">a✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4346" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4348" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.4346" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4348" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.4346" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4401" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4403" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.4401" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4403" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.4401" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-11789007566504494152-35938-35961"><a href="Tactic-Proofs/Tactic-Reference/#rw"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-35938" data-verso-hover="1278">rw</span></a> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-WellFounded.fix_eq" data-verso-hover="1260">WellFounded.fix_eq</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11789007566504494152-35938-35961"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1694" data-verso-hover="1271">a✝¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1695" data-verso-hover="1272">a✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">(<span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0
  <span class="keyword token" data-binding="">else</span>
    <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0
    <span class="keyword token" data-binding="">else</span>
      1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> +
        </span></a>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4347" data-verso-hover="7">y</span> <span class="var token" data-binding="var-_uniq.4349" data-verso-hover="1279">x</span> =&gt; <span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4372" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4374" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.4372" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4374" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.4372" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <span class="var token" data-binding="var-_uniq.4347" data-verso-hover="7">y</span>)
          <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4431" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4433" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0 <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><span class="const token" data-binding="const-GT.gt" data-verso-hover="1273"> &gt; </span><span class="var token" data-binding="var-_uniq.4431" data-verso-hover="7">n</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4433" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.4431" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-9518192396337109289-35964-36071"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-35964" data-verso-hover="557">simp_all</span></a> <span class="keyword token" data-binding="kw-occ-null-35973">only</span> <span class="unknown token" data-binding="">[</span>
    <span class="const token" data-binding="const-gt_iff_lt" data-verso-hover="1280">gt_iff_lt</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-Nat.not_lt" data-verso-hover="1283">Nat.not_lt</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-dite_false" data-verso-hover="1286">dite_false</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-dite_eq_ite" data-verso-hover="1281">dite_eq_ite</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-ite_false" data-verso-hover="1287">ite_false</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-ite_eq_right_iff" data-verso-hover="1288">ite_eq_right_iff</span>
  <span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9518192396337109289-35964-36071"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1694" data-verso-hover="1271">a✝¹</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4235" data-verso-hover="1284">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span> → 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="const token" data-binding="const-div.proof_1" data-verso-hover="1276">proof_1</span>.<a href="Recursive-Definitions/Well-Founded-Recursion/#WellFounded___fix"><span class="const token" data-binding="const-WellFounded.fix" data-verso-hover="1255">fix</span></a> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4359" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4361" data-verso-hover="1269">r</span> =&gt; <span class="keyword token" data-binding="">if</span> h : <span class="var token" data-binding="var-_uniq.4359" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span> <span class="keyword token" data-binding="">then</span> 0 <span class="keyword token" data-binding="">else</span> 1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a><span class="var token" data-binding="var-_uniq.4361" data-verso-hover="1269">r</span> <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.4359" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a> ⋯) <a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">(</span></a><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504"> - </span></a><span class="var token" data-binding="var-_uniq.1691" data-verso-hover="7">k</span><a href="Type-Classes/Basic-Classes/#HSub___mk"><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="504">)</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-36074-36079"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-36074" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-36074-36079"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></details></section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Recursive-Definitions/Structural-Recursion/#structural-recursion" rel="prev" title="6.2. Structural Recursion"><span class="arrow">←</span><span class="where">6.2. Structural Recursion</span></a><a class="local-button active" href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint" rel="next" title="6.4. Partial Fixpoint Recursion"><span class="where">6.4. Partial Fixpoint Recursion</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

