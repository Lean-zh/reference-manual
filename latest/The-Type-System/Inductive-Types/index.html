<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Inductive Types</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 5%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
dl.toml-table-field-spec {
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
div.planned {
  font-style: italic;
}
div.planned .label {
  font-size: large;
  text-align: center;
  font-family: var(--verso-structure-font-family);
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: larger;
  margin-top: 0;
  margin-left: 1.5em;
  margin-right: 1.5em;
  margin-bottom: 0.5em;
  display: inline-block;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>.example {
  padding: 1.5em;
  border: 1px solid #98B2C0;
  border-radius: 0.5em;
  margin-bottom: 0.75em;
  margin-top: 0.75em;
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example p:last-child {margin-bottom:0;}
.example .description::before {
  content: "Example: ";
}
.example[open] .description {
  margin-bottom: 1em;
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 2px #99b3c0;
  background-color: #99b3c0;
  padding-left: 1px;
  padding-right: 1px;
  padding-bottom: 1px;
  padding-top: 1.5rem;
  margin-bottom: 1rem;
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  background-color: white;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 1.5rem;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: 1.5rem !important;
  margin-right: 1.5rem;
}

.namedocs .label {
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  right: 0.5rem;
  top: 0.5rem;
}

/* Sticking content into the right margin is not good on narrow screens,
   so move the label to the left to make space for the permalink widget. */

@media screen and (max-width: 700px) {
  .namedocs:has(.permalink-widget.block) .label {
    right: 1.5rem;
  }
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold;
}

.namedocs > .text .constructor {
  padding-left: 0.5rem;
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: 1.5rem;
}
.namedocs .text > :last-child {
  margin-bottom: 1.5rem;
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="current numbered"><td class="num">3.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files/#The-Lean-Language-Reference--Source-Files">Source Files</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="Output-from-Lean/#The-Lean-Language-Reference--Output-from-Lean">Output from Lean</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Elan/#elan">Elan</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-type-system" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-type-system" checked="checked"></label><span class="number">3.</span> <span class=""><a href="The-Type-System/#type-system">The Type System</a></span></div>
              <table><tr class="numbered"><td class="num">3.1.</td><td><a href="The-Type-System/Functions/#functions">Functions</a></td></tr><tr class="numbered"><td class="num">3.2.</td><td><a href="The-Type-System/Propositions/#propositions">Propositions</a></td></tr><tr class="numbered"><td class="num">3.3.</td><td><a href="The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes">Universes</a></td></tr><tr class="current numbered"><td class="num">3.4.</td><td><a href="The-Type-System/Inductive-Types/#inductive-types">Inductive Types</a></td></tr><tr class="numbered"><td class="num">3.5.</td><td><a href="The-Type-System/Quotients/#quotients">Quotients</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-inductive-types" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-inductive-types" checked="checked"></label><span class="number">3.4.</span> <span class="current"><a href="The-Type-System/Inductive-Types/#inductive-types">Inductive Types</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="The-Type-System/Inductive-Types/#inductive-declarations">Inductive Type Declarations</a></span></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#Lean___Parser___Command___declaration"><span class="syntax"><span class="keyword">inductive</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">where</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">)*</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">deriving</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="The-Type-System/Inductive-Types/#inductive-datatypes-parameters-and-indices">Parameters and Indices</a></span></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#inductive___autoPromoteIndices"><code>inductive.autoPromoteIndices</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="The-Type-System/Inductive-Types/#example-inductive-types">Example Inductive Types</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.3.</span> <a href="The-Type-System/Inductive-Types/#anonymous-constructor-syntax">Anonymous Constructor Syntax</a></span></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#Lean___Parser___Term___anonymousCtor"><span class="syntax"><span class="keyword">⟨</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">⟩</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.4.</span> <a href="The-Type-System/Inductive-Types/#inductive-declarations-deriving-instances">Deriving Instances</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="The-Type-System/Inductive-Types/#structures">Structure Declarations</a></span></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#Lean___Parser___Command___declaration-next"><span class="syntax"><span class="keyword">structure</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">extends</span><span class="ws"> </span><span class="meta">(</span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">)?</span><span class="meta">…</span><span class="meta">),*</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">where</span><span class="ws"> </span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">::</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">deriving</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="The-Type-System/Inductive-Types/#structure-params">Structure Parameters</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.2.</span> <a href="The-Type-System/Inductive-Types/#structure-fields">Fields</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.3.</span> <a href="The-Type-System/Inductive-Types/#structure-constructors">Structure Constructors</a></span></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#Lean___Parser___Term___structInst"><span class="syntax"><span class="keyword">{</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">}</span></span></a></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#Lean___Parser___Term___structInstField"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#Lean___Parser___Term___structInstField-next"><span class="syntax"><span class="meta">…</span></span></a></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#Lean___Parser___Term___structInst-next"><span class="syntax"><span class="keyword">{</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">with</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="keyword">}</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.4.</span> <a href="The-Type-System/Inductive-Types/#structure-inheritance">Structure Inheritance</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="The-Type-System/Inductive-Types/#inductive-types-logical-model">Logical Model</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.1.</span> <a href="The-Type-System/Inductive-Types/#recursors">Recursors</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.1.1.</span> <a href="The-Type-System/Inductive-Types/#recursor-types">Recursor Types</a></span></li>
                <li>
                  <span class="header head-4"><span class="level-num">3.1.1.1.</span> <a href="The-Type-System/Inductive-Types/#subsingleton-elimination">Subsingleton Elimination</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.1.2.</span> <a href="The-Type-System/Inductive-Types/#iota-reduction">Reduction</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.2.</span> <a href="The-Type-System/Inductive-Types/#well-formed-inductives">Well-Formedness Requirements</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.2.1.</span> <a href="The-Type-System/Inductive-Types/#The-Lean-Language-Reference--The-Type-System--Inductive-Types--Logical-Model--Well-Formedness-Requirements--Universe-Levels">Universe Levels</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.2.2.</span> <a href="The-Type-System/Inductive-Types/#strict-positivity">Strict Positivity</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.2.3.</span> <a href="The-Type-System/Inductive-Types/#prop-vs-type">Prop vs Type</a></span></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#bootstrap___inductiveCheckResultingUniverse"><code>bootstrap.inductiveCheckResultingUniverse</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.3.</span> <a href="The-Type-System/Inductive-Types/#recursor-elaboration-helpers">Constructions for Termination Checking</a></span></li>
                <li>
                  <a href="The-Type-System/Inductive-Types/#SizeOf___mk"><code>SizeOf</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="The-Type-System/Inductive-Types/#run-time-inductives">Run-Time Representation</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.1.</span> <a href="The-Type-System/Inductive-Types/#inductive-types-runtime-special-support">Exceptions</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.2.</span> <a href="The-Type-System/Inductive-Types/#inductive-types-runtime-relevance">Relevance</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.3.</span> <a href="The-Type-System/Inductive-Types/#inductive-types-trivial-wrappers">Trivial Wrappers</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.4.</span> <a href="The-Type-System/Inductive-Types/#inductive-types-standard-representation">Other Inductive Types</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">4.4.1.</span> <a href="The-Type-System/Inductive-Types/#inductive-types-ffi">FFI</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="The-Type-System/Inductive-Types/#mutual-inductive-types">Mutual Inductive Types</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.1.</span> <a href="The-Type-System/Inductive-Types/#mutual-inductive-types-requirements">Requirements</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">5.1.1.</span> <a href="The-Type-System/Inductive-Types/#mutual-inductive-types-dependencies">Mutual Dependencies</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">5.1.2.</span> <a href="The-Type-System/Inductive-Types/#mutual-inductive-types-same-parameters">Parameters Must Match</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">5.1.3.</span> <a href="The-Type-System/Inductive-Types/#mutual-inductive-types-same-universe">Universe Levels</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">5.1.4.</span> <a href="The-Type-System/Inductive-Types/#mutual-inductive-types-positivity">Positivity</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.2.</span> <a href="The-Type-System/Inductive-Types/#mutual-inductive-types-recursors">Recursors</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.3.</span> <a href="The-Type-System/Inductive-Types/#mutual-inductive-types-run-time">Run-Time Representation</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.4.</span> <a href="The-Type-System/Inductive-Types/#nested-inductive-types">Nested inductive types</a></span></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes" rel="prev" title="3.3. Universes"><span class="arrow">←</span><span class="where">3.3. Universes</span></a><a class="local-button active" href="The-Type-System/Quotients/#quotients" rel="next" title="3.5. Quotients"><span class="where">3.5. Quotients</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              3.4. Inductive Types<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-types" title="Permalink">🔗</a></span></h1>
            <p>
              <span id="--tech-term-Inductive-types"><em>Inductive types</em></span> are the primary means of introducing new types to Lean.
While <a class="technical-term" href="The-Type-System/Universes/#--tech-term-universes">universes</a>, <a class="technical-term" href="The-Type-System/Functions/#--tech-term-Functions">functions</a>, and <a class="technical-term" href="The-Type-System/Quotients/#--tech-term-Quotient-types">quotient types</a> are built-in primitives that could not be added by users, every other type in Lean is either an inductive type or defined in terms of universes, functions, and inductive types.
Inductive types are specified by their <span id="--tech-term-type-constructors"><em>type constructors</em></span> <span id="--index-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span> and their <span id="--tech-term-constructors"><em>constructors</em></span>; <span id="--index-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span> their other properties are derived from these.
Each inductive type has a single type constructor, which may take both <a class="technical-term" href="The-Type-System/Universes/#--tech-term-universe-parameters">universe parameters</a> and ordinary parameters.
Inductive types may have any number of constructors; these constructors introduce new values whose types are headed by the inductive type's type constructor.</p>
            <p>
              Based on the type constructor and the constructors for an inductive type, Lean derives a <span id="--tech-term-recursor"><em>recursor</em></span><span id="--index-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>.
Logically, recursors represent induction principles or elimination rules; computationally, they represent primitive recursive computations.
The termination of recursive functions is justified by translating them into uses of the recursors, so Lean's kernel only needs to perform type checking of recursor applications, rather than including a separate termination analysis.
Lean additionally produces a number of helper constructions based on the recursor,<span class="marginalia"><span class="note">The term <em>recursor</em> is always used, even for non-recursive types.</span></span> which are used elsewhere in the system.</p>
            <p>
              <em>Structures</em> are a special case of inductive types that have exactly one constructor.
When a structure is declared, Lean generates helpers that enable additional language features to be used with the new structure.</p>
            <p>
              This section describes the specific details of the syntax used to specify both inductive types and structures, the new constants and definitions in the environment that result from inductive type declarations, and the run-time representation of inductive types' values in compiled code.</p>
            <section>
              <h2 id="inductive-declarations">
                3.4.1. Inductive Type Declarations<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-declarations" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="command-next-next">
                <span class="label">syntax</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___declaration"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.declaration"><a href="Source-Files/Module-Contents#Lean___Parser___Command___declModifiers"><span class="nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code>declModifiers</span></a>
      <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.inductive"><code class="hover-info"><code class="docstring">In Lean, every concrete type other than the universes
and every type constructor other than dependent arrows
is an instance of a general family of type constructions known as inductive types.
It is remarkable that it is possible to construct a substantial edifice of mathematics
based on nothing more than the type universes, dependent arrow types, and inductive types;
everything else follows from those.
Intuitively, an inductive type is built up from a specified list of constructors.
For example, `List α` is the list of elements of type `α`, and is defined as follows:
```
inductive List (α : Type u) where
| nil
| cons (head : α) (tail : List α)
```
A list of elements of type `α` is either the empty list, `nil`,
or an element `head : α` followed by a list `tail : List α`.
See [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)
for more information.
</code></code><span class="keyword">inductive</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span> <span class="from-nonterminal" data-kind="null"><span class="keyword">where</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.ctor"><span class="from-nonterminal" data-kind="null"></span><span class="keyword">|</span> <a href="Source-Files/Module-Contents#Lean___Parser___Command___declModifiers"><span class="nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code>declModifiers</span></a> <span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span></span></span><span class="bnf">)*</span>
      </span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Command.optDeriving"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><a href="Type-Classes/Deriving-Instances/#Lean___Parser___Command___optDeriving-next"><span class="keyword">deriving</span></a> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span><span class="bnf">,*</span></span></span><span class="bnf">)?</span></span></span></span></span></pre><p>
                    Declares a new inductive type.
The meaning of the <code class="grammar"><span class="nonterminal" data-kind="declModifiers">declModifiers</span></code> is as described in the section <a href="Source-Files/Module-Contents/#declaration-modifiers">on declaration modifiers</a>.</p>
                  </div>
                </div>
              <p>
                After declaring an inductive type, its type constructor, constructors, and recursor are present in the environment.
New inductive types extend Lean's core logic—they are not encoded or represented by some other already-present data.
Inductive type declarations must satisfy <a href="The-Type-System/Inductive-Types/#well-formed-inductives">a number of well-formedness requirements</a> to ensure that the logic remains consistent.</p>
              <p>
                The first line of the declaration, from <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.inductive : command</code></code><code class="kw">inductive</code></span> to <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.inductive : command</code></code><code class="kw">where</code></span>, specifies the new <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-type-constructors">type constructor</a>'s name and type.
If a type signature for the type constructor is provided, then its result type must be a <a class="technical-term" href="The-Type-System/Universes/#--tech-term-universes">universe</a>, but the parameters do not need to be types.
If no signature is provided, then Lean will attempt to infer a universe that's just big enough to contain the resulting type.
In some situations, this process may fail to find a minimal universe or fail to find one at all, necessitating an annotation.</p>
              <p>
                The constructor specifications follow <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.inductive : command</code></code><code class="kw">where</code></span>.
Constructors are not mandatory, as constructorless inductive types such as <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Empty-Type/#Empty"><span class="const token" data-binding="const-Empty" data-verso-hover="193">Empty</span></a></code> are perfectly sensible.
Each constructor specification begins with a vertical bar (<code>'|'</code>, Unicode <code>'VERTICAL BAR' (U+007c)</code>), declaration modifiers, and a name.
The name is a <a class="technical-term" href="Source-Files/Files/#--tech-term-raw-identifier">raw identifier</a>.
A declaration signature follows the name.
The signature may specify any parameters, modulo the well-formedness requirements for inductive type declarations, but the return type in the signature must be a saturated application of the type constructor of the inductive type being specified.
If no signature is provided, then the constructor's type is inferred by inserting sufficient implicit parameters to construct a well-formed return type.</p>
              <p>
                The new inductive type's name is defined in the <a class="technical-term" href="Source-Files/Module-Contents/#--tech-term-current-namespace">current namespace</a>.
Each constructor's name is in the inductive type's namespace.<span id="--index-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span></p>
              <section>
                <h3 id="inductive-datatypes-parameters-and-indices">
                  3.4.1.1. Parameters and Indices<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-datatypes-parameters-and-indices" title="Permalink">🔗</a></span></h3>
                <p>
                  Type constructors may take two kinds of arguments: <span id="--tech-term-parameters"><em>parameters</em></span> <span id="--index-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span> and <span id="--tech-term-indices"><em>indices</em></span>.<span id="--index-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>
Parameters must be used consistently in the entire definition; all occurrences of the type constructor in each constructor in the declaration must take precisely the same argument.
Indices may vary among the occurrences of the type constructor.
All parameters must precede all indices in the type constructor's signature.</p>
                <p>
                  Parameters that occur prior to the colon (<code>':'</code>) in the type constructor's signature are considered parameters to the entire inductive type declaration.
They are always parameters that must be uniform throughout the type's definition.
Generally speaking, parameters that occur after the colon are indices that may vary throughout the definition of the type.
However, if the option <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#inductive___autoPromoteIndices"><span class="option token" data-binding="option-inductive.autoPromoteIndices" data-verso-hover="194">inductive.autoPromoteIndices</span></a></code> is <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code>, then syntactic indices that could have been parameters are made into parameters.
An index could have been a parameter if all of its type dependencies are themselves parameters and it is used uniformly as an uninstantiated variable in all occurrences of the inductive type's type constructor in all constructors.</p>
                <div class="namedocs" id="inductive___autoPromoteIndices">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.option&name=inductive.autoPromoteIndices" title="Permalink">🔗</a></span><span class="label">option</span><pre class="signature hl lean block">inductive.autoPromoteIndices</pre><div class="text">
                    <p>
                      Default value: <code class="hl lean inline"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code></p>
                    <p>
                      Promote indices to parameters in inductive types whenever possible.</p>
                    </div>
                  </div>
                <p>
                  Indices can be seen as defining a <em>family</em> of types.
Each choice of indices selects a type from the family, which has its own set of available constructors.
Type constructors with indices are said to specify <span id="--tech-term-indexed-families"><em>indexed families</em></span> <span id="--index-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span> of types.</p>
                </section>
              <section>
                <h3 id="example-inductive-types">
                  3.4.1.2. Example Inductive Types<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=example-inductive-types" title="Permalink">🔗</a></span></h3>
                <details class="example"><summary class="description">A constructorless type</summary><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Vacant"><span class="const token" data-binding="const-Vacant" data-verso-hover="195">Vacant</span></a></code> is an empty inductive type, equivalent to Lean's <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Empty-Type/#Empty"><span class="const token" data-binding="const-Empty" data-verso-hover="193">Empty</span></a></code> type:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-6957" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Vacant" data-verso-hover="195" id="Vacant">Vacant</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="keyword token" data-binding="kw-occ-null-6981">where</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Empty inductive types are not useless; they can be used to indicate unreachable code.</p>
                  </details><details class="example"><summary class="description">A constructorless proposition</summary><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#No"><span class="const token" data-binding="const-No" data-verso-hover="196">No</span></a></code> is a false <a class="technical-term" href="The-Type-System/Propositions/#--tech-term-Propositions">proposition</a>, equivalent to Lean's <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-7213" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-No" data-verso-hover="196" id="No">No</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span> <span class="keyword token" data-binding="kw-occ-null-7233">where</span>
<span class="unknown token" data-binding=""></span></code></details><details class="example"><summary class="description">A unit type</summary><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#One"><span class="const token" data-binding="const-One" data-verso-hover="197">One</span></a></code> is equivalent to Lean's <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></code> type:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-7489" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-One" data-verso-hover="197" id="One">One</span> <span class="keyword token" data-binding="kw-occ-null-7503">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-One.one" data-verso-hover="198" id="One">one</span>
<span class="unknown token" data-binding=""></span></code><p>
                    It is an example of an inductive type in which the signatures have been omitted for both the type constructor and the constructor.
Lean assigns <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#One"><span class="const token" data-binding="const-One" data-verso-hover="197">One</span></a></code> to <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="50">Type</span></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">One : Type</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-7718">#check</span></a></span> <a href="The-Type-System/Inductive-Types/#One"><span class="const token" data-binding="const-One" data-verso-hover="197">One</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>One : Type
</pre></div>
                  <p>
                    The constructor is named <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#One"><span class="const token" data-binding="const-One.one" data-verso-hover="198">One.one</span></a></code>, because constructor names are the type constructor's namespace.
Because <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#One"><span class="const token" data-binding="const-One" data-verso-hover="197">One</span></a></code> expects no arguments, the signature inferred for <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#One"><span class="const token" data-binding="const-One.one" data-verso-hover="198">One.one</span></a></code> is:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">One.one : One</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-7987">#check</span></a></span> <a href="The-Type-System/Inductive-Types/#One"><span class="const token" data-binding="const-One.one" data-verso-hover="198">One.one</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>One.one : One
</pre></div>
                  </details><details class="example"><summary class="description">A true proposition</summary><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Yes___intro"><span class="const token" data-binding="const-Yes" data-verso-hover="199">Yes</span></a></code> is equivalent to Lean's <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a></code> proposition:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-8153" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Yes" data-verso-hover="199" id="Yes___intro">Yes</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span> <span class="keyword token" data-binding="kw-occ-null-8174">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Yes.intro" data-verso-hover="200" id="Yes___intro">intro</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Unlike <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#One"><span class="const token" data-binding="const-One" data-verso-hover="197">One</span></a></code>, the new inductive type <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Yes___intro"><span class="const token" data-binding="const-Yes" data-verso-hover="199">Yes</span></a></code> is specified to be in the <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code> universe.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Yes : Prop</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-8322">#check</span></a></span> <a href="The-Type-System/Inductive-Types/#Yes___intro"><span class="const token" data-binding="const-Yes" data-verso-hover="199">Yes</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>Yes : Prop
</pre></div>
                  <p>
                    The signature inferred for <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Yes___intro"><span class="const token" data-binding="const-Yes.intro" data-verso-hover="200">Yes.intro</span></a></code> is:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Yes.intro : Yes</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-8445">#check</span></a></span> <a href="The-Type-System/Inductive-Types/#Yes___intro"><span class="const token" data-binding="const-Yes.intro" data-verso-hover="200">Yes.intro</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>Yes.intro : Yes
</pre></div>
                  </details><details class="example"><summary class="description">A type with parameter and index</summary><p>
                    An <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="const token" data-binding="const-α" data-verso-hover="202">α</span> <span class="const token" data-binding="const-b" data-verso-hover="203">b</span></code> is a list where <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-α" data-verso-hover="202">α</span></code> is the type of the data stored in the list and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-b" data-verso-hover="203">b</span></code> is <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code> when there are an even number of entries:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-8979" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-9007" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-9026" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="keyword token" data-binding="kw-occ-null-9033">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="204">nil</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="205">cons</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="79">isEven</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Booleans/#Bool___not"><span class="const token" data-binding="const-Bool.not" data-verso-hover="206">not</span></a> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="79">isEven</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                    This example is well typed because there are two entries in the list:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-9224">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="205">.cons</span> <span class="literal string token" data-binding="" data-verso-hover="121">"a"</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="205">.cons</span> <span class="literal string token" data-binding="" data-verso-hover="122">"b"</span> <span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="204">.nil</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                    This example is not well typed because there are three entries in the list:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-9417">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">type mismatch
  EvenOddList.cons "a" (EvenOddList.cons "b" (EvenOddList.cons "c" EvenOddList.nil))
has type
  EvenOddList String !!!true : Type
but is expected to have type
  EvenOddList String true : Type</code></span></span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="205">.cons</span></span> <span class="literal string token" data-binding="" data-verso-hover="121">"a"</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="205">.cons</span> <span class="literal string token" data-binding="" data-verso-hover="122">"b"</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="205">.cons</span> <span class="literal string token" data-binding="" data-verso-hover="123">"c"</span> <span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="204">.nil</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>type mismatch
  EvenOddList.cons "a" (EvenOddList.cons "b" (EvenOddList.cons "c" EvenOddList.nil))
has type
  EvenOddList String !!!true : Type
but is expected to have type
  EvenOddList String true : Type
</pre></div>
                  <p>
                    In this declaration, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-α" data-verso-hover="202">α</span></code> is a <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-parameters">parameter</a>, because it is used consistently in all occurrences of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span></code>.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-b" data-verso-hover="203">b</span></code> is an <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-indices">index</a>, because different <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></code> values are used for it at different occurrences.</p>
                  </details><details class="example"><summary class="description">Parameters before and after the colon</summary><p>
                    In this example, both parameters are specified before the colon in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Either" data-verso-hover="207">Either</span></code>'s signature.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-10645" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Either" data-verso-hover="207">Either</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10668" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="172">β</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10682" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10692" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Level.max-10698">max</span> <span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-10707">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Either.left" data-verso-hover="208" id="Either___right">left</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Either" data-verso-hover="207">Either</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="172">β</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Either.right" data-verso-hover="209" id="Either___right">right</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Either" data-verso-hover="207">Either</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="172">β</span>
<span class="unknown token" data-binding=""></span></code><p>
                    In this version, there are two types named <code>α</code> that might not be identical:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-10900" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Either'" data-verso-hover="210" id="Either___">Either'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10924" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="172">β</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10938" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10948" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Level.max-10954">max</span> <span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-10963">where</span>
  <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">inductive datatype parameter mismatch
  α
expected
  α✝</code></span></span><span class="unknown token" data-binding="">|</span></span> <span class="unknown token" data-binding="">left</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10986" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">β</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11004" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Either___"><span class="const token" data-binding="const-Either'" data-verso-hover="210">Either'</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">β</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">right</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">Either'</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">β</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>inductive datatype parameter mismatch
  α
expected
  α✝
</pre></div>
                  <p>
                    Placing the parameters after the colon results in parameters that can be instantiated by the constructors:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-11295" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Either''" data-verso-hover="211" id="Either_________right">Either''</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11316" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11327" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">v</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11338" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Level.max-11344">max</span> <span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-11353">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Either''.left" data-verso-hover="212" id="Either_________right">left</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11376" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">β</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11394" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Either_________right"><span class="const token" data-binding="const-Either''" data-verso-hover="211">Either''</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">β</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Either''.right" data-verso-hover="213" id="Either_________right">right</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Either_________right"><span class="const token" data-binding="const-Either''" data-verso-hover="211">Either''</span></a> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.37" data-verso-hover="172">β</span>
<span class="unknown token" data-binding=""></span></code><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Either_________right"><span class="const token" data-binding="const-Either''.right" data-verso-hover="213">Either''.right</span></a></code>'s type parameters are discovered via Lean's ordinary rules for <a class="technical-term" href="Source-Files/Module-Contents/#--tech-term-Automatic-implicit">automatic implicit</a> parameters.</p>
                  </details></section>
              <section>
                <h3 id="anonymous-constructor-syntax">
                  3.4.1.3. Anonymous Constructor Syntax<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=anonymous-constructor-syntax" title="Permalink">🔗</a></span></h3>
                <p>
                  If an inductive type has just one constructor, then this constructor is eligible for <span id="--tech-term-anonymous-constructor-syntax"><em>anonymous constructor syntax</em></span>.
Instead of writing the constructor's name applied to its arguments, the explicit arguments can be enclosed in angle brackets (<code>'⟨'</code> and <code>'⟩'</code>, Unicode <code>MATHEMATICAL LEFT ANGLE BRACKET	(U+0x27e8)</code> and <code>MATHEMATICAL RIGHT ANGLE BRACKET	(U+0x27e9)</code>) and separated with commas.
This works in both pattern and expression contexts.
Providing arguments by name or converting all implicit parameters to explicit parameters with <code>@</code> requires using the ordinary constructor syntax.</p>
                <div class="namedocs" id="term">
                  <span class="label">syntax</span><span class="title">Anonymous Constructors</span><div class="text">
                    <p>
                      Constructors can be invoked anonymously by enclosing their explicit arguments in angle brackets, separated by commas.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___anonymousCtor"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.anonymousCtor"><code class="hover-info"><code class="docstring">The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the
expected type is an inductive type with a single constructor `c`.
If more terms are given than `c` has parameters, the remaining arguments
are turned into a new anonymous constructor application. For example,
`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.
</code></code><span class="keyword">⟨</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span><span class="bnf">,*</span> </span><span class="keyword">⟩</span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">Anonymous constructors</summary><p>
                    The type <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="214">AtLeastOne</span></a> <span class="const token" data-binding="const-α" data-verso-hover="90">α</span></code> is similar to <code>List α</code>, except there's always at least one element present:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-12700" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-AtLeastOne" data-verso-hover="214" id="AtLeastOne">AtLeastOne</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-12727" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-12737" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="keyword token" data-binding="kw-occ-null-12744">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="215" id="AtLeastOne">mk</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="214">AtLeastOne</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="214">AtLeastOne</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Anonymous constructor syntax can be used to construct them:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12880">def</span> <span class="const token" data-binding="const-oneTwoThree" data-verso-hover="216">oneTwoThree</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="214">AtLeastOne</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">⟨</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">,</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">⟨</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">,</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">⟨</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">,</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">⟩</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">⟩</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">⟩</span>
<span class="unknown token" data-binding=""></span></code><p>
                    and to match against them:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12999">def</span> <span class="const token" data-binding="const-AtLeastOne.head" data-verso-hover="217" id="AtLeastOne___head">AtLeastOne.head</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="214">AtLeastOne</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="44">α</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">⟩</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="46">x</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Equivalently, traditional constructor syntax could have been used:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13142">def</span> <span class="const token" data-binding="const-oneTwoThree'" data-verso-hover="218" id="oneTwoThree___">oneTwoThree'</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="214">AtLeastOne</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">.mk</span></a> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">.mk</span></a> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">.mk</span></a> <span class="typed token" data-binding="" data-verso-hover="7">3</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13223">def</span> <span class="const token" data-binding="const-AtLeastOne.head'" data-verso-hover="219" id="oneTwoThree___">AtLeastOne.head'</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="214">AtLeastOne</span></a> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="44">α</span>
  <span class="unknown token" data-binding="">|</span> <a href="The-Type-System/Inductive-Types/#AtLeastOne"><span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="215">.mk</span></a> <span class="var token" data-binding="var-_uniq.71" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.71" data-verso-hover="46">x</span>
<span class="unknown token" data-binding=""></span></code></details></section>
              <section>
                <h3 id="inductive-declarations-deriving-instances">
                  3.4.1.4. Deriving Instances<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-declarations-deriving-instances" title="Permalink">🔗</a></span></h3>
                <p>
                  The optional <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.inductive : command</code></code><code class="kw">deriving</code></span> clause of an inductive type declaration can be used to derive instances of type classes.
Please refer to <a href="Type-Classes/Deriving-Instances/#deriving-instances">the section on instance deriving</a> for more information.</p>
                </section>
              </section>
            <section>
              <h2 id="structures">
                3.4.2. Structure Declarations<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=structures" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="command-next-next-next">
                <span class="label">syntax</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___declaration-next"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.declaration"><a href="Source-Files/Module-Contents#Lean___Parser___Command___declModifiers"><span class="nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code>declModifiers</span></a>
      <span class="from-nonterminal" data-kind="Lean.Parser.Command.structure"><span class="from-nonterminal" data-kind="Lean.Parser.Command.structureTk"><span class="keyword">structure</span> </span><span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">*</span> </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.extends"><span class="keyword">extends</span> <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.structParent"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span> </span><span class="bnf">)?</span></span><span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">),*</span></span><span class="from-nonterminal" data-kind="null"></span></span></span><span class="bnf">)?</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="keyword">where</span>
        <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.structCtor"><a href="Source-Files/Module-Contents#Lean___Parser___Command___declModifiers"><span class="nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code>declModifiers</span></a> <span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">::</span></span></span><span class="bnf">)?</span>
        </span><span class="nonterminal" data-kind="Lean.Parser.Command.structFields">structFields</span>
      </span><span class="from-nonterminal" data-kind="Lean.Parser.Command.optDeriving"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><a href="Type-Classes/Deriving-Instances/#Lean___Parser___Command___optDeriving-next"><span class="keyword">deriving</span></a> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span><span class="bnf">,*</span></span></span><span class="bnf">)?</span></span></span></span></span></pre><p>
                    Declares a new structure type.</p>
                  </div>
                </div>
              <p>
                <span id="--tech-term-Structures">Structures</span> are inductive types that have only a single constructor and no indices.
In exchange for these restrictions, Lean generates code for structures that offers a number of conveniences: projection functions are generated for each field, an additional constructor syntax based on field names rather than positional arguments is available, a similar syntax may be used to replace the values of certain named fields, and structures may extend other structures.
Just like other inductive types, structures may be recursive; they are subject to the same restrictions regarding strict positivity.
Structures do not add any expressive power to Lean; all of their features are implemented in terms of code generation.</p>
              <section>
                <h3 id="structure-params">
                  3.4.2.1. Structure Parameters<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=structure-params" title="Permalink">🔗</a></span></h3>
                <p>
                  Just like ordinary inductive type declarations, the header of the structure declaration contains a signature that may specify both parameters and a resulting universe.
Structures may not define <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-indexed-families">indexed families</a>.</p>
                </section>
              <section>
                <h3 id="structure-fields">
                  3.4.2.2. Fields<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=structure-fields" title="Permalink">🔗</a></span></h3>
                <p>
                  Each field of a structure declaration corresponds to a parameter of the constructor.
Auto-implicit arguments are inserted in each field separately, even if their names coincide, and the fields become constructor parameters that quantify over types.</p>
                <details class="example"><summary class="description">Auto-implicit parameters in structure fields</summary><p>
                    The structure <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#MyStructure___field2"><span class="const token" data-binding="const-MyStructure" data-verso-hover="220">MyStructure</span></a></code> contains a field whose type is an auto-implicit parameter:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-2326">structure</span> <span class="const token" data-binding="const-MyStructure" data-verso-hover="220" id="MyStructure___field2">MyStructure</span> <span class="keyword token" data-binding="kw-occ-null-2348">where</span>
  <span class="const token" data-binding="const-MyStructure.field1" data-verso-hover="221" id="MyStructure___field2">field1</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="165">α</span>
  <span class="const token" data-binding="const-MyStructure.field2" data-verso-hover="222" id="MyStructure___field2">field2</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="223">α</span>
<span class="unknown token" data-binding=""></span></code><p>
                    The type constructor <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#MyStructure___field2"><span class="const token" data-binding="const-MyStructure" data-verso-hover="220">MyStructure</span></a></code> takes two universe parameters:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#MyStructure___field2"><span class="const token" data-binding="const-MyStructure" data-verso-hover="220">MyStructure</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-2492" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Level.max-2498">max</span> <span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span></code><p>
                    The resulting type is in <code>Type</code> rather than <code>Sort</code> because the constructor fields quantify over types in <code>Sort</code>. In particular, both fields in its constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-MyStructure.mk" data-verso-hover="224">MyStructure.mk</span></code> take an implicit type parameter:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-MyStructure.mk" data-verso-hover="224">MyStructure.mk</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="225">field1</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="95">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-2779" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="95">α</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="226">field2</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="104">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-2813" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="104">α</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#MyStructure___field2"><span class="const token" data-binding="const-MyStructure" data-verso-hover="220">MyStructure</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span></code></details><p>
                  For each field, a <span id="--tech-term-projection-function">projection function</span> is generated that extracts the field's value from the underlying type's constructor.
This function is in the structure's name's namespace.
Structure field projections are handled specially by the elaborator (as described in the <a href="The-Type-System/Inductive-Types/#structure-inheritance">section on structure inheritance</a>), which performs extra steps beyond looking up a namespace.
When field types depend on prior fields, the types of the dependent projection functions are written in terms of earlier projections, rather than explicit pattern matching.</p>
                <details class="example"><summary class="description">Dependent projection types</summary><p>
                    The structure <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#ArraySized___array"><span class="const token" data-binding="const-ArraySized" data-verso-hover="227">ArraySized</span></a></code> contains a field whose type depends on both a structure parameter and an earlier field:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-3611">structure</span> <span class="const token" data-binding="const-ArraySized" data-verso-hover="227" id="ArraySized___array">ArraySized</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-3638" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>  <span class="keyword token" data-binding="kw-occ-null-3662">where</span>
  <span class="const token" data-binding="const-ArraySized.array" data-verso-hover="228" id="ArraySized___array">array</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
  <span class="const token" data-binding="const-ArraySized.size_eq_length" data-verso-hover="229" id="ArraySized___array">size_eq_length</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="230">array</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="87">size</span></a> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span>
<span class="unknown token" data-binding=""></span></code><p>
                    The signature of the projection function <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#ArraySized___array"><span class="const token" data-binding="const-ArraySized.size_eq_length" data-verso-hover="229">size_eq_length</span></a></code> takes the structure type's parameter as an implicit parameter and refers to the earlier field using the corresponding projection:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#ArraySized___array"><span class="const token" data-binding="const-ArraySized.size_eq_length" data-verso-hover="229">ArraySized.size_eq_length</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-4002" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="231">self</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#ArraySized___array"><span class="const token" data-binding="const-ArraySized" data-verso-hover="227">ArraySized</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="231">self</span><span class="unknown token" data-binding="">.</span><a href="The-Type-System/Inductive-Types/#ArraySized___array"><span class="const token" data-binding="const-ArraySized.array" data-verso-hover="228">array</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="87">size</span></a> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span></code></details><p>
                  Structure fields may have default values, specified with <code>:=</code>.
These values are used if no explicit value is provided.</p>
                <details class="example"><summary class="description">Default values</summary><p>
                    An adjacency list representation of a graph can be represented as an array of lists of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>.
The size of the array indicates the number of vertices, and the outgoing edges from each vertex are stored in the array at the vertex's index.
Because the default value <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span></code> is provided for the field <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Graph"><span class="const token" data-binding="const-Graph.adjacency" data-verso-hover="232">adjacency</span></a></code>, the empty graph <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Graph"><span class="const token" data-binding="const-Graph.empty" data-verso-hover="233">Graph.empty</span></a></code> can be constructed without providing any field values.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-4689">structure</span> <span class="const token" data-binding="const-Graph" data-verso-hover="234" id="Graph">Graph</span> <span class="keyword token" data-binding="kw-occ-null-4705">where</span>
  <span class="const token" data-binding="const-Graph.adjacency" data-verso-hover="232" id="Graph">adjacency</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4750">def</span> <span class="const token" data-binding="const-Graph.empty" data-verso-hover="233" id="Graph">Graph.empty</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Graph"><span class="const token" data-binding="const-Graph" data-verso-hover="234">Graph</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span>
<span class="unknown token" data-binding=""></span></code></details><p>
                  Structure fields may additionally be accessed via their index, using dot notation.
Fields are numbered beginning with <code>1</code>.</p>
                </section>
              <section>
                <h3 id="structure-constructors">
                  3.4.2.3. Structure Constructors<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=structure-constructors" title="Permalink">🔗</a></span></h3>
                <p>
                  Structure constructors may be explicitly named by providing the constructor name and <code>::</code> prior to the fields.
If no name is explicitly provided, then the constructor is named <code>mk</code> in the structure type's namespace.
<a href="Source-Files/Module-Contents/#declaration-modifiers">Declaration modifiers</a> may additionally be provided along with an explicit constructor name.</p>
                <details class="example"><summary class="description">Non-default constructor name</summary><p>
                    The structure  <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Palindrome___ofString"><span class="const token" data-binding="const-Palindrome" data-verso-hover="235">Palindrome</span></a></code> contains a string and a proof that the string is the same when reversed:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-5481">structure</span> <span class="const token" data-binding="const-Palindrome" data-verso-hover="235" id="Palindrome___ofString">Palindrome</span> <span class="keyword token" data-binding="kw-occ-null-5502">where</span>
  <span class="const token" data-binding="const-Palindrome.ofString" data-verso-hover="236" id="Palindrome___ofString">ofString</span> <span class="unknown token" data-binding="">::</span>
  <span class="const token" data-binding="const-Palindrome.text" data-verso-hover="237" id="Palindrome___ofString">text</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a>
  <span class="const token" data-binding="const-Palindrome.is_palindrome" data-verso-hover="238" id="Palindrome___ofString">is_palindrome</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="239">text</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String.data" data-verso-hover="240">data</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___reverse"><span class="const token" data-binding="const-List.reverse" data-verso-hover="109">reverse</span></a> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="239">text</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String.data" data-verso-hover="240">data</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                    Its constructor is named <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Palindrome___ofString"><span class="const token" data-binding="const-Palindrome.ofString" data-verso-hover="236">Palindrome.ofString</span></a></code>, rather than <code>Palindrome.mk</code>.</p>
                  </details><details class="example"><summary class="description">Modifiers on structure constructor</summary><p>
                    The structure <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk"><span class="const token" data-binding="const-NatStringBimap" data-verso-hover="241">NatStringBimap</span></a></code> maintains a finite bijection between natural numbers and strings.
It consists of a pair of maps, such that the keys each occur as values exactly once in the other map.
Because the constructor is private, code outside the defining module can't construct new instances and must use the provided API, which maintains the invariants of the type.
Additionally, providing the default constructor name explicitly is an opportunity to attach a <a class="technical-term" href="Source-Files/Module-Contents/#--tech-term-documentation-comments">documentation comment</a> to the constructor.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-6261">structure</span> <span class="const token" data-binding="const-NatStringBimap" data-verso-hover="241" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">NatStringBimap</span> <span class="keyword token" data-binding="kw-occ-null-6286">where</span>
  <span class="doc-comment token" data-binding="">/--
  Build a finite bijection between some
  natural numbers and strings
  -/</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.private-6375">private</span> <span class="const token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="242" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">mk</span> <span class="unknown token" data-binding="">::</span>
  <span class="const token" data-binding="const-NatStringBimap.natToString" data-verso-hover="243" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">natToString</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Std.HashMap" data-verso-hover="244">Std.HashMap</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a>
  <span class="const token" data-binding="const-NatStringBimap.stringToNat" data-verso-hover="245" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">stringToNat</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Std.HashMap" data-verso-hover="244">Std.HashMap</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6468">def</span> <span class="const token" data-binding="const-NatStringBimap.empty" data-verso-hover="246" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">NatStringBimap.empty</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk"><span class="const token" data-binding="const-NatStringBimap" data-verso-hover="241">NatStringBimap</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="242">⟨</span><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="242">,</span> <span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="242">⟩</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6527">def</span> <span class="const token" data-binding="const-NatStringBimap.insert" data-verso-hover="247" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">NatStringBimap.insert</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.620" data-verso-hover="7">nat</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.622" data-verso-hover="239">string</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.624" data-verso-hover="248">map</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk"><span class="const token" data-binding="const-NatStringBimap" data-verso-hover="241">NatStringBimap</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="The-Type-System/Inductive-Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk"><span class="const token" data-binding="const-NatStringBimap" data-verso-hover="241">NatStringBimap</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-6647" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.624" data-verso-hover="248">map</span><span class="unknown token" data-binding="">.</span><a href="The-Type-System/Inductive-Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk"><span class="const token" data-binding="const-NatStringBimap.natToString" data-verso-hover="243">natToString</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Std.HashMap.contains" data-verso-hover="249">contains</span> <span class="var token" data-binding="var-_uniq.620" data-verso-hover="7">nat</span> <span class="unknown token" data-binding="">||</span>
      <span class="var token" data-binding="var-_uniq.624" data-verso-hover="248">map</span><span class="unknown token" data-binding="">.</span><a href="The-Type-System/Inductive-Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk"><span class="const token" data-binding="const-NatStringBimap.stringToNat" data-verso-hover="245">stringToNat</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Std.HashMap.contains" data-verso-hover="249">contains</span> <span class="var token" data-binding="var-_uniq.622" data-verso-hover="239">string</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-6647" data-verso-hover="81">then</span></a>
    <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-6647" data-verso-hover="81">else</span></a>
    <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk"><span class="const token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="242">NatStringBimap.mk</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.624" data-verso-hover="248">map</span><span class="unknown token" data-binding="">.</span><a href="The-Type-System/Inductive-Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk"><span class="const token" data-binding="const-NatStringBimap.natToString" data-verso-hover="243">natToString</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Std.HashMap.insert" data-verso-hover="250">insert</span> <span class="var token" data-binding="var-_uniq.620" data-verso-hover="7">nat</span> <span class="var token" data-binding="var-_uniq.622" data-verso-hover="239">string</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.624" data-verso-hover="248">map</span><span class="unknown token" data-binding="">.</span><a href="The-Type-System/Inductive-Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk"><span class="const token" data-binding="const-NatStringBimap.stringToNat" data-verso-hover="245">stringToNat</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Std.HashMap.insert" data-verso-hover="250">insert</span> <span class="var token" data-binding="var-_uniq.622" data-verso-hover="239">string</span> <span class="var token" data-binding="var-_uniq.620" data-verso-hover="7">nat</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code></details><p>
                  Because structures are represented by single-constructor inductive types, their constructors can be invoked or matched against using <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-anonymous-constructor-syntax">anonymous constructor syntax</a>.
Additionally, structures may be constructed or matched against using <span id="--tech-term-structure-instance"><em>structure instance</em></span> notation, which includes the names of the fields together with values for them.</p>
                <div class="namedocs" id="term-next">
                  <span class="label">syntax</span><span class="title">Structure Instances</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___structInst"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.structInst"><code class="hover-info"><code class="docstring">Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be
inherited. If `e` is itself a variable called `x`, it can be elided:
`fun y =&gt; { x := 1, y }`.
A *structure update* of an existing value can be given via `with`:
`{ point with x := 1 }`.
The structure type can be specified if not inferable:
`{ x := 1, y := 2 : Point }`.
</code></code><span class="keyword">{</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFields"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span><span class="bnf">,*</span>
        <span class="from-nonterminal" data-kind="null"></span></span></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.optEllipsis"><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="bnf">)?</span> </span><span class="keyword">}</span></span></pre><p>
                      Constructs a value of a constructor type given values for named fields.
Field specifiers may take two forms:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___structInstField"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstField"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstLVal">structInstLVal</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFieldDef"><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___structInstField-next"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstField"><span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstLVal"><span class="nonterminal" data-kind="ident">ident</span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      A <code class="grammar"><span class="nonterminal" data-kind="structInstLVal">structInstLVal</span></code> is a field name (an identifier), a field index (a natural number), or a term in square brackets, followed by a sequence of zero or more subfields.
Subfields are either a field name or index preceded by a dot, or a term in square brackets.</p>
                    <p>
                      This syntax is elaborated to applications of structure constructors.
The values provided for fields are by name, and they may be provided in any order.
The values provided for subfields are used to initialize fields of constructors of structures that are themselves found in fields.
Terms in square brackets are not allowed when constructing a structure; they are used in structure updates.</p>
                    <p>
                      Field specifiers that do not contain <code>:=</code> are field abbreviations.
In this context, the identifier <code>f</code> is an abbreviation for <code>f := f</code>; that is, the value of <code>f</code> in the current scope is used to initialize the field <code>f</code>.</p>
                    <p>
                      Every field that does not have a default value must be provided.
If a tactic is specified as the default argument, then it is run at elaboration time to construct the argument's value.</p>
                    <p>
                      In a pattern context, field names are mapped to patterns that match the corresponding projection, and field abbreviations bind a pattern variable that is the field's name.
Default arguments are still present in patterns; if a pattern does not specify a value for a field with a default value, then the pattern only matches the default.</p>
                    <p>
                      The optional type annotation allows the structure type to be specified in contexts where it is not otherwise determined.</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">Patterns and default values</summary><p>
                    The structure <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AugmentedIntList___list"><span class="const token" data-binding="const-AugmentedIntList" data-verso-hover="251">AugmentedIntList</span></a></code> contains a list together with some extra information, which is empty if omitted:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-9253">structure</span> <span class="const token" data-binding="const-AugmentedIntList" data-verso-hover="251" id="AugmentedIntList___list">AugmentedIntList</span> <span class="keyword token" data-binding="kw-occ-null-9280">where</span>
  <span class="const token" data-binding="const-AugmentedIntList.list" data-verso-hover="252" id="AugmentedIntList___list">list</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="71">Int</span></a>
  <span class="const token" data-binding="const-AugmentedIntList.augmentation" data-verso-hover="253" id="AugmentedIntList___list">augmentation</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="254">""</span>
<span class="unknown token" data-binding=""></span></code><p>
                    When testing whether the list is empty, the function <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AugmentedIntList___isEmpty"><span class="const token" data-binding="const-AugmentedIntList.isEmpty" data-verso-hover="255">isEmpty</span></a></code> is also testing whether the <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AugmentedIntList___list"><span class="const token" data-binding="const-AugmentedIntList.augmentation" data-verso-hover="253">augmentation</span></a></code> field is empty, because the omitted field's default value is also used in pattern contexts:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9638">def</span> <span class="const token" data-binding="const-AugmentedIntList.isEmpty" data-verso-hover="255" id="AugmentedIntList___isEmpty">AugmentedIntList.isEmpty</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AugmentedIntList___list"><span class="const token" data-binding="const-AugmentedIntList" data-verso-hover="251">AugmentedIntList</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">{</span><a href="The-Type-System/Inductive-Types/#AugmentedIntList___list"><span class="const token" data-binding="const-AugmentedIntList.list" data-verso-hover="256">list</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">false</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9736" data-verso-hover="6">#eval</span></a></span> <span class="unknown token" data-binding="">{</span><a href="The-Type-System/Inductive-Types/#AugmentedIntList___list"><span class="const token" data-binding="const-AugmentedIntList.list" data-verso-hover="256">list</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <a href="The-Type-System/Inductive-Types/#AugmentedIntList___list"><span class="const token" data-binding="const-AugmentedIntList.augmentation" data-verso-hover="257">augmentation</span></a> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="258">"extra"</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AugmentedIntList___list"><span class="const token" data-binding="const-AugmentedIntList" data-verso-hover="251">AugmentedIntList</span></a><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">.</span><a href="The-Type-System/Inductive-Types/#AugmentedIntList___isEmpty"><span class="const token" data-binding="const-AugmentedIntList.isEmpty" data-verso-hover="255">isEmpty</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>false
</pre></div>
                  </details><div class="namedocs" id="term-next-next">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___structInst-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.structInst"><code class="hover-info"><code class="docstring">Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be
inherited. If `e` is itself a variable called `x`, it can be elided:
`fun y =&gt; { x := 1, y }`.
A *structure update* of an existing value can be given via `with`:
`{ point with x := 1 }`.
The structure type can be specified if not inferable:
`{ x := 1, y := 2 : Point }`.
</code></code><span class="keyword">{</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span> </span><span class="keyword">with</span>
        </span><span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFields"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span><span class="bnf">,*</span>
        <span class="from-nonterminal" data-kind="null"></span></span></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.optEllipsis"><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="bnf">)?</span></span><span class="keyword">}</span></span></pre><p>
                      Updates a value of a constructor type.
The term that precedes the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.structInst : term</code><span class="sep"></span><code class="docstring">Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be
inherited. If `e` is itself a variable called `x`, it can be elided:
`fun y =&gt; { x := 1, y }`.
A *structure update* of an existing value can be given via `with`:
`{ point with x := 1 }`.
The structure type can be specified if not inferable:
`{ x := 1, y := 2 : Point }`.
</code></code><code class="kw">with</code></span> clause is expected to have a structure type; it is the value that is being updated.
A new instance of the structure is created in which every field not specified is copied from the value that is being updated, and the specified fields are replaced with their new values.
When updating a structure, array values may also be replaced by including the index to be updated in square brackets.
This updating does not require that the index expression be in bounds for the array, and out-of-bounds updates are discarded.</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">Updating arrays</summary><p>
                    Updating structures may use array indices as well as projection names.
Updates at indices that are out of bounds are ignored:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-10759">structure</span> <span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="259" id="two______">AugmentedIntArray</span> <span class="keyword token" data-binding="kw-occ-null-10787">where</span>
  <span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="260" id="two______">array</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="71">Int</span></a>
  <span class="const token" data-binding="const-AugmentedIntArray.augmentation" data-verso-hover="261" id="two______">augmentation</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="254">""</span>
<span class="keyword token" data-binding="kw-occ-null-10843">deriving</span> <span class="const token" data-binding="const-Repr" data-verso-hover="262">Repr</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10858">def</span> <span class="const token" data-binding="const-one" data-verso-hover="263">one</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="259">AugmentedIntArray</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="264">array</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">#[</span><span class="typed token" data-binding="" data-verso-hover="265">1</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">}</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10905">def</span> <span class="const token" data-binding="const-two" data-verso-hover="266">two</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="259">AugmentedIntArray</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><span class="const token" data-binding="const-one" data-verso-hover="263">one</span> <span class="keyword token" data-binding="kw-occ-null-10937">with</span> <a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="264">array</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">#[</span><span class="typed token" data-binding="" data-verso-hover="265">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="265">2</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">}</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10964">def</span> <span class="const token" data-binding="const-two'" data-verso-hover="267" id="two______">two'</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="259">AugmentedIntArray</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><span class="const token" data-binding="const-two" data-verso-hover="266">two</span> <span class="keyword token" data-binding="kw-occ-null-10997">with</span> <a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="264">array</span></a><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="265">2</span><span class="unknown token" data-binding="">}</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11021">def</span> <span class="const token" data-binding="const-two''" data-verso-hover="268" id="two______">two''</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="259">AugmentedIntArray</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><span class="const token" data-binding="const-two" data-verso-hover="266">two</span> <span class="keyword token" data-binding="kw-occ-null-11055">with</span> <a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="264">array</span></a><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">99</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="265">3</span><span class="unknown token" data-binding="">}</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">({ array := #[1], augmentation := "" },
 { array := #[1, 2], augmentation := "" },
 { array := #[2, 2], augmentation := "" },
 { array := #[1, 2], augmentation := "" })</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-11080" data-verso-hover="6">#eval</span></a></span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-one" data-verso-hover="263">one</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-two" data-verso-hover="266">two</span><span class="unknown token" data-binding="">,</span> <a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-two'" data-verso-hover="267">two'</span></a><span class="unknown token" data-binding="">,</span> <a href="The-Type-System/Inductive-Types/#two______"><span class="const token" data-binding="const-two''" data-verso-hover="268">two''</span></a><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>({ array := #[1], augmentation := "" },
 { array := #[1, 2], augmentation := "" },
 { array := #[2, 2], augmentation := "" },
 { array := #[1, 2], augmentation := "" })
</pre></div>
                  </details><p>
                  Values of structure types may also be declared using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declValEqns : command</code></code><code class="kw">where</code></span>, followed by definitions for each field.
This may only be used as part of a definition, not in an expression context.</p>
                <details class="example"><summary class="description"><code>where</code> for structures</summary><p>
                    The product type in Lean is a structure named <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="116">Prod</span></a></code>.
Products can be defined using their projections:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11733">def</span> <span class="const token" data-binding="const-location" data-verso-hover="269" id="location">location</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Floating-Point-Numbers/#Float___mk"><span class="const token" data-binding="const-Float" data-verso-hover="270">Float</span></a> <span class="unknown token" data-binding="">×</span> <a href="Basic-Types/Floating-Point-Numbers/#Float___mk"><span class="const token" data-binding="const-Float" data-verso-hover="270">Float</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-11763">where</span>
  <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.fst" data-verso-hover="271">fst</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">22.807</span>
  <a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.snd" data-verso-hover="272">snd</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">13.923</span>
<span class="unknown token" data-binding=""></span></code></details></section>
              <section>
                <h3 id="structure-inheritance">
                  3.4.2.4. Structure Inheritance<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=structure-inheritance" title="Permalink">🔗</a></span></h3>
                <p>
                  Structures may be declared as extending other structures using the optional <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.structure : command</code></code><code class="kw">extends</code></span> clause.
The resulting structure type has all of the fields of all of the parent structure types.
If the parent structure types have overlapping field names, then all overlapping field names must have the same type.
If the overlapping fields have different default values, then the default value from the last parent structure that includes the field is used.
New default values in the child structure take precedence over default values from the parent structures.</p>
                <p>
                  When the new structure extends existing structures, the new structure's constructor takes the existing structure's information as additional arguments.
Typically, this is in the form of a constructor parameter for each parent structure type.
This parent value contains all of the parent's fields.
If the parents' fields overlap, however, then the subset of non-overlapping fields from one or more of the parents is included instead of an entire value of the parent structure to prevent duplicating field information.</p>
                <p>
                  There is no subtyping relation between a parent structure type and its children.
Even if structure <code>B</code> extends structure <code>A</code>, a function expecting an <code>A</code> will not accept a <code>B</code>.
However, conversion functions are generated that convert a structure into each of its parents.
These conversion functions are in the child structure's namespace, and their name is the parent structure's name preceded by <code>to</code>.</p>
                <details class="example"><summary class="description">Structure type inheritance with overlapping fields</summary><p>
                    In this example, a <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Textbook" data-verso-hover="273">Textbook</span></a></code> is a <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Book" data-verso-hover="274">Book</span></a></code> that is also an <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="275">AcademicWork</span></a></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-14060">structure</span> <span class="const token" data-binding="const-Book" data-verso-hover="274" id="AcademicWork___author">Book</span> <span class="keyword token" data-binding="kw-occ-null-14075">where</span>
  <span class="const token" data-binding="const-Book.title" data-verso-hover="276" id="AcademicWork___author">title</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a>
  <span class="const token" data-binding="const-Book.author" data-verso-hover="277" id="AcademicWork___author">author</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-14117">structure</span> <span class="const token" data-binding="const-AcademicWork" data-verso-hover="275" id="AcademicWork___author">AcademicWork</span> <span class="keyword token" data-binding="kw-occ-null-14140">where</span>
  <span class="const token" data-binding="const-AcademicWork.author" data-verso-hover="278" id="AcademicWork___author">author</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a>
  <span class="const token" data-binding="const-AcademicWork.discipline" data-verso-hover="279" id="AcademicWork___author">discipline</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-14187">structure</span> <span class="const token" data-binding="const-Textbook" data-verso-hover="273" id="AcademicWork___author">Textbook</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-14206">extends</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Book" data-verso-hover="274">Book</span></a><span class="unknown token" data-binding="">,</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="275">AcademicWork</span></a>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Textbook.toBook (self : Textbook) : Book</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-14234">#check</span></a></span> <span class="const token" data-binding="const-Textbook.toBook" data-verso-hover="280">Textbook.toBook</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Because the field <code>author</code> occurs in both <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Book" data-verso-hover="274">Book</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="275">AcademicWork</span></a></code>, the constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Textbook.mk" data-verso-hover="281">Textbook.mk</span></code> does not take both parents as arguments.
Its signature is:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Textbook.mk" data-verso-hover="281">Textbook.mk</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="282">toBook</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Book" data-verso-hover="274">Book</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="239">discipline</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Textbook" data-verso-hover="273">Textbook</span></a></code><p>
                    The conversion functions are:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Textbook.toBook" data-verso-hover="280">Textbook.toBook</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="283">self</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Textbook" data-verso-hover="273">Textbook</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Book" data-verso-hover="274">Book</span></a></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Textbook.toAcademicWork" data-verso-hover="284">Textbook.toAcademicWork</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="283">self</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Textbook" data-verso-hover="273">Textbook</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="275">AcademicWork</span></a></code><p>
                    The latter combines the <code>author</code> field of the included <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Book" data-verso-hover="274">Book</span></a></code> with the unbundled <code>Discipline</code> field, and is equivalent to:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14817">def</span> <span class="const token" data-binding="const-toAcademicWork" data-verso-hover="285" id="toAcademicWork">toAcademicWork</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="283">self</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-Textbook" data-verso-hover="273">Textbook</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#AcademicWork___author"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="275">AcademicWork</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-14874" data-verso-hover="286">let</span> <span class="const token" data-binding="const-Textbook.mk" data-verso-hover="281">.mk</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="282">book</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="239">discipline</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="283">self</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-14908" data-verso-hover="286">let</span> <span class="const token" data-binding="const-Book.mk" data-verso-hover="287">.mk</span> <span class="var token" data-binding="var-_uniq.32" data-verso-hover="239">_title</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="239">author</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="282">book</span>
  <span class="const token" data-binding="const-AcademicWork.mk" data-verso-hover="288">.mk</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="239">author</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="239">discipline</span>
<span class="unknown token" data-binding=""></span></code></details><p>
                  The resulting structure's projections can be used as if its fields are simply the union of the parents' fields.
The Lean elaborator automatically generates an appropriate projection when fields are used.
Likewise, the field-based initialization and structure update notations hide the details of the encoding of inheritance.
The encoding is, however, visible when using the constructor's name, when using <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-anonymous-constructor-syntax">anonymous constructor syntax</a>, or when referring to fields by their index rather than their name.</p>
                <details class="example"><summary class="description">Field Indices and Structure Inheritance</summary><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-15708">structure</span> <span class="const token" data-binding="const-Pair" data-verso-hover="289">Pair</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-15729" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-15737">where</span>
  <span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
  <span class="const token" data-binding="const-Pair.snd" data-verso-hover="291">snd</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
<span class="keyword token" data-binding="kw-occ-null-15765">deriving</span> <span class="const token" data-binding="const-Repr" data-verso-hover="262">Repr</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-15780">structure</span> <span class="const token" data-binding="const-Triple" data-verso-hover="292" id="coords">Triple</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1383" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-15803" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-15811">extends</span> <span class="const token" data-binding="const-Pair" data-verso-hover="289">Pair</span> <span class="var token" data-binding="var-_uniq.1383" data-verso-hover="55">α</span> <span class="keyword token" data-binding="kw-occ-null-15827">where</span>
  <span class="const token" data-binding="const-Triple.thd" data-verso-hover="293" id="coords">thd</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.1383" data-verso-hover="55">α</span>
<span class="keyword token" data-binding="kw-occ-null-15844">deriving</span> <span class="const token" data-binding="const-Repr" data-verso-hover="262">Repr</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15859">def</span> <span class="const token" data-binding="const-coords" data-verso-hover="294" id="coords">coords</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#coords"><span class="const token" data-binding="const-Triple" data-verso-hover="292">Triple</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="295">fst</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">17</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-Pair.snd" data-verso-hover="295">snd</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span> <a href="The-Type-System/Inductive-Types/#coords"><span class="const token" data-binding="const-Triple.thd" data-verso-hover="295">thd</span></a> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">95</span><span class="unknown token" data-binding="">}</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Evaluating the first field index of <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#coords"><span class="const token" data-binding="const-coords" data-verso-hover="294">coords</span></a></code> yields the underlying <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="289">Pair</span></code>, rather than the contents of the field <code>fst</code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">{ fst := 17, snd := 2 }</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-16078" data-verso-hover="6">#eval</span></a></span> <a href="The-Type-System/Inductive-Types/#coords"><span class="const token" data-binding="const-coords" data-verso-hover="294">coords</span></a><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>{ fst := 17, snd := 2 }
</pre></div>
                  <p>
                    The elaborator translates <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#coords"><span class="const token" data-binding="const-coords" data-verso-hover="294">coords</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span></code> into <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#coords"><span class="const token" data-binding="const-coords" data-verso-hover="294">coords</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Triple.toPair" data-verso-hover="296">toPair</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="290">fst</span></code>.</p>
                  </details><details class="example"><summary class="description">No structure subtyping</summary><p>
                    Given these definitions of even numbers, even prime numbers, and a concrete even prime:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-16477">structure</span> <span class="const token" data-binding="const-EvenNumber" data-verso-hover="297" id="EvenNumber">EvenNumber</span> <span class="keyword token" data-binding="kw-occ-null-16498">where</span>
  <span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="298" id="EvenNumber">val</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="const token" data-binding="const-EvenNumber.isEven" data-verso-hover="299" id="EvenNumber">isEven</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">∣</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">val</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-16537">by</span> <a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-16543" data-verso-hover="187">decide</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-16551">structure</span> <span class="const token" data-binding="const-EvenPrime" data-verso-hover="300" id="EvenNumber">EvenPrime</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-16571">extends</span> <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber" data-verso-hover="297">EvenNumber</span></a> <span class="keyword token" data-binding="kw-occ-null-16590">where</span>
  <span class="const token" data-binding="const-EvenPrime.notOne" data-verso-hover="301" id="EvenNumber">notOne</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.282" data-verso-hover="7">val</span> <span class="unknown token" data-binding="">≠</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-16617">by</span> <a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-16623" data-verso-hover="187">decide</span></a>
  <span class="const token" data-binding="const-EvenPrime.isPrime" data-verso-hover="302" id="EvenNumber">isPrime</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">∀</span> <span class="var token" data-binding="var-_uniq.302" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.302" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">≤</span> <span class="var token" data-binding="var-_uniq.282" data-verso-hover="7">val</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.302" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">∣</span> <span class="var token" data-binding="var-_uniq.282" data-verso-hover="7">val</span>  <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.302" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">∨</span> <span class="var token" data-binding="var-_uniq.302" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.282" data-verso-hover="7">val</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-16697">def</span> <span class="const token" data-binding="const-two" data-verso-hover="303">two</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenPrime" data-verso-hover="300">EvenPrime</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-16717">where</span>
  <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="295">val</span></a> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span>
  <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenPrime.isPrime" data-verso-hover="304">isPrime</span></a> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-13250909244039764668-16747-16749"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-16747" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13250909244039764668-16747-16749"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.1458" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>),
  <span class="var token" data-binding="var-_uniq.1458" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>{ <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="295">val</span></a> := 2, <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.isEven" data-verso-hover="306">isEven</span></a> := ⋯ }.<a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="298">val</span></a> → <span class="var token" data-binding="var-_uniq.1458" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#Dvd___mk"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="307"> ∣ </span></a>{ <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="295">val</span></a> := 2, <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.isEven" data-verso-hover="306">isEven</span></a> := ⋯ }.<a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="298">val</span></a> → <span class="var token" data-binding="var-_uniq.1458" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="308"> ∨ </span></a><span class="var token" data-binding="var-_uniq.1458" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>{ <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="295">val</span></a> := 2, <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.isEven" data-verso-hover="306">isEven</span></a> := ⋯ }.<a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="298">val</span></a></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-12935152441928068528-16754-16760"><a href="Tactic-Proofs/Tactic-Reference/#intros"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-16754" data-verso-hover="309">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12935152441928068528-16754-16760"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.699" data-verso-hover="310">a✝¹</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>{ <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="295">val</span></a> := 2, <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.isEven" data-verso-hover="306">isEven</span></a> := ⋯ }.<a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="298">val</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.700" data-verso-hover="311">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span><a href="Type-Classes/Basic-Classes/#Dvd___mk"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="307"> ∣ </span></a>{ <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="295">val</span></a> := 2, <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.isEven" data-verso-hover="306">isEven</span></a> := ⋯ }.<a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="298">val</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="308"> ∨ </span></a><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>{ <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="295">val</span></a> := 2, <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.isEven" data-verso-hover="306">isEven</span></a> := ⋯ }.<a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="298">val</span></a></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-11012062672748491740-16765-16780"><a href="Tactic-Proofs/Tactic-Reference/#dsimp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.dsimp-16765" data-verso-hover="312">dsimp</span></a> <span class="keyword token" data-binding="kw-occ-null-16771">only</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-16776" data-verso-hover="313">at</span> <span class="unknown token" data-binding="">*</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11012062672748491740-16765-16780"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.699" data-verso-hover="314">a✝¹</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span><a href="Type-Classes/Basic-Classes/#LE___mk"><span class="const token" data-binding="const-LE.le" data-verso-hover="305"> ≤ </span></a>2</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.700" data-verso-hover="315">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span><a href="Type-Classes/Basic-Classes/#Dvd___mk"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="307"> ∣ </span></a>2</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="308"> ∨ </span></a><span class="var token" data-binding="var-_uniq.698" data-verso-hover="7">n✝</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>2</span></span></span></span></span>
    <a href="Tactic-Proofs/The-Tactic-Language/#repeat___"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.repeat'-16785" data-verso-hover="316">repeat'</span></a> <span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-1550177950801587145-16794-16816"><a href="Tactic-Proofs/Tactic-Reference/#cases"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-16794" data-verso-hover="317">cases</span></a> <span class="unknown token" data-binding="">‹</span><span class="unknown token" data-binding="">Nat.le</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">›</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1550177950801587145-16794-16816"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-6" checked="checked"><span for="--verso-unique-6" class="goal-name">step.step.refl.refl</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1154" data-verso-hover="318">a✝</span></span><span class="colon">:</span><span class="type">0<a href="Type-Classes/Basic-Classes/#Dvd___mk"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="307"> ∣ </span></a>2</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>1<a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="308"> ∨ </span></a>0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a>2</span></span></span></span></span></span><span class="unknown token" data-binding="">)</span>
    <a href="Tactic-Proofs/The-Tactic-Language/#all_goals"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.allGoals-16822" data-verso-hover="319">all_goals</span></a> <span class="tactic"><label for="tactic-state-7-16832-16837"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-16832" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-16832-16837"><span class="tactic-state">All goals completed! 🐙</span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-16839">def</span> <span class="const token" data-binding="const-printEven" data-verso-hover="321" id="EvenNumber">printEven</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1458" data-verso-hover="322">num</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber" data-verso-hover="297">EvenNumber</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a> <a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="IO/Console-Output/#IO___print"><span class="const token" data-binding="const-IO.print" data-verso-hover="323">IO.print</span></a> <span class="var token" data-binding="var-_uniq.1458" data-verso-hover="322">num</span><span class="unknown token" data-binding="">.</span><a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="298">val</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                    it is a type error to apply <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-printEven" data-verso-hover="321">printEven</span></a></code> directly to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-two" data-verso-hover="303">two</span></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">printEven sorry : IO Unit</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-17022">#check</span></a></span> <a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-printEven" data-verso-hover="321">printEven</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">application type mismatch
  printEven two
argument
  two
has type
  EvenPrime : Type
but is expected to have type
  EvenNumber : Type</code></span></span><span class="const token" data-binding="const-two" data-verso-hover="303">two</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>application type mismatch
  printEven two
argument
  two
has type
  EvenPrime : Type
but is expected to have type
  EvenNumber : Type
</pre></div>
                  <p>
                    because values of type <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenPrime" data-verso-hover="300">EvenPrime</span></a></code> are not also values of type <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#EvenNumber"><span class="const token" data-binding="const-EvenNumber" data-verso-hover="297">EvenNumber</span></a></code>.</p>
                  </details></section>
              </section>
            <section>
              <h2 id="inductive-types-logical-model">
                3.4.3. Logical Model<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-types-logical-model" title="Permalink">🔗</a></span></h2>
              <section>
                <h3 id="recursors">
                  3.4.3.1. Recursors<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=recursors" title="Permalink">🔗</a></span></h3>
                <p>
                  Every inductive type is equipped with a <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-recursor">recursor</a>.
The recursor is completely determined by the signatures of the type constructor and the constructors.
Recursors have function types, but they are primitive and are not definable using <code>fun</code>.</p>
                <section>
                  <h4 id="recursor-types">
                    3.4.3.1.1. Recursor Types<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=recursor-types" title="Permalink">🔗</a></span></h4>
                  <p>
                    The recursor takes the following parameters:</p>
                  <dl><dt> The inductive type's <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-parameters">parameters</a></dt><dd><p>
                        Because parameters are consistent, they can be abstracted over the entire recursor</p>
                      </dd><dt> The <span id="--tech-term-motive"><em>motive</em></span></dt><dd><p>
                        The motive determines the type of an application of the recursor. The motive is a function whose arguments are the type's indices and an instance of the type with these indices instantiated. The specific universe for the type that the motive determines depends on the inductive type's universe and the specific constructors—see the section on <a href="The-Type-System/Inductive-Types/#subsingleton-elimination"><a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-subsingleton">subsingleton</a> elimination</a> for details.</p>
                      </dd><dt> A case for each constructor</dt><dd><p>
                        For each constructor, the recursor expects a function that satisfies the motive for an arbitrary application of the constructor. Each case abstracts over all of the constructor's parameters. If the constructor's parameter's type is the inductive type itself, then the case additionally takes a parameter whose type is the motive applied to that parameter's value—this will receive the result of recursively processing the recursive parameter.</p>
                      </dd><dt> The target</dt><dd><p>
                        Finally, the recursor takes an instance of the type as an argument, along with any index values.</p>
                      </dd></dl><p>
                    The result type of the recursor is the motive applied to these indices and the target.</p>
                  <details class="example"><summary class="description">The recursor for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></code></summary><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></code>'s recursor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool.rec" data-verso-hover="324">Bool.rec</span></code> has the following parameters:</p>
                    <ul>
                      <li>
                        <p>
                          The motive computes a type in any universe, given a <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></code>.</p>
                        </li>
                      <li>
                        <p>
                          There are cases for both constructors, in which the motive is satisfied for both <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code>.</p>
                        </li>
                      <li>
                        <p>
                          The target is some <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></code>.</p>
                        </li>
                      </ul>
                    <p>
                      The return type is the motive applied to the target.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Bool.rec" data-verso-hover="324">Bool.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="325">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-2505" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="326">false</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="325">motive</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="327">true</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="325">motive</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="79">t</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="325">motive</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="79">t</span></code></details><details class="example"><summary class="description">The recursor for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a></code></summary><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a></code>'s recursor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.rec" data-verso-hover="328">List.rec</span></code> has the following parameters:</p>
                    <ul>
                      <li>
                        <p>
                          The parameter <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-α" data-verso-hover="202">α</span></code> comes first, because the parameter and the cases need to refer to it</p>
                        </li>
                      <li>
                        <p>
                          The motive computes a type in any universe, given a <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="const token" data-binding="const-α" data-verso-hover="202">α</span></code>. There is no connection between the universe levels <code>u</code> and <code>v</code>.</p>
                        </li>
                      <li>
                        <p>
                          There are cases for both constructors:</p>
                        <ul>
                          <li>
                            <p>
                              The motive is satisfied for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">List.nil</span></a></code></p>
                            </li>
                          <li>
                            <p>
                              The motive should be satisfiable for any application of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">List.cons</span></a></code>, given that it is satisfiable for the tail. The extra parameter <code>motive tail</code> is because <code>tail</code>'s type is a recursive occurrence of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a></code>.</p>
                            </li>
                          </ul>
                        </li>
                      <li>
                        <p>
                          The target is some <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="const token" data-binding="const-α" data-verso-hover="202">α</span></code>.</p>
                        </li>
                      </ul>
                    <p>
                      Once again, the return type is the motive applied to the target.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-List.rec" data-verso-hover="328">List.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-3469" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-3499" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="332">nil</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="333">cons</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="46">head</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="51">tail</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="51">tail</span> <span class="unknown token" data-binding="">→</span>
    <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="46">head</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="51">tail</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="51">t</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="51">t</span></code></details><details class="example"><summary class="description">Recursor with parameters and indices</summary><p>
                      Given the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-3771" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-3799" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-3818" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="keyword token" data-binding="kw-occ-null-3825">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="204">nil</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="205">cons</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="79">isEven</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Booleans/#Bool___not"><span class="const token" data-binding="const-Bool.not" data-verso-hover="206">not</span></a> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="79">isEven</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                      The recursor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList.rec" data-verso-hover="334">EvenOddList.rec</span></code> is very similar to that for <code>List</code>.
The difference comes from the presence of the index:</p>
                    <ul>
                      <li>
                        <p>
                          The motive now abstracts over any arbitrary choice of index.</p>
                        </li>
                      <li>
                        <p>
                          The case for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="204">nil</span></code> applies the motive to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="204">nil</span></code>'s index value <code>true</code>.</p>
                        </li>
                      <li>
                        <p>
                          The case for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="205">cons</span></code> abstracts over the index value used in its recursive occurrence, and instantiates the motive with its negation.</p>
                        </li>
                      <li>
                        <p>
                          The target additionally abstracts over an arbitrary choice of index.</p>
                        </li>
                      </ul>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList.rec" data-verso-hover="334">EvenOddList.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-4518" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="335">motive</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="79">isEven</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="79">isEven</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-4584" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="336">nil</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="335">motive</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a> <span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="204">EvenOddList.nil</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34" data-verso-hover="337">cons</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="79">isEven</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="46">head</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="338">tail</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="79">isEven</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="335">motive</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="79">isEven</span> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="338">tail</span> <span class="unknown token" data-binding="">→</span>
    <span class="var token" data-binding="var-_uniq.10" data-verso-hover="335">motive</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">!</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="79">isEven</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="205">EvenOddList.cons</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="46">head</span> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="338">tail</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="79">isEven</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.41" data-verso-hover="338">t</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="172">α</span> <span class="var token" data-binding="var-_uniq.37" data-verso-hover="79">isEven</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="335">motive</span> <span class="var token" data-binding="var-_uniq.37" data-verso-hover="79">isEven</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="338">t</span></code></details><p>
                    When using a predicate (that is, a function that returns a <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>) for the motive, recursors express induction.
The cases for non-recursive constructors are the base cases, and the additional arguments supplied to constructors with recursive arguments are the induction hypotheses.</p>
                  <section>
                    <h5 id="subsingleton-elimination">
                      3.4.3.1.1.1. Subsingleton Elimination<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=subsingleton-elimination" title="Permalink">🔗</a></span></h5>
                    <p>
                      Proofs in Lean are computationally irrelevant.
In other words, having been provided with <strong>some</strong> proof of a proposition, it should be impossible for a program to check <strong>which</strong> proof it has received.
This is reflected in the types of recursors for inductively defined propositions or predicates.
For these types, if there's more than one potential proof of the theorem then the motive may only return another <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>.
If the type is structured such that there's only at most one proof anyway, then the motive may return a type in any universe.
A proposition that has at most one inhabitant is called a <span id="--tech-term-subsingleton"><em>subsingleton</em></span>.
Rather than obligating users to <em>prove</em> that there's only one possible proof, a conservative syntactic approximation is used to check whether a proposition is a subsingleton.
Propositions that fulfill both of the following requirements are considered to be subsingletons:</p>
                    <ul>
                      <li>
                        <p>
                          There is at most one constructor.</p>
                        </li>
                      <li>
                        <p>
                          Each of the constructor's parameter types is either a <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>, a parameter, or an index.</p>
                        </li>
                      </ul>
                    <details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a></code> is a subsingleton</summary><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a></code> is a subsingleton because it has one constructor, and this constructor has no parameters.
Its recursor has the following signature:</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-True.rec" data-verso-hover="339">True.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="340">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-6513" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="341">intro</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="340">motive</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True.intro" data-verso-hover="342">True.intro</span></a><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="343">t</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="340">motive</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="343">t</span></code></details><details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code> is a subsingleton</summary><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code> is a subsingleton because it has no constructors.
Its recursor has the following signature:</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-False.rec" data-verso-hover="344">False.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="345">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-6782" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="346">t</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="345">motive</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="346">t</span></code><p>
                        Note that the motive is an explicit parameter.
This is because it is not mentioned in any further parameters' types, so it could not be solved by unification.</p>
                      </details><details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347">And</span></a></code> is a subsingleton</summary><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347">And</span></a></code> is a subsingleton because it has one constructor, and both of the constructor's parameters' types are propositions.
Its recursor has the following signature:</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-And.rec" data-verso-hover="348">And.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">a</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="131">b</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="349">motive</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">a</span> <span class="unknown token" data-binding="">∧</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="131">b</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-7255" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="350">intro</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="351">left</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">a</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="352">right</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="131">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="349">motive</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And.intro" data-verso-hover="353">And.intro</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="351">left</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="352">right</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="354">t</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">a</span> <span class="unknown token" data-binding="">∧</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="131">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="349">motive</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="354">t</span></code></details><details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="308">Or</span></a></code> is not a subsingleton</summary><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or" data-verso-hover="308">Or</span></a></code> is not a subsingleton because it has more than one constructor.
Its recursor has the following signature:</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Or.rec" data-verso-hover="355">Or.rec</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">a</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="131">b</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="356">motive</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">a</span> <span class="unknown token" data-binding="">∨</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="131">b</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="357">inl</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="351">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="356">motive</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or.inl" data-verso-hover="358">.inl</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="351">h</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="359">inr</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="352">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="131">b</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="356">motive</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Propositions/Logical-Connectives/#Or___inl"><span class="const token" data-binding="const-Or.inr" data-verso-hover="360">.inr</span></a> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="352">h</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="361">t</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="131">a</span> <span class="unknown token" data-binding="">∨</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="131">b</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="356">motive</span> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="361">t</span></code><p>
                        The motive's type indicates that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.rec" data-verso-hover="355">Or.rec</span></code> can only be used to produce proofs.
A proof of a disjunction can be used to prove something else, but there's no way for a program to inspect <em>which</em> of the two disjuncts was true and used for the proof.</p>
                      </details><details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16">Eq</span></a></code> is a subsingleton</summary><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16">Eq</span></a></code> is a subsingleton because it has just one constructor, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq.refl" data-verso-hover="362">Eq.refl</span></a></code>.
This constructor instantiates <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16">Eq</span></a></code>'s index with a parameter value, so all arguments are parameters:</p>
                      <code class="hl lean block" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq.refl" data-verso-hover="362">Eq.refl</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="95">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-8224" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="95">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16">Eq</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="46">x</span></code><p>
                        Its recursor has the following signature:</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Eq.rec" data-verso-hover="363">Eq.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="104">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-8330" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="104">α</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="364">motive</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="46">y</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="104">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="46">y</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-8382" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="365">refl</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="364">motive</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq.refl" data-verso-hover="362">.refl</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="46">y</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="104">α</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="366">t</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="46">y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="364">motive</span> <span class="var token" data-binding="var-_uniq.22" data-verso-hover="46">y</span> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="366">t</span></code><p>
                        This means that proofs of equality can be used to rewrite the types of non-propositions.</p>
                      </details></section>
                  </section>
                <section>
                  <h4 id="iota-reduction">
                    3.4.3.1.2. Reduction<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=iota-reduction" title="Permalink">🔗</a></span></h4>
                  <p>
                    In addition to adding new constants to the logic, inductive type declarations also add new reduction rules.
These rules govern the interaction between recursors and constructors; specifically recursors that have constructors as their targets.
This form of reduction is called <span id="--tech-term-___-reduction"><em>ι-reduction</em></span> (iota reduction)<span id="--index-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span><span id="--index-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>.</p>
                  <p>
                    When the recursor's target is a constructor with no recursive parameters, the recursor application reduces to an application of the constructor's case to the constructor's arguments.
If there are recursive parameters, then these arguments to the case are found by applying the recursor to the recursive occurrence.</p>
                  </section>
                </section>
              <section>
                <h3 id="well-formed-inductives">
                  3.4.3.2. Well-Formedness Requirements<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=well-formed-inductives" title="Permalink">🔗</a></span></h3>
                <p>
                  Inductive type declarations are subject to a number of well-formedness requirements.
These requirements ensure that Lean remains consistent as a logic when it is extended with the inductive type's new rules.
They are conservative: there exist potential inductive types that do not undermine consistency, but that these requirements nonetheless reject.</p>
                <section>
                  <h4 id="The-Lean-Language-Reference--The-Type-System--Inductive-Types--Logical-Model--Well-Formedness-Requirements--Universe-Levels">
                    3.4.3.2.1. Universe Levels</h4>
                  <p>
                    Type constructors of inductive types must either inhabit a <a class="technical-term" href="The-Type-System/Universes/#--tech-term-universes">universe</a> or a function type whose return type is a universe.
Each constructor must inhabit a function type that returns a saturated application of the inductive type.
If the inductive type's universe is <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>, then there are no further restrictions on universes, because <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code> is <a class="technical-term" href="The-Type-System/Universes/#--tech-term-impredicative">impredicative</a>.
If the universe is not <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>, then the following must hold for each parameter to the constructor:</p>
                  <ul>
                    <li>
                      <p>
                        If the constructor's parameter is a parameter (in the sense of parameters vs indices) of the inductive type, then this parameter's type may be no larger than the type constructor's universe.</p>
                      </li>
                    <li>
                      <p>
                        All other constructor parameters must be smaller than the type constructor's universe.</p>
                      </li>
                    </ul>
                  <details class="example"><summary class="description">Universes, constructors, and parameters</summary><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Either" data-verso-hover="207">Either</span></code> is in the greater of its arguments' universes, because both are parameters to the inductive type:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-10705" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Either" data-verso-hover="207">Either</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10728" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="172">β</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10742" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-10752" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Level.max-10758">max</span> <span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-10767">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Either.inl" data-verso-hover="367" id="Either___inl">inl</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Either" data-verso-hover="207">Either</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="172">β</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Either.inr" data-verso-hover="368" id="Either___inl">inr</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="172">β</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Either" data-verso-hover="207">Either</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="172">β</span>
<span class="unknown token" data-binding=""></span></code><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#CanRepr"><span class="const token" data-binding="const-CanRepr" data-verso-hover="369">CanRepr</span></a></code> is in a larger universe than the constructor parameter <code>α</code>, because <code>α</code> is not one of the inductive type's parameters:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-10983" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-CanRepr" data-verso-hover="369" id="CanRepr">CanRepr</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11003" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-11016">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-CanRepr.mk" data-verso-hover="370" id="CanRepr">mk</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11037" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Repr" data-verso-hover="262">Repr</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#CanRepr"><span class="const token" data-binding="const-CanRepr" data-verso-hover="369">CanRepr</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      Constructorless inductive types may be in universes smaller than their parameters:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-11167" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Spurious" data-verso-hover="371" id="Spurious">Spurious</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="136">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11192" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">5</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-11202" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">0</span> <span class="keyword token" data-binding="kw-occ-null-11209">where</span>
<span class="unknown token" data-binding=""></span></code><p>
                      It would, however, be impossible to add a constructor to <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Spurious"><span class="const token" data-binding="const-Spurious" data-verso-hover="371">Spurious</span></a></code> without changing its levels.</p>
                    </details></section>
                <section>
                  <h4 id="strict-positivity">
                    3.4.3.2.2. Strict Positivity<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=strict-positivity" title="Permalink">🔗</a></span></h4>
                  <p>
                    All occurrences of the type being defined in the types of the parameters of the constructors must be in <span id="--tech-term-strictly-positive"><em>strictly positive</em></span> positions.
A position is strictly positive if it is not in a function's argument type (no matter how many function types are nested around it) and it is not an argument of any expression other than type constructors of inductive types.
This restriction rules out unsound inductive type definitions, at the cost of also ruling out some unproblematic ones.</p>
                  <details class="example"><summary class="description">Non-strictly-positive inductive types</summary><p>
                      The type <code>Bad</code> would make Lean inconsistent if it were not rejected:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #1 of 'Bad.bad' has a non positive occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-12064" data-verso-hover="20">inductive</span></span> <span class="const token" data-binding="const-Bad" data-verso-hover="372">Bad</span> <span class="keyword token" data-binding="kw-occ-null-12078">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">bad</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Bad" data-verso-hover="372">Bad</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Bad" data-verso-hover="372">Bad</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Bad" data-verso-hover="372">Bad</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>(kernel) arg #1 of 'Bad.bad' has a non positive occurrence of the datatypes being declared
</pre></div>
                    <p>
                      This is because it would be possible to write a circular argument that proves <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code> under the assumption <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bad" data-verso-hover="373">Bad</span></code>.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bad.bad" data-verso-hover="374">Bad.bad</span></code> is rejected because the constructor's parameter has type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bad" data-verso-hover="373">Bad</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Bad" data-verso-hover="373">Bad</span></code>, which is a function type in which <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bad" data-verso-hover="373">Bad</span></code> occurs as an argument type.</p>
                    <p>
                      This declaration of a fixed point operator is rejected, because <code>Fix</code> occurs as an argument to <code>f</code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #2 of 'Fix.fix' contains a non valid occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-12780" data-verso-hover="20">inductive</span></span> <span class="const token" data-binding="const-Fix" data-verso-hover="375" id="Fix">Fix</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="376">f</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-12799" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-12810" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-12818">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">fix</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="376">f</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#Fix"><span class="const token" data-binding="const-Fix" data-verso-hover="375">Fix</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="376">f</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Fix"><span class="const token" data-binding="const-Fix" data-verso-hover="375">Fix</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="376">f</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>(kernel) arg #2 of 'Fix.fix' contains a non valid occurrence of the datatypes being declared
</pre></div>
                    <p>
                      <code>Fix.fix</code> is rejected because <code>f</code> is not a type constructor of an inductive type, but <code>Fix</code> itself occurs as an argument to it.
In this case, <code>Fix</code> is also sufficient to construct a type equivalent to <code>Bad</code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13259">def</span> <span class="const token" data-binding="const-Bad" data-verso-hover="373">Bad</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">:=</span> <a href="The-Type-System/Inductive-Types/#Fix"><span class="const token" data-binding="const-Fix" data-verso-hover="377">Fix</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-13281">fun</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="88">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="88">t</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="88">t</span>
<span class="unknown token" data-binding=""></span></code></details></section>
                <section>
                  <h4 id="prop-vs-type">
                    3.4.3.2.3. Prop vs Type<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=prop-vs-type" title="Permalink">🔗</a></span></h4>
                  <p>
                    Lean rejects universe-polymorphic types that could not, in practice, be used polymorphically.
This could arise if certain instantiations of the universe parameters would cause the type itself to be a <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>.
If this type is not a <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-subsingleton">subsingleton</a>, then is recursor can only target propositions (that is, the <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-motive">motive</a> must return a <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>).
These types only really make sense as <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>s themselves, so the universe polymorphism is probably a mistake.
Because they are largely useless, Lean's inductive type elaborator has not been designed to support these types.</p>
                  <p>
                    When such universe-polymorphic inductive types are indeed subsingletons, it can make sense to define them.
Lean's standard library defines <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="70">PUnit</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Empty-Type/#PEmpty"><span class="const token" data-binding="const-PEmpty" data-verso-hover="378">PEmpty</span></a></code>.
To define a subsingleton that can inhabit <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code> or a <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="50">Type</span></code>, set the option <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#bootstrap___inductiveCheckResultingUniverse"><span class="option token" data-binding="option-bootstrap.inductiveCheckResultingUniverse" data-verso-hover="379">bootstrap.inductiveCheckResultingUniverse</span></a></code> to <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a></code>.</p>
                  <div class="namedocs" id="bootstrap___inductiveCheckResultingUniverse">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.option&name=bootstrap.inductiveCheckResultingUniverse" title="Permalink">🔗</a></span><span class="label">option</span><pre class="signature hl lean block">bootstrap.inductiveCheckResultingUniverse</pre><div class="text">
                      <p>
                        Default value: <code class="hl lean inline"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code></p>
                      <p>
                        by default the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Parser.Command.inductive" data-verso-hover="380">inductive</span></code>/<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Parser.Command.structure" data-verso-hover="381">structure</span></code> commands report an error if the resulting universe is not zero, but may be zero for some universe parameters. Reason: unless this type is a subsingleton, it is hardly what the user wants since it can only eliminate into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code>. In the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Init</span></code> package, we define subsingletons, and we use this option to disable the check. This option may be deleted in the future after we improve the validator</p>
                      </div>
                    </div>
                  <details class="example"><summary class="description">Overly-universe-polymorphic <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></code></summary><p>
                      Defining a version of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></code> that can be in any universe is not allowed:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-14528" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-PBool" data-verso-hover="382" id="PBool">PBool</span> <span class="unknown token" data-binding="">:</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid universe polymorphic resulting type, the resulting universe is not 'Prop', but it may be 'Prop' for some parameter values:
  Sort u
Possible solution: use levels of the form 'max 1 _' or '_ + 1' to ensure the universe is of the form 'Type _'.</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-14546" data-verso-hover="96">Sort</span></span> <span class="unknown token" data-binding="">u</span> <span class="keyword token" data-binding="kw-occ-null-14553">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">true</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">false</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>invalid universe polymorphic resulting type, the resulting universe is not 'Prop', but it may be 'Prop' for some parameter values:
  Sort u
Possible solution: use levels of the form 'max 1 _' or '_ + 1' to ensure the universe is of the form 'Type _'.
</pre></div>
                    </details></section>
                </section>
              <section>
                <h3 id="recursor-elaboration-helpers">
                  3.4.3.3. Constructions for Termination Checking<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=recursor-elaboration-helpers" title="Permalink">🔗</a></span></h3>
                <p>
                  In addition to the type constructor, constructors, and recursors that Lean's core type theory prescribes for inductive types, Lean constructs a number of useful helpers.
First, the equation compiler (which translates recursive functions with pattern matching in to applications of recursors) makes use of these additional constructs:</p>
                <ul>
                  <li>
                    <p>
                      <code>recOn</code> is a version of the recursor in which the target is prior to the cases for each constructor.</p>
                    </li>
                  <li>
                    <p>
                      <code>casesOn</code> is a version of the recursor in which the target is prior to the cases for each constructor, and recursive arguments do not yield induction hypotheses. It expresses case analysis rather than primitive recursion.</p>
                    </li>
                  <li>
                    <p>
                      <code>below</code> computes a type that, for some motive, expresses that <em>all</em> inhabitants of the inductive type that are subtrees of the target satisfy the motive. It transforms a motive for induction or primitive recursion into a motive for strong recursion or strong induction.</p>
                    </li>
                  <li>
                    <p>
                      <code>brecOn</code> is a version of the recursor in which <code>below</code> is used to provide access to all subtrees, rather than just immediate recursive parameters. It represents strong induction.</p>
                    </li>
                  <li>
                    <p>
                      <code>noConfusion</code> is a general statement from which injectivity and disjointness of constructors can be derived.</p>
                    </li>
                  <li>
                    <p>
                      <code>noConfusionType</code> is the motive used for <code>noConfusion</code> that determines what the consequences of two constructors being equal would be. For separate constructors, this is <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code>; if both constructors are the same, then the consequence is the equality of their respective parameters.</p>
                    </li>
                  </ul>
                <p>
                  For <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-recursion-next">well-founded recursion</a>, it is frequently useful to have a generic notion of size available.
This is captured in the <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a></code> class.</p>
                <div class="namedocs" id="SizeOf___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=SizeOf" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block">SizeOf.{u} (<span class="var token" data-binding="var-_uniq.152" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>) : <span class="sort token" data-binding="" data-verso-hover="96">Sort (max 1 u)</span></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf" data-verso-hover="383">SizeOf</span></a></code> is a typeclass automatically derived for every inductive type,
which equips the type with a "size" function to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>.
The default instance defines each constructor to be <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="7">1</span></code> plus the sum of the
sizes of all the constructor fields.</p>
                    <p>
                      This is used for proofs by well-founded induction, since every field of the
constructor has a smaller size than the constructor itself,
and in many cases this will suffice to do the proof that a recursive function
is only called on smaller values.
If the default proof strategy fails, it is recommended to supply a custom
size measure using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">termination_by</span></code> argument on the function definition.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="The-Type-System/Inductive-Types/#SizeOf___mk"><span class="const token" data-binding="const-SizeOf.mk" data-verso-hover="384">SizeOf.mk</span></a>.{u}</pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="385">sizeOf</span> : <span class="var token" data-binding="var-_uniq.146" data-verso-hover="95">α</span> → <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></pre><div class="docs">
                        <p>
                          The "size" of an element, a natural number which decreases on fields of
each inductive type.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="run-time-inductives">
                3.4.4. Run-Time Representation<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=run-time-inductives" title="Permalink">🔗</a></span></h2>
              <p>
                An inductive type's run-time representation depends both on how many constructors it has, how many arguments each constructor takes, and whether these arguments are <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-relevant">relevant</a>.</p>
              <section>
                <h3 id="inductive-types-runtime-special-support">
                  3.4.4.1. Exceptions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-types-runtime-special-support" title="Permalink">🔗</a></span></h3>
                <p>
                  Not every inductive type is represented as indicated here—some inductive types have special support from the Lean compiler:</p>
                <ul>
                  <li>
                    <p>
                      The representation of the fixed-width integer types <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#UInt8___ofBitVec"><span class="const token" data-binding="const-UInt8" data-verso-hover="386">UInt8</span></a></code>, …, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec"><span class="const token" data-binding="const-UInt64" data-verso-hover="387">UInt64</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#Int8___toUInt8"><span class="const token" data-binding="const-Int8" data-verso-hover="388">Int8</span></a></code>, …, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#Int64___toUInt64"><span class="const token" data-binding="const-Int64" data-verso-hover="389">Int64</span></a></code>, and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec"><span class="const token" data-binding="const-USize" data-verso-hover="390">USize</span></a></code> depends on the whether the code is compiled for a 32- or 64-bit architecture.
   Fixed-width integer types that are strictly smaller than the architecture's pointer type are stored unboxed by setting the lowest bit of a pointer to <code>1</code>.
   Integer types that are at least as large as the architecture's pointer type may be boxed or unboxed, depending on whether a concrete value fits in one fewer bits than the pointer type.
   If so, it is encoded by setting the lowest bit of the value to <code>1</code> (checked by <code>lean_is_scalar</code>).
   Otherwise, the value is represented is a pointer to a fixed-size Lean object on the heap.
   In the C FFI, these values are marshalled into the appropriate C types <code>uint8_t</code>, …, <code>uint64_t</code>, and <code>size_t</code>, respectively.<span class="marginalia"><span class="note">Fixed-width signed integer types are also represented as unsigned C integers in the FFI.</span></span></p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Characters/#Char___mk"><span class="const token" data-binding="const-Char" data-verso-hover="103">Char</span></a></code> is represented by <code>uint32_t</code>. Because <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Characters/#Char___mk"><span class="const token" data-binding="const-Char" data-verso-hover="103">Char</span></a></code> values never require more than 21 bits, they are always unboxed.</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Floating-Point-Numbers/#Float___mk"><span class="const token" data-binding="const-Float" data-verso-hover="270">Float</span></a></code> is represented by a pointer to a Lean object that contains a <code>double</code>.</p>
                    </li>
                  <li>
                    <p>
                      An <span id="--tech-term-enum-inductive"><em>enum inductive</em></span> type of at least 2 and at most <code class="math inline">2^{32}</code> constructors, each of which has no parameters, is represented by the first type of <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code> that is sufficient to assign a unique value to each constructor. For example, the type <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></code> is represented by <code>uint8_t</code>, with values <code>0</code> for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a></code> and <code>1</code> for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code>. </p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse"><span class="const token" data-binding="const-Decidable" data-verso-hover="391">Decidable</span></a> <span class="const token" data-binding="const-α" data-verso-hover="392">α</span></code> is represented the same way as <code>Bool</code> </p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="71">Int</span></a></code> are represented by <code>lean_object *</code>.
   A run-time <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> or <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="71">Int</span></a></code> value is either a pointer to an opaque arbitrary-precision integer object or, if the lowest bit of the “pointer” is <code>1</code> (checked by <code>lean_is_scalar</code>), an encoded unboxed natural number or integer (<code>lean_box</code>/<code>lean_unbox</code>). </p>
                    </li>
                  </ul>
                </section>
              <section>
                <h3 id="inductive-types-runtime-relevance">
                  3.4.4.2. Relevance<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-types-runtime-relevance" title="Permalink">🔗</a></span></h3>
                <p>
                  Types and proofs have no run-time representation.
That is, if an inductive type is a <code>Prop</code>, then its values are erased prior to compilation.
Similarly, all theorem statements and types are erased.
Types with run-time representations are called <span id="--tech-term-relevant"><em>relevant</em></span>, while types without run-time representations are called <span id="--tech-term-irrelevant"><em>irrelevant</em></span>.</p>
                <details class="example"><summary class="description">Types are irrelevant</summary><p>
                    Even though <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">List.cons</span></a></code> has the following signature, which indicates three parameters:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">List.cons</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-17065" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span></code><p>
                    its run-time representation has only two, because the type argument is run-time irrelevant.</p>
                  </details><details class="example"><summary class="description">Proofs are irrelevant</summary><p>
                    Even though <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="393">Fin.mk</span></a></code> has the following signature, which indicates three parameters:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="393">Fin.mk</span></a> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">val</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">val</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk"><span class="const token" data-binding="const-Fin" data-verso-hover="394">Fin</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span></code><p>
                    its run-time representation has only two, because the proof is erased.</p>
                  </details><p>
                  In most cases, irrelevant values simply disappear from compiled code.
However, in cases where some representation is required (such as when they are arguments to polymorphic constructors), they are represented by a trivial value.</p>
                </section>
              <section>
                <h3 id="inductive-types-trivial-wrappers">
                  3.4.4.3. Trivial Wrappers<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-types-trivial-wrappers" title="Permalink">🔗</a></span></h3>
                <p>
                  If an inductive type has exactly one constructor, and that constructor has exactly one run-time relevant parameter, then the inductive type is represented identically to its parameter.</p>
                <details class="example"><summary class="description">Zero-Overhead Subtypes</summary><p>
                    The structure <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="395">Subtype</span></a></code> bundles an element of some type with a proof that it satisfies a predicate.
Its constructor takes four arguments, but three of them are irrelevant:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="396">Subtype.mk</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="95">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-18206" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="397">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="95">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="46">val</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="95">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="398">property</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="397">p</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="46">val</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype" data-verso-hover="395">Subtype</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="397">p</span></code><p>
                    Thus, subtypes impose no runtime overhead in compiled code, and are represented identically to the type of the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Subtypes/#Subtype___mk"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="399">val</span></a></code> field.</p>
                  </details></section>
              <section>
                <h3 id="inductive-types-standard-representation">
                  3.4.4.4. Other Inductive Types<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-types-standard-representation" title="Permalink">🔗</a></span></h3>
                <p>
                  If an inductive type doesn't fall into one of the categories above, then its representation is determined by its constructors.
Constructors without relevant parameters are represented by their index into the list of constructors, as unboxed unsigned machine integers (scalars).
Constructors with relevant parameters are represented as an object with a header, the constructor's index, an array of pointers to other objects, and then arrays of scalar fields sorted by their types.
The header tracks the object's reference count and other necessary bookkeeping.</p>
                <p>
                  Recursive functions are compiled as they are in most programming languages, rather than by using the inductive type's recursor.
Elaborating recursive functions to recursors serves to provide reliable termination evidence, not executable code.</p>
                <section>
                  <h4 id="inductive-types-ffi">
                    3.4.4.4.1. FFI<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inductive-types-ffi" title="Permalink">🔗</a></span></h4>
                  <p>
                    From the perspective of C, these other inductive types are represented by <code>lean_object *</code>.
Each constructor is stored as a <code>lean_ctor_object</code>, and <code>lean_is_ctor</code> will return true.
A <code>lean_ctor_object</code> stores the constructor index in its header, and the fields are stored in the <code>m_objs</code> portion of the object.
Lean assumes that <code>sizeof(size_t) == sizeof(void*)</code>—while this is not guaranteed by C, the Lean run-time system contains an assertion that fails if this is not the case.</p>
                  <p>
                    The memory order of the fields is derived from the types and order of the fields in the declaration. They are ordered as follows:</p>
                  <ul>
                    <li>
                      <p>
                        Non-scalar fields stored as <code>lean_object *</code></p>
                      </li>
                    <li>
                      <p>
                        Fields of type <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec"><span class="const token" data-binding="const-USize" data-verso-hover="390">USize</span></a></code></p>
                      </li>
                    <li>
                      <p>
                        Other scalar fields, in decreasing order by size</p>
                      </li>
                    </ul>
                  <p>
                    Within each group the fields are ordered in declaration order. <strong>Warning</strong>: Trivial wrapper types still count toward a field being treated as non-scalar for this purpose.</p>
                  <ul>
                    <li>
                      <p>
                        To access fields of the first kind, use <code>lean_ctor_get(val, i)</code> to get the <code>i</code>th non-scalar field.</p>
                      </li>
                    <li>
                      <p>
                        To access <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec"><span class="const token" data-binding="const-USize" data-verso-hover="390">USize</span></a></code> fields, use <code>lean_ctor_get_usize(val, n+i)</code> to get the <code>i</code>th <code>USize</code> field and <code>n</code> is the total number of fields of the first kind.</p>
                      </li>
                    <li>
                      <p>
                        To access other scalar fields, use <code>lean_ctor_get_uintN(val, off)</code> or <code>lean_ctor_get_usize(val, off)</code> as appropriate. Here <code>off</code> is the byte offset of the field in the structure, starting at <code>n*sizeof(void*)</code> where <code>n</code> is the number of fields of the first two kinds.</p>
                      </li>
                    </ul>
                  <p>
                    For example, a structure such as</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-20861">structure</span> <span class="const token" data-binding="const-S" data-verso-hover="68" id="S___ptr_2">S</span> <span class="keyword token" data-binding="kw-occ-null-20873">where</span>
  <span class="const token" data-binding="const-S.ptr_1" data-verso-hover="400" id="S___ptr_2">ptr_1</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="const token" data-binding="const-S.usize_1" data-verso-hover="401" id="S___ptr_2">usize_1</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec"><span class="const token" data-binding="const-USize" data-verso-hover="390">USize</span></a>
  <span class="const token" data-binding="const-S.sc64_1" data-verso-hover="402" id="S___ptr_2">sc64_1</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec"><span class="const token" data-binding="const-UInt64" data-verso-hover="387">UInt64</span></a>
  <span class="const token" data-binding="const-S.ptr_2" data-verso-hover="403" id="S___ptr_2">ptr_2</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">{</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="404">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec"><span class="const token" data-binding="const-UInt64" data-verso-hover="387">UInt64</span></a> <span class="unknown token" data-binding="">//</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="404">x</span> <span class="unknown token" data-binding="">&gt;</span> <span class="typed token" data-binding="" data-verso-hover="404">0</span> <span class="unknown token" data-binding="">}</span> -- wrappers don't count as scalars
  <span class="const token" data-binding="const-S.sc64_2" data-verso-hover="405" id="S___ptr_2">sc64_2</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Floating-Point-Numbers/#Float___mk"><span class="const token" data-binding="const-Float" data-verso-hover="270">Float</span></a> -- `Float` is 64 bit
  <span class="const token" data-binding="const-S.sc8_1" data-verso-hover="406" id="S___ptr_2">sc8_1</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a>
  <span class="const token" data-binding="const-S.sc16_1" data-verso-hover="407" id="S___ptr_2">sc16_1</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Fixed-Precision-Integers/#UInt16___ofBitVec"><span class="const token" data-binding="const-UInt16" data-verso-hover="408">UInt16</span></a>
  <span class="const token" data-binding="const-S.sc8_2" data-verso-hover="409" id="S___ptr_2">sc8_2</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Fixed-Precision-Integers/#UInt8___ofBitVec"><span class="const token" data-binding="const-UInt8" data-verso-hover="386">UInt8</span></a>
  <span class="const token" data-binding="const-S.sc64_3" data-verso-hover="410" id="S___ptr_2">sc64_3</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec"><span class="const token" data-binding="const-UInt64" data-verso-hover="387">UInt64</span></a>
  <span class="const token" data-binding="const-S.usize_2" data-verso-hover="411" id="S___ptr_2">usize_2</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec"><span class="const token" data-binding="const-USize" data-verso-hover="390">USize</span></a>
  <span class="const token" data-binding="const-S.ptr_3" data-verso-hover="412" id="S___ptr_2">ptr_3</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Characters/#Char___mk"><span class="const token" data-binding="const-Char" data-verso-hover="103">Char</span></a> -- trivial wrapper around `UInt32`
  <span class="const token" data-binding="const-S.sc32_1" data-verso-hover="413" id="S___ptr_2">sc32_1</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Fixed-Precision-Integers/#UInt32___ofBitVec"><span class="const token" data-binding="const-UInt32" data-verso-hover="143">UInt32</span></a>
  <span class="const token" data-binding="const-S.sc16_2" data-verso-hover="414" id="S___ptr_2">sc16_2</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Fixed-Precision-Integers/#UInt16___ofBitVec"><span class="const token" data-binding="const-UInt16" data-verso-hover="408">UInt16</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                    would get re-sorted into the following memory order:</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.ptr_1" data-verso-hover="400">S.ptr_1</span></a></code> - <code>lean_ctor_get(val, 0)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.ptr_2" data-verso-hover="403">S.ptr_2</span></a></code> - <code>lean_ctor_get(val, 1)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.ptr_3" data-verso-hover="412">S.ptr_3</span></a></code> - <code>lean_ctor_get(val, 2)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.usize_1" data-verso-hover="401">S.usize_1</span></a></code> - <code>lean_ctor_get_usize(val, 3)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.usize_2" data-verso-hover="411">S.usize_2</span></a></code> - <code>lean_ctor_get_usize(val, 4)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.sc64_1" data-verso-hover="402">S.sc64_1</span></a></code> - <code>lean_ctor_get_uint64(val, sizeof(void*)*5)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.sc64_2" data-verso-hover="405">S.sc64_2</span></a></code> - <code>lean_ctor_get_float(val, sizeof(void*)*5 + 8)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.sc64_3" data-verso-hover="410">S.sc64_3</span></a></code> - <code>lean_ctor_get_uint64(val, sizeof(void*)*5 + 16)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.sc32_1" data-verso-hover="413">S.sc32_1</span></a></code> - <code>lean_ctor_get_uint32(val, sizeof(void*)*5 + 24)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.sc16_1" data-verso-hover="407">S.sc16_1</span></a></code> - <code>lean_ctor_get_uint16(val, sizeof(void*)*5 + 28)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.sc16_2" data-verso-hover="414">S.sc16_2</span></a></code> - <code>lean_ctor_get_uint16(val, sizeof(void*)*5 + 30)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.sc8_1" data-verso-hover="406">S.sc8_1</span></a></code> - <code>lean_ctor_get_uint8(val, sizeof(void*)*5 + 32)</code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#S___ptr_2"><span class="const token" data-binding="const-S.sc8_2" data-verso-hover="409">S.sc8_2</span></a></code> - <code>lean_ctor_get_uint8(val, sizeof(void*)*5 + 33)</code></p>
                      </li>
                    </ul>
                  </section>
                </section>
              </section>
            <section>
              <h2 id="mutual-inductive-types">
                3.4.5. Mutual Inductive Types<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-inductive-types" title="Permalink">🔗</a></span></h2>
              <p>
                Inductive types may be mutually recursive.
Mutually recursive definitions of inductive types are specified by defining the types in a <code>mutual ... end</code> block.</p>
              <details class="example"><summary class="description">Mutually Defined Inductive Types</summary><p>
                  The type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList" data-verso-hover="201">EvenOddList</span></code> in a prior example used a Boolean index to select whether the list in question should have an even or odd number of elements.
This distinction can also be expressed by the choice of one of two mutually inductive types <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList" data-verso-hover="415">EvenList</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-OddList" data-verso-hover="416">OddList</span></a></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-22704">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-22713" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-EvenList" data-verso-hover="415" id="EvenList___nil">EvenList</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-22738" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-22748" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="keyword token" data-binding="kw-occ-null-22755">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-EvenList.nil" data-verso-hover="417" id="EvenList___nil">nil</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList" data-verso-hover="415">EvenList</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-EvenList.cons" data-verso-hover="418" id="EvenList___nil">cons</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-OddList" data-verso-hover="416">OddList</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList" data-verso-hover="415">EvenList</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-22834" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-OddList" data-verso-hover="416" id="EvenList___nil">OddList</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-22858" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-22868" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="keyword token" data-binding="kw-occ-null-22875">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-OddList.cons" data-verso-hover="419" id="EvenList___nil">cons</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList" data-verso-hover="415">EvenList</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-OddList" data-verso-hover="416">OddList</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-22704">end</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-22933">example</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList" data-verso-hover="415">EvenList</span></a> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <span class="unknown token" data-binding="">:=</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList.cons" data-verso-hover="418">.cons</span></a> <span class="literal string token" data-binding="" data-verso-hover="420">"x"</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-OddList.cons" data-verso-hover="419">.cons</span></a> <span class="literal string token" data-binding="" data-verso-hover="421">"y"</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList.nil" data-verso-hover="417">.nil</span></a><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-22989">example</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-OddList" data-verso-hover="416">OddList</span></a> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <span class="unknown token" data-binding="">:=</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-OddList.cons" data-verso-hover="419">.cons</span></a> <span class="literal string token" data-binding="" data-verso-hover="420">"x"</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList.cons" data-verso-hover="418">.cons</span></a> <span class="literal string token" data-binding="" data-verso-hover="421">"y"</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-OddList.cons" data-verso-hover="419">.cons</span></a> <span class="literal string token" data-binding="" data-verso-hover="422">"z"</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList.nil" data-verso-hover="417">.nil</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23105">example</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-OddList" data-verso-hover="416">OddList</span></a> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <span class="unknown token" data-binding="">:=</span> <a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-OddList.cons" data-verso-hover="419">.cons</span></a> <span class="literal string token" data-binding="" data-verso-hover="420">"x"</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#EvenList___nil"><span class="const token" data-binding="const-EvenList.cons" data-verso-hover="418">.cons</span></a> <span class="literal string token" data-binding="" data-verso-hover="421">"y"</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid dotted identifier notation, unknown identifier `OddList.nil` from expected type
  OddList String</code></span></span><span class="unknown token" data-binding="">.nil</span></span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>invalid dotted identifier notation, unknown identifier `OddList.nil` from expected type
  OddList String
</pre></div>
                </details><section>
                <h3 id="mutual-inductive-types-requirements">
                  3.4.5.1. Requirements<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-inductive-types-requirements" title="Permalink">🔗</a></span></h3>
                <p>
                  The inductive types declared in a <code>mutual</code> block are considered as a group; they must collectively satisfy generalized versions of the well-formedness criteria for non-mutually-recursive inductive types.
This is true even if they could be defined without the <code>mutual</code> block, because they are not in fact mutually recursive.</p>
                <section>
                  <h4 id="mutual-inductive-types-dependencies">
                    3.4.5.1.1. Mutual Dependencies<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-inductive-types-dependencies" title="Permalink">🔗</a></span></h4>
                  <p>
                    Each type constructor's signature must be able to be elaborated without reference to the other inductive types in the <code>mutual</code> group.
In other words, the inductive types in the <code>mutual</code> group may not take each other as arguments.
The constructors of each inductive type may mention the other type constructors in the group in their parameter types, with restrictions that are a generalization of those for recursive occurrences in non-mutual inductive types.</p>
                  <details class="example"><summary class="description">Mutual inductive type constructors may not mention each other</summary><p>
                      These inductive types are not accepted by Lean:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-24408">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-24417" data-verso-hover="20">inductive</span> <span class="unknown token" data-binding="">FreshList</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="423">r</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="keyword token" data-binding="kw-occ-null-24481">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">nil</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">FreshList</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">r</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">cons</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">xs</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">FreshList</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">r</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">fresh</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">Fresh</span> <span class="unknown token" data-binding="">r</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">xs</span><span class="unknown token" data-binding="">)</span>
  <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid mutually inductive types, binder annotation mismatch at parameter 'α'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-24581" data-verso-hover="20">inductive</span></span> <span class="unknown token" data-binding="">Fresh</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="424">r</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="425">α</span> <span class="unknown token" data-binding="">→</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'FreshList'</code></span></span><span class="unknown token" data-binding="">FreshList</span></span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="425">α</span> <span class="unknown token" data-binding="">→</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'FreshList'</code></span></span><span class="unknown token" data-binding="">FreshList</span></span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">r</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span> <span class="keyword token" data-binding="kw-occ-null-24665">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">nil</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">Fresh</span> <span class="unknown token" data-binding="">r</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">.nil</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">cons</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">r</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">Fresh</span> <span class="unknown token" data-binding="">r</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">Fresh</span> <span class="unknown token" data-binding="">r</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">.cons</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">ys</span> <span class="unknown token" data-binding="">f</span><span class="unknown token" data-binding="">)</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-24408">end</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      The type constructors may not refer to the other type constructors in the <code>mutual</code> group, so <code>FreshList</code> is not in scope in the type constructor of <code>Fresh</code>:</p>
                    <div class="error">
                      <pre>unknown identifier 'FreshList'
</pre></div>
                    </details></section>
                <section>
                  <h4 id="mutual-inductive-types-same-parameters">
                    3.4.5.1.2. Parameters Must Match<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-inductive-types-same-parameters" title="Permalink">🔗</a></span></h4>
                  <p>
                    All inductive types in the <code>mutual</code> group must have the same <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-parameters">parameters</a>.
Their indices may differ.</p>
                  <details class="example"><summary class="description">Differing numbers of parameters</summary><p>
                      Even though <code>Both</code> and <code>OneOf</code> are not mutually recursive, they are declared in the same <code>mutual</code> block and must therefore have identical parameters:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-25452">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-25461" data-verso-hover="20">inductive</span> <span class="unknown token" data-binding="">Both</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-25482" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="172">β</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-25496" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-25504">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">mk</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">β</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">Both</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">β</span>
  <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid inductive type, number of parameters mismatch in mutually inductive datatypes</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-25548" data-verso-hover="20">inductive</span></span> <span class="unknown token" data-binding="">Optional</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-25573" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-25581">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">none</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">some</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">Optional</span> <span class="unknown token" data-binding="">α</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-25452">end</span></a>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>invalid inductive type, number of parameters mismatch in mutually inductive datatypes
</pre></div>
                    </details><details class="example"><summary class="description">Differing parameter types</summary><p>
                      Even though <code>Many</code> and <code>OneOf</code> are not mutually recursive, they are declared in the same <code>mutual</code> block and must therefore have identical parameters.
They both have exactly one parameter, but <code>Many</code>'s parameter is not necessarily in the same universe as <code>Optional</code>'s:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-26132">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-26141" data-verso-hover="20">inductive</span> <span class="unknown token" data-binding="">Many</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-26170" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="keyword token" data-binding="kw-occ-null-26177">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">nil</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">Many</span> <span class="unknown token" data-binding="">α</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">cons</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">Many</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">Many</span> <span class="unknown token" data-binding="">α</span>
  <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid mutually inductive types, parameter 'α' has type
  Type u : Type (u + 1)
but is expected to have type
  Type : Type 1</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-26245" data-verso-hover="20">inductive</span></span> <span class="unknown token" data-binding="">Optional</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-26270" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-26278">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">none</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">some</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">Optional</span> <span class="unknown token" data-binding="">α</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-26132">end</span></a>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>invalid mutually inductive types, parameter 'α' has type
  Type u : Type (u + 1)
but is expected to have type
  Type : Type 1
</pre></div>
                    </details></section>
                <section>
                  <h4 id="mutual-inductive-types-same-universe">
                    3.4.5.1.3. Universe Levels<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-inductive-types-same-universe" title="Permalink">🔗</a></span></h4>
                  <p>
                    The universe levels of each inductive type in a mutual group must obey the same requirements as non-mutually-recursive inductive types.
Additionally, all the inductive types in a mutual group must be in the same universe, which implies that their constructors are similarly limited with respect to their parameters' universes.</p>
                  <details class="example"><summary class="description">Universe mismatch</summary><p>
                      These mutually-inductive types are a somewhat complicated way to represent run-length encoding of a list:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-27063">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-27072" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-RLE" data-verso-hover="426">RLE</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="keyword token" data-binding="kw-occ-null-27105">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-RLE.nil" data-verso-hover="427" id="RLE___run">nil</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-RLE" data-verso-hover="426">RLE</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-RLE.run" data-verso-hover="428" id="RLE___run">run</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.94" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="88">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.96" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.96" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">≠</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="429">PrefixRunOf</span></a> <span class="var token" data-binding="var-_uniq.96" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.94" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.92" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-RLE" data-verso-hover="426">RLE</span> <span class="var token" data-binding="var-_uniq.92" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-RLE" data-verso-hover="426">RLE</span> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="51">xs</span>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-27216" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="429" id="RLE___run">PrefixRunOf</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="keyword token" data-binding="kw-occ-null-27284">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="430" id="RLE___run">zero</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.170" data-verso-hover="431">noMore</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">∃</span><span class="var token" data-binding="var-_uniq.161" data-verso-hover="432">zs</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.141" data-verso-hover="432">xs</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.154" data-verso-hover="433">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.161" data-verso-hover="432">zs</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-27331">by</span> <a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-27337" data-verso-hover="36">simp</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="429">PrefixRunOf</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="var token" data-binding="var-_uniq.154" data-verso-hover="433">x</span> <span class="var token" data-binding="var-_uniq.141" data-verso-hover="432">xs</span> <span class="var token" data-binding="var-_uniq.141" data-verso-hover="432">xs</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="434" id="RLE___run">succ</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="429">PrefixRunOf</span></a> <span class="var token" data-binding="var-_uniq.185" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.191" data-verso-hover="435">x</span> <span class="var token" data-binding="var-_uniq.197" data-verso-hover="436">xs</span> <span class="var token" data-binding="var-_uniq.203" data-verso-hover="436">ys</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="429">PrefixRunOf</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.185" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.191" data-verso-hover="435">x</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.191" data-verso-hover="435">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.197" data-verso-hover="436">xs</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.203" data-verso-hover="436">ys</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-27063">end</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-27444">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-RLE" data-verso-hover="426">RLE</span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:=</span>
  <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-RLE.run" data-verso-hover="428">.run</span></a> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-12875798682284018932-27498-27500"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-27498" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12875798682284018932-27498-27500"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">2<span class="const token" data-binding="const-Ne" data-verso-hover="437"> ≠ </span>0</span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-27501-27507"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-27501" data-verso-hover="187">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-27501-27507"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="434">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="434">.succ</span></a> <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="430">.zero</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;|</span>
  <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-RLE.run" data-verso-hover="428">.run</span></a> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-12875798682284018932-27546-27548"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-27546" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12875798682284018932-27546-27548"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">2<span class="const token" data-binding="const-Ne" data-verso-hover="437"> ≠ </span>0</span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-27549-27555"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-27549" data-verso-hover="187">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-27549-27555"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="434">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="434">.succ</span></a> <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="430">.zero</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;|</span>
  <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-RLE.run" data-verso-hover="428">.run</span></a> <span class="typed token" data-binding="" data-verso-hover="7">3</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-17098923058934507682-27594-27596"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-27594" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17098923058934507682-27594-27596"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-Ne" data-verso-hover="437"> ≠ </span>0</span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-27597-27603"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-27597" data-verso-hover="187">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-27597-27603"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="434">.succ</span></a> <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="430">.zero</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;|</span>
  <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-RLE.run" data-verso-hover="428">.run</span></a> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="typed token" data-binding="" data-verso-hover="7">3</span> <span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-3000842265203412013-27634-27636"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-27634" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3000842265203412013-27634-27636"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">3<span class="const token" data-binding="const-Ne" data-verso-hover="437"> ≠ </span>0</span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-27637-27643"><a href="Tactic-Proofs/Tactic-Reference/#decide"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-27637" data-verso-hover="187">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-27637-27643"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="434">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="434">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="434">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="430">.zero</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;|</span>
  <a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-RLE.nil" data-verso-hover="427">.nil</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      Specifying <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#RLE___run"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="429">PrefixRunOf</span></a></code> as a <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="23">Prop</span></code> would be sensible, but it cannot be done because the types would be in different universes:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-27889">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-27898" data-verso-hover="20">inductive</span> <span class="unknown token" data-binding="">RLE</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="438">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="keyword token" data-binding="kw-occ-null-27931">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">nil</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">RLE</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">run</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">n</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">n</span> <span class="unknown token" data-binding="">≠</span> <span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">PrefixRunOf</span> <span class="unknown token" data-binding="">n</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">xs</span> <span class="unknown token" data-binding="">ys</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">RLE</span> <span class="unknown token" data-binding="">ys</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">RLE</span> <span class="unknown token" data-binding="">xs</span>

  <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid mutually inductive types, resulting universe mismatch, given
  Prop
expected type
  Type</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-28042" data-verso-hover="20">inductive</span></span> <span class="unknown token" data-binding="">PrefixRunOf</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="439">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="439">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="439">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span> <span class="keyword token" data-binding="kw-occ-null-28110">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">zero</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">noMore</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">∃</span><span class="unknown token" data-binding="">zs</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">xs</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">::</span> <span class="unknown token" data-binding="">zs</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-28157">by</span> <a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-28163" data-verso-hover="36">simp</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">PrefixRunOf</span> <span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">xs</span> <span class="unknown token" data-binding="">xs</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">succ</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">PrefixRunOf</span> <span class="unknown token" data-binding="">n</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">xs</span> <span class="unknown token" data-binding="">ys</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">PrefixRunOf</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">::</span> <span class="unknown token" data-binding="">xs</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">ys</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-27889">end</span></a>
<span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>invalid mutually inductive types, resulting universe mismatch, given
  Prop
expected type
  Type
</pre></div>
                    <p>
                      This particular property can be expressed by separately defining the well-formedness condition and using a subtype:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28535">def</span> <span class="const token" data-binding="const-RunLengths" data-verso-hover="440" id="RunsMatch">RunLengths</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">:=</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">×</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28573">def</span> <span class="const token" data-binding="const-NoRepeats" data-verso-hover="441" id="RunsMatch">NoRepeats</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RunLengths" data-verso-hover="440">RunLengths</span></a> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.122" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">::</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.124" data-verso-hover="46">y</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.125" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.126" data-verso-hover="442">xs</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.122" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">≠</span> <span class="var token" data-binding="var-_uniq.124" data-verso-hover="46">y</span> <span class="unknown token" data-binding="">∧</span> <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-NoRepeats" data-verso-hover="441">NoRepeats</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.124" data-verso-hover="46">y</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.125" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.126" data-verso-hover="442">xs</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28716">def</span> <span class="const token" data-binding="const-RunsMatch" data-verso-hover="443" id="RunsMatch">RunsMatch</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RunLengths" data-verso-hover="440">RunLengths</span></a> <span class="var token" data-binding="var-_uniq.419" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.419" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.498" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.499" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.500" data-verso-hover="442">xs</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.501" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.501" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___take"><span class="const token" data-binding="const-List.take" data-verso-hover="444">take</span></a> <span class="var token" data-binding="var-_uniq.499" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Linked-Lists/#List___replicate"><span class="const token" data-binding="const-List.replicate" data-verso-hover="445">List.replicate</span></a> <span class="var token" data-binding="var-_uniq.499" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.498" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">∧</span>
    <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RunsMatch" data-verso-hover="443">RunsMatch</span></a> <span class="var token" data-binding="var-_uniq.500" data-verso-hover="442">xs</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.501" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___drop"><span class="const token" data-binding="const-List.drop" data-verso-hover="110">drop</span></a> <span class="var token" data-binding="var-_uniq.499" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28896">def</span> <span class="const token" data-binding="const-NonZero" data-verso-hover="446" id="RunsMatch">NonZero</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RunLengths" data-verso-hover="440">RunLengths</span></a> <span class="var token" data-binding="var-_uniq.832" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.890" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.891" data-verso-hover="442">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.890" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">≠</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">∧</span> <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-NonZero" data-verso-hover="446">NonZero</span></a> <span class="var token" data-binding="var-_uniq.891" data-verso-hover="442">xs</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-28991">structure</span> <span class="const token" data-binding="const-RLE" data-verso-hover="447">RLE</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1095" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.1092" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-29020">where</span>
  <span class="const token" data-binding="const-RLE.rle" data-verso-hover="448" id="RunsMatch">rle</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RunLengths" data-verso-hover="440">RunLengths</span></a> <span class="var token" data-binding="var-_uniq.1092" data-verso-hover="44">α</span>
  <span class="const token" data-binding="const-RLE.noRepeats" data-verso-hover="449" id="RunsMatch">noRepeats</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-NoRepeats" data-verso-hover="441">NoRepeats</span></a> <span class="var token" data-binding="var-_uniq.1101" data-verso-hover="450">rle</span>
  <span class="const token" data-binding="const-RLE.runsMatch" data-verso-hover="451" id="RunsMatch">runsMatch</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RunsMatch" data-verso-hover="443">RunsMatch</span></a> <span class="var token" data-binding="var-_uniq.1101" data-verso-hover="450">rle</span> <span class="var token" data-binding="var-_uniq.1095" data-verso-hover="51">xs</span>
  <span class="const token" data-binding="const-RLE.nonZero" data-verso-hover="452" id="RunsMatch">nonZero</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-NonZero" data-verso-hover="446">NonZero</span></a> <span class="var token" data-binding="var-_uniq.1101" data-verso-hover="450">rle</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-29132">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-RLE" data-verso-hover="447">RLE</span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-29171">where</span>
  <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RLE.rle" data-verso-hover="453">rle</span></a> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span>
  <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RLE.noRepeats" data-verso-hover="454">noRepeats</span></a> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14791385744128616585-29234-29236"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-29234" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14791385744128616585-29234-29236"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-NoRepeats" data-verso-hover="441">NoRepeats</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">[</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>2<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>2<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>2<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>3<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>3<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">]</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-29237-29253"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-29237" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-NoRepeats" data-verso-hover="441">NoRepeats</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-29237-29253"><span class="tactic-state">All goals completed! 🐙</span></span>
  <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RLE.runsMatch" data-verso-hover="456">runsMatch</span></a> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-17290760914236520226-29269-29271"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-29269" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17290760914236520226-29269-29271"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RunsMatch" data-verso-hover="443">RunsMatch</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">[</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>2<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>2<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>2<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>3<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>3<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">]</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">[</span></a>1<a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a>1<a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a>2<a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a>2<a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a>3<a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a>1<a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a>1<a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a>1<a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">]</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-29272-29288"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-29272" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RunsMatch" data-verso-hover="443">RunsMatch</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-29272-29288"><span class="tactic-state">All goals completed! 🐙</span></span>
  <a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-RLE.nonZero" data-verso-hover="457">nonZero</span></a> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-7699652078728741566-29302-29304"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-29302" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7699652078728741566-29302-29304"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-NonZero" data-verso-hover="446">NonZero</span></a> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">[</span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>2<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>2<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>2<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>3<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">, </span></a><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">(</span></a>1<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">, </span></a>3<a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="455">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">]</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-29305-29319"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-29305" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><a href="The-Type-System/Inductive-Types/#RunsMatch"><span class="const token" data-binding="const-NonZero" data-verso-hover="446">NonZero</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-29305-29319"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></details></section>
                <section>
                  <h4 id="mutual-inductive-types-positivity">
                    3.4.5.1.4. Positivity<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-inductive-types-positivity" title="Permalink">🔗</a></span></h4>
                  <p>
                    Each inductive type that is defined in the <code>mutual</code> group may occur only strictly positively in the types of the parameters of the constructors of all the types in the group.
In other words, in the type of each parameter to each constructor in all the types of the group, none of the type constructors in the group occur to the left of any arrows, and none of them occur in argument positions unless they are an argument to an inductive type's type constructor.</p>
                  <details class="example"><summary class="description">Mutual strict positivity</summary><p>
                      In the following mutual group, <code>Tm</code> occurs in a negative position in the argument to <code>Binding.scope</code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-30051">mutual</span></a>
  <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #1 of 'Binding.scope' has a non positive occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-30060" data-verso-hover="20">inductive</span></span> <span class="const token" data-binding="const-Tm" data-verso-hover="458">Tm</span> <span class="keyword token" data-binding="kw-occ-null-30073">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">app</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tm" data-verso-hover="458">Tm</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tm" data-verso-hover="458">Tm</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tm" data-verso-hover="458">Tm</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">lam</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Tm"><span class="const token" data-binding="const-Binding" data-verso-hover="458">Binding</span></a> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tm" data-verso-hover="458">Tm</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-30137" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Binding" data-verso-hover="458" id="Tm">Binding</span> <span class="keyword token" data-binding="kw-occ-null-30155">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">scope</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Tm" data-verso-hover="458">Tm</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Tm" data-verso-hover="458">Tm</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Tm"><span class="const token" data-binding="const-Binding" data-verso-hover="458">Binding</span></a>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-30051">end</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                      Because <code>Tm</code> is part of the same mutual group, it must occur only strictly positively in the arguments to the constructors of <code>Binding</code>.
It occurs, however, negatively:</p>
                    <div class="error">
                      <pre>(kernel) arg #1 of 'Binding.scope' has a non positive occurrence of the datatypes being declared
</pre></div>
                    </details><details class="example"><summary class="description">Nested positions</summary><p>
                      The definitions of <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Stx___node"><span class="const token" data-binding="const-LocatedStx" data-verso-hover="459">LocatedStx</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Stx___node"><span class="const token" data-binding="const-Stx" data-verso-hover="460">Stx</span></a></code> satisfy the positivity condition because the recursive occurrences are not to the left of any arrows and, when they are arguments, they are arguments to inductive type constructors.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-30783">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-30792" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-LocatedStx" data-verso-hover="459" id="Stx___node">LocatedStx</span> <span class="keyword token" data-binding="kw-occ-null-30813">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-LocatedStx.mk" data-verso-hover="461" id="Stx___node">mk</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">line</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">col</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="462">val</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Stx___node"><span class="const token" data-binding="const-Stx" data-verso-hover="460">Stx</span></a><span class="unknown token" data-binding="">)</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-30859" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Stx" data-verso-hover="460" id="Stx___node">Stx</span> <span class="keyword token" data-binding="kw-occ-null-30873">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Stx.atom" data-verso-hover="463" id="Stx___node">atom</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="239">str</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Stx.node" data-verso-hover="464" id="Stx___node">node</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="239">kind</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="465">args</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="The-Type-System/Inductive-Types/#Stx___node"><span class="const token" data-binding="const-LocatedStx" data-verso-hover="459">LocatedStx</span></a><span class="unknown token" data-binding="">)</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-30783">end</span></a>
<span class="unknown token" data-binding=""></span></code></details></section>
                </section>
              <section>
                <h3 id="mutual-inductive-types-recursors">
                  3.4.5.2. Recursors<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-inductive-types-recursors" title="Permalink">🔗</a></span></h3>
                <p>
                  Mutual inductive types are provided with primitive recursors, just like non-mutually-defined inductive types.
These recursors take into account that they must process the other types in the group, and thus will have a motive for each inductive type.
Because all inductive types in the <code>mutual</code> group are required to have identical parameters, the recursors still take the parameters first, abstracting them over the motives and the rest of the recursor.
Additionally, because the recursor must process the group's other types, it will require cases for each constructor of each of the types in the group.
The actual dependency structure between the types is not taken into account; even if an additional motive or constructor case is not really required due to there being fewer mutual dependencies than there could be, the generated recursor still requires them.</p>
                <details class="example"><summary class="description">Even and odd</summary><code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-31946">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-31955" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span> <span class="keyword token" data-binding="kw-occ-null-31985">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Even.zero" data-verso-hover="24">zero</span> <span class="unknown token" data-binding="">:</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Even.succ" data-verso-hover="466" id="Even___zero-next-next-next">succ</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Odd" data-verso-hover="467">Odd</span></a> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">→</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-32049" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Odd" data-verso-hover="467" id="Even___zero-next-next-next">Odd</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span> <span class="keyword token" data-binding="kw-occ-null-32078">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Odd.succ" data-verso-hover="468" id="Even___zero-next-next-next">succ</span> <span class="unknown token" data-binding="">:</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a> <span class="var token" data-binding="var-_uniq.91" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Odd" data-verso-hover="467">Odd</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-31946">end</span></a>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Even.rec" data-verso-hover="469">Even.rec</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="470">motive_1</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="471">motive_2</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Odd" data-verso-hover="467">Odd</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="472">zero</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="470">motive_1</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even.zero" data-verso-hover="24">Even.zero</span></a><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="473">succ</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="474">a</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Odd" data-verso-hover="467">Odd</span></a> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="471">motive_2</span> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="474">a</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="470">motive_1</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Even.succ" data-verso-hover="466">Even.succ</span></a> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="474">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.101" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.103" data-verso-hover="475">a</span> <span class="unknown token" data-binding="">:</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a> <span class="var token" data-binding="var-_uniq.101" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="470">motive_1</span> <span class="var token" data-binding="var-_uniq.101" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="475">a</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="471">motive_2</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.101" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Odd.succ" data-verso-hover="468">Odd.succ</span></a> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="475">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
  <span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.150" data-verso-hover="476">t</span> <span class="unknown token" data-binding="">:</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="470">motive_1</span> <span class="var token" data-binding="var-_uniq.148" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.150" data-verso-hover="476">t</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Odd.rec" data-verso-hover="477">Odd.rec</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="470">motive_1</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="471">motive_2</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Odd" data-verso-hover="467">Odd</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="472">zero</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="470">motive_1</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even.zero" data-verso-hover="24">Even.zero</span></a><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.96" data-verso-hover="473">succ</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="474">a</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Odd" data-verso-hover="467">Odd</span></a> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="471">motive_2</span> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.32" data-verso-hover="474">a</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="470">motive_1</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Even.succ" data-verso-hover="466">Even.succ</span></a> <span class="var token" data-binding="var-_uniq.32" data-verso-hover="474">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.100" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.102" data-verso-hover="475">a</span> <span class="unknown token" data-binding="">:</span> <a href="Introduction/#Even___zero-next-next"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a> <span class="var token" data-binding="var-_uniq.100" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="470">motive_1</span> <span class="var token" data-binding="var-_uniq.100" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="475">a</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="471">motive_2</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.100" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Odd.succ" data-verso-hover="468">Odd.succ</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="475">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.147" data-verso-hover="7">a</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.149" data-verso-hover="478">t</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Even___zero-next-next-next"><span class="const token" data-binding="const-Odd" data-verso-hover="467">Odd</span></a> <span class="var token" data-binding="var-_uniq.147" data-verso-hover="7">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="471">motive_2</span> <span class="var token" data-binding="var-_uniq.147" data-verso-hover="7">a</span> <span class="var token" data-binding="var-_uniq.149" data-verso-hover="478">t</span></code></details><details class="example"><summary class="description">Spuriously mutual types</summary><p>
                    The types <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Two" data-verso-hover="479">Two</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Three" data-verso-hover="480">Three</span></a></code> are defined in a mutual block, even though they do not refer to each other:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-33035">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-33044" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Two" data-verso-hover="479" id="Three">Two</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-33070">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Two.mk" data-verso-hover="481" id="Three">mk</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Two" data-verso-hover="479">Two</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-33110" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Three" data-verso-hover="480" id="Three">Three</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-33138">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Three.mk" data-verso-hover="482" id="Three">mk</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Three" data-verso-hover="480">Three</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-33035">end</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                    <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Two" data-verso-hover="479">Two</span></a></code>'s recursor, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Two.rec" data-verso-hover="483">Two.rec</span></code>, nonetheless requires a motive and a case for <code class="hl lean inline" data-lean-context="examples"><a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Three" data-verso-hover="480">Three</span></a></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Two.rec" data-verso-hover="483">Two.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="484">motive_1</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Two" data-verso-hover="479">Two</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-33356" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="485">motive_2</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Three" data-verso-hover="480">Three</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-33391" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="486">mk</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="46">a_1</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="484">motive_1</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Two.mk" data-verso-hover="481">Two.mk</span></a> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="46">a_1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="46">a_1</span> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="46">a_2</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="485">motive_2</span> <span class="unknown token" data-binding="">(</span><a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Three.mk" data-verso-hover="482">Three.mk</span></a> <span class="var token" data-binding="var-_uniq.23" data-verso-hover="46">a</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="46">a_1</span> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="46">a_2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="487">t</span> <span class="unknown token" data-binding="">:</span> <a href="The-Type-System/Inductive-Types/#Three"><span class="const token" data-binding="const-Two" data-verso-hover="479">Two</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="88">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="484">motive_1</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="487">t</span></code></details></section>
              <section>
                <h3 id="mutual-inductive-types-run-time">
                  3.4.5.3. Run-Time Representation<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-inductive-types-run-time" title="Permalink">🔗</a></span></h3>
                <p>
                  Mutual inductive types are represented identically to <a href="The-Type-System/Inductive-Types/#run-time-inductives">non-mutual inductive types</a> in compiled code and in the runtime.
The restrictions on mutual inductive types exist to ensure Lean's consistency as a logic, and do not impact compiled code.</p>
                </section>
              <section>
                <h3 id="nested-inductive-types">
                  3.4.5.4. Nested inductive types<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=nested-inductive-types" title="Permalink">🔗</a></span></h3>
                <div class="planned">
                  <div class="label">
                    Planned Content</div>
                  <p>
                    A description of nested inductive types, including a definition of the term, the shape of the eliminator, and the rules that govern them.</p>
                  <p>
                    Tracked at issue <a href="https://github.com/leanprover/reference-manual/issues/235">#235</a></p>
                  </div>
                </section>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes" rel="prev" title="3.3. Universes"><span class="arrow">←</span><span class="where">3.3. Universes</span></a><a class="local-button active" href="The-Type-System/Quotients/#quotients" rel="next" title="3.5. Quotients"><span class="where">3.5. Quotients</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

