<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>命名空间与区段</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
  text-decoration-skip-ink: none;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
  display: inline-grid;
  grid-template-columns: 1fr;
  vertical-align: top;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: inline-block;
  vertical-align: top;
  grid-row: 2;
  justify-self: start;
}

.hl.lean .tactic > label {
  position: relative;
  grid-row: 1;
}

@media (hover: hover) {
  .hl.lean .tactic:has(.tactic-toggle:not(:checked)) > label:hover {
    background-color: #eeeeee;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

.extra-doc-links {
  list-style-type: none;
  margin-left: 0;
  padding: 0;
}

.extra-doc-links > li {
  display: inline-block;
}

.extra-doc-links > li:not(:last-child)::after {
  content: '|';
  display: inline-block;
  margin: 0 0.25em;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
            const extraLinks = tgt.parentElement.dataset['versoLinks'];
            if (extraLinks) {
              try {
                const extras = JSON.parse(extraLinks);
                const links = document.createElement('ul');
                links.className = 'extra-doc-links';
                extras.forEach((l) => {
                  const li = document.createElement('li');
                  li.innerHTML = "<a href=\"" + l['href'] + "\" title=\"" + l.long + "\">" + l.short + "</a>";
                  links.appendChild(li);
                });
                content.appendChild(links);
              } catch (error) {
                console.error(error);
              }
            }
          }
          return content;
        }
      };


      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort', defaultTippyProps);
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    <script defer="defer" data-domain="lean-lang.org/doc/reference/latest" src="https://plausible.io/js/script.outbound-links.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Lean 语言参考手册</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Lean 语言参考手册</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot" checked="checked"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">简介</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration and Compilation/#elaboration-and-compilation">繁释与编译</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The Type System/#type-system">类型系统</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source Files and Modules/#files">源文件与模块</a></td></tr><tr class="current numbered"><td class="num">6.</td><td><a href="Namespaces and Sections/#namespaces-sections">命名空间与区段</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#Lean-__________________--______">索引</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-namespaces-sections" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-namespaces-sections" checked="checked"></label><span class="number">6.</span> <span class="current"><a href="Namespaces and Sections/#namespaces-sections">命名空间与区段</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Namespaces and Sections/#namespaces">命名空间</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="Namespaces and Sections/#Lean-__________________--_____________________--____________--________________________">命名空间与作用域</a></span></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___open"><span class="syntax"><span class="keyword">open</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___openHiding"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">hiding</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___openRenaming"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">renaming</span><span class="ws"> </span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">→</span><span class="ws"> </span><span class="meta">…</span><span class="meta">),*</span></span></a></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___openOnly"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___openScoped"><span class="syntax"><span class="keyword">scoped</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="Namespaces and Sections/#Lean-__________________--_____________________--____________--____________">导出名称</a></span></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___export"><span class="syntax"><span class="keyword">export</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">(</span><span class="meta">…</span><span class="keyword">)</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Namespaces and Sections/#scopes">区段作用域（Section Scopes）</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="Namespaces and Sections/#scope-commands">控制区段作用域</a></span></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___section"><span class="syntax"><span class="keyword">section</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___namespace"><span class="syntax"><span class="keyword">namespace</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___end"><span class="syntax"><span class="keyword">end</span></span></a></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___end-next"><span class="syntax"><span class="keyword">end</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___in"><span class="syntax"><span class="keyword">in</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.2.</span> <a href="Namespaces and Sections/#section-variables">区段变量（Section Variables）</a></span></li>
                <li>
                  <a href="Namespaces and Sections/#Lean___Parser___Command___variable"><span class="syntax"><span class="keyword">variable</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Source Files and Modules/#files" rel="prev" title="5. 源文件与模块"><span class="arrow">←</span><span class="where">5. 源文件与模块</span></a><a class="local-button active" href="Definitions/#definitions" rel="next" title="7. Definitions"><span class="where">7. Definitions</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              6. 命名空间与区段<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=namespaces-sections" title="Permalink">🔗</a></span></h1>
            <p>
              名字会被组织到分层的 <span id="--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>命名空间</em></span> 里，命名空间为名字的集合。
在 Lean 中，命名空间是组织 API 的主要方式：它为操作提供本体论，并将相关项聚合起来。
此外，虽然不是通过将名字直接放入命名空间的方式，但一些特性（比如 <a href="Notations-and-Macros/#language-extension">语法扩展</a>、<a class="technical-term" href="Type-Classes/#--tech-term-instances">实例</a> 以及 <a class="technical-term" href="Attributes/#--tech-term-Attributes">属性</a>）的效果可以被“附着”到某个命名空间。</p>
            <p>
              通过将操作整理到命名空间，使得库的结构在概念上得到全局的梳理。然而，在实际的 Lean 文件中，通常并不会同等地使用所有名字。
<a class="technical-term" href="Namespaces and Sections/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">区段</a> 提供了在局部视图下组织全局名字集的方法，也能精准控制编译器选项、语言扩展、实例和属性等的作用域。
区段也允许将多个声明共享的参数集中声明，并可借助 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.variable : command</code><span class="sep"></span><code class="docstring">Declares one or more typed variables, or modifies whether already-declared variables are
  implicit.

Introduces variables that can be used in definitions within the same `namespace` or `section` block.
When a definition mentions a variable, Lean will add it as an argument of the definition. This is
useful in particular when writing many definitions that have parameters in common (see below for an
example).

Variable declarations have the same flexibility as regular function parameters. In particular they
can be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they
can be anonymous). This can be changed, for instance one can turn explicit variable `x` into an
implicit one with `variable {x}`. Note that currently, you should avoid changing how variables are
bound and declare new variables at the same time; see [issue 2789] for more on this topic.

In *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that
changes to the proof cannot change the statement of the overall theorem. Instead, variables are only
available to the proof if they have been mentioned in the theorem header or in an `include` command
or are instance implicit and depend only on such variables.

See [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed
discussion.

[tpil vars]:
https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections
(Variables and Sections on Theorem Proving in Lean) [tpil classes]:
https://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in
Lean) [binder docs]:
https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation
for the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789
on github)

## Examples

```lean
section
  variable
    {α : Type u}      -- implicit
    (a : α)           -- explicit
    [instBEq : BEq α] -- instance implicit, named
    [Hashable α]      -- instance implicit, anonymous

  def isEqual (b : α) : Bool :=
    a == b

  #check isEqual
  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool

  variable
    {a} -- `a` is implicit now

  def eqComm {b : α} := a == b ↔ b == a

  #check eqComm
  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop
end
```

The following shows a typical use of `variable` to factor out definition arguments:

```lean
variable (Src : Type)

structure Logger where
  trace : List (Src × String)
#check Logger
-- Logger (Src : Type) : Type

namespace Logger
  -- switch `Src : Type` to be implicit until the `end Logger`
  variable {Src}

  def empty : Logger Src where
    trace := []
  #check empty
  -- Logger.empty {Src : Type} : Logger Src

  variable (log : Logger Src)

  def len :=
    log.trace.length
  #check len
  -- Logger.len {Src : Type} (log : Logger Src) : Nat

  variable (src : Src) [BEq Src]

  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments

  def filterSrc :=
    log.trace.filterMap
      fun (src', str') =&gt; if src' == src then some str' else none
  #check filterSrc
  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String

  def lenSrc :=
    log.filterSrc src |&gt;.length
  #check lenSrc
  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat
end Logger
```

The following example demonstrates availability of variables in proofs:
```lean
variable
  {α : Type}    -- available in the proof as indirectly mentioned through `a`
  [ToString α]  -- available in the proof as `α` is included
  (a : α)       -- available in the proof as mentioned in the header
  {β : Type}    -- not available in the proof
  [ToString β]  -- not available in the proof

theorem ex : a = a := rfl
```
After elaboration of the proof, the following warning will be generated to highlight the unused
hypothesis:
```
included section variable '[ToString α]' is not used in 'ex', consider excluding it
```
In such cases, the offending variable declaration should be moved down or into a section so that
only theorems that do depend on it follow it until the end of the section.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___variable"><code class="kw">variable</code></a></span> 命令按需传播。</p>
            <section>
              <h2 id="namespaces">
                6.1. 命名空间<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=namespaces" title="Permalink">🔗</a></span></h2>
              <p>
                名称中如果包含句点（不在 <a class="technical-term" href="Source Files and Modules/#--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">书名号</a> 之内），则代表这是一个分层名称；句点将名称分成若干<em>组成部分</em>。
除了最后一个组成部分外，其他所有部分都构成了命名空间，而最后一个部分才是名称本身。</p>
              <p>
                命名空间用于对相关的定义、定理、类型以及其他声明进行分组。
当命名空间与某个类型名称对应时，可以使用 <a class="technical-term" href="Terms/Function-Application/#--tech-term-generalized-field-notation">广义域标记法</a> 来访问其内容。
除了整理命名，命名空间还对 <a href="Notations-and-Macros/#language-extension">语法扩展</a>、<a href="Attributes/#attributes">属性</a> 以及 <a href="Type-Classes/#type-classes">类型类实例</a> 进行分组。</p>
              <p>
                命名空间与 <a class="technical-term" href="Source Files and Modules/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">模块</a> 是正交的：模块是一起进行繁释、编译和加载的代码单元，但模块名和它所提供的名称之间并无必要的关联。
模块可以包含任意命名空间下的名字，并且分层模块的嵌套结构与分层命名空间之间没有联系。</p>
              <p>
                Lean 中存在一个根命名空间，一般情况下就是省略命名空间时使用的空间。
可以通过以 <code>_root_</code> 开头的名称显式指明根命名空间。
在某些情况下（如在某个 <a class="technical-term" href="Namespaces and Sections/#--tech-term-_______________-next-next-next-next-next-next-next-next-next">作用域</a> 或局部作用域中），否则名字会被当作相对当前环境来解释，这时就可能需要显式指定 <code>_root_</code>。</p>
              <details class="example"><summary class="description">显式根命名空间</summary><div class="example-content">
                  <p>
                    当前命名空间中的名字优先于根命名空间中的名字。
下面这个例子中，<code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Forest___statement" title="Definition of example Forest.color"><span class="const token" data-binding="const-Forest.color" data-verso-hover="916">color</span></a></code> 在 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Forest___statement" title="Definition of example Forest.statement"><span class="const token" data-binding="const-Forest.statement" data-verso-hover="917">Forest.statement</span></a></code> 的定义中指的是</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4150">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-color" data-verso-hover="918" id="Forest___statement">color</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="919">"yellow"</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-4172" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Forest</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4189">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Forest.color" data-verso-hover="916" id="Forest___statement">color</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="920">"green"</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4210">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Forest.statement" data-verso-hover="917" id="Forest___statement">statement</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termS!_-4227">s!</span><span class="unknown token" data-binding="">"Lemons are {</span><a href="Namespaces and Sections/#Forest___statement" title="Definition of example Forest.color"><span class="const token" data-binding="const-Forest.color" data-verso-hover="916">color</span></a><span class="unknown token" data-binding="">}"</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-4250" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Forest</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"Lemons are green"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-4289" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><a href="Namespaces and Sections/#Forest___statement" title="Definition of example Forest.statement"><span class="const token" data-binding="const-Forest.statement" data-verso-hover="917">Forest.statement</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>"Lemons are green"
</pre></div>
                  <p>
                    在 <code>Forest</code> 命名空间内，如果要引用根命名空间下的 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Forest___statement" title="Definition of example color"><span class="const token" data-binding="const-color" data-verso-hover="918">color</span></a></code>，则需要加上 <code>_root_</code> 前缀进行限定：</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-4512" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Forest</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4529">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Forest.nextStatement" data-verso-hover="921" id="Forest___nextStatement">nextStatement</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-termS!_-4552">s!</span><span class="unknown token" data-binding="">"Ripe lemons are {</span><a href="Namespaces and Sections/#Forest___statement" title="Definition of example color"><span class="const token" data-binding="const-color" data-verso-hover="922">_root_.color</span></a><span class="unknown token" data-binding="">}, not {</span><a href="Namespaces and Sections/#Forest___statement" title="Definition of example Forest.color"><span class="const token" data-binding="const-Forest.color" data-verso-hover="916">color</span></a><span class="unknown token" data-binding="">}"</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-4600" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Forest</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"Ripe lemons are yellow, not green"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-4640" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><a href="Namespaces and Sections/#Forest___nextStatement" title="Definition of example Forest.nextStatement"><span class="const token" data-binding="const-Forest.nextStatement" data-verso-hover="921">Forest.nextStatement</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>"Ripe lemons are yellow, not green"
</pre></div>
                  </div>
                </details><section>
                <h3 id="Lean-__________________--_____________________--____________--________________________">
                  6.1.1. 命名空间与作用域</h3>
                <p>
                  每个 <a class="technical-term" href="Namespaces and Sections/#--tech-term-_______________-next-next-next-next-next-next-next-next-next">作用域</a> 都有一个 <span id="--tech-term-__________________-next-next-next-next" class="def-technical-term"><em>当前命名空间</em></span>，其取值由 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> 命令决定。<span class="marginalia"><span class="note">关于 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> 命令的详细介绍见 <a href="Namespaces and Sections/#scope-commands">作用域命令</a> 一节。</span></span>
在作用域中声明的名字会被加入当前命名空间。
如果声明的名称由多部分组成，那么其命名空间会嵌套在当前命名空间下；声明体中的当前命名空间是该嵌套命名空间。
作用域还包含一组 <span id="--tech-term-_____________________-next" class="def-technical-term"><em>已打开命名空间</em></span>，这些命名空间中的内容在当前作用域内无需额外限定就可直接访问。
<a class="technical-term" href="IO/Tasks-and-Threads/#--tech-term-resolving-next">解析</a> 一个标识符时，会考虑当前命名空间和已打开命名空间。
但是，被标记为 <span id="--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term">受保护</span> 的声明（即带有 <code class="plain-keyword">protected</code> <a href="Definitions/Modifiers/#declaration-modifiers">修饰符</a> 的声明）在打开命名空间时并不会被带入作用域。
关于根据当前命名空间和打开的命名空间解析标识符的规则，详见 <a href="Terms/Identifiers/#identifiers-and-resolution">标识符作为项的一节</a>。</p>
                <details class="example"><summary class="description">当前命名空间</summary><div class="example-content">
                    <p>
                      定义一个归纳类型，会使其构造子被置于该类型的命名空间下，例如 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.coffee"><span class="const token" data-binding="const-HotDrink.coffee" data-verso-hover="923">HotDrink.coffee</span></a></code>、<code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.tea"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="924">HotDrink.tea</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.cocoa"><span class="const token" data-binding="const-HotDrink.cocoa" data-verso-hover="925">HotDrink.cocoa</span></a></code>：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-9141" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-HotDrink" data-verso-hover="926" id="HotDrink___cocoa">HotDrink</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-9160">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-HotDrink.coffee" data-verso-hover="923" id="HotDrink___cocoa">coffee</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="924" id="HotDrink___cocoa">tea</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-HotDrink.cocoa" data-verso-hover="925" id="HotDrink___cocoa">cocoa</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      在命名空间外，除非打开该命名空间，否则需要加前缀才能使用这些名字：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">HotDrink.tea : HotDrink</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-9323">#check</span></a></span><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.tea"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="924">HotDrink.tea</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>HotDrink.tea : HotDrink
</pre></div>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-9438">#check</span></a><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'tea'</code></span></span><span class="unknown token" data-binding="">tea</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'tea'
</pre></div>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___section" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-9530" data-verso-hover="119">section</span></a><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-9538" data-verso-hover="120">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">HotDrink</span><span class="inter-text">
</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">HotDrink.tea : HotDrink</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-9552">#check</span></a></span><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.tea"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="924">tea</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-9563" data-verso-hover="125">end</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>HotDrink.tea : HotDrink
</pre></div>
                    <p>
                      如果直接在 <code>HotDrink</code> 命名空间中定义函数，该函数体会在当前命名空间为 <code>HotDrink</code> 的情况下进行繁释。
这时构造子都在作用域内：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9802">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-HotDrink.ofString?" data-verso-hover="927" id="HotDrink___ofString___">HotDrink.ofString?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="141">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink"><span class="const token" data-binding="const-HotDrink" data-verso-hover="926">HotDrink</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="928">"coffee"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.coffee"><span class="const token" data-binding="const-HotDrink.coffee" data-verso-hover="923">coffee</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="929">"tea"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.tea"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="924">tea</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="930">"cocoa"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.cocoa"><span class="const token" data-binding="const-HotDrink.cocoa" data-verso-hover="925">cocoa</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      定义另一个归纳类型会新建一个命名空间：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-10014" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-ColdDrink" data-verso-hover="931" id="ColdDrink">ColdDrink</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-10034">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-ColdDrink.water" data-verso-hover="932" id="ColdDrink">water</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-ColdDrink.juice" data-verso-hover="933" id="ColdDrink">juice</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      在 <code>HotDrink</code> 命名空间中，可以直接定义 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#ColdDrink___toString" title="Definition of example HotDrink.toString"><span class="const token" data-binding="const-HotDrink.toString" data-verso-hover="934">HotDrink.toString</span></a></code>，无需显式前缀。
而要在 <code>ColdDrink</code> 命名空间中定义一个函数，则需要加上 <code>_root_</code> 限定，否则会变成定义 <code>HotDrink.ColdDrink.toString</code>：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-10322" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">HotDrink</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10342">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-HotDrink.toString" data-verso-hover="934" id="ColdDrink___toString">toString</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink"><span class="const token" data-binding="const-HotDrink" data-verso-hover="926">HotDrink</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="141">String</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.coffee"><span class="const token" data-binding="const-HotDrink.coffee" data-verso-hover="923">coffee</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="928">"coffee"</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.tea"><span class="const token" data-binding="const-HotDrink.tea" data-verso-hover="924">tea</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="929">"tea"</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Namespaces and Sections/#HotDrink___cocoa" title="Definition of example HotDrink.cocoa"><span class="const token" data-binding="const-HotDrink.cocoa" data-verso-hover="925">cocoa</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="930">"cocoa"</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10439">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-ColdDrink.toString" data-verso-hover="935" id="ColdDrink___toString">_root_.ColdDrink.toString</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Namespaces and Sections/#ColdDrink" title="Definition of example ColdDrink"><span class="const token" data-binding="const-ColdDrink" data-verso-hover="931">ColdDrink</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="141">String</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Namespaces and Sections/#ColdDrink" title="Definition of example ColdDrink.water"><span class="const token" data-binding="const-ColdDrink.water" data-verso-hover="932">.water</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="936">"water"</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Namespaces and Sections/#ColdDrink" title="Definition of example ColdDrink.juice"><span class="const token" data-binding="const-ColdDrink.juice" data-verso-hover="933">.juice</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="937">"juice"</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-10537" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">HotDrink</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> 命令用于打开一个命名空间，使其内容可以在当前作用域内使用。
打开命名空间有多种变化方式，便于灵活管理本地作用域。</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">打开命名空间</span><div class="text">
                    <p>
                      <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> 命令用于打开一个命名空间：</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___open"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.open"><code class="hover-info"><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><span class="keyword">open</span> <span class="nonterminal" data-kind="Lean.Parser.Command.openDecl.pseudo">openDecl</span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___openDecl">
                  <span class="label">open declaration</span><span class="title">打开整个命名空间</span><div class="text">
                    <p>
                      用一个或多个标识符组成序列，会顺序将这些命名空间打开：</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openSimple"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openSimple"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span></span></pre><p>
                      每个命名空间都相对于所有已打开的命名空间解析，得到一组命名空间。
在处理下一个命名空间之前，会先顺序打开这一组命名空间的所有成员。</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">打开嵌套命名空间</summary><div class="example-content">
                    <p>
                      被打开的命名空间会相对于当前已打开的命名空间进行处理。
如果某个组成部分在不同的命名空间路径中同时出现，则一次 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> 命令可以通过迭代方式将所有相关命名空间引入作用域。
下面这个例子定义了多个命名空间下的名称：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-14062" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text"> -- _root_.A
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14086">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-A.a1" data-verso-hover="938" id="A___B___C___a3">a1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-14098" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">B</span><span class="inter-text"> -- _root_.A.B
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14124">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-A.B.a2" data-verso-hover="939" id="A___B___C___a3">a2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-14136" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">C</span><span class="inter-text"> -- _root_.A.B.C
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14164">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-A.B.C.a3" data-verso-hover="940" id="A___B___C___a3">a3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-14176" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">C</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-14182" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">B</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-14188" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-14194" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">B</span><span class="inter-text"> -- _root_.B
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14218">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-B.a4" data-verso-hover="941" id="A___B___C___a3">a4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-14230" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">C</span><span class="inter-text"> -- _root_.B.C
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14256">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-B.C.a5" data-verso-hover="942" id="A___B___C___a3">a5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-14268" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">C</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-14274" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">B</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-14280" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">C</span><span class="inter-text"> -- _root_.C
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14304">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-C.a6" data-verso-hover="943" id="A___B___C___a3">a6</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-14316" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">C</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      这些名字分别是：</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example A.a1"><span class="const token" data-binding="const-A.a1" data-verso-hover="938">A.a1</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example A.B.a2"><span class="const token" data-binding="const-A.B.a2" data-verso-hover="939">A.B.a2</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example A.B.C.a3"><span class="const token" data-binding="const-A.B.C.a3" data-verso-hover="940">A.B.C.a3</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example B.a4"><span class="const token" data-binding="const-B.a4" data-verso-hover="941">B.a4</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example B.C.a5"><span class="const token" data-binding="const-B.C.a5" data-verso-hover="942">B.C.a5</span></a></code></p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example C.a6"><span class="const token" data-binding="const-C.a6" data-verso-hover="943">C.a6</span></a></code></p>
                        </li>
                      </ul>
                    <p>
                      通过一次嵌套的 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> 命令，可以将六个名字全部引入作用域：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___section" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-14584" data-verso-hover="119">section</span></a><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-14592" data-verso-hover="120">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">B</span><span class="inter-text"> </span><span class="unknown token" data-binding="">C</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-14603">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example A.a1"><span class="const token" data-binding="const-A.a1" data-verso-hover="938">a1</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example A.B.a2"><span class="const token" data-binding="const-A.B.a2" data-verso-hover="939">a2</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example A.B.C.a3"><span class="const token" data-binding="const-A.B.C.a3" data-verso-hover="940">a3</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example B.a4"><span class="const token" data-binding="const-B.a4" data-verso-hover="941">a4</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example B.C.a5"><span class="const token" data-binding="const-B.C.a5" data-verso-hover="942">a5</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example C.a6"><span class="const token" data-binding="const-C.a6" data-verso-hover="943">a6</span></a><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-14639" data-verso-hover="125">end</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      如果命令中的初始命名空间使用了 <code>A.B</code>，则不会打开 <code>_root_.A</code>、<code>_root_.B</code> 或 <code>_root_.B.C</code>：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___section" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-14804" data-verso-hover="119">section</span></a><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-14812" data-verso-hover="120">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">A.B</span><span class="inter-text"> </span><span class="unknown token" data-binding="">C</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-14823">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'a1'</code></span></span><span class="unknown token" data-binding="">a1</span></span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example A.B.a2"><span class="const token" data-binding="const-A.B.a2" data-verso-hover="939">a2</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example A.B.C.a3"><span class="const token" data-binding="const-A.B.C.a3" data-verso-hover="940">a3</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'a4'</code></span></span><span class="unknown token" data-binding="">a4</span></span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'a5'</code></span></span><span class="unknown token" data-binding="">a5</span></span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="Namespaces and Sections/#A___B___C___a3" title="Definition of example C.a6"><span class="const token" data-binding="const-C.a6" data-verso-hover="943">a6</span></a><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-14859" data-verso-hover="125">end</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'a1'
</pre></div>
                    <div class="error">
                      <pre>unknown identifier 'a4'
</pre></div>
                    <div class="error">
                      <pre>unknown identifier 'a5'
</pre></div>
                    <p>
                      打开 <code>A.B</code> 后，<code>A.B.C</code> 可以作为 <code>C</code> 来访问，而 <code>_root_.C</code> 也同样如此，因此后续 open 的 <code>C</code> 实际会打开这两个名字。</p>
                    </div>
                  </details><div class="namedocs" id="Lean___Parser___Command___openDecl-next">
                  <span class="label">open declaration</span><span class="title">隐藏名字</span><div class="text">
                    <p>
                      <code class="plain-keyword">hiding</code> 声明用来指定在打开命名空间时哪些名字<em>不能</em>被带入作用域。
与打开整个命名空间不同的是，这时提供的标识符必须唯一地指明待打开命名空间。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openHiding"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openHiding"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">hiding</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___openDecl-next-next">
                  <span class="label">open declaration</span><span class="title">重命名</span><div class="text">
                    <p>
                      <code class="plain-keyword">renaming</code> 声明允许将打开的命名空间中的部分名字重命名；在当前作用域中可用新名字访问它们。
此处提供的标识符必须唯一地指定要打开的命名空间。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openRenaming"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openRenaming"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">renaming</span> <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.openRenamingItem"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">→</span> <span class="nonterminal" data-kind="ident">ident</span></span></span><span class="bnf">),*</span></span></span></pre><p>
                      ASCII 箭头（<code>-&gt;</code>）也可以替代 Unicode 箭头（<code>→</code>）。</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___openDecl-next-next-next">
                  <span class="label">open declaration</span><span class="title">限制引入名称</span><div class="text">
                    <p>
                      用圆括号括住一组名字表示只将括号内列出的名字带入作用域。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openOnly"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openOnly"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span><span class="keyword">)</span></span></pre><p>
                      指定的命名空间会加到当前所有已打开命名空间中，每个名字会在所有这些命名空间中查找。
列出的每个名字都必须是明确且唯一的，也就是说每个名字只能在所有考虑到的命名空间中存在于唯一一处。</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___openDecl-next-next-next-next">
                  <span class="label">open declaration</span><span class="title">仅打开受限定声明</span><div class="text">
                    <p>
                      <code class="plain-keyword">scoped</code> 关键字用于只打开指定命名空间中的所有受限定属性、类型类实例和语法扩展，但不会将实际名字带入作用域。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___openScoped"><span class="nonterminal documented" data-kind="Lean.Parser.Command.openDecl"><code class="hover-info"><code class="docstring">`openDecl` is the body of an `open` declaration (see `open`) </code></code>openDecl</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.openScoped"><span class="keyword">scoped</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">打开受限定声明</summary><div class="example-content">
                    <p>
                      下面例子中，在命名空间 <code>NS</code> 下定义了一个受限定的 <a class="technical-term" href="Notations-and-Macros/Notations/#--tech-term-notation">符号扩展</a> 以及一个定义：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-20347" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">NS</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.scoped-20360">scoped</span><span class="inter-text"> </span><a href="Notations-and-Macros/Notations/#Lean___Parser___Command___notation" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.notation-20360">notation</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="944">"{!{"</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="945">e</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="946">"}!}"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="945">e</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="945">e</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20400">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NS.three" data-verso-hover="947" id="NS___three">three</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-20415" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">NS</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      在命名空间外，这个符号扩展无法直接使用：</p>
                    <pre class="syntax-error hl lean"><code class="line">def x := {!{ "pear" }<span class="parse-message has-info error"><code class="hover-info">unexpected token '!'; expected '}'</code>!</span>}</code></pre><div class="error">
                      <pre>&lt;example&gt;:1:21-1:22: unexpected token '!'; expected '}'</pre></div>
                    <p>
                      用 <code class="plain-keyword">open scoped</code> 命令后，符号扩展才能使用：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-20707" data-verso-hover="120">open</span></a><span class="inter-text"> </span><a href="Namespaces and Sections/#Lean___Parser___Command___openScoped" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.openScoped-20712">scoped</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">NS</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20722">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-x" data-verso-hover="948">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{!{</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="949">"pear"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}!}</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      但是，名字 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#NS___three" title="Definition of example NS.three"><span class="const token" data-binding="const-NS.three" data-verso-hover="947">NS.three</span></a></code> 仍然无法直接访问：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20854">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-y" data-verso-hover="950">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'three'</code></span></span><span class="unknown token" data-binding="">three</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'three'
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="Lean-__________________--_____________________--____________--____________">
                  6.1.2. 导出名称</h3>
                <p>
                  <span id="--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>导出</em></span>一个名字，就是将其引入到当前命名空间内。
与定义不同，导出的名字是完全透明的：在使用时会直接解析到原始名字。
将名字导出到根命名空间，则可以直接不加限定地访问它；Lean 标准库会这样做，例如 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code> 的构造子，或像 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-MonadState.get" data-verso-hover="951">get</span></code> 这样的关键类型类方法。</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">导出名称</span><div class="text">
                    <p>
                      <code class="plain-keyword">export</code> 命令可以将其他命名空间中的名字添加到当前命名空间，就好像它们原本就是在这里声明的一样。
当当前命名空间被打开时，这些导出的名字也会被带入作用域。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___export"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.export"><code class="hover-info"><code class="docstring">Adds names from other namespaces to the current namespace.

The command `export Some.Namespace (name₁ name₂)` makes `name₁` and `name₂`:

- visible in the current namespace without prefix `Some.Namespace`, like `open`, and
- visible from outside the current namespace `N` as `N.name₁` and `N.name₂`.

## Examples

```lean
namespace Morning.Sky
  def star := "venus"
end Morning.Sky

namespace Evening.Sky
  export Morning.Sky (star)
  -- `star` is now in scope
  #check star
end Evening.Sky

-- `star` is visible in `Evening.Sky`
#check Evening.Sky.star
```
</code></code><span class="keyword">export</span> <span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span></span><span class="keyword">)</span></span></pre><p>
                      内部实现上，导出的名字会注册成其目标的别名。
在 <a class="technical-term" href="Elaboration and Compilation/#--tech-term-______-next-next">内核</a> 看来，只有原始名字存在；<a class="technical-term" href="Notations-and-Macros/Elaborators/#--tech-term-elaborators">繁释器</a> 在 <a class="technical-term" href="IO/Tasks-and-Threads/#--tech-term-resolving-next">解析</a> 标识符到名字的过程中负责处理别名。</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">导出名称</summary><div class="example-content">
                    <p>
                      声明 <a class="technical-term" href="The Type System/Inductive Types/#--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next">归纳类型</a> <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Veg___Leafy___cabbage" title="Definition of example Veg.Leafy"><span class="const token" data-binding="const-Veg.Leafy" data-verso-hover="952">Veg.Leafy</span></a></code> 的同时，也声明了构造子 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Veg___Leafy___cabbage" title="Definition of example Veg.Leafy.spinach"><span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="953">Veg.Leafy.spinach</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Veg___Leafy___cabbage" title="Definition of example Veg.Leafy.cabbage"><span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="954">Veg.Leafy.cabbage</span></a></code>：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-23680" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Veg</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-23694" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Veg.Leafy" data-verso-hover="952" id="Veg___Leafy___cabbage">Leafy</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-23710">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="955" id="Veg___Leafy___cabbage">spinach</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="956" id="Veg___Leafy___cabbage">cabbage</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___export" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-23740" data-verso-hover="957">export</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Leafy</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Namespaces and Sections/#Veg___Leafy___cabbage" title="Definition of example Veg.Leafy.spinach"><span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="955">spinach</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-23763" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Veg</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___export" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-23771" data-verso-hover="957">export</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Veg.Leafy</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Namespaces and Sections/#Veg___Leafy___cabbage" title="Definition of example Veg.Leafy.cabbage"><span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="954">cabbage</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      第一次 <code class="plain-keyword">export</code> 命令将 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Veg___Leafy___cabbage" title="Definition of example Veg.Leafy.spinach"><span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="953">Veg.Leafy.spinach</span></a></code> 作为 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Veg___Leafy___cabbage" title="Definition of example Veg.Leafy.spinach"><span class="const token" data-binding="const-Veg.Leafy.spinach" data-verso-hover="953">Veg.spinach</span></a></code> 引入作用域，因为此时 <a class="technical-term" href="Namespaces and Sections/#--tech-term-__________________-next-next-next-next-next">当前命名空间</a> 是 <code>Veg</code>。
第二次导出将 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Veg___Leafy___cabbage" title="Definition of example Veg.Leafy.cabbage"><span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="954">Veg.Leafy.cabbage</span></a></code> 引入根命名空间，可以直接使用 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Veg___Leafy___cabbage" title="Definition of example Veg.Leafy.cabbage"><span class="const token" data-binding="const-Veg.Leafy.cabbage" data-verso-hover="954">cabbage</span></a></code>。</p>
                    </div>
                  </details></section>
              </section>
            <section>
              <h2 id="scopes">
                6.2. 区段作用域（Section Scopes）<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=scopes" title="Permalink">🔗</a></span></h2>
              <p>
                许多命令会对当前 <span id="--tech-term-_______________-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>区段作用域</em></span>产生影响（有时在明确语境下简称为“作用域”）。
每个 Lean 模块都自带一个区段作用域。
通过 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> 命令、<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> 命令，以及 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> 命令组合子，可以创建嵌套的作用域。</p>
              <p>
                区段作用域中追踪如下数据：</p>
              <dl><dt> 当前命名空间（The Current Namespace）</dt><dd><p>
                    <span id="--tech-term-__________________-next-next-next-next-next" class="def-technical-term"><em>当前命名空间</em></span> 指新声明将被定义到的命名空间。
  此外，<a class="technical-term" href="IO/Tasks-and-Threads/#--tech-term-resolving-next">名字解析</a> 包括所有当前命名空间前缀，以作为全局名字可用的作用域一部分。</p>
                  </dd><dt> 已“开放”的命名空间（Opened Namespaces）</dt><dd><p>
                    当一个命名空间被 <span id="--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>开放</em></span> 时，其名字无需显式前缀即可在当前作用域可用。
  此外，被开放命名空间下的限定属性及 <a href="Notations-and-Macros/Defining-New-Syntax/#syntax-rules">作用域内语法扩展</a> 在当前区段作用域内也会生效。</p>
                  </dd><dt> 选项（Options）</dt><dd><p>
                    编译器选项在其被更改的作用域结束时，会复原为原来的值。</p>
                  </dd><dt> 区段变量（Section Variables）</dt><dd><p>
                    <a class="technical-term" href="Namespaces and Sections/#--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">区段变量</a>，即自动加到定义里的名字（或 <a class="technical-term" href="Type-Classes/#--tech-term-instance-implicit-next">实例隐式</a> 参数）。
  当区段变量出现在定理陈述中时，也会自动加为定理的全称假设。</p>
                  </dd></dl><section>
                <h3 id="scope-commands">
                  6.2.1. 控制区段作用域<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=scope-commands" title="Permalink">🔗</a></span></h3>
                <p>
                  <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> 命令会新建一个 <span id="--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term">区段</span> 作用域，但并不会修改当前命名空间、已开放命名空间或区段变量。
所有对区段作用域做出的更改，在区段结束时将被还原。
区段可以选择命名；关闭区段的 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> 命令需使用相同的名字。
如果区段名含有多个部分（即有 <code>.</code>分隔），则会引入多层嵌套区段。
区段名字不会产生其它效果，仅是为了可读性和方便重构。</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">区段</span><div class="text">
                    <p>
                      <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> 命令创建一个区段作用域，该作用域会持续到 <code>end</code> 命令或者文件结尾为止。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___section"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.section"><code class="hover-info"><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><span class="from-nonterminal" data-kind="Lean.Parser.Command.sectionHeader"><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span><span class="keyword">section</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span><span class="bnf">?</span></span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">命名区段</summary><div class="example-content">
                    <p>
                      名字 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Greetings___english" title="Definition of example Greetings.english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="958">english</span></a></code> 是在 <code>Greetings</code> 命名空间下定义的。</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9178">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Greetings.english" data-verso-hover="958" id="Greetings___english">Greetings.english</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="277">"Hello"</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      在其命名空间外无法直接访问。</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9303" data-verso-hover="6">#eval</span></a><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'english'</code></span></span><span class="unknown token" data-binding="">english</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'english'
</pre></div>
                    <p>
                      打开一个区段可以让对全局作用域的修改被限制在其中。
下例区段名为 <code>Greetings</code>。</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___section" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-9496" data-verso-hover="119">section</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Greetings</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      即使区段名和定义中的命名空间一致，由于区段名字仅作为可读和重构辅助，这个名字仍未在作用域内：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9703" data-verso-hover="6">#eval</span></a><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'english'</code></span></span><span class="unknown token" data-binding="">english</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'english'
</pre></div>
                    <p>
                      打开 <code>Greetings</code> 命名空间后，<code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Greetings___english" title="Definition of example Greetings.english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="958">Greetings.english</span></a></code> 就能以 <code class="hl lean inline" data-lean-context="examples"><a href="Namespaces and Sections/#Greetings___english" title="Definition of example Greetings.english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="958">english</span></a></code> 名称出现于当前作用域：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-9949" data-verso-hover="120">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Greetings</span><span class="inter-text">

</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"Hello"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9965" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><a href="Namespaces and Sections/#Greetings___english" title="Definition of example Greetings.english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="958">english</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>"Hello"
</pre></div>
                    <p>
                      关闭区段时，区段的名字必须被使用：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid 'end', name is missing (expected Greetings)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-10131" data-verso-hover="125">end</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>invalid 'end', name is missing (expected Greetings)
</pre></div>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-10227" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Greetings</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      当区段被关闭时，通过 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> 命令带来的影响会恢复：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-10399" data-verso-hover="6">#eval</span></a><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'english'</code></span></span><span class="unknown token" data-binding="">english</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'english'
</pre></div>
                    </div>
                  </details><p>
                  <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> 命令也会新建一个区段作用域。
在这个区段作用域下，当前命名空间会变为所提供的名字（相对周围的当前命名空间）。
如同区段一样，对区段作用域的更改会在命名空间关闭时还原。</p>
                <p>
                  要关闭命名空间，<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> 命令需提供当前命名空间的某个后缀，关闭后该后缀就会被移除。
所有由 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> 命令引入、并属于该后缀的区段作用域也会一起关闭。</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">命名空间声明</span><div class="text">
                    <p>
                      <code>namespace</code> 命令通过追加指定标识符来修改当前命名空间。</p>
                    <p>
                      会创建一个区段作用域，该作用域会持续到 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> 命令或者文件结尾为止。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___namespace"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.namespace"><code class="hover-info"><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><span class="keyword">namespace</span> <span class="nonterminal" data-kind="ident">ident</span></span></pre></div>
                  </div>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">区段与命名空间终止</span><div class="text">
                    <p>
                      不带标识符时，<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> 会关闭最近打开的匿名区段。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___end"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.end"><code class="hover-info"><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><span class="keyword">end</span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      W带标识符时，会关闭最近打开的区段或者命名空间。
若是区段，则标识符必须是自上次 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> 命令以来所打开区段名拼接的后缀。
若是命名空间，则标识符必须是自上次未闭合的 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> 以来当前命名空间扩展的后缀；之后当前命名空间会移除此后缀。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___end-next"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.end"><code class="hover-info"><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><span class="keyword">end</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span></span></pre></div>
                  </div>
                <p>
                  <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><code class="kw">end</code></a></span> 用于关闭 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><code class="kw">mutual</code></a></span> 块，它是 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual"><code class="kw">mutual</code></a></span> 语法本身的一部分，而不是 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> 命令。</p>
                <details class="example"><summary class="description">嵌套命名空间与区段</summary><div class="example-content">
                    <p>
                      命名空间与区段可以嵌套使用。
一次 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> 命令可以关闭一个或多个命名空间，或者一个或多个区段，但不能混合关闭两者。</p>
                    <p>
                      通过两个单独命令将当前命名空间设为 <code>A.B.C</code> 后，可以用一次 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> 指定 <code>B.C</code> 后缀批量关闭：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-15642" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">A.B</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-15656" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">C</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-15668" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">B.C</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      此时，当前命名空间变为 <code>A</code>。</p>
                    <p>
                      接下来，打开一个匿名区段和命名空间 <code>D.E</code>：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___section" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-15791" data-verso-hover="119">section</span></a><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-15799" data-verso-hover="121">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">D.E</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      此时，当前命名空间变为 <code>A.D.E</code>。
此时如果试图用 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> 一次性关闭全部三者，会因为中间有区段导致失败：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid 'end', name mismatch (expected «».D.E)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-16052" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A.D.E</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>invalid 'end', name mismatch (expected «».D.E)
</pre></div>
                    <p>
                      因此需要分别终止命名空间和区段：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-16197" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">D.E</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-16205" data-verso-hover="125">end</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-16209" data-verso-hover="125">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  如果只需对单个命令临时开放作用域，可以使用 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> 命令组合子来创建单条命令的区段作用域。
<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> 具备右结合性，可以组合多层作用域调整。</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">局部区段作用域</span><div class="text">
                    <p>
                      <code>in</code> 命令组合子为单个命令引入区段作用域。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___in"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.in"><span class="nonterminal" data-kind="command.pseudo">command</span> <span class="keyword">in</span>
      <span class="nonterminal" data-kind="command.pseudo">command</span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">利用 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> 创建局部作用域</summary><div class="example-content">
                    <p>
                      可以使用 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> 让命名空间内容只在单个命令中可见：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-17802">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Dessert.cupcake" data-verso-hover="959" id="Dessert___cupcake">Dessert.cupcake</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="960">"delicious"</span><span class="inter-text">

</span><a href="Namespaces and Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-17838" data-verso-hover="120">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Dessert</span><span class="inter-text"> </span><a href="Namespaces and Sections/#Lean___Parser___Command___in" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-17838">in</span></a><span class="inter-text">
</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"delicious"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-17854" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><a href="Namespaces and Sections/#Dessert___cupcake" title="Definition of example Dessert.cupcake"><span class="const token" data-binding="const-Dessert.cupcake" data-verso-hover="959">cupcake</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      该命令之后，<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___open"><code class="kw">open</code></a></span> 的影响即恢复：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-17998" data-verso-hover="6">#eval</span></a><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'cupcake'</code></span></span><span class="unknown token" data-binding="">cupcake</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'cupcake'
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="section-variables">
                  6.2.2. 区段变量（Section Variables）<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=section-variables" title="Permalink">🔗</a></span></h3>
                <p>
                  <span id="--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>区段变量</em></span> 指自动作为参数加到所有提及它们的声明里的参数。
不论 <code class="hl lean inline" data-lean-context="examples"><a href="Definitions/Headers-and-Signatures/#autoImplicit" title="Documentation for option autoImplicit"><span class="option token" data-binding="option-autoImplicit" data-verso-hover="369">autoImplicit</span></a></code> 选项是否为 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>，都适用。
区段变量可以是隐式、严格隐式或者显式参数，实例隐式参数则有特别处理。</p>
                <p>
                  如果在非定理声明中遇到了区段变量，其就会被自动加为参数。
其中若有 “实例隐式” 区段变量引用了该变量，它们也会被自动加上。
如果新增的变量又依赖其它变量，那么那些变量也会被递归添加；这一过程会持续直到不再有新依赖为止。
所有区段变量按照声明顺序，在其它参数之前加入。
只有当区段变量在定理的陈述中出现时，才会被自动添加到定理。
否则，如果在证明项中更改依赖区段变量，可能会导致定理陈述发生变化。</p>
                <p>
                  区段变量可以通过 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.variable : command</code><span class="sep"></span><code class="docstring">Declares one or more typed variables, or modifies whether already-declared variables are
  implicit.

Introduces variables that can be used in definitions within the same `namespace` or `section` block.
When a definition mentions a variable, Lean will add it as an argument of the definition. This is
useful in particular when writing many definitions that have parameters in common (see below for an
example).

Variable declarations have the same flexibility as regular function parameters. In particular they
can be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they
can be anonymous). This can be changed, for instance one can turn explicit variable `x` into an
implicit one with `variable {x}`. Note that currently, you should avoid changing how variables are
bound and declare new variables at the same time; see [issue 2789] for more on this topic.

In *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that
changes to the proof cannot change the statement of the overall theorem. Instead, variables are only
available to the proof if they have been mentioned in the theorem header or in an `include` command
or are instance implicit and depend only on such variables.

See [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed
discussion.

[tpil vars]:
https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections
(Variables and Sections on Theorem Proving in Lean) [tpil classes]:
https://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in
Lean) [binder docs]:
https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation
for the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789
on github)

## Examples

```lean
section
  variable
    {α : Type u}      -- implicit
    (a : α)           -- explicit
    [instBEq : BEq α] -- instance implicit, named
    [Hashable α]      -- instance implicit, anonymous

  def isEqual (b : α) : Bool :=
    a == b

  #check isEqual
  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool

  variable
    {a} -- `a` is implicit now

  def eqComm {b : α} := a == b ↔ b == a

  #check eqComm
  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop
end
```

The following shows a typical use of `variable` to factor out definition arguments:

```lean
variable (Src : Type)

structure Logger where
  trace : List (Src × String)
#check Logger
-- Logger (Src : Type) : Type

namespace Logger
  -- switch `Src : Type` to be implicit until the `end Logger`
  variable {Src}

  def empty : Logger Src where
    trace := []
  #check empty
  -- Logger.empty {Src : Type} : Logger Src

  variable (log : Logger Src)

  def len :=
    log.trace.length
  #check len
  -- Logger.len {Src : Type} (log : Logger Src) : Nat

  variable (src : Src) [BEq Src]

  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments

  def filterSrc :=
    log.trace.filterMap
      fun (src', str') =&gt; if src' == src then some str' else none
  #check filterSrc
  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String

  def lenSrc :=
    log.filterSrc src |&gt;.length
  #check lenSrc
  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat
end Logger
```

The following example demonstrates availability of variables in proofs:
```lean
variable
  {α : Type}    -- available in the proof as indirectly mentioned through `a`
  [ToString α]  -- available in the proof as `α` is included
  (a : α)       -- available in the proof as mentioned in the header
  {β : Type}    -- not available in the proof
  [ToString β]  -- not available in the proof

theorem ex : a = a := rfl
```
After elaboration of the proof, the following warning will be generated to highlight the unused
hypothesis:
```
included section variable '[ToString α]' is not used in 'ex', consider excluding it
```
In such cases, the offending variable declaration should be moved down or into a section so that
only theorems that do depend on it follow it until the end of the section.
</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___variable"><code class="kw">variable</code></a></span> 命令声明。</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">变量声明</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___variable"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.variable"><code class="hover-info"><code class="docstring">Declares one or more typed variables, or modifies whether already-declared variables are
  implicit.

Introduces variables that can be used in definitions within the same `namespace` or `section` block.
When a definition mentions a variable, Lean will add it as an argument of the definition. This is
useful in particular when writing many definitions that have parameters in common (see below for an
example).

Variable declarations have the same flexibility as regular function parameters. In particular they
can be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they
can be anonymous). This can be changed, for instance one can turn explicit variable `x` into an
implicit one with `variable {x}`. Note that currently, you should avoid changing how variables are
bound and declare new variables at the same time; see [issue 2789] for more on this topic.

In *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that
changes to the proof cannot change the statement of the overall theorem. Instead, variables are only
available to the proof if they have been mentioned in the theorem header or in an `include` command
or are instance implicit and depend only on such variables.

See [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed
discussion.

[tpil vars]:
https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections
(Variables and Sections on Theorem Proving in Lean) [tpil classes]:
https://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in
Lean) [binder docs]:
https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation
for the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789
on github)

## Examples

```lean
section
  variable
    {α : Type u}      -- implicit
    (a : α)           -- explicit
    [instBEq : BEq α] -- instance implicit, named
    [Hashable α]      -- instance implicit, anonymous

  def isEqual (b : α) : Bool :=
    a == b

  #check isEqual
  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool

  variable
    {a} -- `a` is implicit now

  def eqComm {b : α} := a == b ↔ b == a

  #check eqComm
  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop
end
```

The following shows a typical use of `variable` to factor out definition arguments:

```lean
variable (Src : Type)

structure Logger where
  trace : List (Src × String)
#check Logger
-- Logger (Src : Type) : Type

namespace Logger
  -- switch `Src : Type` to be implicit until the `end Logger`
  variable {Src}

  def empty : Logger Src where
    trace := []
  #check empty
  -- Logger.empty {Src : Type} : Logger Src

  variable (log : Logger Src)

  def len :=
    log.trace.length
  #check len
  -- Logger.len {Src : Type} (log : Logger Src) : Nat

  variable (src : Src) [BEq Src]

  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments

  def filterSrc :=
    log.trace.filterMap
      fun (src', str') =&gt; if src' == src then some str' else none
  #check filterSrc
  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String

  def lenSrc :=
    log.filterSrc src |&gt;.length
  #check lenSrc
  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat
end Logger
```

The following example demonstrates availability of variables in proofs:
```lean
variable
  {α : Type}    -- available in the proof as indirectly mentioned through `a`
  [ToString α]  -- available in the proof as `α` is included
  (a : α)       -- available in the proof as mentioned in the header
  {β : Type}    -- not available in the proof
  [ToString β]  -- not available in the proof

theorem ex : a = a := rfl
```
After elaboration of the proof, the following warning will be generated to highlight the unused
hypothesis:
```
included section variable '[ToString α]' is not used in 'ex', consider excluding it
```
In such cases, the offending variable declaration should be moved down or into a section so that
only theorems that do depend on it follow it until the end of the section.
</code></code><span class="keyword">variable</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span> <span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">*</span></span></span></pre></div>
                  </div>
                <p>
                  <code>variable</code> 后允许的带括号参数（bracketed binders）语法与 <a href="Definitions/Headers-and-Signatures/#bracketed-parameter-syntax">定义头的语法</a>一致。</p>
                <details class="example"><summary class="description">区段变量</summary><div class="example-content">
                    <p>
                      在下例区段中，自动隐式参数被禁用，并定义了一组区段变量。</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___section" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-21587" data-verso-hover="119">section</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-21595" data-verso-hover="90">set_option</span><span class="inter-text"> </span><a href="Definitions/Headers-and-Signatures/#autoImplicit" title="Documentation for option autoImplicit"><span class="option token" data-binding="option-autoImplicit" data-verso-hover="369">autoImplicit</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-21595" data-verso-hover="90">false</span><span class="inter-text">
</span><a href="The Type System/Universe/#Lean___Parser___Command___universe-next" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.universe-21625" data-verso-hover="373">universe</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">u</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___variable" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-21636" data-verso-hover="122">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="51">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#Zero___mk" title="Documentation for Zero"><span class="const token" data-binding="const-Zero" data-verso-hover="961">Zero</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#Add___mk" title="Documentation for Add"><span class="const token" data-binding="const-Add" data-verso-hover="251">Add</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      由于自动隐式参数已禁用，下面这个定义会失败：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-21823">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-addAll" data-verso-hover="962">addAll</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="372">lst</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'β'</code></span></span><span class="unknown token" data-binding="">β</span></span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'β'</code></span></span><span class="unknown token" data-binding="">β</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="372">lst</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___foldr" title="Documentation for List.foldr"><span class="const token" data-binding="const-List.foldr" data-verso-hover="963">foldr</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">init</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="371">0</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>unknown identifier 'β'
</pre></div>
                    <p>
                      另一方面，即便在定义时不写 <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.7438" data-verso-hover="51">xs</span></code>，也能使用它：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22028">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-addAll" data-verso-hover="964">addAll</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___foldr" title="Documentation for List.foldr"><span class="const token" data-binding="const-List.foldr" data-verso-hover="963">foldr</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">init</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="45">0</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  如果希望即使区段变量没有在定理声明里显式提及时也自动加到定理上，可以用 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.include : command</code><span class="sep"></span><code class="docstring">`include eeny meeny` instructs Lean to include the section `variable`s `eeny` and `meeny` in all
theorems in the remainder of the current section, differing from the default behavior of
conditionally including variables based on use in the theorem header. Other commands are
not affected. `include` is usually followed by `in theorem ...` to limit the inclusion
to the subsequent declaration.
</code></code><code class="kw">include</code></span> 命令标记该变量。
所有被标记的变量都会被无条件添加到所有定理中。
<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.omit : command</code><span class="sep"></span><code class="docstring">`omit` instructs Lean to not include a variable previously `include`d. Apart from variable names, it
can also refer to typeclass instance variables by type using the syntax `omit [TypeOfInst]`, in
which case all instance variables that unify with the given type are omitted. `omit` should usually
only be used in conjunction with `in` in order to keep the section structure simple.
</code></code><code class="kw">omit</code></span> 命令可用于去除变量的 include 标记；通常建议配合 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Namespaces and Sections/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> 使用。</p>
                <details class="example"><summary class="description">Included and Omitted Section Variables</summary><div class="example-content">
                    <p>
                      本区段的变量包含了一个谓词以及用于证明其适用于所有自然数的条件，还加了一个多余的假设。</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces and Sections/#Lean___Parser___Command___section" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-24828" data-verso-hover="119">section</span></a><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___variable" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-24836" data-verso-hover="122">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___variable" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-24864" data-verso-hover="122">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.49" data-verso-hover="966">pZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.117" data-verso-hover="967">pStep</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.53" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.53" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><a href="Namespaces and Sections/#Lean___Parser___Command___variable" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-24922" data-verso-hover="122">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.231" data-verso-hover="968">pFifteen</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">15</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      但下例定理默认只加了 <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.8113" data-verso-hover="965">p</span></code> 这个变量，导致无法证明：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-25072">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-p_all" data-verso-hover="969">p_all</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
case zero
p : Nat → Prop
⊢ p 0

case succ
p : Nat → Prop
n✝ : Nat
a✝ : p n✝
⊢ p (n✝ + 1)</code></span></span><span class="tactic"><label for="tactic-state-18023802970606905166-25102-25104-164"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-25102" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18023802970606905166-25102-25104-164"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.144" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.144" data-verso-hover="7">n</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-6222865684869141857-25107-25114-166"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-25107" data-verso-hover="775">intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6222865684869141857-25107-25114-166"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-13811916536682915986-25117-25128-168"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-25117" data-verso-hover="835">induction</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13811916536682915986-25117-25128-168"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-169" checked="checked"><span for="--verso-unique-169" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-170"><span for="--verso-unique-170" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.134" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.135" data-verso-hover="970">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.134" data-verso-hover="7">n✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.include : command</code><span class="sep"></span><code class="docstring">`include eeny meeny` instructs Lean to include the section `variable`s `eeny` and `meeny` in all
theorems in the remainder of the current section, differing from the default behavior of
conditionally including variables based on use in the theorem header. Other commands are
not affected. `include` is usually followed by `in theorem ...` to limit the inclusion
to the subsequent declaration.
</code></code><code class="kw">include</code></span> 命令会无条件插入额外假设：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.include-25262" data-verso-hover="971">include</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pStep</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pFifteen</span><span class="inter-text">

</span><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">automatically included section variable(s) unused in theorem 'p_all':
  pFifteen
consider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:
  omit pFifteen in theorem ...
note: this linter can be disabled with `set_option linter.unusedSectionVars false`</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-25292">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-p_all" data-verso-hover="972">p_all</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-4073655487795542288-25322-25324-171"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-25322" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4073655487795542288-25322-25324-171"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="973">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span><span class="inter-text"> </span><span class="unknown token" data-binding="">15</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.658" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.658" data-verso-hover="7">n</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-14245112769361947064-25327-25334-173"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-25327" data-verso-hover="775">intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14245112769361947064-25327-25334-173"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="973">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span><span class="inter-text"> </span><span class="unknown token" data-binding="">15</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-9418222449458764320-25337-25348-175"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-25337" data-verso-hover="835">induction</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9418222449458764320-25337-25348-175"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-176" checked="checked"><span for="--verso-unique-176" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="973">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span><span class="inter-text"> </span><span class="unknown token" data-binding="">15</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-177"><span for="--verso-unique-177" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="973">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span><span class="inter-text"> </span><span class="unknown token" data-binding="">15</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.134" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.135" data-verso-hover="970">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.134" data-verso-hover="7">n✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-9418222449458764320-25349-25352-178"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9418222449458764320-25349-25352-178"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-179" checked="checked"><span for="--verso-unique-179" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="973">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span><span class="inter-text"> </span><span class="unknown token" data-binding="">15</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-180"><span for="--verso-unique-180" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.16" data-verso-hover="973">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="965">p✝</span><span class="inter-text"> </span><span class="unknown token" data-binding="">15</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.659" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.134" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.135" data-verso-hover="970">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.134" data-verso-hover="7">n✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-25353-25361-181"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;},{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-25353" data-verso-hover="35">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-25353-25361-181"><span class="tactic-state">All goals completed! 🐙</span></span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      由于插入了无意义的 <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.8135" data-verso-hover="968">pFifteen</span></code>，Lean 会发出警告：</p>
                    <div class="warning">
                      <pre>automatically included section variable(s) unused in theorem 'p_all':
  pFifteen
consider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:
  omit pFifteen in theorem ...
note: this linter can be disabled with `set_option linter.unusedSectionVars false`
</pre></div>
                    <p>
                      为避免这个问题，可用 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.omit : command</code><span class="sep"></span><code class="docstring">`omit` instructs Lean to not include a variable previously `include`d. Apart from variable names, it
can also refer to typeclass instance variables by type using the syntax `omit [TypeOfInst]`, in
which case all instance variables that unify with the given type are omitted. `omit` should usually
only be used in conjunction with `in` in order to keep the section structure simple.
</code></code><code class="kw">omit</code></span> 去掉 <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.8144" data-verso-hover="968">pFifteen</span></code> 的 include 标记：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.include-25916" data-verso-hover="971">include</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pStep</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pFifteen</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.omit-25946" data-verso-hover="974">omit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pFifteen</span><span class="inter-text"> </span><a href="Namespaces and Sections/#Lean___Parser___Command___in" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-25946">in</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-25963">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-p_all" data-verso-hover="975">p_all</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.220" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.220" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-12306376187074219296-25993-25995-182"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-25993" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12306376187074219296-25993-25995-182"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.761" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.761" data-verso-hover="7">n</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-14116074423403087138-25998-26005-184"><a href="Tactic-Proofs/Tactic-Reference/#intro" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-25998" data-verso-hover="775">intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.224" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14116074423403087138-25998-26005-184"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.224" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.224" data-verso-hover="7">n</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-18244087234810760989-26008-26019-186"><a href="Tactic-Proofs/Tactic-Reference/#induction" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-26008" data-verso-hover="835">induction</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.224" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18244087234810760989-26008-26019-186"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-187" checked="checked"><span for="--verso-unique-187" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-188"><span for="--verso-unique-188" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.242" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.243" data-verso-hover="970">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.242" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.242" data-verso-hover="7">n✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-18244087234810760989-26020-26023-189"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18244087234810760989-26020-26023-189"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-190" checked="checked"><span for="--verso-unique-190" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-191"><span for="--verso-unique-191" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.29" data-verso-hover="966">pZero</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.97" data-verso-hover="967">pStep</span></span><span class="colon">:</span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.762" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.242" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.243" data-verso-hover="970">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.242" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="965">p</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.242" data-verso-hover="7">n✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">+</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Type-Classes/Basic-Classes/#HAdd___mk" title="Documentation for HAdd.hAdd"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-26024-26032-192"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;},{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-26024" data-verso-hover="35">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-26024-26032-192"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-26046" data-verso-hover="125">end</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              </section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="Source Files and Modules/#files" rel="prev" title="5. 源文件与模块"><span class="arrow">←</span><span class="where">5. 源文件与模块</span></a><a class="local-button active" href="Definitions/#definitions" rel="next" title="7. Definitions"><span class="where">7. Definitions</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

