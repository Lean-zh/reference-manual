<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>归纳类型</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
  text-decoration-skip-ink: none;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
  display: inline-grid;
  grid-template-columns: 1fr;
  vertical-align: top;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: inline-block;
  vertical-align: top;
  grid-row: 2;
  justify-self: start;
}

.hl.lean .tactic > label {
  position: relative;
  grid-row: 1;
}

@media (hover: hover) {
  .hl.lean .tactic:has(.tactic-toggle:not(:checked)) > label:hover {
    background-color: #eeeeee;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

.extra-doc-links {
  list-style-type: none;
  margin-left: 0;
  padding: 0;
}

.extra-doc-links > li {
  display: inline-block;
}

.extra-doc-links > li:not(:last-child)::after {
  content: '|';
  display: inline-block;
  margin: 0 0.25em;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
            const extraLinks = tgt.parentElement.dataset['versoLinks'];
            if (extraLinks) {
              try {
                const extras = JSON.parse(extraLinks);
                const links = document.createElement('ul');
                links.className = 'extra-doc-links';
                extras.forEach((l) => {
                  const li = document.createElement('li');
                  li.innerHTML = "<a href=\"" + l['href'] + "\" title=\"" + l.long + "\">" + l.short + "</a>";
                  links.appendChild(li);
                });
                content.appendChild(links);
              } catch (error) {
                console.error(error);
              }
            }
          }
          return content;
        }
      };


      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort', defaultTippyProps);
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    <script defer="defer" data-domain="lean-lang.org/doc/reference/latest" src="https://plausible.io/js/script.outbound-links.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Lean 语言参考手册</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Lean 语言参考手册</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">简介</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration and Compilation/#elaboration-and-compilation">繁释与编译</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="current numbered"><td class="num">4.</td><td><a href="The Type System/#type-system">类型系统</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#Lean-__________________--______">索引</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-type-system" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-type-system" checked="checked"></label><span class="number">4.</span> <span class=""><a href="The Type System/#type-system">类型系统</a></span></div>
              <table><tr class="numbered"><td class="num">4.1.</td><td><a href="The Type System/Functions/#functions">函数</a></td></tr><tr class="numbered"><td class="num">4.2.</td><td><a href="The Type System/Propositions/#propositions">命题 (Propositions)</a></td></tr><tr class="numbered"><td class="num">4.3.</td><td><a href="The Type System/Universe/#universe">宇宙（Universe）</a></td></tr><tr class="current numbered"><td class="num">4.4.</td><td><a href="The Type System/Inductive Types/#inductive-types">归纳类型</a></td></tr><tr class="numbered"><td class="num">4.5.</td><td><a href="The Type System/Quotients/#quotients">商类型</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-inductive-types" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-inductive-types" checked="checked"></label><span class="number">4.4.</span> <span class="current"><a href="The Type System/Inductive Types/#inductive-types">归纳类型</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="The Type System/Inductive Types/#inductive-declarations">归纳类型声明</a></span></li>
                <li>
                  <a href="The Type System/Inductive Types/#Lean___Parser___Command___declaration"><span class="syntax"><span class="keyword">inductive</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">where</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">)*</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">deriving</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="The Type System/Inductive Types/#inductive-datatypes-parameters-and-indices">参数与索引</a></span></li>
                <li>
                  <a href="The Type System/Inductive Types/#inductive___autoPromoteIndices"><code>inductive.autoPromoteIndices</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="The Type System/Inductive Types/#example-inductive-types">归纳类型样例</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.3.</span> <a href="The Type System/Inductive Types/#anonymous-constructor-syntax">匿名构造子语法</a></span></li>
                <li>
                  <a href="The Type System/Inductive Types/#Lean___Parser___Term___anonymousCtor"><span class="syntax"><span class="keyword">⟨</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">⟩</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.4.</span> <a href="The Type System/Inductive Types/#inductive-declarations-deriving-instances">派生实例</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="The Type System/Inductive Types/#structures">结构体声明</a></span></li>
                <li>
                  <a href="The Type System/Inductive Types/#Lean___Parser___Command___declaration-next"><span class="syntax"><span class="keyword">structure</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">extends</span><span class="ws"> </span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">)?</span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">where</span><span class="ws"> </span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">::</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">deriving</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="The Type System/Inductive Types/#structure-params">结构体参数</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.2.</span> <a href="The Type System/Inductive Types/#structure-fields">字段</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.3.</span> <a href="The Type System/Inductive Types/#structure-constructors">结构体构造子</a></span></li>
                <li>
                  <a href="The Type System/Inductive Types/#Lean___Parser___Term___structInst"><span class="syntax"><span class="keyword">{</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">}</span></span></a></li>
                <li>
                  <a href="The Type System/Inductive Types/#Lean___Parser___Term___structInstField"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="The Type System/Inductive Types/#Lean___Parser___Term___structInst-next"><span class="syntax"><span class="keyword">{</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">with</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="keyword">}</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.4.</span> <a href="The Type System/Inductive Types/#structure-inheritance">结构体继承</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="The Type System/Inductive Types/#inductive-types-logical-model">逻辑模型</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.1.</span> <a href="The Type System/Inductive Types/#recursors">递归子</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.1.1.</span> <a href="The Type System/Inductive Types/#recursor-types">递归子类型</a></span></li>
                <li>
                  <span class="header head-4"><span class="level-num">3.1.1.1.</span> <a href="The Type System/Inductive Types/#subsingleton-elimination">子单元消去</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.1.2.</span> <a href="The Type System/Inductive Types/#iota-reduction">规约</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.2.</span> <a href="The Type System/Inductive Types/#well-formed-inductives">良构性约束</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.2.1.</span> <a href="The Type System/Inductive Types/#inductive-type-universe-levels">宇宙层级</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.2.2.</span> <a href="The Type System/Inductive Types/#strict-positivity">严格正性</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">3.2.3.</span> <a href="The Type System/Inductive Types/#prop-vs-type">Prop vs Type</a></span></li>
                <li>
                  <a href="The Type System/Inductive Types/#bootstrap___inductiveCheckResultingUniverse"><code>bootstrap.inductiveCheckResultingUniverse</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.3.</span> <a href="The Type System/Inductive Types/#recursor-elaboration-helpers">用于终止性检查的构造</a></span></li>
                <li>
                  <a href="The Type System/Inductive Types/#SizeOf___mk"><code>SizeOf</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="The Type System/Inductive Types/#run-time-inductives">运行时表示</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.1.</span> <a href="The Type System/Inductive Types/#inductive-types-runtime-special-support">特例</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.2.</span> <a href="The Type System/Inductive Types/#inductive-types-runtime-relevance">相关性</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.3.</span> <a href="The Type System/Inductive Types/#inductive-types-trivial-wrappers">平凡包装类型</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">4.4.</span> <a href="The Type System/Inductive Types/#inductive-types-standard-representation">其它归纳类型</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">4.4.1.</span> <a href="The Type System/Inductive Types/#inductive-types-ffi">FFI</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="The Type System/Inductive Types/#mutual-inductive-types">互递归归纳类型</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.1.</span> <a href="The Type System/Inductive Types/#mutual-inductive-types-requirements">要求</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">5.1.1.</span> <a href="The Type System/Inductive Types/#mutual-inductive-types-dependencies">互相关系</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">5.1.2.</span> <a href="The Type System/Inductive Types/#mutual-inductive-types-same-parameters">参数必须匹配</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">5.1.3.</span> <a href="The Type System/Inductive Types/#mutual-inductive-types-same-universe">宇宙层级</a></span></li>
                <li>
                  <span class="header head-3"><span class="level-num">5.1.4.</span> <a href="The Type System/Inductive Types/#mutual-inductive-types-positivity">正性条件(Positivity)</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.2.</span> <a href="The Type System/Inductive Types/#mutual-inductive-types-recursors">递归子</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.3.</span> <a href="The Type System/Inductive Types/#mutual-inductive-types-run-time">运行时表示</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.4.</span> <a href="The Type System/Inductive Types/#nested-inductive-types">Nested Inductive Types</a></span></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="The Type System/Universe/#universe" rel="prev" title="4.3. 宇宙（Universe）"><span class="arrow">←</span><span class="where">4.3. 宇宙（Universe）</span></a><a class="local-button active" href="The Type System/Quotients/#quotients" rel="next" title="4.5. 商类型"><span class="where">4.5. 商类型</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              4.4. 归纳类型<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-types" title="Permalink">🔗</a></span></h1>
            <p>
              <span id="--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>归纳类型</em></span> 是在 Lean 中引入新类型的主要方式。
虽然 <a class="technical-term" href="The Type System/Universe/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next">宇宙</a>、<a class="technical-term" href="The Type System/Functions/#--tech-term-______-next-next-next-next-next-next">函数</a> 以及 <a class="technical-term" href="The Type System/Quotients/#--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">商类型</a> 是内置的原语类型，用户无法自行添加，但 Lean 里的其它类型要么是归纳类型，要么是基于宇宙、函数与归纳类型定义的。
归纳类型的定义依赖于它们的 <span id="--tech-term-_______________-next-next-next" class="def-technical-term"><em>类型构造子</em></span> 和 <span id="--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>构造子</em></span> ；<span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>它们的其它性质也由这些定义推导而来。
每个归纳类型有唯一的类型构造子，这个构造子可能带有 <a class="technical-term" href="The Type System/Universe/#--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next">宇宙参数</a> 和普通参数。
归纳类型可以拥有任意数量的构造子；这些构造子用于生成新的值，其类型由归纳类型的类型构造子决定。</p>
            <p>
              根据归纳类型的类型构造子和构造子，Lean 会自动生成一个 <span id="--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>递归子</em></span><span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>。
从逻辑上讲，递归子代表归纳原则或消去规则；从计算角度看，它们表示原始递归计算。
递归函数的终止性由其翻译为递归子的调用来保证，因此 Lean 的内核只需对递归子的应用做类型检查，而无需单独进行终止性分析。
除此之外，Lean 还根据递归子生成很多辅助结构<span class="marginalia"><span class="note">无论类型是否递归，递归子总会被用到</span></span>，这些结构被系统的其他部分使用。</p>
            <p>
              <em>结构体</em> 是一种特殊的归纳类型，只包含一个构造子。
当一个结构体被声明时，Lean 会自动生成辅助工具，使得新结构体能支持更多语言特性。</p>
            <p>
              本节描述用于定义归纳类型和结构体的具体语法细节、归纳类型声明会在环境中引入哪些新的常量和定义，以及在编译后归纳类型值的运行时表现。</p>
            <section>
              <h2 id="inductive-declarations">
                4.4.1. 归纳类型声明<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-declarations" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">归纳类型声明</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___declaration"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.declaration"><a href="Definitions/Modifiers/#Lean___Parser___Command___declModifiers"><span class="nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code>declModifiers</span></a>
      <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.inductive"><code class="hover-info"><code class="docstring">In Lean, every concrete type other than the universes
and every type constructor other than dependent arrows
is an instance of a general family of type constructions known as inductive types.
It is remarkable that it is possible to construct a substantial edifice of mathematics
based on nothing more than the type universes, dependent arrow types, and inductive types;
everything else follows from those.
Intuitively, an inductive type is built up from a specified list of constructors.
For example, `List α` is the list of elements of type `α`, and is defined as follows:
```
inductive List (α : Type u) where
| nil
| cons (head : α) (tail : List α)
```
A list of elements of type `α` is either the empty list, `nil`,
or an element `head : α` followed by a list `tail : List α`.
See [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)
for more information.
</code></code><span class="keyword">inductive</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <a href="Definitions/Headers-and-Signatures/#Lean___Parser___Command___optDeclSig"><span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span></a> <span class="from-nonterminal" data-kind="null"><span class="keyword">where</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.ctor"><span class="from-nonterminal" data-kind="null"></span><span class="keyword">|</span> <a href="Definitions/Modifiers/#Lean___Parser___Command___declModifiers"><span class="nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code>declModifiers</span></a> <span class="nonterminal" data-kind="ident">ident</span> <a href="Definitions/Headers-and-Signatures/#Lean___Parser___Command___optDeclSig"><span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span></a></span></span><span class="bnf">)*</span>
      </span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Command.optDeriving"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><a href="Type-Classes/Deriving-Instances/#Lean___Parser___Command___optDeriving-next"><span class="keyword">deriving</span></a> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span><span class="bnf">,*</span></span></span><span class="bnf">)?</span></span></span></span></span></pre><p>
                    声明一个新的归纳类型。
<code class="grammar"><span class="nonterminal" data-kind="declModifiers">declModifiers</span></code> 的含义可在 <a href="Definitions/Modifiers/#declaration-modifiers">声明修饰词部分</a> 查询。</p>
                  </div>
                </div>
              <p>
                声明归纳类型后，其类型构造子、构造子和递归子会添加到环境中。
新的归纳类型扩展了 Lean 的核心逻辑——它们不是由系统中已有的数据编码或模拟出来的。
归纳类型声明还必须满足一系列 <a href="The Type System/Inductive Types/#well-formed-inductives">良构性要求</a> 以确保逻辑系统的一致性。</p>
              <p>
                声明的第一行，从 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.inductive : command</code></code><code class="kw">inductive</code></span> 到 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.inductive : command</code></code><code class="kw">where</code></span>，用于指定新的 <a class="technical-term" href="The Type System/Inductive Types/#--tech-term-_______________-next-next-next">类型构造子</a> 的名字和类型。
如果为类型构造子提供了类型签名，则结果类型必须是 <a class="technical-term" href="The Type System/Universe/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next">宇宙</a>，但参数不一定要是类型。
如果没有提供签名，Lean 会尝试为结果类型推断出刚好合适的宇宙。
在某些场景下，推断可能无法找到最小宇宙甚至无法推断成功，此时需要手动注释。</p>
              <p>
                构造子定义在 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.inductive : command</code></code><code class="kw">where</code></span>后边。
构造子并非必需，比如像 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Empty-Type/#Empty" title="Documentation for Empty"><span class="const token" data-binding="const-Empty" data-verso-hover="268">Empty</span></a></code> 这样没有构造子的归纳类型是完全合理的。
每个构造子定义以竖线 (<code>'|'</code>, Unicode <code>'VERTICAL BAR' (U+007c)</code>)、声明修饰词和名字。
名字是 <a class="technical-term" href="Source-Files-and-Modules/#--tech-term-raw-identifier">原始标识符</a>。
名字后接声明签名。
签名可以包含任意参数，但需满足归纳类型声明的良构性要求，返回类型必须是归纳类型的类型构造子的饱和应用。
如果未指定签名，则 Lean 会插入足够的隐式参数来推断出良构的返回类型。</p>
              <p>
                新归纳类型的名字定义在<a class="technical-term" href="Namespaces-and-Sections/#--tech-term-current-namespace-next">当前命名空间</a>中。
每个构造子的名字位于该归纳类型的命名空间下。<span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span></p>
              <section>
                <h3 id="inductive-datatypes-parameters-and-indices">
                  4.4.1.1. 参数与索引<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-datatypes-parameters-and-indices" title="Permalink">🔗</a></span></h3>
                <p>
                  类型构造子可以接收两类参数：<span id="--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>参数</em></span> <span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span> 和 <span id="--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>索引</em></span> <span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>。
定义中，参数必须在整个归纳类型定义中保持一致；所有构造子中出现的类型构造子，参数必须一模一样。
索引则可以在不同构造子的类型构造子的具体应用中变化。
所有参数在类型构造子的签名中必须排在索引的前面。</p>
                <p>
                  在类型构造子的签名中冒号（<code>':'</code>）之前的内容作为整个归纳类型声明的参数，
这些参数在类型定义过程中始终如一。
通常，冒号之后为索引，可以在归纳类型定义中变化。
但如果 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#inductive___autoPromoteIndices" title="Documentation for option inductive.autoPromoteIndices"><span class="option token" data-binding="option-inductive.autoPromoteIndices" data-verso-hover="269">inductive.autoPromoteIndices</span></a></code> 选项为 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code>，则本来可以作为参数的语法层面的索引会被自动提升为参数。
当一个索引的所有类型依赖全都是参数类型，且它在所有构造子的类型构造子调用中始终未实例化、未变化，那么它就可以被当作参数。</p>
                <div class="namedocs" id="inductive___autoPromoteIndices">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.option&amp;name=inductive.autoPromoteIndices" title="Permalink">🔗</a></span><span class="label">option</span><pre class="signature hl lean block">inductive.autoPromoteIndices</pre><div class="text">
                    <p>
                      Default value: <code class="hl lean inline"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code></p>
                    <p>
                      Promote indices to parameters in inductive types whenever possible.</p>
                    </div>
                  </div>
                <p>
                  索引实际上定义了一个<em>类型族</em>。
每次索引取值确定，就从族中选出一个类型，该类型有它各自的构造子。
含索引的类型构造子即定义了一个 <span id="--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>索引族</em></span> <span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>。</p>
                </section>
              <section>
                <h3 id="example-inductive-types">
                  4.4.1.2. 归纳类型样例<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=example-inductive-types" title="Permalink">🔗</a></span></h3>
                <details class="example"><summary class="description">一个没有构造子的类型</summary><div class="example-content">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Vacant" title="Definition of example Vacant"><span class="const token" data-binding="const-Vacant" data-verso-hover="270">Vacant</span></a></code> 是一个空的归纳类型，等价于 Lean 的 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Empty-Type/#Empty" title="Documentation for Empty"><span class="const token" data-binding="const-Empty" data-verso-hover="268">Empty</span></a></code> 类型：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-13264" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vacant" data-verso-hover="270" id="Vacant">Vacant</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-13288">where</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      空归纳类型并非毫无用处；它们可以用于标记不可达代码。</p>
                    </div>
                  </details><details class="example"><summary class="description">一个没有构造子的命题</summary><div class="example-content">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#No" title="Definition of example No"><span class="const token" data-binding="const-No" data-verso-hover="271">No</span></a></code> 是一个假命题，等价于 Lean 的 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-13810" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-No" data-verso-hover="271" id="No">No</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-13830">where</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><details class="example"><summary class="description">单位类型</summary><div class="example-content">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Solo" data-verso-hover="272">Solo</span></code> 和 Lean 的 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#Unit" title="Documentation for Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a></code> 类型等价：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-14772" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Solo" data-verso-hover="272">Solo</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-14787">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Solo.solo" data-verso-hover="273" id="Solo">solo</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      这是一个类型构造子和构造子的签名都被省略的例子。Lean 会将 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Solo" data-verso-hover="272">Solo</span></code> 推断为 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span></code>：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Solo : Type</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-14953">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-Solo" data-verso-hover="272">Solo</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>Solo : Type
</pre></div>
                    <p>
                      构造子的名字是 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Solo" title="Definition of example Solo.solo"><span class="const token" data-binding="const-Solo.solo" data-verso-hover="273">Solo.solo</span></a></code>，因为构造子的名字在类型构造子的命名空间下。
由于 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Solo" data-verso-hover="272">Solo</span></code> 无需参数，Lean 自动推断 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Solo" title="Definition of example Solo.solo"><span class="const token" data-binding="const-Solo.solo" data-verso-hover="273">Solo.solo</span></a></code> 的类型为：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Solo.solo : Solo</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-15222">#check</span></a></span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Solo" title="Definition of example Solo.solo"><span class="const token" data-binding="const-Solo.solo" data-verso-hover="273">Solo.solo</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>Solo.solo : Solo
</pre></div>
                    </div>
                  </details><details class="example"><summary class="description">真命题</summary><div class="example-content">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Yes___intro" title="Definition of example Yes"><span class="const token" data-binding="const-Yes" data-verso-hover="274">Yes</span></a></code> 等价于 Lean 的 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="263">True</span></a></code> 命题：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-15984" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Yes" data-verso-hover="274" id="Yes___intro">Yes</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-16005">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Yes.intro" data-verso-hover="275" id="Yes___intro">intro</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      不同于 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-One" data-verso-hover="276">One</span></code>，新的归纳类型 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Yes___intro" title="Definition of example Yes"><span class="const token" data-binding="const-Yes" data-verso-hover="274">Yes</span></a></code> 被指定为 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code> 宇宙。</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Yes : Prop</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-16140">#check</span></a></span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Yes___intro" title="Definition of example Yes"><span class="const token" data-binding="const-Yes" data-verso-hover="274">Yes</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>Yes : Prop
</pre></div>
                    <p>
                      推断得到的 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Yes___intro" title="Definition of example Yes.intro"><span class="const token" data-binding="const-Yes.intro" data-verso-hover="275">Yes.intro</span></a></code> 的签名如下：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Yes.intro : Yes</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-16267">#check</span></a></span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Yes___intro" title="Definition of example Yes.intro"><span class="const token" data-binding="const-Yes.intro" data-verso-hover="275">Yes.intro</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>Yes.intro : Yes
</pre></div>
                    </div>
                  </details><details class="example"><summary class="description">一个带参数和索引的类型</summary><div class="example-content">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="const token" data-binding="const-α" data-verso-hover="278">α</span><span class="inter-text"> </span><span class="const token" data-binding="const-b" data-verso-hover="279">b</span></code> 表示一种列表，其中 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-α" data-verso-hover="278">α</span></code> 是元素类型，<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-b" data-verso-hover="279">b</span></code> 为 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> 表示含偶数个元素：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-18599" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-18653">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="280">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="281">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="156">isEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Booleans/#Bool___not" title="Documentation for Bool.not"><span class="const token" data-binding="const-Bool.not" data-verso-hover="282">not</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="156">isEven</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      以下例子类型合法，因为列表有两个元素：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-18832">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="281">.cons</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="190">"a"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="281">.cons</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="191">"b"</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="280">.nil</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      下面这个例子类型不合法，因为实际有三个元素：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-19016">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">type mismatch
  EvenOddList.cons "a" (EvenOddList.cons "b" (EvenOddList.cons "c" EvenOddList.nil))
has type
  EvenOddList String !!!true : Type
but is expected to have type
  EvenOddList String true : Type</code></span></span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="281">.cons</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="190">"a"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="281">.cons</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="191">"b"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="281">.cons</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="192">"c"</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="280">.nil</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>type mismatch
  EvenOddList.cons "a" (EvenOddList.cons "b" (EvenOddList.cons "c" EvenOddList.nil))
has type
  EvenOddList String !!!true : Type
but is expected to have type
  EvenOddList String true : Type
</pre></div>
                    <p>
                      在本声明中，<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-α" data-verso-hover="278">α</span></code> 是 <a class="technical-term" href="The Type System/Inductive Types/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next">参数</a>，
因为它在 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span></code> 的每次出现都保持一致；<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-b" data-verso-hover="279">b</span></code> 是 <a class="technical-term" href="The Type System/Inductive Types/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next-next">索引</a>，因为它在不同出现中可取不同值。</p>
                    </div>
                  </details><details class="example"><summary class="description">参数在冒号前和冒号后</summary><div class="example-content">
                    <p>
                      在本例中，所有参数都在 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Either" data-verso-hover="283">Either</span></code> 签名的冒号前：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-21754" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either" data-verso-hover="283">Either</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="level-op token" data-binding="level-op-max" data-verso-hover="284">max</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-21816">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either.left" data-verso-hover="285" id="Either___right">left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either" data-verso-hover="283">Either</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either.right" data-verso-hover="286" id="Either___right">right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either" data-verso-hover="283">Either</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      在下面这个版本中，有两个名为 <code>α</code> 的类型，可能不完全相同：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-22017" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either'" data-verso-hover="287" id="Either___">Either'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="level-op token" data-binding="level-op-max" data-verso-hover="284">max</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-22080">where</span><span class="inter-text">
  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Mismatched inductive type parameter in
  Either' α β
The provided argument
  α
is not definitionally equal to the expected parameter
  α✝

Note: The value of parameter 'α✝' must be fixed throughout the inductive declaration. Consider making this parameter an index if it must vary.</code></span></span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="246">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Either___" title="Definition of example Either'"><span class="const token" data-binding="const-Either'" data-verso-hover="287">Either'</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="246">β</span></span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Either'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">β</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>Mismatched inductive type parameter in
  Either' α β
The provided argument
  α
is not definitionally equal to the expected parameter
  α✝

Note: The value of parameter 'α✝' must be fixed throughout the inductive declaration. Consider making this parameter an index if it must vary.
</pre></div>
                    <p>
                      把参数放在冒号后，则对应的构造子参数可以由构造子自行实例化：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-22627" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either''" data-verso-hover="288" id="Either_________right">Either''</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="level-op token" data-binding="level-op-max" data-verso-hover="284">max</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="inter-text"> </span><span class="level-op token" data-binding="level-op-+">+</span><span class="inter-text"> </span><span class="level-const token" data-binding="level-const-1" data-verso-hover="209">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-22689">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either''.left" data-verso-hover="289" id="Either_________right">left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="246">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Either_________right" title="Definition of example Either''"><span class="const token" data-binding="const-Either''" data-verso-hover="288">Either''</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="246">β</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either''.right" data-verso-hover="290" id="Either_________right">right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="246">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Either_________right" title="Definition of example Either''"><span class="const token" data-binding="const-Either''" data-verso-hover="288">Either''</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="246">β</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      此时需要更大的宇宙层级，因为 <a href="The Type System/Inductive Types/#inductive-type-universe-levels">构造子的参数必须处于比归纳类型本身更低的宇宙</a>。
<code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Either_________right" title="Definition of example Either''.right"><span class="const token" data-binding="const-Either''.right" data-verso-hover="290">Either''.right</span></a></code> 的类型参数会按 Lean 的 <a class="technical-term" href="Definitions/Headers-and-Signatures/#--tech-term-automatic-implicit-parameters">自动隐式参数</a> 规则推断。</p>
                    </div>
                  </details></section>
              <section>
                <h3 id="anonymous-constructor-syntax">
                  4.4.1.3. 匿名构造子语法<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=anonymous-constructor-syntax" title="Permalink">🔗</a></span></h3>
                <p>
                  如果归纳类型只有一个构造子，则这个构造子可以使用 <span id="--tech-term-_____________________" class="def-technical-term"><em>匿名构造子语法</em></span>。
即，不必写出构造子的名字并将其应用到参数上，而直接把所有显式参数用尖括号（<code>'⟨'</code> 和 <code>'⟩'</code>, Unicode <code>MATHEMATICAL LEFT ANGLE BRACKET (U+0x27e8)</code> 和 <code>MATHEMATICAL RIGHT ANGLE BRACKET (U+0x27e9)</code>）括起来，并用逗号分隔即可。
这种语法可以用于模式匹配和表达式。
若想按照参数名字提供参数，或将所有隐式参数变为显式，则需使用普通构造子语法。</p>
                <div class="namedocs" id="term">
                  <span class="label">syntax</span><span class="title">匿名构造子</span><div class="text">
                    <p>
                      可通过用尖括号括起所有显式参数并用逗号分隔，匿名地调用构造子。</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___anonymousCtor"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.anonymousCtor"><code class="hover-info"><code class="docstring">The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the
expected type is an inductive type with a single constructor `c`.
If more terms are given than `c` has parameters, the remaining arguments
are turned into a new anonymous constructor application. For example,
`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.
</code></code><span class="keyword">⟨</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span><span class="bnf">,*</span> </span><span class="keyword">⟩</span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">匿名构造子</summary><div class="example-content">
                    <p>
                      类型 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="291">AtLeastOne</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-α" data-verso-hover="165">α</span></code> 和 <code>List α</code> 相似，区别在于它始终至少有一个元素：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-25884" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="291" id="AtLeastOne">AtLeastOne</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-25928">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="292" id="AtLeastOne">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="291">AtLeastOne</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="291">AtLeastOne</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      可采用匿名构造子语法进行构造：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-26050">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-oneTwoThree" data-verso-hover="293">oneTwoThree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="291">AtLeastOne</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">⟨</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">,</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">⟨</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">,</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">⟨</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">,</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">⟩</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">⟩</span><span class="unknown token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">⟩</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      也可用该语法进行模式匹配：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-26182">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-AtLeastOne.head" data-verso-hover="294" id="AtLeastOne___head">AtLeastOne.head</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="291">AtLeastOne</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="43">α</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="45">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="45">x</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      同样，传统构造子语法也可以：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-26301">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-oneTwoThree'" data-verso-hover="295" id="oneTwoThree___">oneTwoThree'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="291">AtLeastOne</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne.mk"><span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">.mk</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne.mk"><span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">.mk</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne.mk"><span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">.mk</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-26382">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-AtLeastOne.head'" data-verso-hover="296" id="oneTwoThree___">AtLeastOne.head'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne"><span class="const token" data-binding="const-AtLeastOne" data-verso-hover="291">AtLeastOne</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.46" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.46" data-verso-hover="43">α</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AtLeastOne" title="Definition of example AtLeastOne.mk"><span class="const token" data-binding="const-AtLeastOne.mk" data-verso-hover="292">.mk</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.77" data-verso-hover="45">x</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="inductive-declarations-deriving-instances">
                  4.4.1.4. 派生实例<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-declarations-deriving-instances" title="Permalink">🔗</a></span></h3>
                <p>
                  归纳类型声明末尾可选的 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.inductive : command</code></code><code class="kw">deriving</code></span> 子句，可用于自动派生类型类实例。
详情请见 <a href="Type-Classes/Deriving-Instances/#deriving-instances">关于实例自动派生的章节</a>。</p>
                </section>
              </section>
            <section>
              <h2 id="structures">
                4.4.2. 结构体声明<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=structures" title="Permalink">🔗</a></span></h2>
              <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">结构体声明</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___declaration-next"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.declaration"><a href="Definitions/Modifiers/#Lean___Parser___Command___declModifiers"><span class="nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code>declModifiers</span></a>
      <span class="from-nonterminal" data-kind="Lean.Parser.Command.structure"><span class="from-nonterminal" data-kind="Lean.Parser.Command.structureTk"><span class="keyword">structure</span> </span><span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">*</span> </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.extends"><span class="keyword">extends</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.structParent"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span> </span><span class="bnf">)?</span></span><span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">,*</span></span><span class="from-nonterminal" data-kind="null"></span></span></span><span class="bnf">)?</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="keyword">where</span>
        <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.structCtor"><a href="Definitions/Modifiers/#Lean___Parser___Command___declModifiers"><span class="nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code>declModifiers</span></a> <span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">::</span></span></span><span class="bnf">)?</span>
        </span><span class="nonterminal" data-kind="Lean.Parser.Command.structFields">structFields</span>
      </span><span class="from-nonterminal" data-kind="Lean.Parser.Command.optDeriving"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><a href="Type-Classes/Deriving-Instances/#Lean___Parser___Command___optDeriving-next"><span class="keyword">deriving</span></a> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span><span class="bnf">,*</span></span></span><span class="bnf">)?</span></span></span></span></span></pre><p>
                    声明一个新的结构体类型。</p>
                  </div>
                </div>
              <p>
                <span id="--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>结构体</em></span> 是只有一个构造子、无下标的归纳类型。
作为这些约束的交换，Lean 会为结构体自动生成一些便捷功能：为每个字段生成投影函数、允许基于字段名（而非位置参数）的新构造语法、同样可以按指定字段名修改值，并且结构体可以扩展其它结构体。
结构体和其它归纳类型一样，可以递归定义；它们必须遵守严格正性限制。
结构体本身并没有带来 Lean 表达力的增强；它们的所有特性都是通过代码生成机制实现的。</p>
              <section>
                <h3 id="structure-params">
                  4.4.2.1. 结构体参数<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=structure-params" title="Permalink">🔗</a></span></h3>
                <p>
                  与普通归纳类型声明相同，结构体声明的头部可以包含参数和结果宇宙层级。
结构体不能定义 <a class="technical-term" href="The Type System/Inductive Types/#--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next">索引族</a>。</p>
                </section>
              <section>
                <h3 id="structure-fields">
                  4.4.2.2. 字段<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=structure-fields" title="Permalink">🔗</a></span></h3>
                <p>
                  结构体声明的每个字段，都对应构造子的一个参数。
每个字段中都会独立插入自动隐式参数,即使名称相同，且这些字段会成为构造子的参数以量化类型。</p>
                <details class="example"><summary class="description">结构体字段中的自动隐式参数</summary><div class="example-content">
                    <p>
                      结构体 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#MyStructure___field2" title="Definition of example MyStructure"><span class="const token" data-binding="const-MyStructure" data-verso-hover="297">MyStructure</span></a></code> 包含一个字段，其类型是自动隐式参数：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-4899">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-MyStructure" data-verso-hover="297" id="MyStructure___field2">MyStructure</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-4921">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-MyStructure.field1" data-verso-hover="298" id="MyStructure___field2">field1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="128">α</span><span class="inter-text">
  </span><span class="const token" data-binding="const-MyStructure.field2" data-verso-hover="299" id="MyStructure___field2">field2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="300">α</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      类型构造子 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#MyStructure___field2" title="Definition of example MyStructure"><span class="const token" data-binding="const-MyStructure" data-verso-hover="297">MyStructure</span></a></code> 需要两个宇宙参数：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="The Type System/Inductive Types/#MyStructure___field2" title="Definition of example MyStructure"><span class="const token" data-binding="const-MyStructure" data-verso-hover="297">MyStructure</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="level-op token" data-binding="level-op-max" data-verso-hover="284">max</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">)</span></code><p>
                      由于构造子字段量化于 <code>Sort</code> 中的类型，因此其结果类型是 <code>Type</code>，而非 <code>Sort</code>。具体来说，构造子 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-MyStructure.mk" data-verso-hover="301">MyStructure.mk</span></code> 的两个字段都带有隐式类型参数：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-MyStructure.mk" data-verso-hover="301">MyStructure.mk</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="302">field1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="170">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="170">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="303">field2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="179">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="179">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#MyStructure___field2" title="Definition of example MyStructure"><span class="const token" data-binding="const-MyStructure" data-verso-hover="297">MyStructure</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span></code></div>
                  </details><p>
                  对于每个字段，都会自动生成一个 <span id="--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>投影函数</em></span>，用于从构造子中提取字段的值。
这个函数在结构体名称对应的命名空间中。
结构体字段投影由繁释器特别处理（具体见 <a href="The Type System/Inductive Types/#structure-inheritance">结构体继承</a>），其行为比仅查找命名空间要复杂。
当字段类型依赖于之前字段时，依赖型投影函数的类型会使用之前的投影表达，而不是显式模式匹配。</p>
                <details class="example"><summary class="description">依赖型投影类型</summary><div class="example-content">
                    <p>
                      结构体 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#ArraySized___array" title="Definition of example ArraySized"><span class="const token" data-binding="const-ArraySized" data-verso-hover="304">ArraySized</span></a></code> 包含一个字段，其类型依赖于结构体参数和先前字段：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-7298">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArraySized" data-verso-hover="304" id="ArraySized___array">ArraySized</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-null-7349">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-ArraySized.array" data-verso-hover="305" id="ArraySized___array">array</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="161">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text">
  </span><span class="const token" data-binding="const-ArraySized.size_eq_length" data-verso-hover="306" id="ArraySized___array">size_eq_length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="307">array</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size" title="Documentation for Array.size"><span class="const token" data-binding="const-Array.size" data-verso-hover="163">size</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      投影函数 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#ArraySized___array" title="Definition of example ArraySized.size_eq_length"><span class="const token" data-binding="const-ArraySized.size_eq_length" data-verso-hover="306">size_eq_length</span></a></code> 的签名中，会隐式带入结构体类型的参数，通过先前的投影引用之前的字段：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="The Type System/Inductive Types/#ArraySized___array" title="Definition of example ArraySized.size_eq_length"><span class="const token" data-binding="const-ArraySized.size_eq_length" data-verso-hover="306">ArraySized.size_eq_length</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="308">self</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ArraySized___array" title="Definition of example ArraySized"><span class="const token" data-binding="const-ArraySized" data-verso-hover="304">ArraySized</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="308">self</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#ArraySized___array" title="Definition of example ArraySized.array"><span class="const token" data-binding="const-ArraySized.array" data-verso-hover="305">array</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size" title="Documentation for Array.size"><span class="const token" data-binding="const-Array.size" data-verso-hover="163">size</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">length</span></code></div>
                  </details><p>
                  结构体字段可以通过 <code>:=</code> 指定默认值。
如果没有提供该字段的显式值，则使用默认值。</p>
                <details class="example"><summary class="description">默认值</summary><div class="example-content">
                    <p>
                      图的邻接表可用一个 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> 列表的数组表示。
数组大小代表顶点数，数组中每个元素（通过顶点下标访问）存储对应顶点的出边。
由于 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Graph" title="Definition of example Graph.adjacency"><span class="const token" data-binding="const-Graph.adjacency" data-verso-hover="309">adjacency</span></a></code> 字段提供了默认值 <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span></code>，空图 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Graph" title="Definition of example Graph.empty"><span class="const token" data-binding="const-Graph.empty" data-verso-hover="310">Graph.empty</span></a></code> 在构造时无需提供字段值。</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-8903">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Graph" data-verso-hover="311" id="Graph">Graph</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-8919">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Graph.adjacency" data-verso-hover="309" id="Graph">adjacency</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="161">Array</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8964">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Graph.empty" data-verso-hover="310" id="Graph">Graph.empty</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Graph" title="Definition of example Graph"><span class="const token" data-binding="const-Graph" data-verso-hover="311">Graph</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  结构体字段还可以通过索引以点号访问。
字段编号从 <code>1</code> 开始。</p>
                </section>
              <section>
                <h3 id="structure-constructors">
                  4.4.2.3. 结构体构造子<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=structure-constructors" title="Permalink">🔗</a></span></h3>
                <p>
                  结构体构造子可以通过在字段前加构造子名称与 <code>::</code> 显式命名。
若未显式指定名称，则构造子在结构体命名空间中名为 <code>mk</code>。
<a href="Definitions/Modifiers/#declaration-modifiers">声明修饰符</a> 也可被用于显式构造子名称前。</p>
                <details class="example"><summary class="description">非默认构造子名称</summary><div class="example-content">
                    <p>
                      结构体 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Palindrome___ofString" title="Definition of example Palindrome"><span class="const token" data-binding="const-Palindrome" data-verso-hover="312">Palindrome</span></a></code> 包含一个字符串以及显示该字符串反转与原字相等的证明：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-10509">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Palindrome" data-verso-hover="312" id="Palindrome___ofString">Palindrome</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-10530">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Palindrome.ofString" data-verso-hover="313" id="Palindrome___ofString">ofString</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Palindrome.text" data-verso-hover="314" id="Palindrome___ofString">text</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-Palindrome.is_palindrome" data-verso-hover="315" id="Palindrome___ofString">is_palindrome</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="316">text</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String.data"><span class="const token" data-binding="const-String.data" data-verso-hover="317">data</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___reverse" title="Documentation for List.reverse"><span class="const token" data-binding="const-List.reverse" data-verso-hover="184">reverse</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="316">text</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String.data"><span class="const token" data-binding="const-String.data" data-verso-hover="317">data</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      其构造子为 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Palindrome___ofString" title="Definition of example Palindrome.ofString"><span class="const token" data-binding="const-Palindrome.ofString" data-verso-hover="313">Palindrome.ofString</span></a></code>，而非 <code>Palindrome.mk</code>。</p>
                    </div>
                  </details><details class="example"><summary class="description">结构体构造子的修饰符</summary><div class="example-content">
                    <p>
                      结构体 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk" title="Definition of example NatStringBimap"><span class="const token" data-binding="const-NatStringBimap" data-verso-hover="318">NatStringBimap</span></a></code> 表示自然数与字符串之间的有限双射。
它由一对映射组成，每个映射的键在另一个映射的值中也仅出现一次。
由于构造子被声明为 private，定义模块之外的代码无法直接构造新实例，只能通过维护类型不变性的 API 构造。
同时，显式指定默认构造子名称时，可以给构造子加上 <a class="technical-term" href="Definitions/Modifiers/#--tech-term-Documentation-comments">文档注释</a>。</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-12381">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-NatStringBimap" data-verso-hover="318" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">NatStringBimap</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-12406">where</span><span class="inter-text">
  </span><span class="doc-comment token" data-binding="">/--
  在一些自然数和字符串之间构建一个有限双射
  -/</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.private-12488">private</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="319" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text">
  </span><span class="const token" data-binding="const-NatStringBimap.natToString" data-verso-hover="320" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">natToString</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap" title="Documentation for Std.HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="321">Std.HashMap</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-NatStringBimap.stringToNat" data-verso-hover="322" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">stringToNat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap" title="Documentation for Std.HashMap"><span class="const token" data-binding="const-Std.HashMap" data-verso-hover="321">Std.HashMap</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12581">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NatStringBimap.empty" data-verso-hover="323" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">NatStringBimap.empty</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk" title="Definition of example NatStringBimap"><span class="const token" data-binding="const-NatStringBimap" data-verso-hover="318">NatStringBimap</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="319">⟨</span><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="319">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="319">⟩</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12640">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NatStringBimap.insert" data-verso-hover="324" id="_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk">NatStringBimap.insert</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.725" data-verso-hover="7">nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.727" data-verso-hover="316">string</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.729" data-verso-hover="325">map</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk" title="Definition of example NatStringBimap"><span class="const token" data-binding="const-NatStringBimap" data-verso-hover="318">NatStringBimap</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk" title="Definition of example NatStringBimap"><span class="const token" data-binding="const-NatStringBimap" data-verso-hover="318">NatStringBimap</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-12760" data-verso-hover="139">if</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.729" data-verso-hover="325">map</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk" title="Definition of example NatStringBimap.natToString"><span class="const token" data-binding="const-NatStringBimap.natToString" data-verso-hover="320">natToString</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___contains" title="Documentation for Std.HashMap.contains"><span class="const token" data-binding="const-Std.HashMap.contains" data-verso-hover="326">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.725" data-verso-hover="7">nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">||</span><span class="inter-text">
      </span><span class="var token" data-binding="var-_uniq.729" data-verso-hover="325">map</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk" title="Definition of example NatStringBimap.stringToNat"><span class="const token" data-binding="const-NatStringBimap.stringToNat" data-verso-hover="322">stringToNat</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___contains" title="Documentation for Std.HashMap.contains"><span class="const token" data-binding="const-Std.HashMap.contains" data-verso-hover="326">contains</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.727" data-verso-hover="316">string</span><span class="inter-text"> </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-12760" data-verso-hover="139">then</span></a><span class="inter-text">
    </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a><span class="inter-text">
  </span><a href="Terms/Conditionals/#termIfThenElse" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-termIfThenElse-12760" data-verso-hover="139">else</span></a><span class="inter-text">
    </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk" title="Definition of example _private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk"><span class="const token" data-binding="const-_private.Manual.Language.InductiveTypes.Structures.0.NatStringBimap.mk" data-verso-hover="319">NatStringBimap.mk</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.729" data-verso-hover="325">map</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk" title="Definition of example NatStringBimap.natToString"><span class="const token" data-binding="const-NatStringBimap.natToString" data-verso-hover="320">natToString</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___insert" title="Documentation for Std.HashMap.insert"><span class="const token" data-binding="const-Std.HashMap.insert" data-verso-hover="327">insert</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.725" data-verso-hover="7">nat</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.727" data-verso-hover="316">string</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.729" data-verso-hover="325">map</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#_private___Manual___Language___InductiveTypes___Structures___0___NatStringBimap___mk" title="Definition of example NatStringBimap.stringToNat"><span class="const token" data-binding="const-NatStringBimap.stringToNat" data-verso-hover="322">stringToNat</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Maps-and-Sets/#Std___HashMap___insert" title="Documentation for Std.HashMap.insert"><span class="const token" data-binding="const-Std.HashMap.insert" data-verso-hover="327">insert</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.727" data-verso-hover="316">string</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.725" data-verso-hover="7">nat</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  由于结构体本质上就是单构造子的归纳类型，其构造子既可以直接调用或用于<a class="technical-term" href="The Type System/Inductive Types/#--tech-term-_____________________">匿名构造子语法</a>下的模式匹配,
也可以用 <span id="--tech-term-_______________-next-next-next-next" class="def-technical-term"><em>结构体实例</em></span> 记法（含有实字段名和值）进行构造或模式匹配。</p>
                <div class="namedocs" id="term-next">
                  <span class="label">syntax</span><span class="title">结构体实例</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___structInst"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.structInst"><code class="hover-info"><code class="docstring">Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be
inherited. If `e` is itself a variable called `x`, it can be elided:
`fun y =&gt; { x := 1, y }`.
A *structure update* of an existing value can be given via `with`:
`{ point with x := 1 }`.
The structure type can be specified if not inferable:
`{ x := 1, y := 2 : Point }`.
</code></code><span class="keyword">{</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFields"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span><span class="bnf">,*</span>
        <span class="from-nonterminal" data-kind="null"></span></span></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.optEllipsis"><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="bnf">)?</span> </span><span class="keyword">}</span></span></pre><p>
                      指定字段名及其值来构造一个结构体类型的值。
字段说明可有两种形式：</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___structInstField"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstField"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstLVal">structInstLVal</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFieldDef"><span class="keyword">:=</span> <span class="from-nonterminal" data-kind="null"></span><span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___structInstField-next"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstField"><span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstLVal"><span class="nonterminal" data-kind="ident">ident</span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      <code class="grammar"><span class="nonterminal" data-kind="structInstLVal">structInstLVal</span></code> 可以是字段名（标识符）、字段索引（自然数），或带中括号的项，并可接零个或多个子字段。
子字段可以是带点的字段名或索引，也可以是带中括号的项。</p>
                    <p>
                      该语法在繁释时会转换为结构体构造子的应用。
字段以名称分配，顺序不限。
子字段赋值用于初始化嵌套在字段中的结构体的字段。
在构造结构体时不允许带中括号的项，中括号用于结构体更新。</p>
                    <p>
                      不带 <code>:=</code> 的字段被认为是字段缩写。
此时，标识符 <code>f</code> 等价于 <code>f := f</code>，即作用域中的 <code>f</code> 会被用于字段赋值。</p>
                    <p>
                      所有无默认值的字段，都需要明确提供。
如果默认参数指定为 tactic，那么在繁释阶段会运行 tactic 求得参数值。</p>
                    <p>
                      在模式匹配语境下，字段名映射到能匹配相应投影的模式，字段缩写可直接绑定同名模式变量。
默认参数同样适用于模式；如果模式未指定带默认值字段的值，则模式只匹配默认值。</p>
                    <p>
                      可选类型注解允许在类型无法直接唯一确定时明确指定结构体类型。</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">模式与默认值</summary><div class="example-content">
                    <p>
                      结构体 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AugmentedIntList___list" title="Definition of example AugmentedIntList"><span class="const token" data-binding="const-AugmentedIntList" data-verso-hover="328">AugmentedIntList</span></a></code> 包含一个整数列表及一些可选额外信息（默认为空字符串）：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-17946">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-AugmentedIntList" data-verso-hover="328" id="AugmentedIntList___list">AugmentedIntList</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-17973">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-AugmentedIntList.list" data-verso-hover="329" id="AugmentedIntList___list">list</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="148">Int</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-AugmentedIntList.augmentation" data-verso-hover="330" id="AugmentedIntList___list">augmentation</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="331">""</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      在测试列表是否为空时，函数 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AugmentedIntList___isEmpty" title="Definition of example AugmentedIntList.isEmpty"><span class="const token" data-binding="const-AugmentedIntList.isEmpty" data-verso-hover="332">isEmpty</span></a></code> 还会检测字段 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AugmentedIntList___list" title="Definition of example AugmentedIntList.augmentation"><span class="const token" data-binding="const-AugmentedIntList.augmentation" data-verso-hover="330">augmentation</span></a></code> 是否为空；因为忽略字段会采用默认值，模式匹配同样如此：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18299">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-AugmentedIntList.isEmpty" data-verso-hover="332" id="AugmentedIntList___isEmpty">AugmentedIntList.isEmpty</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AugmentedIntList___list" title="Definition of example AugmentedIntList"><span class="const token" data-binding="const-AugmentedIntList" data-verso-hover="328">AugmentedIntList</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><a href="The Type System/Inductive Types/#AugmentedIntList___list" title="Definition of example AugmentedIntList.list"><span class="const token" data-binding="const-AugmentedIntList.list" data-verso-hover="333">list</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="inter-text">

</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">false</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-18397" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><a href="The Type System/Inductive Types/#AugmentedIntList___list" title="Definition of example AugmentedIntList.list"><span class="const token" data-binding="const-AugmentedIntList.list" data-verso-hover="333">list</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AugmentedIntList___list" title="Definition of example AugmentedIntList.augmentation"><span class="const token" data-binding="const-AugmentedIntList.augmentation" data-verso-hover="334">augmentation</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="335">"extra"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AugmentedIntList___list" title="Definition of example AugmentedIntList"><span class="const token" data-binding="const-AugmentedIntList" data-verso-hover="328">AugmentedIntList</span></a><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#AugmentedIntList___isEmpty" title="Definition of example AugmentedIntList.isEmpty"><span class="const token" data-binding="const-AugmentedIntList.isEmpty" data-verso-hover="332">isEmpty</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>false
</pre></div>
                    </div>
                  </details><div class="namedocs" id="term-next-next">
                  <span class="label">syntax</span><span class="title">结构体更新</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___structInst-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.structInst"><code class="hover-info"><code class="docstring">Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be
inherited. If `e` is itself a variable called `x`, it can be elided:
`fun y =&gt; { x := 1, y }`.
A *structure update* of an existing value can be given via `with`:
`{ point with x := 1 }`.
The structure type can be specified if not inferable:
`{ x := 1, y := 2 : Point }`.
</code></code><span class="keyword">{</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span> </span><span class="keyword">with</span>
        </span><span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFields"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span><span class="bnf">,*</span>
        <span class="from-nonterminal" data-kind="null"></span></span></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.optEllipsis"><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="bnf">)?</span></span><span class="keyword">}</span></span></pre><p>
                      对构造子类型的值进行更新。
<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.structInst : term</code><span class="sep"></span><code class="docstring">Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be
inherited. If `e` is itself a variable called `x`, it can be elided:
`fun y =&gt; { x := 1, y }`.
A *structure update* of an existing value can be given via `with`:
`{ point with x := 1 }`.
The structure type can be specified if not inferable:
`{ x := 1, y := 2 : Point }`.
</code></code><code class="kw">with</code></span> 子句之前的项应为结构体类型值，即待更新的原值。
新的结构体实例中，所有未指定的字段都从原始值拷贝，指定字段被覆盖为新值。
更新结构体时，也可以通过中括号带索引更新数组字段。
索引表达式不要求越界，越界更新会被忽略。</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">数组更新</summary><div class="example-content">
                    <p>
                      结构体更新可以用字段名，也可以用数组索引。
越界索引的更新会被直接忽略：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-20703">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="336" id="two______">AugmentedIntArray</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-20731">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="337" id="two______">array</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="161">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="148">Int</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-AugmentedIntArray.augmentation" data-verso-hover="338" id="two______">augmentation</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="331">""</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-null-20787">deriving</span><span class="inter-text"> </span><span class="const token" data-binding="const-Repr" data-verso-hover="67">Repr</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20802">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-one" data-verso-hover="339">one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#two______" title="Definition of example AugmentedIntArray"><span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="336">AugmentedIntArray</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><a href="The Type System/Inductive Types/#two______" title="Definition of example AugmentedIntArray.array"><span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="340">array</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">#[</span><span class="typed token" data-binding="" data-verso-hover="341">1</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20849">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-two" data-verso-hover="342">two</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#two______" title="Definition of example AugmentedIntArray"><span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="336">AugmentedIntArray</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="const token" data-binding="const-one" data-verso-hover="339">one</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-20881">with</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#two______" title="Definition of example AugmentedIntArray.array"><span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="340">array</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">#[</span><span class="typed token" data-binding="" data-verso-hover="341">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="341">2</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20908">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-two'" data-verso-hover="343" id="two______">two'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#two______" title="Definition of example AugmentedIntArray"><span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="336">AugmentedIntArray</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="const token" data-binding="const-two" data-verso-hover="342">two</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-20941">with</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#two______" title="Definition of example AugmentedIntArray.array"><span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="340">array</span></a><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="341">2</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20965">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-two''" data-verso-hover="344" id="two______">two''</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#two______" title="Definition of example AugmentedIntArray"><span class="const token" data-binding="const-AugmentedIntArray" data-verso-hover="336">AugmentedIntArray</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="const token" data-binding="const-two" data-verso-hover="342">two</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-20999">with</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#two______" title="Definition of example AugmentedIntArray.array"><span class="const token" data-binding="const-AugmentedIntArray.array" data-verso-hover="340">array</span></a><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">99</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="341">3</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">({ array := #[1], augmentation := "" },
 { array := #[1, 2], augmentation := "" },
 { array := #[2, 2], augmentation := "" },
 { array := #[1, 2], augmentation := "" })</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-21024" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-one" data-verso-hover="339">one</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-two" data-verso-hover="342">two</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#two______" title="Definition of example two'"><span class="const token" data-binding="const-two'" data-verso-hover="343">two'</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#two______" title="Definition of example two''"><span class="const token" data-binding="const-two''" data-verso-hover="344">two''</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>({ array := #[1], augmentation := "" },
 { array := #[1, 2], augmentation := "" },
 { array := #[2, 2], augmentation := "" },
 { array := #[1, 2], augmentation := "" })
</pre></div>
                    </div>
                  </details><p>
                  结构体类型的值也可以使用 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declValEqns : command</code></code><code class="kw">where</code></span>，
在定义后为每个字段赋值，只能用于定义体，不能在通用表达式中用。</p>
                <details class="example"><summary class="description">结构体中的 <code>where</code></summary><div class="example-content">
                    <p>
                      Lean 中的乘积类型是名为 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod"><span class="const token" data-binding="const-Prod" data-verso-hover="188">Prod</span></a></code> 的结构体。
可以用字段投影方式来给乘积类型赋值：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22154">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-location" data-verso-hover="345" id="location">location</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Floating-Point-Numbers/#Float-next" title="Documentation for Float"><span class="const token" data-binding="const-Float" data-verso-hover="346">Float</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><a href="Basic-Types/Floating-Point-Numbers/#Float-next" title="Documentation for Float"><span class="const token" data-binding="const-Float" data-verso-hover="346">Float</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-22184">where</span><span class="inter-text">
  </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.fst"><span class="const token" data-binding="const-Prod.fst" data-verso-hover="347">fst</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">22.807</span><span class="inter-text">
  </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.snd"><span class="const token" data-binding="const-Prod.snd" data-verso-hover="348">snd</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">13.923</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              <section>
                <h3 id="structure-inheritance">
                  4.4.2.4. 结构体继承<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=structure-inheritance" title="Permalink">🔗</a></span></h3>
                <p>
                  结构体可以通过可选的 <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.structure : command</code></code><code class="kw">extends</code></span> 子句继承其它结构体。
结果结构体类型将包含所有父结构体的全部字段。
如果父结构体字段有重名，所有同名字段必须同类型。</p>
                <p>
                  继承结果结构体有一个 <span id="--tech-term-__________________-next" class="def-technical-term"><em>字段解析顺序</em></span>，决定字段的最终取值。
一般来说，该顺序采用 <a href="https://en.wikipedia.org/wiki/C3_linearization">C3 线性化</a>。
即字段解析顺序是所有父结构体列表的一个全序排列（保留 extends 语句顺序），如果无法形成 C3 线性化，则采用启发式算法排序。
结构体自身在解析顺序中最前。</p>
                <p>
                  字段解析顺序用于计算可选字段的默认值。
如未指定字段值，则使用解析顺序中第一个定义了默认的值。
默认值中若引用了其它字段，也采用字段解析顺序；这意味着子结构体如重写了父结构体的默认字段，也可影响父结构体的默认字段的计算结果。
由于子结构体自带最高优先级，因此子结构体中的默认值优先生效于父结构体。</p>
                <p>
                  结构体继承其它结构体时，新结构体的构造子会接受父类型的信息作为附加参数。
通常每个父结构体会作为一个参数传递，其值包含父结构体的全部字段。
如果父结构体有重叠字段，则只保留不重叠的那部分，以避免字段重复。</p>
                <p>
                  父类型与子类型之间没有子类型关系。
即使结构体 <code>B</code> 继承于 <code>A</code>，期望 <code>A</code> 的函数也不会接受 <code>B</code> 类型。
但系统会自动生成转换函数，将结构体转为各自的父结构体类型。
这些转换函数称为 <span id="--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>父投影</em></span>。
父投影函数定义在子结构体的命名空间中，形式为父类型名加前缀 <code>to</code>。</p>
                <details class="example"><summary class="description">结构体类型继承与字段重叠</summary><div class="example-content">
                    <p>
                      In this example, a <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Textbook"><span class="const token" data-binding="const-Textbook" data-verso-hover="349">Textbook</span></a></code> is a <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Book"><span class="const token" data-binding="const-Book" data-verso-hover="350">Book</span></a></code> that is also an <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example AcademicWork"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="351">AcademicWork</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-29648">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Book" data-verso-hover="350" id="AcademicWork___author">Book</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-29663">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Book.title" data-verso-hover="352" id="AcademicWork___author">title</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-Book.author" data-verso-hover="353" id="AcademicWork___author">author</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-29705">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-AcademicWork" data-verso-hover="351" id="AcademicWork___author">AcademicWork</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-29728">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-AcademicWork.author" data-verso-hover="354" id="AcademicWork___author">author</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-AcademicWork.discipline" data-verso-hover="355" id="AcademicWork___author">discipline</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-29775">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Textbook" data-verso-hover="349" id="AcademicWork___author">Textbook</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-29794">extends</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Book"><span class="const token" data-binding="const-Book" data-verso-hover="350">Book</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example AcademicWork"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="351">AcademicWork</span></a><span class="inter-text">

</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Textbook.toBook (self : Textbook) : Book</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-29822">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-Textbook.toBook" data-verso-hover="356">Textbook.toBook</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      因为 <code>author</code> 字段同时出现在 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Book"><span class="const token" data-binding="const-Book" data-verso-hover="350">Book</span></a></code> 与 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example AcademicWork"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="351">AcademicWork</span></a></code>，所以 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Textbook.mk" data-verso-hover="357">Textbook.mk</span></code> 构造子只需传入一个父实例。
其签名为：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Textbook.mk" data-verso-hover="357">Textbook.mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="358">toBook</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Book"><span class="const token" data-binding="const-Book" data-verso-hover="350">Book</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="316">discipline</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Textbook"><span class="const token" data-binding="const-Textbook" data-verso-hover="349">Textbook</span></a></code><p>
                      转换函数为：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Textbook.toBook" data-verso-hover="356">Textbook.toBook</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="359">self</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Textbook"><span class="const token" data-binding="const-Textbook" data-verso-hover="349">Textbook</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Book"><span class="const token" data-binding="const-Book" data-verso-hover="350">Book</span></a></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Textbook.toAcademicWork" data-verso-hover="360">Textbook.toAcademicWork</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="359">self</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Textbook"><span class="const token" data-binding="const-Textbook" data-verso-hover="349">Textbook</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example AcademicWork"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="351">AcademicWork</span></a></code><p>
                      后一函数会将包含的 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Book"><span class="const token" data-binding="const-Book" data-verso-hover="350">Book</span></a></code> 的 <code>author</code> 字段与独立的 <code>Discipline</code> 字段组合，等价于：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-30364">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-toAcademicWork" data-verso-hover="361" id="toAcademicWork">toAcademicWork</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="359">self</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example Textbook"><span class="const token" data-binding="const-Textbook" data-verso-hover="349">Textbook</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#AcademicWork___author" title="Definition of example AcademicWork"><span class="const token" data-binding="const-AcademicWork" data-verso-hover="351">AcademicWork</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-30421" data-verso-hover="109">let</span><span class="inter-text"> </span><span class="const token" data-binding="const-Textbook.mk" data-verso-hover="357">.mk</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="358">book</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="316">discipline</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="359">self</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-30455" data-verso-hover="109">let</span><span class="inter-text"> </span><span class="const token" data-binding="const-Book.mk" data-verso-hover="362">.mk</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="316">_title</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="316">author</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="358">book</span><span class="inter-text">
  </span><span class="const token" data-binding="const-AcademicWork.mk" data-verso-hover="363">.mk</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="316">author</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="316">discipline</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><p>
                  最终结构体的投影用法上就像字段是所有父结构体字段的并集一样。
Lean 的繁释器会在使用字段时自动生成合适的投影。
同样，基于字段的初始化与结构体更新语法可以隐藏继承实现的细节。
但如果直接使用构造子名称、<a class="technical-term" href="The Type System/Inductive Types/#--tech-term-_____________________">匿名构造子语法</a>，或者按索引而非字段名称引用字段时，这些细节是可见的。</p>
                <details class="example"><summary class="description">字段索引与结构体继承</summary><div class="example-content">
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-32375">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Pair" data-verso-hover="364">Pair</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-32404">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="365">fst</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="366">snd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-null-32432">deriving</span><span class="inter-text"> </span><span class="const token" data-binding="const-Repr" data-verso-hover="67">Repr</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-32447">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Triple" data-verso-hover="367" id="coords">Triple</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1468" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-32478">extends</span><span class="inter-text"> </span><span class="const token" data-binding="const-Pair" data-verso-hover="364">Pair</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1468" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-32494">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Triple.thd" data-verso-hover="368" id="coords">thd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1468" data-verso-hover="55">α</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-null-32511">deriving</span><span class="inter-text"> </span><span class="const token" data-binding="const-Repr" data-verso-hover="67">Repr</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-32526">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-coords" data-verso-hover="369" id="coords">coords</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#coords" title="Definition of example Triple"><span class="const token" data-binding="const-Triple" data-verso-hover="367">Triple</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="370">fst</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">17</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Pair.snd" data-verso-hover="370">snd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#coords" title="Definition of example Triple.thd"><span class="const token" data-binding="const-Triple.thd" data-verso-hover="370">thd</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">95</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      对 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#coords" title="Definition of example coords"><span class="const token" data-binding="const-coords" data-verso-hover="369">coords</span></a></code> 的第一字段索引求值时，得到的是 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pair" data-verso-hover="364">Pair</span></code>，而不是字段 <code>fst</code> 的值：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">{ fst := 17, snd := 2 }</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-32725" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#coords" title="Definition of example coords"><span class="const token" data-binding="const-coords" data-verso-hover="369">coords</span></a><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>{ fst := 17, snd := 2 }
</pre></div>
                    <p>
                      繁释器会自动将 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#coords" title="Definition of example coords"><span class="const token" data-binding="const-coords" data-verso-hover="369">coords</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="365">fst</span></code> 转换为 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#coords" title="Definition of example coords"><span class="const token" data-binding="const-coords" data-verso-hover="369">coords</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Triple.toPair" data-verso-hover="371">toPair</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Pair.fst" data-verso-hover="365">fst</span></code>。</p>
                    </div>
                  </details><details class="example"><summary class="description">无结构体子类型关系</summary><div class="example-content">
                    <p>
                      如下定义偶数、偶质数和具体偶质数：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-34081">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenNumber" data-verso-hover="372" id="EvenNumber">EvenNumber</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-34102">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="373" id="EvenNumber">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-EvenNumber.isEven" data-verso-hover="374" id="EvenNumber">isEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-34141">by</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-34147" data-verso-hover="262">decide</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-34155">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenPrime" data-verso-hover="375" id="EvenNumber">EvenPrime</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-34175">extends</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example EvenNumber"><span class="const token" data-binding="const-EvenNumber" data-verso-hover="372">EvenNumber</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-34194">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-EvenPrime.notOne" data-verso-hover="376" id="EvenNumber">notOne</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.357" data-verso-hover="7">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-34221">by</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-34227" data-verso-hover="262">decide</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-EvenPrime.isPrime" data-verso-hover="377" id="EvenNumber">isPrime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.378" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.378" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.357" data-verso-hover="7">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.378" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.357" data-verso-hover="7">val</span><span class="inter-text">  </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.378" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.378" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.357" data-verso-hover="7">val</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34301">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-two" data-verso-hover="378">two</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example EvenPrime"><span class="const token" data-binding="const-EvenPrime" data-verso-hover="375">EvenPrime</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-34321">where</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example EvenNumber.val"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="370">val</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example EvenPrime.isPrime"><span class="const token" data-binding="const-EvenPrime.isPrime" data-verso-hover="379">isPrime</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-14044943974931728645-34351-34353-15"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-34351" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14044943974931728645-34351-34353-15"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1738" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">),</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1738" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="380">≤</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1738" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Dvd___mk" title="Documentation for Dvd.dvd"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="381">∣</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1738" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or"><span class="const token" data-binding="const-Or" data-verso-hover="382">∨</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1738" data-verso-hover="7">n</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
    </span><span class="tactic"><label for="tactic-state-16325844559081887618-34358-34364-17"><a href="Tactic-Proofs/Tactic-Reference/#intros" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intros-34358" data-verso-hover="383">intros</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16325844559081887618-34358-34364-17"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.900" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"></span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.901" data-verso-hover="384">a✝¹</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.900" data-verso-hover="7">n✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#LE___mk" title="Documentation for LE.le"><span class="const token" data-binding="const-LE.le" data-verso-hover="380">≤</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.902" data-verso-hover="385">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.900" data-verso-hover="7">n✝</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Dvd___mk" title="Documentation for Dvd.dvd"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="381">∣</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="var token" data-binding="var-_uniq.900" data-verso-hover="7">n✝</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or"><span class="const token" data-binding="const-Or" data-verso-hover="382">∨</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.900" data-verso-hover="7">n✝</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span><span class="inter-text">
    </span><a href="Tactic-Proofs/The-Tactic-Language/#repeat___" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.repeat'-34369" data-verso-hover="386">repeat'</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-649179006703016080-34378-34400-19"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-34378" data-verso-hover="387">cases</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">‹</span><span class="unknown token" data-binding="">Nat.le</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">›</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-649179006703016080-34378-34400-19"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-20" checked="checked"><span for="--verso-unique-20" class="goal-name">step.step.refl.refl</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1367" data-verso-hover="388">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Type-Classes/Basic-Classes/#Dvd___mk" title="Documentation for Dvd.dvd"><span class="const token" data-binding="const-Dvd.dvd" data-verso-hover="381">∣</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or"><span class="const token" data-binding="const-Or" data-verso-hover="382">∨</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span></span></span></span></span></span></span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><a href="Tactic-Proofs/The-Tactic-Language/#all_goals" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.allGoals-34406" data-verso-hover="389">all_goals</span></a><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-34416-34421-21"><a href="Tactic-Proofs/Tactic-Reference/#omega" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-34416" data-verso-hover="390">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-34416-34421-21"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34423">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-printEven" data-verso-hover="391" id="EvenNumber">printEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1738" data-verso-hover="392">num</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example EvenNumber"><span class="const token" data-binding="const-EvenNumber" data-verso-hover="372">EvenNumber</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="IO/Logical-Model/#IO" title="Documentation for IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit" title="Documentation for Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="IO/Console-Output/#IO___print" title="Documentation for IO.print"><span class="const token" data-binding="const-IO.print" data-verso-hover="393">IO.print</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1738" data-verso-hover="392">num</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example EvenNumber.val"><span class="const token" data-binding="const-EvenNumber.val" data-verso-hover="373">val</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      直接将 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example printEven"><span class="const token" data-binding="const-printEven" data-verso-hover="391">printEven</span></a></code> 应用于 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-two" data-verso-hover="378">two</span></code> 会产生类型错误：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">printEven sorry : IO Unit</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-34610">#check</span></a></span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example printEven"><span class="const token" data-binding="const-printEven" data-verso-hover="391">printEven</span></a><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Application type mismatch: In the application
  printEven two
the argument
  two
has type
  EvenPrime : Type
but is expected to have type
  EvenNumber : Type</code></span></span><span class="const token" data-binding="const-two" data-verso-hover="378">two</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>Application type mismatch: In the application
  printEven two
the argument
  two
has type
  EvenPrime : Type
but is expected to have type
  EvenNumber : Type
</pre></div>
                    <p>
                      因为 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example EvenPrime"><span class="const token" data-binding="const-EvenPrime" data-verso-hover="375">EvenPrime</span></a></code> 类型的值并非 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#EvenNumber" title="Definition of example EvenNumber"><span class="const token" data-binding="const-EvenNumber" data-verso-hover="372">EvenNumber</span></a></code> 类型值。</p>
                    </div>
                  </details><p>
                  <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.print : command</code></code><code class="kw">#print</code></span> 命令能展示所有结构体类型的重要信息，包括 <a class="technical-term" href="The Type System/Inductive Types/#--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">父投影</a>、所有字段（含默认值）、构造子及 <a class="technical-term" href="The Type System/Inductive Types/#--tech-term-__________________-next">字段解析顺序</a>。
对于包含复杂继承菱形的层次结构而言，这些信息非常有用。</p>
                <details class="example"><summary class="description"><code class="plain-keyword">#print</code> 与结构体类型</summary><div class="example-content">
                    <p>
                      以下是关于自行车的结构体抽象，涵盖电动/非电动、大型/普通家庭自行车。
最后一种结构体 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example ElectricFamilyBike"><span class="const token" data-binding="const-ElectricFamilyBike" data-verso-hover="394">ElectricFamilyBike</span></a></code> 形成了继承图中的“菱形”，因为 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example FamilyBike"><span class="const token" data-binding="const-FamilyBike" data-verso-hover="395">FamilyBike</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example ElectricBike"><span class="const token" data-binding="const-ElectricBike" data-verso-hover="396">ElectricBike</span></a></code> 都继承自 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example Bicycle"><span class="const token" data-binding="const-Bicycle" data-verso-hover="397">Bicycle</span></a></code>。</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-38884">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vehicle" data-verso-hover="398" id="ElectricVehicle">Vehicle</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-38902">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Vehicle.wheels" data-verso-hover="399" id="ElectricVehicle">wheels</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-38924">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bicycle" data-verso-hover="397" id="ElectricVehicle">Bicycle</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-38942">extends</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example Vehicle"><span class="const token" data-binding="const-Vehicle" data-verso-hover="398">Vehicle</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-38958">where</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example Vehicle.wheels"><span class="const token" data-binding="const-Vehicle.wheels" data-verso-hover="399">wheels</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-38979">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-ElectricVehicle" data-verso-hover="400" id="ElectricVehicle">ElectricVehicle</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-39005">extends</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example Vehicle"><span class="const token" data-binding="const-Vehicle" data-verso-hover="398">Vehicle</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-39021">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-ElectricVehicle.batteries" data-verso-hover="401" id="ElectricVehicle">batteries</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-39051">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-FamilyBike" data-verso-hover="395" id="ElectricVehicle">FamilyBike</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-39072">extends</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example Bicycle"><span class="const token" data-binding="const-Bicycle" data-verso-hover="397">Bicycle</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-39088">where</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example Vehicle.wheels"><span class="const token" data-binding="const-Vehicle.wheels" data-verso-hover="399">wheels</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-39109">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-ElectricBike" data-verso-hover="396" id="ElectricVehicle">ElectricBike</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-39132">extends</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example Bicycle"><span class="const token" data-binding="const-Bicycle" data-verso-hover="397">Bicycle</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example ElectricVehicle"><span class="const token" data-binding="const-ElectricVehicle" data-verso-hover="400">ElectricVehicle</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-39166">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-ElectricFamilyBike" data-verso-hover="394" id="ElectricVehicle">ElectricFamilyBike</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.extends-39199">extends</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example FamilyBike"><span class="const token" data-binding="const-FamilyBike" data-verso-hover="395">FamilyBike</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example ElectricBike"><span class="const token" data-binding="const-ElectricBike" data-verso-hover="396">ElectricBike</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-39232">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-ElectricBike.batteries" data-verso-hover="402">batteries</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.print : command</code></code><code class="kw">#print</code></span> 可以显示各结构体类型的重要信息：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">structure ElectricBike : Type
number of parameters: 0
parents:
  ElectricBike.toBicycle : Bicycle
  ElectricBike.toElectricVehicle : ElectricVehicle
fields:
  Vehicle.wheels : Nat :=
    2
  ElectricVehicle.batteries : Nat :=
    1
constructor:
  ElectricBike.mk (toBicycle : Bicycle) (batteries : Nat) : ElectricBike
field notation resolution order:
  ElectricBike, Bicycle, ElectricVehicle, Vehicle</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-39376">#print</span></span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example ElectricBike"><span class="const token" data-binding="const-ElectricBike" data-verso-hover="396">ElectricBike</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>structure ElectricBike : Type
number of parameters: 0
parents:
  ElectricBike.toBicycle : Bicycle
  ElectricBike.toElectricVehicle : ElectricVehicle
fields:
  Vehicle.wheels : Nat :=
    2
  ElectricVehicle.batteries : Nat :=
    1
constructor:
  ElectricBike.mk (toBicycle : Bicycle) (batteries : Nat) : ElectricBike
field notation resolution order:
  ElectricBike, Bicycle, ElectricVehicle, Vehicle
</pre></div>
                    <p>
                      默认情况下，<code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example ElectricFamilyBike"><span class="const token" data-binding="const-ElectricFamilyBike" data-verso-hover="394">ElectricFamilyBike</span></a></code> 有三轮，因为在解析顺序中 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example FamilyBike"><span class="const token" data-binding="const-FamilyBike" data-verso-hover="395">FamilyBike</span></a></code> 优先于</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">structure ElectricFamilyBike : Type
number of parameters: 0
parents:
  ElectricFamilyBike.toFamilyBike : FamilyBike
  ElectricFamilyBike.toElectricBike : ElectricBike
fields:
  Vehicle.wheels : Nat :=
    3
  ElectricVehicle.batteries : Nat :=
    2
constructor:
  ElectricFamilyBike.mk (toFamilyBike : FamilyBike) (batteries : Nat) : ElectricFamilyBike
field notation resolution order:
  ElectricFamilyBike, FamilyBike, ElectricBike, Bicycle, ElectricVehicle, Vehicle</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-39959">#print</span></span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ElectricVehicle" title="Definition of example ElectricFamilyBike"><span class="const token" data-binding="const-ElectricFamilyBike" data-verso-hover="394">ElectricFamilyBike</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>structure ElectricFamilyBike : Type
number of parameters: 0
parents:
  ElectricFamilyBike.toFamilyBike : FamilyBike
  ElectricFamilyBike.toElectricBike : ElectricBike
fields:
  Vehicle.wheels : Nat :=
    3
  ElectricVehicle.batteries : Nat :=
    2
constructor:
  ElectricFamilyBike.mk (toFamilyBike : FamilyBike) (batteries : Nat) : ElectricFamilyBike
field notation resolution order:
  ElectricFamilyBike, FamilyBike, ElectricBike, Bicycle, ElectricVehicle, Vehicle
</pre></div>
                    </div>
                  </details></section>
              </section>
            <section>
              <h2 id="inductive-types-logical-model">
                4.4.3. 逻辑模型<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-types-logical-model" title="Permalink">🔗</a></span></h2>
              <section>
                <h3 id="recursors">
                  4.4.3.1. 递归子<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=recursors" title="Permalink">🔗</a></span></h3>
                <p>
                  每一个归纳类型都拥有一个<a class="technical-term" href="The Type System/Inductive Types/#--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next">递归子</a>。
递归子的定义完全由类型构造子和数据构造子的类型签名所决定。
递归子的类型是函数类型，但它们是原语级别的，不能用 <code>fun</code> 来定义。</p>
                <section>
                  <h4 id="recursor-types">
                    4.4.3.1.1. 递归子类型<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=recursor-types" title="Permalink">🔗</a></span></h4>
                  <div class="paragraph">
                    <p>
                      递归子接收以下参数：</p>
                    <dl><dt> 归纳类型的<a class="technical-term" href="The Type System/Inductive Types/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next">参数</a></dt><dd><p>
                          由于参数是一致的，所以它们可以对整个递归子抽象</p>
                        </dd><dt> <span id="--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>动机</em></span>(motive)</dt><dd><p>
                          动机决定了递归子的应用结果的类型。动机是一个函数，其参数是类型的指标及其具体实例。动机决定的类型所处的具体宇宙由归纳类型的宇宙层级和具体的数据构造子决定——详见<a href="The Type System/Inductive Types/#subsingleton-elimination"><a class="technical-term" href="The Type System/Inductive Types/#--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">子单元</a> 消去</a>部分。</p>
                        </dd><dt> 每个构造子的<span id="--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>次要前提</em></span>(minor premise)</dt><dd><p>
                          对于每个构造子，递归子都需要一个函数来满足动机，针对构造子的任意应用。
  每个次要前提都对该构造子的所有参数抽象。
  如果构造子的某个参数类型是归纳类型本身，那么该前提还要接收一个类型为 对应动机应用到这个参数值 上的参数——这个参数会接收到递归处理该递归参数的结果。</p>
                        </dd><dt> <span id="--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>主要前提</em></span>，或称 目标</dt><dd><p>
                          最后，递归子接收一个该类型的实例作为参数，以及所有指标的值。</p>
                        </dd></dl><p>
                      递归子的结果类型，是动机应用于这些指标值和目标的返回值。</p>
                    </div>
                  <details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a></code> 的递归子</summary><div class="example-content">
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a></code> 的递归子 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool.rec" data-verso-hover="403">Bool.rec</span></code> 有如下参数：</p>
                      <ul>
                        <li>
                          <p>
                            动机给定一个 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a></code>，可计算出所属任何宇宙中的类型。</p>
                          </li>
                        <li>
                          <p>
                            两个构造子都有对应的分支，在这两种情况下，动机分别对 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> 成立。</p>
                          </li>
                        <li>
                          <p>
                            目标是某个 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a></code>。</p>
                          </li>
                        </ul>
                      <p>
                        返回类型是动机应用到目标后的结果。</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Bool.rec" data-verso-hover="403">Bool.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="404">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="405">false</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="404">motive</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="406">true</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="404">motive</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="156">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="404">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="156">t</span></code></div>
                    </details><details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a></code> 的递归子</summary><div class="example-content">
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a></code> 的递归子 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.rec" data-verso-hover="407">List.rec</span></code> 有如下参数：</p>
                      <ul>
                        <li>
                          <p>
                            参数 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-α" data-verso-hover="278">α</span></code> 在最前，因为参数以及分支都需要引用它</p>
                          </li>
                        <li>
                          <p>
                            动机在给定一个 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-α" data-verso-hover="278">α</span></code> 时，计算出所属任何宇宙中的类型。这里宇宙层级 <code>u</code> 和 <code>v</code> 没有联系。</p>
                          </li>
                        <li>
                          <p>
                            两个构造子的分支：</p>
                          <ul>
                            <li>
                              <p>
                                动机对 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="408">List.nil</span></a></code> 成立</p>
                              </li>
                            <li>
                              <p>
                                对于 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">List.cons</span></a></code>，只要对尾部成立，同样也应成立。额外的参数 <code>motive tail</code> 是因为 <code>tail</code> 类型是一次递归出现的 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a></code>。</p>
                              </li>
                            </ul>
                          </li>
                        <li>
                          <p>
                            目标是某个 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-α" data-verso-hover="278">α</span></code>。</p>
                          </li>
                        </ul>
                      <p>
                        同样，返回类型是动机应用于目标的结果。</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-List.rec" data-verso-hover="407">List.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="410">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="411">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="410">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="412">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="45">head</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="51">tail</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="410">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="51">tail</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="410">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="45">head</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="51">tail</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="51">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="410">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="51">t</span></code></div>
                    </details><details class="example"><summary class="description">带参数和指标的递归子</summary><div class="example-content">
                      <p>
                        已知 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span></code> 的定义如下：</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-8379" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-8433">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="280">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="281">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="156">isEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Booleans/#Bool___not" title="Documentation for Bool.not"><span class="const token" data-binding="const-Bool.not" data-verso-hover="282">not</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="156">isEven</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList.rec" data-verso-hover="413">EvenOddList.rec</span></code> 的递归子和 <code>List</code> 类似。
不同之处在于多了一个索引：</p>
                      <ul>
                        <li>
                          <p>
                            动机现在对任意的索引抽象。</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="280">nil</span></code> 的分支将动机应用在该构造子的索引值 <code>true</code> 上。</p>
                          </li>
                        <li>
                          <p>
                            <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="281">cons</span></code> 分支对其递归出现时使用的索引值抽象，并用指标取反的结果实例化动机。</p>
                          </li>
                        <li>
                          <p>
                            目标同样对任意索引抽象。</p>
                          </li>
                        </ul>
                      <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList.rec" data-verso-hover="413">EvenOddList.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="414">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="156">isEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="156">isEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="415">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="414">motive</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList.nil" data-verso-hover="280">EvenOddList.nil</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34" data-verso-hover="416">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="156">isEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="45">head</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="417">tail</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="156">isEven</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="414">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="156">isEven</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="417">tail</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="414">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">!</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="156">isEven</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-EvenOddList.cons" data-verso-hover="281">EvenOddList.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="45">head</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="417">tail</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="156">isEven</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.41" data-verso-hover="417">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="246">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="156">isEven</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="414">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="156">isEven</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.41" data-verso-hover="417">t</span></code></div>
                    </details><p>
                    当动机是一个返回 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code> 的谓词时，递归子就表现为归纳法。
非递归构造子的分支是归纳的基本样例，而递归构造子所额外提供的参数就是归纳假设。</p>
                  <section>
                    <h5 id="subsingleton-elimination">
                      4.4.3.1.1.1. 子单元消去<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=subsingleton-elimination" title="Permalink">🔗</a></span></h5>
                    <p>
                      Lean 中的证明是计算无关的。
换句话说，在给定了<strong>某个</strong>命题的证明之后，程序应该无法检测到<strong>到底是哪一个</strong>证明被接受了。
这种思想体现在归纳定义的命题或谓词的递归子的类型中。
对于这些类型，如果定理存在多种可能的证明方式，那么 motive 只能返回另一个 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code>。
如果类型的结构保证了至多只存在一个证明，那么 motive 可以返回任意宇宙中的类型。
拥有至多一个元素的命题被称为 <span id="--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>子单元</em></span>。
Lean 并不会强制用户去<strong>证明</strong>某命题只有唯一的证明，而是采用了一种保守的语法近似方法来检测一个命题是否为子单元。
满足以下两个条件的命题会被视为子单元（subsingleton）：</p>
                    <ul>
                      <li>
                        <p>
                          至多只有一个构造子。</p>
                        </li>
                      <li>
                        <p>
                          每个构造子的参数类型要么是 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code>，要么是参数或者索引。</p>
                        </li>
                      </ul>
                    <details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="263">True</span></a></code> 是子单元</summary><div class="example-content">
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="263">True</span></a></code> 是子单元，因为它仅有一个无参数的构造子。
它的递归子类型如下：</p>
                        <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-True.rec" data-verso-hover="418">True.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="419">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="263">True</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="420">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="419">motive</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True.intro"><span class="const token" data-binding="const-True.intro" data-verso-hover="421">True.intro</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="422">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="263">True</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="419">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="422">t</span></code></div>
                      </details><details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code> 是子单元</summary><div class="example-content">
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code> 是子单元，因为它没有构造子。
它的递归子类型如下：</p>
                        <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-False.rec" data-verso-hover="423">False.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="424">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="425">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="424">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="425">t</span></code><p>
                          注意动机是一个显式参数。
因为它在后续参数类型中没有出现，因此不能自动推断它。</p>
                        </div>
                      </details><details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And"><span class="const token" data-binding="const-And" data-verso-hover="115">And</span></a></code> 是子单元</summary><div class="example-content">
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And"><span class="const token" data-binding="const-And" data-verso-hover="115">And</span></a></code> 是子单元，因为它仅有一个构造子，并且这个构造子的两个参数类型都是命题。
它的递归子类型如下：</p>
                        <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-And.rec" data-verso-hover="426">And.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="200">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="200">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="427">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="200">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="200">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="428">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="429">left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="200">a</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="430">right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="200">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="427">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro"><span class="const token" data-binding="const-And.intro" data-verso-hover="431">And.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="429">left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="430">right</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="432">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="200">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="200">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="427">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="432">t</span></code></div>
                      </details><details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or"><span class="const token" data-binding="const-Or" data-verso-hover="382">Or</span></a></code> 不是子单元</summary><div class="example-content">
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or"><span class="const token" data-binding="const-Or" data-verso-hover="382">Or</span></a></code> 不是子单元，因为它有多个构造子。
它的递归子类型如下：</p>
                        <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Or.rec" data-verso-hover="433">Or.rec</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="200">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="200">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="434">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="200">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="200">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="435">inl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="429">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="200">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="434">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inl"><span class="const token" data-binding="const-Or.inl" data-verso-hover="436">.inl</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="429">h</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="437">inr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="430">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="200">b</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="434">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inr"><span class="const token" data-binding="const-Or.inr" data-verso-hover="438">.inr</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="430">h</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="439">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="200">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="200">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="434">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="439">t</span></code><p>
                          动机的类型表明 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.rec" data-verso-hover="433">Or.rec</span></code> 只能用于产生证明。
对析取命题提供的证明也能用来证明其它命题，但程序无法判别具体是哪个分支为真。</p>
                        </div>
                      </details><details class="example"><summary class="description"><code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">Eq</span></a></code> 是子单元</summary><div class="example-content">
                        <p>
                          <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">Eq</span></a></code> 是子单元，因为它只有一个构造子 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq.refl"><span class="const token" data-binding="const-Eq.refl" data-verso-hover="440">Eq.refl</span></a></code>。
构造子会用参数值实例化 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">Eq</span></a></code> 的索引，因此所有参数都是参数项：</p>
                        <code class="hl lean block" data-lean-context="examples"><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq.refl"><span class="const token" data-binding="const-Eq.refl" data-verso-hover="440">Eq.refl</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="170">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="170">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">Eq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span></code><p>
                          它的递归子类型如下：</p>
                        <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Eq.rec" data-verso-hover="441">Eq.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="179">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="179">α</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="442">motive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="45">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="179">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="45">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="443">refl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="442">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq.refl"><span class="const token" data-binding="const-Eq.refl" data-verso-hover="440">.refl</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="45">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="179">α</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="444">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="45">y</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="442">motive</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="45">y</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="444">t</span></code><p>
                          意味着等式证明可以用来重写非命题类型的类型。</p>
                        </div>
                      </details></section>
                  </section>
                <section>
                  <h4 id="iota-reduction">
                    4.4.3.1.2. 规约<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=iota-reduction" title="Permalink">🔗</a></span></h4>
                  <p>
                    归纳类型声明除了为逻辑添加新常量外，还会引入新的规约规则。
这些规则负责处理递归子和数据构造子之间的互动，尤其是以构造子为目标的递归子的简化行为。
这种规约形式称为 <span id="--tech-term-___-______-next-next-next-next-next" class="def-technical-term"><em>ι-规约</em></span>（iota reduction）<span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span><span id="--index--next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"></span>。</p>
                  <p>
                    当递归子的目标是没有递归参数的构造子时，递归子应用会规约为将该构造子的分支作用于其参数的结果。
如果有递归参数，则这些传递给分支的参数是通过将递归子递归应用于递归出现的参数获得。</p>
                  </section>
                </section>
              <section>
                <h3 id="well-formed-inductives">
                  4.4.3.2. 良构性约束<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=well-formed-inductives" title="Permalink">🔗</a></span></h3>
                <p>
                  归纳类型声明需要满足一系列良构性约束。
这些约束确保当逻辑扩展进入新的归纳类型规则时，Lean 的逻辑系统依然保持一致。
这些约束是保守的：一些不会破坏一致性的归纳类型会被这些约束拒绝。</p>
                <section>
                  <h4 id="inductive-type-universe-levels">
                    4.4.3.2.1. 宇宙层级<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-type-universe-levels" title="Permalink">🔗</a></span></h4>
                  <p>
                    归纳类型的类型构造子必须处于某个<a class="technical-term" href="The Type System/Universe/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next">宇宙</a>中，或是返回类型为宇宙的函数类型。
每个数据构造子的类型必须是返回饱和应用归纳类型的函数类型。
如果归纳类型的宇宙是 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code>，则对宇宙没有进一步的限制，因为 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code> 是<a class="technical-term" href="The Type System/Universe/#--tech-term-_______________-next-next">非直谓的</a>。
如果宇宙不是 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code>，那么以下要求必须成立，对每一个数据构造子的参数都适用：</p>
                  <ul>
                    <li>
                      <p>
                        若构造子的参数是归纳类型的参数（即参数 vs 索引），则该参数类型不能超过类型构造子的宇宙层级。</p>
                      </li>
                    <li>
                      <p>
                        其它所有构造子参数的类型都必须严格小于类型构造子的宇宙层级。</p>
                      </li>
                    </ul>
                  <details class="example"><summary class="description">宇宙、构造子和参数</summary><div class="example-content">
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Either" data-verso-hover="283">Either</span></code> 处于其两个参数宇宙层级的最大值，因为两个参数都是归纳类型的参数：</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-21133" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either" data-verso-hover="283">Either</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="level-op token" data-binding="level-op-max" data-verso-hover="284">max</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-21195">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either.inl" data-verso-hover="445" id="Either___inl">inl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either" data-verso-hover="283">Either</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either.inr" data-verso-hover="446" id="Either___inl">inr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Either" data-verso-hover="283">Either</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#CanRepr" title="Definition of example CanRepr"><span class="const token" data-binding="const-CanRepr" data-verso-hover="447">CanRepr</span></a></code> 的宇宙层级比构造子参数 <code>α</code> 要更高，因为 <code>α</code> 不是归纳类型的参数：</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-21384" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-CanRepr" data-verso-hover="447" id="CanRepr">CanRepr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="level-op token" data-binding="level-op-+">+</span><span class="inter-text"> </span><span class="level-const token" data-binding="level-const-1" data-verso-hover="209">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-21417">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-CanRepr.mk" data-verso-hover="448" id="CanRepr">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Repr" data-verso-hover="67">Repr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#CanRepr" title="Definition of example CanRepr"><span class="const token" data-binding="const-CanRepr" data-verso-hover="447">CanRepr</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                        无构造子的归纳类型的宇宙可以比参数的宇宙更小：</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-21555" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Spurious" data-verso-hover="449" id="Spurious">Spurious</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="212">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-const token" data-binding="level-const-5" data-verso-hover="206">5</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-const token" data-binding="level-const-0" data-verso-hover="205">0</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-21597">where</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                        但对 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Spurious" title="Definition of example Spurious"><span class="const token" data-binding="const-Spurious" data-verso-hover="449">Spurious</span></a></code> 若要添加构造子，其宇宙层级也必须做相应改变。</p>
                      </div>
                    </details></section>
                <section>
                  <h4 id="strict-positivity">
                    4.4.3.2.2. 严格正性<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=strict-positivity" title="Permalink">🔗</a></span></h4>
                  <p>
                    所有定义中的类型在构造子参数类型中的出现都必须处于<span id="--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>严格正性</em></span>的位置。
如果一个类型不处于函数的参数类型里（无论嵌套了多少层函数类型），也不作为任何表达式（除归纳类型的类型构造子外）的参数，那它就是严格正性的位置。
该限制用来排除不安全的归纳类型定义，虽有可能因此排除掉某些良构类型。</p>
                  <details class="example"><summary class="description">非严格正性的归纳类型</summary><div class="example-content">
                      <p>
                        类型 <code>Bad</code> 若能通过编译会导致 Lean 不一致：</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #1 of 'Bad.bad' has a non positive occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-24381" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bad" data-verso-hover="450">Bad</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-24395">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">bad</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Bad" data-verso-hover="450">Bad</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bad" data-verso-hover="450">Bad</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bad" data-verso-hover="450">Bad</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                        <pre>(kernel) arg #1 of 'Bad.bad' has a non positive occurrence of the datatypes being declared
</pre></div>
                      <p>
                        之所以这样，是因为如果假定 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bad" data-verso-hover="451">Bad</span></code> 成立，则可以构造出环状逻辑从而证明 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code>。
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bad.bad" data-verso-hover="452">Bad.bad</span></code> 会被拒绝，是因为构造子的参数类型是 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bad" data-verso-hover="451">Bad</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bad" data-verso-hover="451">Bad</span></code>，也就是 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bad" data-verso-hover="451">Bad</span></code> 作为函数参数出现。</p>
                      <p>
                        以下这个不动点算子类型的定义也会被拒绝，因为 <code>Fix</code> 在 <code>f</code> 的参数中出现：</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #2 of 'Fix.fix' contains a non valid occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-25067" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Fix" data-verso-hover="453" id="Fix">Fix</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="454">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-25105">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">fix</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="454">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#Fix" title="Definition of example Fix"><span class="const token" data-binding="const-Fix" data-verso-hover="453">Fix</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="454">f</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Fix" title="Definition of example Fix"><span class="const token" data-binding="const-Fix" data-verso-hover="453">Fix</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="454">f</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                        <pre>(kernel) arg #2 of 'Fix.fix' contains a non valid occurrence of the datatypes being declared
</pre></div>
                      <p>
                        <code>Fix.fix</code> 会被拒绝，因为 <code>f</code> 并不是某个归纳类型的类型构造子，而 <code>Fix</code> 在这里作为它的参数出现。
实际上，用 <code>Fix</code> 完全可以构造出等价于 <code>Bad</code> 的类型：</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25541">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bad" data-verso-hover="451">Bad</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Fix" title="Definition of example Fix"><span class="const token" data-binding="const-Fix" data-verso-hover="455">Fix</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-25563">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="164">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="164">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="164">t</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                    </details></section>
                <section>
                  <h4 id="prop-vs-type">
                    4.4.3.2.3. Prop vs Type<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=prop-vs-type" title="Permalink">🔗</a></span></h4>
                  <p>
                    Lean 会拒绝那些实际上无法多态使用的宇宙多态类型。
例如，如果对宇宙参数的部分实例化会导致类型变成 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code>，而该类型又不是<a class="technical-term" href="The Type System/Inductive Types/#--tech-term-_________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">子单元</a>，则其递归子只允许针对命题（即<a class="technical-term" href="The Type System/Inductive Types/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next-next-next">动机</a>只能返回 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code>）。
这些类型实际上只适合充当 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code> 本身，所以宇宙多态很可能本就是错误。
由于这种类型几乎无实际意义，Lean 的归纳类型<a class="technical-term" href="Notations-and-Macros/Elaborators/#--tech-term-elaborators">繁释器</a>并未设计为支持它们。</p>
                  <p>
                    如果这种宇宙多态归纳类型本身是子单元，则这样的定义还是有意义的。
Lean 的标准库定义了 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Unit-Type/#PUnit___unit" title="Documentation for PUnit"><span class="const token" data-binding="const-PUnit" data-verso-hover="147">PUnit</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Empty-Type/#PEmpty" title="Documentation for PEmpty"><span class="const token" data-binding="const-PEmpty" data-verso-hover="456">PEmpty</span></a></code>。
若要定义既可属于 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code> 也可属于 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span></code> 的子单元类型，可将选项 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#bootstrap___inductiveCheckResultingUniverse" title="Documentation for option bootstrap.inductiveCheckResultingUniverse"><span class="option token" data-binding="option-bootstrap.inductiveCheckResultingUniverse" data-verso-hover="457">bootstrap.inductiveCheckResultingUniverse</span></a></code> 设为 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code>。</p>
                  <div class="namedocs" id="bootstrap___inductiveCheckResultingUniverse">
                    <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc.option&amp;name=bootstrap.inductiveCheckResultingUniverse" title="Permalink">🔗</a></span><span class="label">option</span><pre class="signature hl lean block">bootstrap.inductiveCheckResultingUniverse</pre><div class="text">
                      <p>
                        Default value: <code class="hl lean inline"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code></p>
                      <p>
                        by default the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Parser.Command.inductive" data-verso-hover="458">inductive</span></code>/<code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Lean.Parser.Command.structure" data-verso-hover="459">structure</span></code> commands report an error if the resulting universe is not zero, but may be zero for some universe parameters. Reason: unless this type is a subsingleton, it is hardly what the user wants since it can only eliminate into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code>. In the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Init</span></code> package, we define subsingletons, and we use this option to disable the check. This option may be deleted in the future after we improve the validator</p>
                      </div>
                    </div>
                  <details class="example"><summary class="description">过度使用宇宙多态的 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a></code></summary><div class="example-content">
                      <p>
                        定义一个可以处于任意宇宙的 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a></code> 是不被允许的：</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-28297" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-PBool" data-verso-hover="460" id="PBool">PBool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid universe polymorphic resulting type, the resulting universe is not 'Prop', but it may be 'Prop' for some parameter values:
  Sort u
Possible solution: use levels of the form 'max 1 _' or '_ + 1' to ensure the universe is of the form 'Type _'.</code></span></span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-28322">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">true</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">false</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                        <pre>invalid universe polymorphic resulting type, the resulting universe is not 'Prop', but it may be 'Prop' for some parameter values:
  Sort u
Possible solution: use levels of the form 'max 1 _' or '_ + 1' to ensure the universe is of the form 'Type _'.
</pre></div>
                      </div>
                    </details></section>
                </section>
              <section>
                <h3 id="recursor-elaboration-helpers">
                  4.4.3.3. 用于终止性检查的构造<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=recursor-elaboration-helpers" title="Permalink">🔗</a></span></h3>
                <p>
                  除了 Lean 核心类型理论为归纳类型规定的类型构造子、数据构造子和递归子外，Lean 还自动生成许多实用的辅助构造。
首先，方程编译器（用于将带模式匹配的递归函数翻译为递归子应用）会用到这些额外构造：</p>
                <ul>
                  <li>
                    <p>
                      <code>recOn</code> 是递归子的一个变体，其目标参数排在每个构造子的分支参数之前。</p>
                    </li>
                  <li>
                    <p>
                      <code>casesOn</code> 也是一个变体，其目标参数也在分支之前，且递归参数不会产生归纳假设。它表达的是分情况分析而非原始递归。</p>
                    </li>
                  <li>
                    <p>
                      <code>below</code> 生成一个类型，表达针对某动机，目标所有子树的所有归纳类型元素都满足该动机。它能把归纳/原始递归用的动机变成强递归/强归纳的动机。</p>
                    </li>
                  <li>
                    <p>
                      <code>brecOn</code> 是使用 <code>below</code> 以可以访问所有子树（而不仅是直接递归参数）的递归子变体，表达强归纳。</p>
                    </li>
                  <li>
                    <p>
                      <code>noConfusion</code> 是一个通用语句，可据此推出构造子的单射性和互斥性。</p>
                    </li>
                  <li>
                    <p>
                      <code>noConfusionType</code> 是为 <code>noConfusion</code> 设计的动机，用以描述两个构造子相等时的推论。对不同构造子而言这是 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a></code>；相同构造子则为各自参数的等式。</p>
                    </li>
                  </ul>
                <p>
                  对于<a class="technical-term" href="Definitions/Recursive-Definitions/#--tech-term-well-founded-recursion">良构递归</a>，通常还需要一个通用意义上的“大小”概念。
这正是 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#SizeOf___mk" title="Documentation for SizeOf"><span class="const token" data-binding="const-SizeOf" data-verso-hover="461">SizeOf</span></a></code> 类型类所提供的。</p>
                <div class="namedocs" id="SizeOf___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=SizeOf" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">SizeOf.{u}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7740" data-verso-hover="170">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort (max 1 u)</span></div><div class="narrow-only"><span class="unknown token" data-binding="">SizeOf.{u}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7740" data-verso-hover="170">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort (max 1 u)</span></div></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="The Type System/Inductive Types/#SizeOf___mk" title="Documentation for SizeOf"><span class="const token" data-binding="const-SizeOf" data-verso-hover="461">SizeOf</span></a></code> is a typeclass automatically derived for every inductive type,
which equips the type with a "size" function to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>.
The default instance defines each constructor to be <code class="hl lean inline" data-lean-context="docstring-examples"><span class="typed token" data-binding="" data-verso-hover="7">1</span></code> plus the sum of the
sizes of all the constructor fields.</p>
                    <p>
                      This is used for proofs by well-founded induction, since every field of the
constructor has a smaller size than the constructor itself,
and in many cases this will suffice to do the proof that a recursive function
is only called on smaller values.
If the default proof strategy fails, it is recommended to supply a custom
size measure using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">termination_by</span></code> argument on the function definition.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="The Type System/Inductive Types/#SizeOf___mk" title="Documentation for SizeOf.mk"><span class="const token" data-binding="const-SizeOf.mk" data-verso-hover="462">SizeOf.mk</span></a><span class="unknown token" data-binding="">.{u}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-SizeOf.sizeOf" data-verso-hover="463">sizeOf</span> : <span class="var token" data-binding="var-_uniq.7734" data-verso-hover="170">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></pre><div class="docs">
                        <p>
                          The "size" of an element, a natural number which decreases on fields of
each inductive type.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="run-time-inductives">
                4.4.4. 运行时表示<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=run-time-inductives" title="Permalink">🔗</a></span></h2>
              <p>
                归纳类型的运行时表示取决于构造子的数量、每个构造子参数的数量，以及参数是否 <a class="technical-term" href="The Type System/Inductive Types/#--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">相关</a>。</p>
              <section>
                <h3 id="inductive-types-runtime-special-support">
                  4.4.4.1. 特例<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-types-runtime-special-support" title="Permalink">🔗</a></span></h3>
                <p>
                  并非所有归纳类型都采用这里描述的表示——部分归纳类型由 Lean 编译器特别支持：</p>
                <ul>
                  <li>
                    <p>
                      固定宽度整数类型 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#UInt8___ofBitVec" title="Documentation for UInt8"><span class="const token" data-binding="const-UInt8" data-verso-hover="464">UInt8</span></a></code>、<code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec" title="Documentation for UInt64"><span class="const token" data-binding="const-UInt64" data-verso-hover="465">UInt64</span></a></code>、<code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#Int8___toUInt8" title="Documentation for Int8"><span class="const token" data-binding="const-Int8" data-verso-hover="466">Int8</span></a></code>、<code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#Int64___toUInt64" title="Documentation for Int64"><span class="const token" data-binding="const-Int64" data-verso-hover="467">Int64</span></a></code> 与 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec" title="Documentation for USize"><span class="const token" data-binding="const-USize" data-verso-hover="468">USize</span></a></code> 的表示，取决于是为 32 位还是 64 位架构编译。
   比指针类型宽度小的固定宽度整数，采用设置指针最低位为 1 的无箱（unbox）方式存储。
   长度等于指针宽度的类型，视具体内容可采用无箱或有箱方式：如果实际数值可以用指针位数减一的位表示，则用最低位为 1 区分为 unbox；否则，将其作为指针指向堆上的固定大小 Lean 对象。
   在 C FFI 中，这些值会被转为相应的 C 类型 <code class="c"><span class="type">uint8_t</span></code>、<code class="c"><span class="type">uint64_t</span></code>、<code class="c"><span class="type">size_t</span></code>。<span class="marginalia"><span class="note">固定宽度有符号整数类型在 FFI 中也表示为无符号整数。</span></span></p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Characters/#Char___mk" title="Documentation for Char"><span class="const token" data-binding="const-Char" data-verso-hover="178">Char</span></a></code> 用 <code>uint32_t</code> 表示。由于 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Characters/#Char___mk" title="Documentation for Char"><span class="const token" data-binding="const-Char" data-verso-hover="178">Char</span></a></code> 取值不超过 21 位，所以总是无箱。</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Floating-Point-Numbers/#Float-next" title="Documentation for Float"><span class="const token" data-binding="const-Float" data-verso-hover="346">Float</span></a></code> 由指向包含 <code>double</code> 的 Lean 对象的指针表示。</p>
                    </li>
                  <li>
                    <p>
                      <span id="--tech-term-__________________-next-next" class="def-technical-term"><em>枚举归纳类型</em></span>，即至少 2 个、且不超过 <code class="math inline">2^{32}</code> 个构造子，且构造子无参数的类型，用 <code class="c"><span class="type">uint8_t</span></code>、<code class="c"><span class="type">uint16_t</span></code>、<code class="c"><span class="type">uint32_t</span></code> 中能一一编号的最小类型表示。例如，<code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a></code> 用 <code class="c"><span class="type">uint8_t</span></code> 表示，<code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="39">false</span></a></code> 为 <code class="c">0</code>，<code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a></code> 为 <code class="c">1</code>。</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Decidable___isFalse" title="Documentation for Decidable"><span class="const token" data-binding="const-Decidable" data-verso-hover="469">Decidable</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-α" data-verso-hover="470">α</span></code> 的表示与 <code>Bool</code> 相同。</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="148">Int</span></a></code> 由 <code class="c"><span class="type">lean_object *</span></code> 表示。运行时的 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> 或 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Integers/#Int___ofNat" title="Documentation for Int"><span class="const token" data-binding="const-Int" data-verso-hover="148">Int</span></a></code>，要么是指向任意精度整数对象的指针，要么（如“指针”的最低位为 1，经 <code class="c"><span class="name">lean_is_scalar</span></code> 检查）为 unbox 编码的无箱自然数或整数（相应转换用 <code class="c"><span class="name">lean_box</span></code>/<code class="c"><span class="name">lean_unbox</span></code>）。</p>
                    </li>
                  </ul>
                </section>
              <section>
                <h3 id="inductive-types-runtime-relevance">
                  4.4.4.2. 相关性<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-types-runtime-relevance" title="Permalink">🔗</a></span></h3>
                <p>
                  类型和证明在运行时没有表示形式。
也就是说，若归纳类型处于 <code>Prop</code>，则其值会在编译前被抹除。
同理，所有定理的陈述和类型都会被抹除。
具有运行时表示的类型称为 <span id="--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>相关类型</em></span>，反之则为 <span id="--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next" class="def-technical-term"><em>无关类型</em></span>。</p>
                <details class="example"><summary class="description">类型是无关的</summary><div class="example-content">
                    <p>
                      虽然 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">List.cons</span></a></code> 的签名表面有三个参数：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">List.cons</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span></code><p>
                      但运行时实际上只有两个参数，因为类型参数是无关的，不参与运行时表示。</p>
                    </div>
                  </details><details class="example"><summary class="description">证明是无关的</summary><div class="example-content">
                    <p>
                      虽然 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="471">Fin.mk</span></a></code> 的签名表面有三个参数：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin.mk"><span class="const token" data-binding="const-Fin.mk" data-verso-hover="471">Fin.mk</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Finite-Natural-Numbers/#Fin___mk" title="Documentation for Fin"><span class="const token" data-binding="const-Fin" data-verso-hover="472">Fin</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span></code><p>
                      但运行时只有两个参数，因为证明会被抹除。</p>
                    </div>
                  </details><p>
                  大多数情况下，无关的值在编译后直接消失。但在少数情况下（如它们是多态构造子的参数时），需要某种“形态”时，会以简单的值表示。</p>
                </section>
              <section>
                <h3 id="inductive-types-trivial-wrappers">
                  4.4.4.3. 平凡包装类型<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-types-trivial-wrappers" title="Permalink">🔗</a></span></h3>
                <p>
                  如果归纳类型只有一个构造子，且该构造子只有一个运行时相关参数，则该归纳类型的运行时表示与其参数类型完全一致。</p>
                <details class="example"><summary class="description">零负载子类型</summary><div class="example-content">
                    <p>
                      结构体 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Subtypes/#Subtype___mk" title="Documentation for Subtype"><span class="const token" data-binding="const-Subtype" data-verso-hover="473">Subtype</span></a></code> 用于将某个类型的元素和满足某谓词的证明打包。
其构造子需要四个参数，但其中三个参数是无关的：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Basic-Types/Subtypes/#Subtype___mk" title="Documentation for Subtype.mk"><span class="const token" data-binding="const-Subtype.mk" data-verso-hover="474">Subtype.mk</span></a><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="170">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="475">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="170">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="45">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="170">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="476">property</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="475">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="45">val</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Subtypes/#Subtype___mk" title="Documentation for Subtype"><span class="const token" data-binding="const-Subtype" data-verso-hover="473">Subtype</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="475">p</span></code><p>
                      因此，子类型在编译后不带来运行时额外开销，其表示和 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Subtypes/#Subtype___mk" title="Documentation for Subtype.val"><span class="const token" data-binding="const-Subtype.val" data-verso-hover="477">val</span></a></code> 字段的类型完全一致。</p>
                    </div>
                  </details><details class="example"><summary class="description">带符号整数</summary><div class="example-content">
                    <p>
                      有符号整数类型 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#Int8___toUInt8" title="Documentation for Int8"><span class="const token" data-binding="const-Int8" data-verso-hover="466">Int8</span></a></code>、...、<code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#Int64___toUInt64" title="Documentation for Int64"><span class="const token" data-binding="const-Int64" data-verso-hover="467">Int64</span></a></code>、<code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#ISize___toUSize" title="Documentation for ISize"><span class="const token" data-binding="const-ISize" data-verso-hover="478">ISize</span></a></code> 是只带唯一字段、该字段包装了对应无符号整数类型的结构体。
因此它们的表示就是无符号 C 类型 <code class="c"><span class="type">uint8_t</span></code>、...、<code class="c"><span class="type">uint64_t</span></code>、<code class="c"><span class="type">size_t</span></code>，因为结构体本身是平凡包装，不带额外信息。</p>
                    </div>
                  </details></section>
              <section>
                <h3 id="inductive-types-standard-representation">
                  4.4.4.4. 其它归纳类型<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-types-standard-representation" title="Permalink">🔗</a></span></h3>
                <p>
                  如果归纳类型不属于上述类别，则其运行时表示由其构造子结构决定。
没有相关参数的构造子，仅以在构造子列表中的索引（无箱无符号机器整数）表示。
有相关参数的构造子表示为一个对象，该对象有头部信息、构造子索引、指向其它对象的指针数组、以及按照类型分组排序的标量字段数组。
头部用来追踪引用计数以及其它记账信息。</p>
                <p>
                  递归函数的编译生成过程与大多数编程语言一致，并不是利用归纳类型的递归子来实现。
将递归函数翻译为递归子只是为了给出可靠的终止证据，而非用于实际执行代码。</p>
                <section>
                  <h4 id="inductive-types-ffi">
                    4.4.4.4.1. FFI<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=inductive-types-ffi" title="Permalink">🔗</a></span></h4>
                  <p>
                    从 C 语言视角看，其他归纳类型统一用 <code class="c"><span class="type">lean_object *</span></code> 表示。
每个构造子的存储为一个 <code class="c"><span class="type">lean_ctor_object</span></code>，且 <code class="c"><span class="name">lean_is_ctor</span></code> 的返回值为“真”。
<code class="c"><span class="type">lean_ctor_object</span></code> 在头部存储构造子索引，各字段存放在对象中的 <code class="c"><span class="name">m_objs</span></code> 区段。Lean 假定 <code class="c"><span class="name">sizeof</span><span class="brack">(</span><span class="type">size_t</span><span class="brack">)</span> == <span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span></code>——虽然 C 标准不保证，但 Lean 运行时包含断言，如果这一条件不满足会直接报错。</p>
                  <p>
                    内存中各字段的布局由声明中的类型及声明顺序决定，排序原则如下：</p>
                  <ul>
                    <li>
                      <p>
                        非标量字段按 <code class="c"><span class="type">lean_object *</span></code> 存储</p>
                      </li>
                    <li>
                      <p>
                        类型为 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec" title="Documentation for USize"><span class="const token" data-binding="const-USize" data-verso-hover="468">USize</span></a></code> 的字段</p>
                      </li>
                    <li>
                      <p>
                        其它标量字段，按大小从大到小排序</p>
                      </li>
                    </ul>
                  <p>
                    每组内部，字段顺序与声明顺序一致。<strong>注意</strong>：即使是“平凡包装类型”，只要包装体类型不是标量，也算作非标量字段。</p>
                  <ul>
                    <li>
                      <p>
                        需要访问第一类字段时，用 <code class="c"><span class="name">lean_ctor_get</span><span class="brack">(</span><span class="name">val</span>, <span class="name">i</span><span class="brack">)</span></code> 获取第 i 个非标量字段；</p>
                      </li>
                    <li>
                      <p>
                        访问 <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec" title="Documentation for USize"><span class="const token" data-binding="const-USize" data-verso-hover="468">USize</span></a></code> 字段时，用 <code class="c"><span class="name">lean_ctor_get_usize</span><span class="brack">(</span><span class="name">val</span>, <span class="name">n</span><span class="op">+</span><span class="name">i</span><span class="brack">)</span></code>，其中 n 是前面所有非标量字段的数目；第 i 个 USize 字段索引为 n+i；</p>
                      </li>
                    <li>
                      <p>
                        访问其它标量字段，用 <code class="c"><span class="name">lean_ctor_get_uintN</span><span class="brack">(</span><span class="name">val</span>, <span class="name">off</span><span class="brack">)</span></code> 或 <code class="c"><span class="name">lean_ctor_get_usize</span><span class="brack">(</span><span class="name">val</span>, <span class="name">off</span><span class="brack">)</span></code>，其中 off 是该字段在结构体中的字节偏移，从 <code class="c"><span class="name">n</span><span class="op">*</span><span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span></code>（n 为前两类字段总数）处算起。</p>
                      </li>
                    </ul>
                  <p>
                    For example, a structure such as</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-42609">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-S" data-verso-hover="141" id="S___ptr_2">S</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-42621">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-S.ptr_1" data-verso-hover="479" id="S___ptr_2">ptr_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="161">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-S.usize_1" data-verso-hover="480" id="S___ptr_2">usize_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec" title="Documentation for USize"><span class="const token" data-binding="const-USize" data-verso-hover="468">USize</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-S.sc64_1" data-verso-hover="481" id="S___ptr_2">sc64_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec" title="Documentation for UInt64"><span class="const token" data-binding="const-UInt64" data-verso-hover="465">UInt64</span></a><span class="inter-text">
  -- wrappers don't count as scalars:
  </span><span class="const token" data-binding="const-S.ptr_2" data-verso-hover="482" id="S___ptr_2">ptr_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="483">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec" title="Documentation for UInt64"><span class="const token" data-binding="const-UInt64" data-verso-hover="465">UInt64</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">//</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="483">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="483">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="const token" data-binding="const-S.sc64_2" data-verso-hover="484" id="S___ptr_2">sc64_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Floating-Point-Numbers/#Float-next" title="Documentation for Float"><span class="const token" data-binding="const-Float" data-verso-hover="346">Float</span></a><span class="inter-text"> -- `Float` is 64 bit
  </span><span class="const token" data-binding="const-S.sc8_1" data-verso-hover="485" id="S___ptr_2">sc8_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-S.sc16_1" data-verso-hover="486" id="S___ptr_2">sc16_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#UInt16___ofBitVec" title="Documentation for UInt16"><span class="const token" data-binding="const-UInt16" data-verso-hover="487">UInt16</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-S.sc8_2" data-verso-hover="488" id="S___ptr_2">sc8_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#UInt8___ofBitVec" title="Documentation for UInt8"><span class="const token" data-binding="const-UInt8" data-verso-hover="464">UInt8</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-S.sc64_3" data-verso-hover="489" id="S___ptr_2">sc64_3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#UInt64___ofBitVec" title="Documentation for UInt64"><span class="const token" data-binding="const-UInt64" data-verso-hover="465">UInt64</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-S.usize_2" data-verso-hover="490" id="S___ptr_2">usize_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#USize___ofBitVec" title="Documentation for USize"><span class="const token" data-binding="const-USize" data-verso-hover="468">USize</span></a><span class="inter-text">
  -- trivial wrapper around `UInt32`
  </span><span class="const token" data-binding="const-S.ptr_3" data-verso-hover="491" id="S___ptr_2">ptr_3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Characters/#Char___mk" title="Documentation for Char"><span class="const token" data-binding="const-Char" data-verso-hover="178">Char</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-S.sc32_1" data-verso-hover="492" id="S___ptr_2">sc32_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#UInt32___ofBitVec" title="Documentation for UInt32"><span class="const token" data-binding="const-UInt32" data-verso-hover="219">UInt32</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-S.sc16_2" data-verso-hover="493" id="S___ptr_2">sc16_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Fixed-Precision-Integers/#UInt16___ofBitVec" title="Documentation for UInt16"><span class="const token" data-binding="const-UInt16" data-verso-hover="487">UInt16</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    排序后，内存布局如下：</p>
                  <ul>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.ptr_1"><span class="const token" data-binding="const-S.ptr_1" data-verso-hover="479">S.ptr_1</span></a></code> - <code class="c"><span class="name">lean_ctor_get</span><span class="brack">(</span><span class="name">val</span>, 0<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.ptr_2"><span class="const token" data-binding="const-S.ptr_2" data-verso-hover="482">S.ptr_2</span></a></code> - <code class="c"><span class="name">lean_ctor_get</span><span class="brack">(</span><span class="name">val</span>, 1<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.ptr_3"><span class="const token" data-binding="const-S.ptr_3" data-verso-hover="491">S.ptr_3</span></a></code> - <code class="c"><span class="name">lean_ctor_get</span><span class="brack">(</span><span class="name">val</span>, 2<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.usize_1"><span class="const token" data-binding="const-S.usize_1" data-verso-hover="480">S.usize_1</span></a></code> - <code class="c"><span class="name">lean_ctor_get_usize</span><span class="brack">(</span><span class="name">val</span>, 3<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.usize_2"><span class="const token" data-binding="const-S.usize_2" data-verso-hover="490">S.usize_2</span></a></code> - <code class="c"><span class="name">lean_ctor_get_usize</span><span class="brack">(</span><span class="name">val</span>, 4<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.sc64_1"><span class="const token" data-binding="const-S.sc64_1" data-verso-hover="481">S.sc64_1</span></a></code> - <code class="c"><span class="name">lean_ctor_get_uint64</span><span class="brack">(</span><span class="name">val</span>, <span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span><span class="op">*</span>5<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.sc64_2"><span class="const token" data-binding="const-S.sc64_2" data-verso-hover="484">S.sc64_2</span></a></code> - <code class="c"><span class="name">lean_ctor_get_float</span><span class="brack">(</span><span class="name">val</span>, <span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span><span class="op">*</span>5 <span class="op">+</span> 8<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.sc64_3"><span class="const token" data-binding="const-S.sc64_3" data-verso-hover="489">S.sc64_3</span></a></code> - <code class="c"><span class="name">lean_ctor_get_uint64</span><span class="brack">(</span><span class="name">val</span>, <span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span><span class="op">*</span>5 <span class="op">+</span> 16<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.sc32_1"><span class="const token" data-binding="const-S.sc32_1" data-verso-hover="492">S.sc32_1</span></a></code> - <code class="c"><span class="name">lean_ctor_get_uint32</span><span class="brack">(</span><span class="name">val</span>, <span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span><span class="op">*</span>5 <span class="op">+</span> 24<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.sc16_1"><span class="const token" data-binding="const-S.sc16_1" data-verso-hover="486">S.sc16_1</span></a></code> - <code class="c"><span class="name">lean_ctor_get_uint16</span><span class="brack">(</span><span class="name">val</span>, <span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span><span class="op">*</span>5 <span class="op">+</span> 28<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.sc16_2"><span class="const token" data-binding="const-S.sc16_2" data-verso-hover="493">S.sc16_2</span></a></code> - <code class="c"><span class="name">lean_ctor_get_uint16</span><span class="brack">(</span><span class="name">val</span>, <span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span><span class="op">*</span>5 <span class="op">+</span> 30<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.sc8_1"><span class="const token" data-binding="const-S.sc8_1" data-verso-hover="485">S.sc8_1</span></a></code> - <code class="c"><span class="name">lean_ctor_get_uint8</span><span class="brack">(</span><span class="name">val</span>, <span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span><span class="op">*</span>5 <span class="op">+</span> 32<span class="brack">)</span></code></p>
                      </li>
                    <li>
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#S___ptr_2" title="Definition of example S.sc8_2"><span class="const token" data-binding="const-S.sc8_2" data-verso-hover="488">S.sc8_2</span></a></code> - <code class="c"><span class="name">lean_ctor_get_uint8</span><span class="brack">(</span><span class="name">val</span>, <span class="name">sizeof</span><span class="brack">(</span><span class="type">void*</span><span class="brack">)</span><span class="op">*</span>5 <span class="op">+</span> 33<span class="brack">)</span></code></p>
                      </li>
                    </ul>
                  </section>
                </section>
              </section>
            <section>
              <h2 id="mutual-inductive-types">
                4.4.5. 互递归归纳类型<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=mutual-inductive-types" title="Permalink">🔗</a></span></h2>
              <p>
                归纳类型之间可以互相递归。
互递归的归纳类型需在 <code>mutual ... end</code> 代码块中统一声明。</p>
              <details class="example"><summary class="description">互递归归纳类型</summary><div class="example-content">
                  <p>
                    在前面的例子中，类型 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-EvenOddList" data-verso-hover="277">EvenOddList</span></code> 用 Boolean 索引来区分列表是偶数还是奇数长度。
这个区分也可以用两个互递归类型 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList"><span class="const token" data-binding="const-EvenList" data-verso-hover="494">EvenList</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example OddList"><span class="const token" data-binding="const-OddList" data-verso-hover="495">OddList</span></a></code> 表达：</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-45636">mutual</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-45645" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenList" data-verso-hover="494" id="EvenList___nil">EvenList</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-45687">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenList.nil" data-verso-hover="496" id="EvenList___nil">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList"><span class="const token" data-binding="const-EvenList" data-verso-hover="494">EvenList</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-EvenList.cons" data-verso-hover="497" id="EvenList___nil">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example OddList"><span class="const token" data-binding="const-OddList" data-verso-hover="495">OddList</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList"><span class="const token" data-binding="const-EvenList" data-verso-hover="494">EvenList</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-45766" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-OddList" data-verso-hover="495" id="EvenList___nil">OddList</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-45807">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-OddList.cons" data-verso-hover="498" id="EvenList___nil">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList"><span class="const token" data-binding="const-EvenList" data-verso-hover="494">EvenList</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example OddList"><span class="const token" data-binding="const-OddList" data-verso-hover="495">OddList</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-45636">end</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-45865">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList"><span class="const token" data-binding="const-EvenList" data-verso-hover="494">EvenList</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList.cons"><span class="const token" data-binding="const-EvenList.cons" data-verso-hover="497">.cons</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="499">"x"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example OddList.cons"><span class="const token" data-binding="const-OddList.cons" data-verso-hover="498">.cons</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="500">"y"</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList.nil"><span class="const token" data-binding="const-EvenList.nil" data-verso-hover="496">.nil</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-45921">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example OddList"><span class="const token" data-binding="const-OddList" data-verso-hover="495">OddList</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example OddList.cons"><span class="const token" data-binding="const-OddList.cons" data-verso-hover="498">.cons</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="499">"x"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList.cons"><span class="const token" data-binding="const-EvenList.cons" data-verso-hover="497">.cons</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="500">"y"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example OddList.cons"><span class="const token" data-binding="const-OddList.cons" data-verso-hover="498">.cons</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="501">"z"</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList.nil"><span class="const token" data-binding="const-EvenList.nil" data-verso-hover="496">.nil</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-46037">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example OddList"><span class="const token" data-binding="const-OddList" data-verso-hover="495">OddList</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example OddList.cons"><span class="const token" data-binding="const-OddList.cons" data-verso-hover="498">.cons</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="499">"x"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#EvenList___nil" title="Definition of example EvenList.cons"><span class="const token" data-binding="const-EvenList.cons" data-verso-hover="497">.cons</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="500">"y"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">.nil</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid dotted identifier notation, unknown identifier `OddList.nil` from expected type
  OddList String</code></span></span><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>invalid dotted identifier notation, unknown identifier `OddList.nil` from expected type
  OddList String
</pre></div>
                  </div>
                </details><section>
                <h3 id="mutual-inductive-types-requirements">
                  4.4.5.1. 要求<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=mutual-inductive-types-requirements" title="Permalink">🔗</a></span></h3>
                <p>
                  <code>mutual</code> 块中的归纳类型视为一个整体；它们必须一起满足对非互递归归纳类型良构性条件的泛化要求。
即便这些类型单独也可以用非互递归方式定义，只要它们放在 mutual 块内，也要集体满足这些要求。</p>
                <section>
                  <h4 id="mutual-inductive-types-dependencies">
                    4.4.5.1.1. 互相关系<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=mutual-inductive-types-dependencies" title="Permalink">🔗</a></span></h4>
                  <p>
                    每个类型构造子的签名必须可以脱离同组其它类型独立完成繁释。
换句话说，mutual 组内的归纳类型不得作为其它归纳类型的参数。
而各个类型的构造子可以在参数类型中引用本组的其它类型构造子，但需遵守与普通递归情形类似的（严格）限制。</p>
                  <details class="example"><summary class="description">类型构造子之间不能互相引用</summary><div class="example-content">
                      <p>
                        下述归纳类型 Lean 不接受：</p>
                      <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-48837">mutual</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-48846" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">FreshList</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="502">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-48910">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">FreshList</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">FreshList</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">fresh</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Fresh</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid mutually inductive types, binder annotation mismatch at parameter 'α'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-49010" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Fresh</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="503">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="504">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'FreshList'</code></span></span><span class="unknown token" data-binding="">FreshList</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="504">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'FreshList'</code></span></span><span class="unknown token" data-binding="">FreshList</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-49094">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Fresh</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">.nil</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Fresh</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ys</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Fresh</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">.cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-48837">end</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                        类型构造子不能出现在同组另一个归纳类型的签名中，所以 <code>FreshList</code> 在 <code>Fresh</code> 的类型构造子中不可见：</p>
                      <div class="error">
                        <pre>unknown identifier 'FreshList'
</pre></div>
                      </div>
                    </details></section>
                <section>
                  <h4 id="mutual-inductive-types-same-parameters">
                    4.4.5.1.2. 参数必须匹配<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=mutual-inductive-types-same-parameters" title="Permalink">🔗</a></span></h4>
                  <p>
                    同一个 mutual 组中的所有归纳类型，<a class="technical-term" href="The Type System/Inductive Types/#--tech-term-______-next-next-next-next-next-next-next-next-next-next-next-next">参数</a> 必须类型完全一致。
索引可以不同。</p>
                  <details class="example"><summary class="description">参数类型不一致</summary><div class="example-content">
                      <p>
                        即便 <code>Many</code> 和 <code>OneOf</code> 之间不存在互递归，只要在同一个 mutual 块声明，也必须参数类型完全一样。两者参数数目一致，但 <code>Many</code> 的参数可能不在 <code>Optional</code> 的宇宙层级：</p>
                      <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-50717">mutual</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-50726" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Both</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="246">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-v" data-verso-hover="247">v</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-50769">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Both</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">β</span><span class="inter-text">
  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid inductive type, number of parameters mismatch in mutually inductive datatypes</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-50813" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Optional</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-50846">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">none</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">some</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Optional</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span></span><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-50717">end</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                        <pre>invalid inductive type, number of parameters mismatch in mutually inductive datatypes
</pre></div>
                      </div>
                    </details><details class="example"><summary class="description">参数类型不一致</summary><div class="example-content">
                      <p>
                        即便 <code>Many</code> 和 <code>OneOf</code> 之间不存在互递归，只要在同一个 mutual 块声明，也必须参数类型完全一样。
两者参数数目一致，但 <code>Many</code> 的参数可能不在 <code>Optional</code> 的宇宙层级：</p>
                      <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-52087">mutual</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-52096" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Many</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-52132">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Many</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Many</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Many</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text">
  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid mutually inductive types, parameter 'α' has type
  Type u : Type (u + 1)
but is expected to have type
  Type : Type 1</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-52200" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Optional</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-52233">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">none</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">some</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Optional</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span></span><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-52087">end</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                        <pre>invalid mutually inductive types, parameter 'α' has type
  Type u : Type (u + 1)
but is expected to have type
  Type : Type 1
</pre></div>
                      </div>
                    </details></section>
                <section>
                  <h4 id="mutual-inductive-types-same-universe">
                    4.4.5.1.3. 宇宙层级<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=mutual-inductive-types-same-universe" title="Permalink">🔗</a></span></h4>
                  <p>
                    互递归组中每个归纳类型的宇宙层级，同样需满足非互递归归纳类型的宇宙要求。
另外，所有 mutual 组的类型必须位于同一宇宙，这意味着它们的构造子的参数也要受宇宙层级统一的限制。</p>
                  <details class="example"><summary class="description">宇宙层级不一致</summary><div class="example-content">
                      <p>
                        这些互递归类型可以表示列表的行程编码（run-length encoding）：</p>
                      <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-55767">mutual</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-55776" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-RLE" data-verso-hover="505">RLE</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-55809">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-RLE.nil" data-verso-hover="506" id="RLE___run">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-RLE" data-verso-hover="505">RLE</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-RLE.run" data-verso-hover="507" id="RLE___run">run</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="164">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="508">PrefixRunOf</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="51">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="51">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-RLE" data-verso-hover="505">RLE</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93" data-verso-hover="51">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-RLE" data-verso-hover="505">RLE</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="51">xs</span><span class="inter-text">

  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-55920" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="508" id="RLE___run">PrefixRunOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-55988">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="509" id="RLE___run">zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.171" data-verso-hover="510">noMore</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">∃</span><span class="var token" data-binding="var-_uniq.162" data-verso-hover="511">zs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.142" data-verso-hover="511">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.155" data-verso-hover="512">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.162" data-verso-hover="511">zs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-56035">by</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;},{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-56041" data-verso-hover="35">simp</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="508">PrefixRunOf</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.155" data-verso-hover="512">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.142" data-verso-hover="511">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.142" data-verso-hover="511">xs</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="513" id="RLE___run">succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="508">PrefixRunOf</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="514">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.198" data-verso-hover="515">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.204" data-verso-hover="515">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="508">PrefixRunOf</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="514">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.192" data-verso-hover="514">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.198" data-verso-hover="515">xs</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.204" data-verso-hover="515">ys</span><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-55767">end</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-56148">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-RLE" data-verso-hover="505">RLE</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example RLE.run"><span class="const token" data-binding="const-RLE.run" data-verso-hover="507">.run</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-12447121325328836907-56202-56204-22"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-56202" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12447121325328836907-56202-56204-22"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ne" data-verso-hover="516">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-56205-56211-24"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-56205" data-verso-hover="262">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-56205-56211-24"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.succ"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="513">.succ</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.succ"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="513">.succ</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.zero"><span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="509">.zero</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;|</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example RLE.run"><span class="const token" data-binding="const-RLE.run" data-verso-hover="507">.run</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-12447121325328836907-56250-56252-25"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-56250" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12447121325328836907-56250-56252-25"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ne" data-verso-hover="516">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-56253-56259-27"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-56253" data-verso-hover="262">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-56253-56259-27"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.succ"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="513">.succ</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.succ"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="513">.succ</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.zero"><span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="509">.zero</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;|</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example RLE.run"><span class="const token" data-binding="const-RLE.run" data-verso-hover="507">.run</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-14847692936109229140-56298-56300-28"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-56298" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14847692936109229140-56298-56300-28"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ne" data-verso-hover="516">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-56301-56307-30"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-56301" data-verso-hover="262">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-56301-56307-30"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.succ"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="513">.succ</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.zero"><span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="509">.zero</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;|</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example RLE.run"><span class="const token" data-binding="const-RLE.run" data-verso-hover="507">.run</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="tactic"><label for="tactic-state-17202874436730851507-56338-56340-31"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-56338" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17202874436730851507-56338-56340-31"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ne" data-verso-hover="516">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-56341-56347-33"><a href="Tactic-Proofs/Tactic-Reference/#decide" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-56341" data-verso-hover="262">decide</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-56341-56347-33"><span class="tactic-state">All goals completed! 🐙</span></span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.succ"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="513">.succ</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.succ"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="513">.succ</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.succ"><span class="const token" data-binding="const-PrefixRunOf.succ" data-verso-hover="513">.succ</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf.zero"><span class="const token" data-binding="const-PrefixRunOf.zero" data-verso-hover="509">.zero</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;|</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example RLE.nil"><span class="const token" data-binding="const-RLE.nil" data-verso-hover="506">.nil</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                        若将 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#RLE___run" title="Definition of example PrefixRunOf"><span class="const token" data-binding="const-PrefixRunOf" data-verso-hover="508">PrefixRunOf</span></a></code> 声明为 <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span></code> 会更有意义，但类型因此不在同一宇宙，导致无法通过类型检查：</p>
                      <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-56590">mutual</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-56599" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">RLE</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="517">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-56632">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">RLE</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">run</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">PrefixRunOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">RLE</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">RLE</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span><span class="inter-text">

  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid mutually inductive types, resulting universe mismatch, given
  Prop
expected type
  Type</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-56743" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">PrefixRunOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="518">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="518">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="518">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-56811">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">noMore</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">∃</span><span class="unknown token" data-binding="">zs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="unknown token" data-binding="">zs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-56858">by</span><span class="inter-text"> </span><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;},{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-56864" data-verso-hover="35">simp</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">PrefixRunOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">PrefixRunOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">PrefixRunOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ys</span></span><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-56590">end</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                        <pre>invalid mutually inductive types, resulting universe mismatch, given
  Prop
expected type
  Type
</pre></div>
                      <p>
                        这里也可以将性质单独定义，再通过子类型表达：</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-57187">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-RunLengths" data-verso-hover="519" id="RunsMatch">RunLengths</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-57225">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NoRepeats" data-verso-hover="520" id="RunsMatch">NoRepeats</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RunLengths"><span class="const token" data-binding="const-RunLengths" data-verso-hover="519">RunLengths</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="263">True</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="263">True</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.124" data-verso-hover="45">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.126" data-verso-hover="45">y</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="521">xs</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.124" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.126" data-verso-hover="45">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example NoRepeats"><span class="const token" data-binding="const-NoRepeats" data-verso-hover="520">NoRepeats</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.126" data-verso-hover="45">y</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="521">xs</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-57368">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-RunsMatch" data-verso-hover="522" id="RunsMatch">RunsMatch</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RunLengths"><span class="const token" data-binding="const-RunLengths" data-verso-hover="519">RunLengths</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.421" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.421" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="263">True</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.503" data-verso-hover="45">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.504" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.505" data-verso-hover="521">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.506" data-verso-hover="51">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.506" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___take" title="Documentation for List.take"><span class="const token" data-binding="const-List.take" data-verso-hover="523">take</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.504" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___replicate" title="Documentation for List.replicate"><span class="const token" data-binding="const-List.replicate" data-verso-hover="524">List.replicate</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.504" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.503" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text">
    </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RunsMatch"><span class="const token" data-binding="const-RunsMatch" data-verso-hover="522">RunsMatch</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.505" data-verso-hover="521">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.506" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___drop" title="Documentation for List.drop"><span class="const token" data-binding="const-List.drop" data-verso-hover="185">drop</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.504" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#False" title="Documentation for False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-57548">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NonZero" data-verso-hover="525" id="RunsMatch">NonZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RunLengths"><span class="const token" data-binding="const-RunLengths" data-verso-hover="519">RunLengths</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.837" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Propositions/Truth/#True___intro" title="Documentation for True"><span class="const token" data-binding="const-True" data-verso-hover="263">True</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.897" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.898" data-verso-hover="521">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.897" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example NonZero"><span class="const token" data-binding="const-NonZero" data-verso-hover="525">NonZero</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.898" data-verso-hover="521">xs</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-57643">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-RLE" data-verso-hover="526">RLE</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1103" data-verso-hover="51">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1100" data-verso-hover="43">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-57672">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-RLE.rle" data-verso-hover="527" id="RunsMatch">rle</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RunLengths"><span class="const token" data-binding="const-RunLengths" data-verso-hover="519">RunLengths</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1100" data-verso-hover="43">α</span><span class="inter-text">
  </span><span class="const token" data-binding="const-RLE.noRepeats" data-verso-hover="528" id="RunsMatch">noRepeats</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example NoRepeats"><span class="const token" data-binding="const-NoRepeats" data-verso-hover="520">NoRepeats</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1111" data-verso-hover="529">rle</span><span class="inter-text">
  </span><span class="const token" data-binding="const-RLE.runsMatch" data-verso-hover="530" id="RunsMatch">runsMatch</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RunsMatch"><span class="const token" data-binding="const-RunsMatch" data-verso-hover="522">RunsMatch</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1111" data-verso-hover="529">rle</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1103" data-verso-hover="51">xs</span><span class="inter-text">
  </span><span class="const token" data-binding="const-RLE.nonZero" data-verso-hover="531" id="RunsMatch">nonZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example NonZero"><span class="const token" data-binding="const-NonZero" data-verso-hover="525">NonZero</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1111" data-verso-hover="529">rle</span><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-57784">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-RLE" data-verso-hover="526">RLE</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-57823">where</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RLE.rle"><span class="const token" data-binding="const-RLE.rle" data-verso-hover="532">rle</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RLE.noRepeats"><span class="const token" data-binding="const-RLE.noRepeats" data-verso-hover="533">noRepeats</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-17511494456438034065-57886-57888-34"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-57886" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17511494456438034065-57886-57888-34"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example NoRepeats"><span class="const token" data-binding="const-NoRepeats" data-verso-hover="520">NoRepeats</span></a><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">[</span></a><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">3</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">]</span></a></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-57889-57905-36"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;},{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-57889" data-verso-hover="35">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example NoRepeats"><span class="const token" data-binding="const-NoRepeats" data-verso-hover="520">NoRepeats</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-57889-57905-36"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RLE.runsMatch"><span class="const token" data-binding="const-RLE.runsMatch" data-verso-hover="535">runsMatch</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-12113898246536364466-57921-57923-37"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-57921" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12113898246536364466-57921-57923-37"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RunsMatch"><span class="const token" data-binding="const-RunsMatch" data-verso-hover="522">RunsMatch</span></a><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">[</span></a><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">3</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">]</span></a><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">[</span></a><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">]</span></a></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-57924-57940-39"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;},{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-57924" data-verso-hover="35">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RunsMatch"><span class="const token" data-binding="const-RunsMatch" data-verso-hover="522">RunsMatch</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-57924-57940-39"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example RLE.nonZero"><span class="const token" data-binding="const-RLE.nonZero" data-verso-hover="536">nonZero</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-18185938873339420692-57954-57956-40"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-57954" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18185938873339420692-57954-57956-40"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example NonZero"><span class="const token" data-binding="const-NonZero" data-verso-hover="525">NonZero</span></a><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">[</span></a><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">3</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">,</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">(</span></a><span class="unknown token" data-binding="">1</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">,</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="534">)</span></a><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List.cons"><span class="const token" data-binding="const-List.cons" data-verso-hover="409">]</span></a></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-57957-57971-42"><a href="Tactic-Proofs/Tactic-Reference/#simp" title="Documentation for tactic" data-verso-links="[{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for tactic&quot;,&quot;href&quot;:&quot;/Tactic-Proofs/Tactic-Reference/#simp&quot;},{&quot;short&quot;:&quot;doc&quot;,&quot;long&quot;:&quot;Documentation for syntax&quot;,&quot;href&quot;:&quot;/The-Simplifier/Invoking-the-Simplifier/#Lean___Parser___Tactic___simp&quot;}]"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-57957" data-verso-hover="35">simp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="The Type System/Inductive Types/#RunsMatch" title="Definition of example NonZero"><span class="const token" data-binding="const-NonZero" data-verso-hover="525">NonZero</span></a><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-57957-57971-42"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                    </details></section>
                <section>
                  <h4 id="mutual-inductive-types-positivity">
                    4.4.5.1.4. 正性条件(Positivity)<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=mutual-inductive-types-positivity" title="Permalink">🔗</a></span></h4>
                  <p>
                    互递归组中各归纳类型只能“严格正”地出现在所有构造子参数的类型表达式中。
即，对于所有类型的所有构造子的每个参数类型，互递归组内的类型构造子不能出现在任何函数箭头左边，也不能出现在参数位置，除非它正好是某个归纳类型类型构造子的参数。</p>
                  <details class="example"><summary class="description">互递归条件下的严格正性</summary><div class="example-content">
                      <p>
                        如下 mutual 组中，<code>Tm</code> 在 <code>Binding.scope</code> 的参数类型里出现了负位置：</p>
                      <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-59786">mutual</span></a><span class="inter-text">
  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #1 of 'Binding.scope' has a non positive occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-59795" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Tm" data-verso-hover="222">Tm</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-59808">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">app</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Tm" data-verso-hover="222">Tm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Tm" data-verso-hover="222">Tm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Tm" data-verso-hover="222">Tm</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">lam</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Tm" title="Definition of example Binding"><span class="const token" data-binding="const-Binding" data-verso-hover="222">Binding</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Tm" data-verso-hover="222">Tm</span></span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-59872" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Binding" data-verso-hover="222" id="Tm">Binding</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-59890">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">scope</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Tm" data-verso-hover="222">Tm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Tm" data-verso-hover="222">Tm</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Tm" title="Definition of example Binding"><span class="const token" data-binding="const-Binding" data-verso-hover="222">Binding</span></a><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-59786">end</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                        由于 <code>Tm</code> 属于同一个互递归组，故只能严格正性出现。实际却出现在负位置：</p>
                      <div class="error">
                        <pre>(kernel) arg #1 of 'Binding.scope' has a non positive occurrence of the datatypes being declared
</pre></div>
                      </div>
                    </details><details class="example"><summary class="description">嵌套位置</summary><div class="example-content">
                      <p>
                        <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Stx___node" title="Definition of example LocatedStx"><span class="const token" data-binding="const-LocatedStx" data-verso-hover="537">LocatedStx</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Stx___node" title="Definition of example Stx"><span class="const token" data-binding="const-Stx" data-verso-hover="538">Stx</span></a></code> 这组互递归类型，递归出现均不在箭头左侧，且作为归纳类型类型构造子的参数，有严格正性：</p>
                      <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-60373">mutual</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-60382" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-LocatedStx" data-verso-hover="537" id="Stx___node">LocatedStx</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-60403">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-LocatedStx.mk" data-verso-hover="539" id="Stx___node">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">line</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">col</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="540">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Stx___node" title="Definition of example Stx"><span class="const token" data-binding="const-Stx" data-verso-hover="538">Stx</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-60449" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Stx" data-verso-hover="538" id="Stx___node">Stx</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-60463">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Stx.atom" data-verso-hover="541" id="Stx___node">atom</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="316">str</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Stx.node" data-verso-hover="542" id="Stx___node">node</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="316">kind</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="149">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="543">args</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Stx___node" title="Definition of example LocatedStx"><span class="const token" data-binding="const-LocatedStx" data-verso-hover="537">LocatedStx</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-60373">end</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                    </details></section>
                </section>
              <section>
                <h3 id="mutual-inductive-types-recursors">
                  4.4.5.2. 递归子<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=mutual-inductive-types-recursors" title="Permalink">🔗</a></span></h3>
                <p>
                  互递归归纳类型和非互递归归纳类型一样，都提供了原语递归子。
这些递归子会考虑到需要处理组内的其他类型，因此每个归纳类型都会有一个目标参数。
由于在 <code>mutual</code> 组中的所有归纳类型都被要求有相同的参数，递归子依然会首先接收这些参数，并将它们抽象到目标参数和递归子的其余部分上。
此外，因为递归子必须处理组内的其他类型，所以它还需要为组内每个类型的每个构造子提供分支。
实际上，类型之间具体的依赖关系在这里没有被考虑；即使由于互递归依赖关系较少，某些目标参数或构造子分支实际上并非必须，生成的递归子依旧会要求这些内容。</p>
                <details class="example"><summary class="description">偶数与奇数</summary><div class="example-content">
                    <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-63338">mutual</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-63347" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-63377">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Even.zero" data-verso-hover="24">zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Even.succ" data-verso-hover="544" id="Even___zero-next-next-next">succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Odd"><span class="const token" data-binding="const-Odd" data-verso-hover="545">Odd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-63441" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Odd" data-verso-hover="545" id="Even___zero-next-next-next">Odd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-63470">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Odd.succ" data-verso-hover="546" id="Even___zero-next-next-next">succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.104" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Odd"><span class="const token" data-binding="const-Odd" data-verso-hover="545">Odd</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.104" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-63338">end</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Even.rec" data-verso-hover="547">Even.rec</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="548">motive_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="549">motive_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Odd"><span class="const token" data-binding="const-Odd" data-verso-hover="545">Odd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="550">zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="548">motive_1</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even.zero"><span class="const token" data-binding="const-Even.zero" data-verso-hover="24">Even.zero</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.108" data-verso-hover="551">succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34" data-verso-hover="552">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Odd"><span class="const token" data-binding="const-Odd" data-verso-hover="545">Odd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="549">motive_2</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34" data-verso-hover="552">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="548">motive_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Even.succ"><span class="const token" data-binding="const-Even.succ" data-verso-hover="544">Even.succ</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34" data-verso-hover="552">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.114" data-verso-hover="553">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="548">motive_1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.114" data-verso-hover="553">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="549">motive_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Odd.succ"><span class="const token" data-binding="const-Odd.succ" data-verso-hover="546">Odd.succ</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.114" data-verso-hover="553">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.170" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.172" data-verso-hover="554">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.170" data-verso-hover="7">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="548">motive_1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.170" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.172" data-verso-hover="554">t</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Odd.rec" data-verso-hover="555">Odd.rec</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="548">motive_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="549">motive_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Odd"><span class="const token" data-binding="const-Odd" data-verso-hover="545">Odd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="550">zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="548">motive_1</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even.zero"><span class="const token" data-binding="const-Even.zero" data-verso-hover="24">Even.zero</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.107" data-verso-hover="551">succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="552">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Odd"><span class="const token" data-binding="const-Odd" data-verso-hover="545">Odd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="549">motive_2</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="552">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="548">motive_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Even.succ"><span class="const token" data-binding="const-Even.succ" data-verso-hover="544">Even.succ</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="552">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.111" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.113" data-verso-hover="553">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Introduction/#Even___zero-next-next" title="Documentation for Even"><span class="const token" data-binding="const-Even" data-verso-hover="21">Even</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.111" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="548">motive_1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.111" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.113" data-verso-hover="553">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="549">motive_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.111" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Odd.succ"><span class="const token" data-binding="const-Odd.succ" data-verso-hover="546">Odd.succ</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.113" data-verso-hover="553">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.169" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.171" data-verso-hover="556">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Even___zero-next-next-next" title="Definition of example Odd"><span class="const token" data-binding="const-Odd" data-verso-hover="545">Odd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.169" data-verso-hover="7">a</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="549">motive_2</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.169" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.171" data-verso-hover="556">t</span></code></div>
                  </details><details class="example"><summary class="description">表面互递归类型</summary><div class="example-content">
                    <p>
                      类型 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Three" title="Definition of example Two"><span class="const token" data-binding="const-Two" data-verso-hover="557">Two</span></a></code> 和 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Three" title="Definition of example Three"><span class="const token" data-binding="const-Three" data-verso-hover="558">Three</span></a></code> 其实互不引用，却作为一个 mutual 组共同声明：</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-65106">mutual</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-65115" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Two" data-verso-hover="557" id="Three">Two</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-65141">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Two.mk" data-verso-hover="559" id="Three">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Three" title="Definition of example Two"><span class="const token" data-binding="const-Two" data-verso-hover="557">Two</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-65181" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Three" data-verso-hover="558" id="Three">Three</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-65209">where</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Three.mk" data-verso-hover="560" id="Three">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Three" title="Definition of example Three"><span class="const token" data-binding="const-Three" data-verso-hover="558">Three</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="164">α</span><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-65106">end</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Three" title="Definition of example Two"><span class="const token" data-binding="const-Two" data-verso-hover="557">Two</span></a></code> 的递归子 <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Two.rec" data-verso-hover="561">Two.rec</span></code> 依然需要 motive 以及 <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#Three" title="Definition of example Three"><span class="const token" data-binding="const-Three" data-verso-hover="558">Three</span></a></code> 的分支：</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Two.rec" data-verso-hover="561">Two.rec</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="562">motive_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Three" title="Definition of example Two"><span class="const token" data-binding="const-Two" data-verso-hover="557">Two</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="563">motive_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Three" title="Definition of example Three"><span class="const token" data-binding="const-Three" data-verso-hover="558">Three</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="564">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="45">a_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="562">motive_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#Three" title="Definition of example Two.mk"><span class="const token" data-binding="const-Two.mk" data-verso-hover="559">Two.mk</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="45">a_1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="45">a_1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="45">a_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="563">motive_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#Three" title="Definition of example Three.mk"><span class="const token" data-binding="const-Three.mk" data-verso-hover="560">Three.mk</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="45">a_1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="45">a_2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="565">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Three" title="Definition of example Two"><span class="const token" data-binding="const-Two" data-verso-hover="557">Two</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="164">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="562">motive_1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="565">t</span></code></div>
                  </details></section>
              <section>
                <h3 id="mutual-inductive-types-run-time">
                  4.4.5.3. 运行时表示<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=mutual-inductive-types-run-time" title="Permalink">🔗</a></span></h3>
                <p>
                  互递归归纳类型在编译后及运行期的表示，与 <a href="The Type System/Inductive Types/#run-time-inductives">非互递归归纳类型</a> 完全一致。
对于互递归归纳类型的限制，是为了保证 Lean 作为一种逻辑的可靠性，不影响实际代码的编译与运行。</p>
                </section>
              <section>
                <h3 id="nested-inductive-types">
                  4.4.5.4. Nested Inductive Types<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=nested-inductive-types" title="Permalink">🔗</a></span></h3>
                <p>
                  <span id="--tech-term-Nested-inductive-types" class="def-technical-term"><em>Nested inductive types</em></span> are inductive types in which recursive occurrences of the type being defined are parameters to other inductive type constructors.
These recursive occurrences are “nested” underneath the other type constructors.
Nested inductive types that satisfy certain requirements can be translated into mutual inductive types; this translation demonstrates that they are sound.
Internally, the <a class="technical-term" href="Elaboration and Compilation/#--tech-term-______-next-next">kernel</a> performs this translation; if it succeeds, then the <em>original</em> nested inductive type is accepted.
This avoids performance and usability issues that would arise from details of the translation surfacing.</p>
                <div class="paragraph">
                  <p>
                    Nested recursive occurrences must satisfy the following requirements:</p>
                  <ul>
                    <li>
                      <p>
                        They must be nested <em>directly</em> under an inductive type's type constructor.
  Terms that reduce to such nested occurrences are not accepted.</p>
                      </li>
                    <li>
                      <p>
                        Local variables such as the constructor's parameters may not occur in the arguments to the nested occurrence.</p>
                      </li>
                    <li>
                      <p>
                        The nested occurrences must occur strictly positively.</p>
                      </li>
                    </ul>
                  </div>
                <details class="example"><summary class="description">Nested Inductive Types</summary><div class="example-content">
                    <p>
                      Instead of using two constructors, the natural numbers can be defined using <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-1553" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-1575">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat.mk" data-verso-hover="567">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="568">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Arbitrarily-branching trees, also known as <em>rose trees</em>, are nested inductive types:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-1707" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-RTree" data-verso-hover="569">RTree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-1746">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-RTree.empty" data-verso-hover="570" id="RTree___node">empty</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-RTree.node" data-verso-hover="571" id="RTree___node">node</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="45">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="572">children</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-RTree" data-verso-hover="569">RTree</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><details class="example"><summary class="description">Invalid Nested Inductive Types</summary><div class="example-content">
                    <p>
                      This declaration of arbitrarily-branching rose trees declares an alias for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a></code>, rather than using <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a></code> directly:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.abbrev-2040">abbrev</span><span class="inter-text"> </span><span class="const token" data-binding="const-Children" data-verso-hover="573" id="Children">Children</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text">

</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #3 of 'RTree.node' contains a non valid occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-2065" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-RTree" data-verso-hover="574">RTree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-2104">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">empty</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">node</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="45">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="575">children</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#Children" title="Definition of example Children"><span class="const token" data-binding="const-Children" data-verso-hover="573">Children</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-RTree" data-verso-hover="574">RTree</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>(kernel) arg #3 of 'RTree.node' contains a non valid occurrence of the datatypes being declared
</pre></div>
                    <div class="paragraph">
                      <p>
                        This declaration of arbitrarily-branching rose trees tracks the depth of the tree using an index.
The constructor <code>DRTree.node</code> has an <a class="technical-term" href="Definitions/Headers-and-Signatures/#--tech-term-automatic-implicit-parameters">automatic implicit parameter</a> <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.740" data-verso-hover="7">n</span></code> that represents the depths of all sub-trees.
However, local variables such as constructor parameters are not permitted as arguments to nested occurrences:</p>
                      <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) invalid nested inductive datatype 'List', nested inductive datatypes parameters cannot contain local variables.</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-2761" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-DRTree" data-verso-hover="576" id="DRTree">DRTree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-2809">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">empty</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#DRTree" title="Definition of example DRTree"><span class="const token" data-binding="const-DRTree" data-verso-hover="576">DRTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">node</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="45">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="577">children</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#DRTree" title="Definition of example DRTree"><span class="const token" data-binding="const-DRTree" data-verso-hover="576">DRTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#DRTree" title="Definition of example DRTree"><span class="const token" data-binding="const-DRTree" data-verso-hover="576">DRTree</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                        <pre>(kernel) invalid nested inductive datatype 'List', nested inductive datatypes parameters cannot contain local variables.
</pre></div>
                      </div>
                    <p>
                      This declaration includes a non-strictly-positive occurrence of the inductive type, nested under an <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #1 of 'WithCheck.check' has a non positive occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-3226" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-WithCheck" data-verso-hover="222" id="WithCheck">WithCheck</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-3246">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">done</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="578">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#WithCheck" title="Definition of example WithCheck"><span class="const token" data-binding="const-WithCheck" data-verso-hover="222">WithCheck</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="157">Bool</span></a><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>(kernel) arg #1 of 'WithCheck.check' has a non positive occurrence of the datatypes being declared
</pre></div>
                    </div>
                  </details><p>
                  The translation from nested inductive types to mutual inductive types proceeds as follows:</p>
                <dl><dt> Nested occurrences become inductive types</dt><dd><p>
                      Nested occurrences of the inductive type are translated into new inductive types in the same mutual group, which replace the original nested occurrences.
  These new inductive types have the same constructors as the outer inductive type, except the original parameters are instantiated by the translated version of the type.
  The original inductive type becomes an alias for the version in which the nested occurrences have been rewritten.
  This process is repeated if the resulting type is also a nested inductive type (e.g. a type nested under <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="161">Array</span></a></code> becomes a type nested under <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a></code>, because <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="161">Array</span></a></code>'s constructor takes a <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="42">List</span></a></code>).</p>
                    </dd><dt> Conversions to and from the nested types</dt><dd><p>
                      Conversions between the outer inductive type applied to the new alias and the generated auxiliary types are generated.
  These conversions are then proved to be mutual inverses.</p>
                    </dd><dt> Constructor reconstruction</dt><dd><p>
                      Each constructor of the original type is defined as a function that returns the constructor of the translated type, after applying the appropriate conversions.</p>
                    </dd><dt> Recursor reconstruction</dt><dd><p>
                      The recursor for the nested inductive type is constructed from the recursor for the translated type.
  In the translation, the motives for the nested occurrences are composed with the conversion functions and the <a class="technical-term" href="The Type System/Inductive Types/#--tech-term-____________-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">minor premises</a> use them as needed.
  The proofs that the conversion functions are mutually inverse are needed because the encoded constructors convert in one direction, but end up applied to the result of the conversion in the other direction.</p>
                    </dd></dl><details class="example"><summary class="description">Translating Nested Inductive Types</summary><div class="example-content">
                    <p>
                      This nested inductive type represents the natural numbers:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-5288" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5303">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat.mk" data-verso-hover="567">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="568">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text">

</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">ONat.rec.{u} {motive_1 : ONat → Sort u} {motive_2 : Option ONat → Sort u}
  (mk : (pred : Option ONat) → motive_2 pred → motive_1 (ONat.mk pred)) (none : motive_2 none)
  (some : (val : ONat) → motive_1 val → motive_2 (some val)) (t : ONat) : motive_1 t</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-5345">#check</span></a></span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#ONat___rec" title="Definition of example ONat.rec"><span class="const token" data-binding="const-ONat.rec" data-verso-hover="579">ONat.rec</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The first step in the internal translation is to replace the nested occurrences with auxiliary inductive types that “inline” the resulting type.
In this case, the nested occurrence is under <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code>; thus, the auxiliary type has the constructors of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code>, with <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example ONat'"><span class="const token" data-binding="const-ONat'" data-verso-hover="580">ONat'</span></a></code> substituted for the type parameter:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-5704">mutual</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-5711" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat'" data-verso-hover="580" id="OptONat___some">ONat'</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5727">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat'.mk" data-verso-hover="581" id="OptONat___some">mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="582">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat"><span class="const token" data-binding="const-OptONat" data-verso-hover="583">OptONat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example ONat'"><span class="const token" data-binding="const-ONat'" data-verso-hover="580">ONat'</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-5766" data-verso-hover="20">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-OptONat" data-verso-hover="583" id="OptONat___some">OptONat</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-5784">where</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-OptONat.none" data-verso-hover="584" id="OptONat___some">none</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-OptONat.some" data-verso-hover="585" id="OptONat___some">some</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example ONat'"><span class="const token" data-binding="const-ONat'" data-verso-hover="580">ONat'</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat"><span class="const token" data-binding="const-OptONat" data-verso-hover="583">OptONat</span></a><span class="inter-text">
</span><a href="Definitions/Recursive-Definitions/#Lean___Parser___Command___mutual" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-5704">end</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example ONat'"><span class="const token" data-binding="const-ONat'" data-verso-hover="580">ONat'</span></a></code> is the encoding of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5892">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example ONat'"><span class="const token" data-binding="const-ONat'" data-verso-hover="580">ONat'</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The next step is to define conversion functions that translate the original nested type to and from the auxiliary type:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6043">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586" id="OptONat___ofOption">OptONat.ofOption</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat"><span class="const token" data-binding="const-OptONat" data-verso-hover="583">OptONat</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">Option.none</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.none"><span class="const token" data-binding="const-OptONat.none" data-verso-hover="584">OptONat.none</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">Option.some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="587">o</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.some"><span class="const token" data-binding="const-OptONat.some" data-verso-hover="585">OptONat.some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="587">o</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6158">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588" id="OptONat___ofOption">OptONat.toOption</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat"><span class="const token" data-binding="const-OptONat" data-verso-hover="583">OptONat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.none"><span class="const token" data-binding="const-OptONat.none" data-verso-hover="584">OptONat.none</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">Option.none</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.some"><span class="const token" data-binding="const-OptONat.some" data-verso-hover="585">OptONat.some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="589">o</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">Option.some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="589">o</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      These conversion functions are mutually inverse:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6335">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-OptONat.to_of_eq_id" data-verso-hover="590" id="OptONat___to_of_eq_id">OptONat.to_of_eq_id</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="568">o</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">OptONat.toOption</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="568">o</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="568">o</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-16017691003291394127-6404-6406-43"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6404" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16017691003291394127-6404-6406-43"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="568">o</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="568">o</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="568">o</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-12179852273711506312-6409-6416-45"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-6409" data-verso-hover="387">cases</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="568">o</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12179852273711506312-6409-6416-45"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-46" checked="checked"><span for="--verso-unique-46" class="goal-name">none</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">Option.none</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">Option.none</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-47"><span for="--verso-unique-47" class="goal-name">some</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.50" data-verso-hover="587">val✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">Option.some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="587">val✝</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">Option.some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="587">val✝</span></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-12179852273711506312-6417-6420-48"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12179852273711506312-6417-6420-48"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-49" checked="checked"><span for="--verso-unique-49" class="goal-name">none</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">Option.none</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">Option.none</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-50"><span for="--verso-unique-50" class="goal-name">some</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.50" data-verso-hover="587">val✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">Option.some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="587">val✝</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">Option.some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="587">val✝</span></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-6421-6424-51"><a href="Tactic-Proofs/Tactic-Reference/#rfl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-6421" data-verso-hover="14">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-6421-6424-51"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6425">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-OptONat.of_to_eq_id" data-verso-hover="591" id="OptONat___to_of_eq_id">OptONat.of_to_eq_id</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="582">o</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">OptONat.ofOption</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">OptONat.toOption</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="582">o</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="582">o</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-16218574104983036715-6502-6504-52"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6502" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16218574104983036715-6502-6504-52"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.91" data-verso-hover="582">o</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat"><span class="const token" data-binding="const-OptONat" data-verso-hover="583">OptONat</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="582">o</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="582">o</span></span></span></span></span></span><span class="inter-text">
  </span><span class="tactic"><label for="tactic-state-4557537977950616812-6507-6514-54"><a href="Tactic-Proofs/Tactic-Reference/#cases" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-6507" data-verso-hover="387">cases</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91" data-verso-hover="582">o</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4557537977950616812-6507-6514-54"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-55" checked="checked"><span for="--verso-unique-55" class="goal-name">none</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.none"><span class="const token" data-binding="const-OptONat.none" data-verso-hover="584">none</span></a><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.none"><span class="const token" data-binding="const-OptONat.none" data-verso-hover="584">none</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-56"><span for="--verso-unique-56" class="goal-name">some</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.131" data-verso-hover="589">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example ONat'"><span class="const token" data-binding="const-ONat'" data-verso-hover="580">ONat'</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.some"><span class="const token" data-binding="const-OptONat.some" data-verso-hover="585">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="589">a✝</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.some"><span class="const token" data-binding="const-OptONat.some" data-verso-hover="585">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="589">a✝</span></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-4557537977950616812-6515-6518-57"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4557537977950616812-6515-6518-57"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-58" checked="checked"><span for="--verso-unique-58" class="goal-name">none</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.none"><span class="const token" data-binding="const-OptONat.none" data-verso-hover="584">none</span></a><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.none"><span class="const token" data-binding="const-OptONat.none" data-verso-hover="584">none</span></a></span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-59"><span for="--verso-unique-59" class="goal-name">some</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.131" data-verso-hover="589">a✝</span></span><span class="colon">:</span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example ONat'"><span class="const token" data-binding="const-ONat'" data-verso-hover="580">ONat'</span></a><span class="inter-text"></span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text"></span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">ofOption</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.some"><span class="const token" data-binding="const-OptONat.some" data-verso-hover="585">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="589">a✝</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl" title="Documentation for Eq"><span class="const token" data-binding="const-Eq" data-verso-hover="16">=</span></a><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example OptONat.some"><span class="const token" data-binding="const-OptONat.some" data-verso-hover="585">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.131" data-verso-hover="589">a✝</span></span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-6519-6522-60"><a href="Tactic-Proofs/Tactic-Reference/#rfl" title="Documentation for tactic"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-6519" data-verso-hover="14">rfl</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-6519-6522-60"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The original constructor is translated to an application of the translation's corresponding constructor, with the appropriate conversion applied for the nested occurrence:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6708">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat.mk" data-verso-hover="567">ONat.mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="568">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="The Type System/Inductive Types/#OptONat___some" title="Definition of example ONat'.mk"><span class="const token" data-binding="const-ONat'.mk" data-verso-hover="581">ONat'.mk</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.ofOption"><span class="const token" data-binding="const-OptONat.ofOption" data-verso-hover="586">.ofOption</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="568">pred</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Finally, the original type's recursor can be translated.
The translated recursor uses the translated type's recursor.
The original nested occurrences are translated using the conversions, and the proofs that the conversions are mutually inverse are used to rewrite types as needed.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-7074">noncomputable</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7088">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat.rec" data-verso-hover="592" id="ONat___rec">ONat.rec</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="593">motive1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="594">motive2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="171">Sort</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="56">u</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="595">h1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="568">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="594">motive2</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="568">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
      </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="593">motive1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-ONat.mk" data-verso-hover="567">ONat.mk</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="568">pred</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="596">h2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="594">motive2</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="47">none</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="597">h3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="587">o</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="593">motive1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="587">o</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="594">motive2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="587">o</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34" data-verso-hover="587">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-ONat" data-verso-hover="566">ONat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="593">motive1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34" data-verso-hover="587">t</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">@</span><span class="const token" data-binding="const-ONat'.rec" data-verso-hover="598">ONat'.rec</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="593">motive1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="594">motive2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∘</span><span class="inter-text"> </span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">OptONat.toOption</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-7432">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.79" data-verso-hover="582">pred</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="599">ih</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
      </span><a href="The Type System/Inductive Types/#OptONat___to_of_eq_id" title="Definition of example OptONat.of_to_eq_id"><span class="const token" data-binding="const-OptONat.of_to_eq_id" data-verso-hover="600">OptONat.of_to_eq_id</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.79" data-verso-hover="582">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="595">h1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.79" data-verso-hover="582">pred</span><span class="unknown token" data-binding="">.</span><a href="The Type System/Inductive Types/#OptONat___ofOption" title="Definition of example OptONat.toOption"><span class="const token" data-binding="const-OptONat.toOption" data-verso-hover="588">toOption</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="599">ih</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="596">h2</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="597">h3</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details></section>
              </section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="The Type System/Universe/#universe" rel="prev" title="4.3. 宇宙（Universe）"><span class="arrow">←</span><span class="where">4.3. 宇宙（Universe）</span></a><a class="local-button active" href="The Type System/Quotients/#quotients" rel="next" title="4.5. 商类型"><span class="where">4.5. 商类型</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

