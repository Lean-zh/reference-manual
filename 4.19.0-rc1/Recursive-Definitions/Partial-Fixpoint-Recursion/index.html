<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Partial Fixpoint Recursion</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 5%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
dl.toml-table-field-spec {
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
div.planned {
  font-style: italic;
}
div.planned .label {
  font-size: large;
  text-align: center;
  font-family: var(--verso-structure-font-family);
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: larger;
  margin-top: 0;
  margin-left: 1.5em;
  margin-right: 1.5em;
  margin-bottom: 0.5em;
  display: inline-block;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>.example {
  padding: 1.5em;
  border: 1px solid #98B2C0;
  border-radius: 0.5em;
  margin-bottom: 0.75em;
  margin-top: 0.75em;
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example p:last-child {margin-bottom:0;}
.example .description::before {
  content: "Example: ";
}
.example[open] .description {
  margin-bottom: 1em;
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 2px #99b3c0;
  background-color: #99b3c0;
  padding-left: 1px;
  padding-right: 1px;
  padding-bottom: 1px;
  padding-top: 1.5rem;
  margin-bottom: 1rem;
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  background-color: white;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 1.5rem;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: 1.5rem !important;
  margin-right: 1.5rem;
}

.namedocs .label {
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  right: 0.5rem;
  top: 0.5rem;
}

/* Sticking content into the right margin is not good on narrow screens,
   so move the label to the left to make space for the permalink widget. */

@media screen and (max-width: 700px) {
  .namedocs:has(.permalink-widget.block) .label {
    right: 1.5rem;
  }
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold;
}

.namedocs > .text .constructor {
  padding-left: 0.5rem;
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: 1.5rem;
}
.namedocs .text > :last-child {
  margin-bottom: 1.5rem;
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files/#The-Lean-Language-Reference--Source-Files">Source Files</a></td></tr><tr class="current numbered"><td class="num">6.</td><td><a href="Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="Output-from-Lean/#The-Lean-Language-Reference--Output-from-Lean">Output from Lean</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Elan/#elan">Elan</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-recursive-definitions" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-recursive-definitions" checked="checked"></label><span class="number">6.</span> <span class=""><a href="Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></span></div>
              <table><tr class="numbered"><td class="num">6.1.</td><td><a href="Recursive-Definitions/Mutual-Recursion/#mutual-syntax">Mutual Recursion</a></td></tr><tr class="numbered"><td class="num">6.2.</td><td><a href="Recursive-Definitions/Structural-Recursion/#structural-recursion">Structural Recursion</a></td></tr><tr class="numbered"><td class="num">6.3.</td><td><a href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion">Well-Founded Recursion</a></td></tr><tr class="current numbered"><td class="num">6.4.</td><td><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint">Partial Fixpoint Recursion</a></td></tr><tr class="numbered"><td class="num">6.5.</td><td><a href="Recursive-Definitions/Partial-and-Unsafe-Recursive-Definitions/#partial-unsafe">Partial and Unsafe Recursive Definitions</a></td></tr><tr class="numbered"><td class="num">6.6.</td><td><a href="Recursive-Definitions/Controlling-Reduction/#The-Lean-Language-Reference--Recursive-Definitions--Controlling-Reduction">Controlling Reduction</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-partial-fixpoint" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-partial-fixpoint" checked="checked"></label><span class="number">6.4.</span> <span class="current"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint">Partial Fixpoint Recursion</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint-tailrec">Tail-Recursive Functions</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint-monadic">Monadic functions</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-correctness-theorem">Partial Correctness Theorems</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#mutual-partial-fixpoint">Mutual Recursion with Partial Fixpoints</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint-theory">Theory and Construction</a></span></li>
                <li>
                  <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><code>PartialOrder</code></a></li>
                <li>
                  <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___CCPO___mk"><code>CCPO</code></a></li>
                <li>
                  <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___monotone"><code>monotone</code></a></li>
                <li>
                  <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___fix"><code>fix</code></a></li>
                <li>
                  <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___fix_eq"><code>fix_eq</code></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion" rel="prev" title="6.3. Well-Founded Recursion"><span class="arrow">←</span><span class="where">6.3. Well-Founded Recursion</span></a><a class="local-button active" href="Recursive-Definitions/Partial-and-Unsafe-Recursive-Definitions/#partial-unsafe" rel="next" title="6.5. Partial and Unsafe Recursive Definitions"><span class="where">6.5. Partial and Unsafe Recursive Definitions</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              6.4. Partial Fixpoint Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-fixpoint" title="Permalink">🔗</a></span></h1>
            <p>
              All definitions are fundamentally equations: the new constant being defined is equal to the right-hand side of the definition.
For functions defined by <a href="Recursive-Definitions/Structural-Recursion/#structural-recursion">structural recursion</a>, this equation holds <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally</a>, and there is a unique value returned by application of the function.
For functions defined by <a href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion">well-founded recursion</a>, the equation may hold only <a class="technical-term" href="The-Type-System/Propositions/#--tech-term-Propositions">propositionally</a>, but all type-correct applications of the function to arguments are equal to the respective values prescribed by the definition.
In both cases, the fact that the function terminates for all inputs means that the value computed by applying the function is always uniquely determined.</p>
            <p>
              In some cases where a function does not terminate for all arguments, the equation may not <em>uniquely</em> determine the function's return value for each input, but there are nonetheless functions for which the defining equation holds.
In these cases, a definition as a <span id="--tech-term-partial-fixpoint"><em>partial fixpoint</em></span> may still be possible.
Any function that satisfies the defining equation can be used to demonstrate that the equation does not create a logical contradiction, and the equation can then be proven as a theorem about this function.
As with the other strategies for defining recursive functions, compiled code uses the function as it was originally written; like definitions in terms of eliminators or recursion over accessibility proofs, the function used to define the partial fixpoint is used only to justify the function's equations in Lean's logic for purposes of mathematical reasoning.</p>
            <p>
              The term <a class="technical-term" href="Recursive-Definitions/Partial-Fixpoint-Recursion/#--tech-term-partial-fixpoint"><em>partial fixpoint</em></a> is specific to Lean.
Functions declared <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span> do not require termination proofs, so long as the type of their return values is inhabited, but they are completely opaque from the perspective of Lean's logic.
Partial fixpoints, on the other hand, can be rewritten using their defining equations while writing proofs.
Logically speaking, partial fixpoints are total functions that don't reduce <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally</a> when applied, but for which equational rewrite rule are provided.
They are <em>partial</em> in the sense that the defining equation does not necessarily specify a value for all possible arguments.</p>
            <p>
              While partial fixpoints do allow functions to be defined that cannot be expressed using structural or well-founded recursion, the technique is also useful in other cases.
Even in cases where the defining equation fully describes the function's behavior and a termination proof using <a href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion">well-founded recursion</a> would be possible, it may simply be more convenient to define the function as a partial fixpoint to avoid a having to write a termination proof.</p>
            <p>
              Defining recursive functions as partial fixpoints only occurs when explicitly requested by annotating the definition with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span>.</p>
            <div class="paragraph">
              <p>
                There are two classes of functions that can be defined as partial fixpoints:</p>
              <ul>
                <li>
                  <p>
                    Tail-recursive functions whose return type is inhabited type</p>
                  </li>
                <li>
                  <p>
                    Functions that return values in a suitable monad, such as the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> monad</p>
                  </li>
                </ul>
              <p>
                Both classes are backed by the same theory and construction: least fixpoints of monotone equations in chain-complete partial orders.</p>
              </div>
            <p>
              Just as with structural and well-founded recursion, Lean allows <a class="technical-term" href="Recursive-Definitions/Mutual-Recursion/#--tech-term-mutually-recursive">mutually recursive</a> functions to be defined as partial fixpoints.
To use this feature, every function definition in a <a class="technical-term" href="Recursive-Definitions/Mutual-Recursion/#--tech-term-mutual-block">mutual block</a> must be annotated with the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span> modifier.</p>
            <details class="example"><summary class="description">Definition by Partial Fixpoint</summary><p>
                The following function finds the least natural number for which the predicate <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.5" data-verso-hover="1289">p</span></code> holds.
If <code>p</code> never holds, then this equation does not specify the behavior: the function <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#find"><span class="const token" data-binding="const-find" data-verso-hover="1290">find</span></a></code> could return <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">42</span></code> or any other <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> in that case and still satisfy the equation.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4611">def</span> <span class="const token" data-binding="const-find" data-verso-hover="1290" id="find">find</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1289">p</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="1291">i</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-4665" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1289">p</span> <span class="var token" data-binding="var-_uniq.21" data-verso-hover="1291">i</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-4665" data-verso-hover="81">then</span></a>
    <span class="var token" data-binding="var-_uniq.21" data-verso-hover="1291">i</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-4665" data-verso-hover="81">else</span></a>
    <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#find"><span class="const token" data-binding="const-find" data-verso-hover="1290">find</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="1289">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="1291">i</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-4709" data-verso-hover="1292">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                The elaborator can prove that functions satisfying the equation exist.
Within Lean's logic, <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#find"><span class="const token" data-binding="const-find" data-verso-hover="1290">find</span></a></code> is defined to be an arbitrary such function.</p>
              </details><section>
              <h2 id="partial-fixpoint-tailrec">
                6.4.1. Tail-Recursive Functions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-fixpoint-tailrec" title="Permalink">🔗</a></span></h2>
              <div class="paragraph">
                <p>
                  A recursive function can be defined as a partial fixpoint if the following two conditions hold:</p>
                <ol start="1">
                  <li>
                    <p>
                      The function's return type is inhabited (as with <a href="Recursive-Definitions/Partial-and-Unsafe-Recursive-Definitions/#partial-unsafe">functions marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span></a>) - either a <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Nonempty___intro"><span class="const token" data-binding="const-Nonempty" data-verso-hover="668">Nonempty</span></a></code> or <code class="hl lean inline" data-lean-context="examples"><a href="Type-Classes/Basic-Classes/#Inhabited___mk"><span class="const token" data-binding="const-Inhabited" data-verso-hover="100">Inhabited</span></a></code> instance works.</p>
                    </li>
                  <li>
                    <p>
                      All recursive calls are in <a class="technical-term" href="Recursive-Definitions/Partial-Fixpoint-Recursion/#--tech-term-tail-position">tail position</a> of the function.</p>
                    </li>
                  </ol>
                <p>
                  An expression is in <span id="--tech-term-tail-position"><em>tail position</em></span> in the function body if it is:</p>
                <ul>
                  <li>
                    <p>
                      the function body itself,</p>
                    </li>
                  <li>
                    <p>
                      the branches of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression that is in tail position,</p>
                    </li>
                  <li>
                    <p>
                      the branches of an <span class="hl lean keyword-of"><code class="hover-info"><code>termIfThenElse : term</code><span class="sep"></span><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></code><a href="Terms/Conditionals/#termIfThenElse"><code class="kw">if</code></a></span> expression that is in tail position, and</p>
                    </li>
                  <li>
                    <p>
                      the body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.let : term</code><span class="sep"></span><code class="docstring">`let` is used to declare a local definition. Example:
```
let x := 1
let y := x + 1
x + y
```
Since functions are first class citizens in Lean, you can use `let` to declare
local functions too.
```
let double := fun x =&gt; 2*x
double (double 3)
```
For recursive definitions, you should use `let rec`.
You can also perform pattern matching using `let`. For example,
assume `p` has type `Nat × Nat`, then you can write
```
let (x, y) := p
x + y
```
</code></code><code class="kw">let</code></span> expression that is in tail position.</p>
                    </li>
                  </ul>
                <p>
                  In particular, the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression, the condition of an <span class="hl lean keyword-of"><code class="hover-info"><code>termIfThenElse : term</code><span class="sep"></span><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></code><a href="Terms/Conditionals/#termIfThenElse"><code class="kw">if</code></a></span> expression and the arguments of functions are not tail positions.</p>
                </div>
              <details class="example"><summary class="description">Loops are Tail Recursive Functions</summary><p>
                  Because the function body itself is a <a class="technical-term" href="Recursive-Definitions/Partial-Fixpoint-Recursion/#--tech-term-tail-position">tail position</a>, the infinitely looping function <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#loop"><span class="const token" data-binding="const-loop" data-verso-hover="1293">loop</span></a></code> is tail recursive.
It can be defined as a partial fixpoint.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6534">def</span> <span class="const token" data-binding="const-loop" data-verso-hover="1293" id="loop">loop</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#loop"><span class="const token" data-binding="const-loop" data-verso-hover="1293">loop</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-6575" data-verso-hover="1292">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code></details><details class="example"><summary class="description">Tail Recursion with Branching</summary><p>
                  <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Array___find"><span class="const token" data-binding="const-Array.find" data-verso-hover="1294">Array.find</span></a></code> could also be constructed using well-founded recursion with a termination proof, but may be more convenient to define using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span>, where no termination proof is needed.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6899">def</span> <span class="const token" data-binding="const-Array.find" data-verso-hover="1294" id="Array___find">Array.find</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="230">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="1291">i</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-6984" data-verso-hover="1150">if</span></a> <span class="var token" data-binding="var-_uniq.65" data-verso-hover="86">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="1291">i</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="230">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="87">size</span></a> <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-6984" data-verso-hover="1150">then</span></a>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7012" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="230">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="1291">i</span><span class="unknown token" data-binding="">]</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7012" data-verso-hover="81">then</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="230">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="1291">i</span><span class="unknown token" data-binding="">]</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7012" data-verso-hover="81">else</span></a>
      <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Array___find"><span class="const token" data-binding="const-Array.find" data-verso-hover="1294">Array.find</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="230">xs</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="1291">i</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <a href="Terms/Conditionals/#termDepIfThenElse"><span class="keyword token" data-binding="kw-occ-termDepIfThenElse-6984" data-verso-hover="1150">else</span></a>
    <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-7100" data-verso-hover="1292">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                  If the result of the recursive call is not just returned, but passed to another function, it is not in tail position and this definition fails.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7328">def</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1295">List.findIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Integers/#Int___ofNat"><span class="const token" data-binding="const-Int" data-verso-hover="71">Int</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-7391" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-7391" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="265">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.63" data-verso-hover="46">x</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.64" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7435" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.63" data-verso-hover="46">x</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7435" data-verso-hover="81">then</span></a>
      <span class="typed token" data-binding="" data-verso-hover="265">0</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7435" data-verso-hover="81">else</span></a>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-7470">have</span> <span class="var token" data-binding="var-_uniq.171" data-verso-hover="265">r</span> <span class="unknown token" data-binding="">:=</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Could not prove 'List.findIndex' to be monotone in its recursive calls:
  Cannot eliminate recursive call `List.findIndex ys p` enclosed in
    let_fun r := ys✝.findIndex p;
    if r = -1 then -1 else r + 1
  </code></span></span><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1295">List.findIndex</span></span> <span class="var token" data-binding="var-_uniq.64" data-verso-hover="51">ys</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span>
      <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7506" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.171" data-verso-hover="265">r</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="265">1</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7506" data-verso-hover="81">then</span></a> <span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="265">1</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-7506" data-verso-hover="81">else</span></a> <span class="var token" data-binding="var-_uniq.171" data-verso-hover="265">r</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="265">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-7535" data-verso-hover="1292">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                  The error message on the recursive call is:</p>
                <div class="error">
                  <pre>Could not prove 'List.findIndex' to be monotone in its recursive calls:
  Cannot eliminate recursive call `List.findIndex ys p` enclosed in
    let_fun r := ys✝.findIndex p;
    if r = -1 then -1 else r + 1
  
</pre></div>
                </details></section>
            <section>
              <h2 id="partial-fixpoint-monadic">
                6.4.2. Monadic functions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-fixpoint-monadic" title="Permalink">🔗</a></span></h2>
              <p>
                Defining a function as a partial fixpoint is more powerful if the function's return type is a monad that is an instance of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.MonoBind" data-verso-hover="1296">Lean.Order.MonoBind</span></code>, such as <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code>.
In this case, recursive call are not restricted to tail-positions, but may also occur inside higher-order monadic functions such as <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1297">bind</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___mapM"><span class="const token" data-binding="const-List.mapM" data-verso-hover="1298">List.mapM</span></a></code>.</p>
              <p>
                The set of higher-order functions for which this works is <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint-theory">extensible</a>, so no exhaustive list is given here.
The aspiration is that a monadic recursive function definition that is built using abstract monadic operations like <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1297">bind</span></a></code>, but that does not open the abstraction of the monad (e.g. by matching on the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> value), is accepted.
In particular, using <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-notation"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</a> should work.</p>
              <details class="example"><summary class="description">Monadic functions</summary><p>
                  The following function implements the Ackermann function in the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> monad, and is accepted without an (explicit or implicit) termination proof:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8936">def</span> <span class="const token" data-binding="const-ack" data-verso-hover="1299">ack</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="7">m</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span>   <span class="var token" data-binding="var-_uniq.37" data-verso-hover="7">y</span>   <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="7">y</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">x</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>   <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-ack" data-verso-hover="1299">ack</span> <span class="var token" data-binding="var-_uniq.153" data-verso-hover="7">x</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.253" data-verso-hover="7">x</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.254" data-verso-hover="7">y</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-9040">do</span></a> <span class="const token" data-binding="const-ack" data-verso-hover="1299">ack</span> <span class="var token" data-binding="var-_uniq.253" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-ack" data-verso-hover="1299">ack</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.253" data-verso-hover="7">x</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.254" data-verso-hover="7">y</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-9067" data-verso-hover="1292">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Recursive calls may also occur within higher-order functions such as <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___mapM"><span class="const token" data-binding="const-List.mapM" data-verso-hover="1298">List.mapM</span></a></code>, if they are set up appropriately, and <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-notation"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</a>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-9294">structure</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1300">Tree</span> <span class="keyword token" data-binding="kw-occ-null-9309">where</span> <span class="const token" data-binding="const-Tree.cs" data-verso-hover="1301" id="Tree___rev___">cs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="const token" data-binding="const-Tree" data-verso-hover="1300">Tree</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9331">def</span> <span class="const token" data-binding="const-Tree.rev" data-verso-hover="1302" id="Tree___rev___">Tree.rev</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.471" data-verso-hover="1303">t</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1300">Tree</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <span class="const token" data-binding="const-Tree" data-verso-hover="1300">Tree</span> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-9372">do</span></a>
  <span class="const token" data-binding="const-Tree.mk" data-verso-hover="1304">Tree.mk</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="var token" data-binding="var-_uniq.471" data-verso-hover="1303">t</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Tree___rev___"><span class="const token" data-binding="const-Tree.cs" data-verso-hover="1301">cs</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___reverse"><span class="const token" data-binding="const-List.reverse" data-verso-hover="109">reverse</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___mapM"><span class="const token" data-binding="const-List.mapM" data-verso-hover="1298">mapM</span></a> <span class="unknown token" data-binding="">(</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Tree___rev___"><span class="const token" data-binding="const-Tree.rev" data-verso-hover="1302">Tree.rev</span></a> <span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-9423" data-verso-hover="1292">partial_fixpoint</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9441">def</span> <span class="const token" data-binding="const-Tree.rev'" data-verso-hover="1305" id="Tree___rev___">Tree.rev'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.998" data-verso-hover="1303">t</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="1300">Tree</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <span class="const token" data-binding="const-Tree" data-verso-hover="1300">Tree</span> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-9483">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-9488">let</span> <span class="keyword token" data-binding="kw-occ-null-9492">mut</span> <span class="var token" data-binding="var-_uniq.1130" data-verso-hover="1306">cs</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-9507" data-verso-hover="1158">for</span> <span class="var token" data-binding="var-_uniq.1124" data-verso-hover="1303">c</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-9511">in</span> <span class="var token" data-binding="var-_uniq.998" data-verso-hover="1303">t</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Tree___rev___"><span class="const token" data-binding="const-Tree.cs" data-verso-hover="1301">cs</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-9507" data-verso-hover="1158">do</span>
    <span class="var token" data-binding="var-_uniq.1130" data-verso-hover="1306">cs</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="var token" data-binding="var-_uniq.1124" data-verso-hover="1303">c</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Tree___rev___"><span class="const token" data-binding="const-Tree.rev'" data-verso-hover="1305">rev'</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.1130" data-verso-hover="1306">cs</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-9555" data-verso-hover="157">return</span> <span class="const token" data-binding="const-Tree.mk" data-verso-hover="1304">Tree.mk</span> <span class="var token" data-binding="var-_uniq.1130" data-verso-hover="1306">cs</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-9573" data-verso-hover="1292">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Pattern matching on the result of the recursive call will prevent the definition by partial fixpoint from going through:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9777">def</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-9847" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-9847" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-9893" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-9893" data-verso-hover="81">then</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-9893" data-verso-hover="81">else</span></a>
      <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-9933" data-verso-hover="52">match</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Could not prove 'List.findIndex' to be monotone in its recursive calls:
  Cannot eliminate recursive call `List.findIndex ys p` enclosed in
    match ys✝.findIndex p with
    | none =&gt; none
    | some r =&gt; some (r + 1)
  </code></span></span><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span></span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-9933" data-verso-hover="52">with</span></a>
      <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
      <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.183" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.183" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-10016" data-verso-hover="1292">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>Could not prove 'List.findIndex' to be monotone in its recursive calls:
  Cannot eliminate recursive call `List.findIndex ys p` enclosed in
    match ys✝.findIndex p with
    | none =&gt; none
    | some r =&gt; some (r + 1)
  
</pre></div>
                <p>
                  In this particular case, using <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308">Functor.map</span></a></code> instead of explicit pattern matching helps:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10391">def</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-10461" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-10461" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-10507" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-10507" data-verso-hover="81">then</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-10507" data-verso-hover="81">else</span></a>
      <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;$&gt;</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-10580" data-verso-hover="1292">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code></details></section>
            <section>
              <h2 id="partial-correctness-theorem">
                6.4.3. Partial Correctness Theorems<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-correctness-theorem" title="Permalink">🔗</a></span></h2>
              <p>
                For every function defined as a partial fixpoint, Lean proves that the defining equation is satisfied.
This enables proofs by rewriting.
However, these equational theorems are not sufficient for reasoning about the behavior of the function on arguments for which the function specification does not terminate.
Code paths that lead to infinite recursion at runtime would end up as infinite chains of rewrites in a potential proof.</p>
              <p>
                Partial fixpoints in suitable monads, on the other hand, provide additional theorems that map the undefined values from non-termination to suitable values in the monad.
In the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> monad, then partial fixpoint equals <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">Option.none</span></a></code> on all function inputs for which the defining equation specifies non-termination.
From this fact, Lean proves a <span id="--tech-term-partial-correctness-theorem"><em>partial correctness theorem</em></span> for the function which allows facts to be concluded when the function's result is <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">Option.some</span></a></code>.</p>
              <details class="example"><summary class="description">Partial Correctness Theorem</summary><p>
                  Recall <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span></code> from an earlier example:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11725">def</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11795" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11795" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span><span class="unknown token" data-binding="">::</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11841" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="46">x</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11841" data-verso-hover="81">then</span></a>
      <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
    <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-11841" data-verso-hover="81">else</span></a>
      <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;$&gt;</span> <span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="51">ys</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="169">p</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.partialFixpoint-11914" data-verso-hover="1292">partial_fixpoint</span>
<span class="unknown token" data-binding=""></span></code><p>
                  With this function definition, Lean automatically proves the following partial correctness theorem:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex.partial_correctness" data-verso-hover="1309">List.findIndex.partial_correctness</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u_1</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-12097" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u_1</span><span class="unknown token" data-binding="">}</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1310">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.271" data-verso-hover="1311">h</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1312">findIndex</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
      <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1310">motive</span> <span class="var token" data-binding="var-_uniq.25" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">r</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
        <span class="unknown token" data-binding="">∀</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.42" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span>
          <span class="unknown token" data-binding="">(</span><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-12347" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.40" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-12347" data-verso-hover="52">with</span></a>
              <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
              <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.81" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.82" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">=&gt;</span>
                <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-12431" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.81" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-12431" data-verso-hover="81">then</span></a> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
                <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-12431" data-verso-hover="81">else</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-12479">fun</span> <span class="var token" data-binding="var-_uniq.141" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.141" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;$&gt;</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.82" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">→</span>
            <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1310">motive</span> <span class="var token" data-binding="var-_uniq.40" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="7">r</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.274" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.276" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="var token" data-binding="var-_uniq.274" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">findIndex</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.276" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">→</span>
    <span class="var token" data-binding="var-_uniq.13" data-verso-hover="1310">motive</span> <span class="var token" data-binding="var-_uniq.274" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.276" data-verso-hover="7">r</span></code><div class="paragraph">
                  <p>
                    Here, the motive is a relation between the parameter and return types of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span></code>, with the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> removed from the return type.
If, when given an arbitrary partial function with a signature that's compatible with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span></code>, the following hold:</p>
                  <ul>
                    <li>
                      <p>
                        the motive is satisfied for all inputs for which the arbitrary function returns a value (rather than <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a></code>),</p>
                      </li>
                    <li>
                      <p>
                        taking one rewriting step with the defining equation, in which the recursive calls are replaced by the arbitrary function, also implies the satisfaction of the motive</p>
                      </li>
                    </ul>
                  <p>
                    then the motive is satsified for all inputs for which the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">List.findIndex</span></code> returns <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a></code>.</p>
                  </div>
                <p>
                  The partial correctness theorem is a reasoning principle.
It can be used to prove that the resulting number is a valid index in the list and that the predicate holds for that index:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-13516">theorem</span> <span class="const token" data-binding="const-List.findIndex_implies_pred" data-verso-hover="1313" id="List___findIndex_implies_pred">List.findIndex_implies_pred</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">findIndex</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">→</span>
    <span class="unknown token" data-binding="">∃</span><span class="var token" data-binding="var-_uniq.86" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">i</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.86" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">∧</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.86" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-16703994356377171746-13660-13662"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-13660" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16703994356377171746-13660-13662"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span>.<span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">findIndex</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-15134129819889766819-13665-13770"><a href="Tactic-Proofs/Tactic-Reference/#apply"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-13665" data-verso-hover="583">apply</span></a> <span class="const token" data-binding="const-List.findIndex.partial_correctness" data-verso-hover="1309">List.findIndex.partial_correctness</span>
          <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-13727">fun</span> <span class="var token" data-binding="var-_uniq.271" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.274" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">∃</span> <span class="var token" data-binding="var-_uniq.279" data-verso-hover="46">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.271" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.274" data-verso-hover="7">i</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span> <span class="unknown token" data-binding="">=</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.279" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">∧</span> <span class="var token" data-binding="var-_uniq.268" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.279" data-verso-hover="46">x</span><span class="unknown token" data-binding="">)</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15134129819889766819-13665-13770"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-161" checked="checked"><span for="--verso-unique-161" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="1312">findIndex</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>),
  (∀ (<span class="var token" data-binding="var-_uniq.7675" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7677" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7675" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7677" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7679" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7675" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7677" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7679" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7679" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a>) →
    ∀ (<span class="var token" data-binding="var-_uniq.7608" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7610" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>),
      (<span class="keyword token" data-binding="">match</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="51">xs</span> <span class="keyword token" data-binding="">with</span>
          | <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">]</span></a> =&gt; <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
          | <span class="var token" data-binding="var-_uniq.7666" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.7667" data-verso-hover="51">ys</span> =&gt; <span class="const token" data-binding="const-ite" data-verso-hover="520">if </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7628" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="const token" data-binding="const-ite" data-verso-hover="520"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="520"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<span class="const token" data-binding="const-ite" data-verso-hover="520"> </span><span class="const token" data-binding="const-ite" data-verso-hover="520">else </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7647" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.7647" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7629" data-verso-hover="51">ys</span>)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
          </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7610" data-verso-hover="7">r</span> →
        <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7612" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7610" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7612" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7612" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-12319846446209893875-13773-13802"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-13773" data-verso-hover="553">intro</span></a> <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span> <span class="var token" data-binding="var-_uniq.471" data-verso-hover="51">xs</span> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span> <span class="var token" data-binding="var-_uniq.477" data-verso-hover="1317">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12319846446209893875-13773-13802"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-162" checked="checked"><span for="--verso-unique-162" class="goal-name">h</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.471" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.477" data-verso-hover="1317">hsome</span></span><span class="colon">:</span><span class="type">(<span class="keyword token" data-binding="">match</span> <span class="var token" data-binding="var-_uniq.471" data-verso-hover="51">xs</span> <span class="keyword token" data-binding="">with</span>
  | <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">]</span></a> =&gt; <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a>
  | <span class="var token" data-binding="var-_uniq.7645" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.7646" data-verso-hover="51">ys</span> =&gt; <span class="const token" data-binding="const-ite" data-verso-hover="520">if </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7607" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="const token" data-binding="const-ite" data-verso-hover="520"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="520"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<span class="const token" data-binding="const-ite" data-verso-hover="520"> </span><span class="const token" data-binding="const-ite" data-verso-hover="520">else </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7626" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.7626" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="51">ys</span>)<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> =
  </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.471" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-18176597347844276682-13805-13819"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-13805" data-verso-hover="523">split</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-13811" data-verso-hover="313">at</span> <span class="var token" data-binding="var-_uniq.477" data-verso-hover="1317">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18176597347844276682-13805-13819"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.648" data-verso-hover="1318">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-164"><span for="--verso-unique-164" class="goal-name">h.h_2</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.651" data-verso-hover="1319">hsome</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="520">(</span><span class="const token" data-binding="const-ite" data-verso-hover="520">if </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x✝</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="const token" data-binding="const-ite" data-verso-hover="520"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="520"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<span class="const token" data-binding="const-ite" data-verso-hover="520"> </span><span class="const token" data-binding="const-ite" data-verso-hover="520">else </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7620" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.7620" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys✝</span><span class="const token" data-binding="const-ite" data-verso-hover="520">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">(</span></a><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x✝</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys✝</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
  <a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.«tacticNext_=>_»-13822" data-verso-hover="1320">next</span></a> <span class="tactic"><label for="tactic-state-5653032334287677772-13827-13829"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5653032334287677772-13827-13829"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.648" data-verso-hover="1318">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">[</span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.nil" data-verso-hover="329">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-13830-13843"><a href="Tactic-Proofs/Tactic-Reference/#contradiction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.contradiction-13830" data-verso-hover="1321">contradiction</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-13830-13843"><span class="tactic-state">All goals completed! 🐙</span></span>
  <a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.«tacticNext_=>_»-13846" data-verso-hover="1320">next</span></a> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span> <span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span> <span class="tactic"><label for="tactic-state-11700763941941574685-13856-13858"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11700763941941574685-13856-13858"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.651" data-verso-hover="1322">hsome</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-ite" data-verso-hover="520">(</span><span class="const token" data-binding="const-ite" data-verso-hover="520">if </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a><span class="const token" data-binding="const-ite" data-verso-hover="520"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="520"> </span><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<span class="const token" data-binding="const-ite" data-verso-hover="520"> </span><span class="const token" data-binding="const-ite" data-verso-hover="520">else </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7620" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.7620" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><span class="const token" data-binding="const-ite" data-verso-hover="520">)</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">(</span></a><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
    <span class="tactic"><label for="tactic-state-9515629488321346935-13863-13877"><a href="Tactic-Proofs/Tactic-Reference/#split"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-13863" data-verso-hover="523">split</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-13869" data-verso-hover="313">at</span> <span class="var token" data-binding="var-_uniq.651" data-verso-hover="1322">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9515629488321346935-13863-13877"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.679" data-verso-hover="1323">h✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.927" data-verso-hover="1324">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">(</span></a><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.674" data-verso-hover="1325">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1092" data-verso-hover="1326">hsome</span></span><span class="colon">:</span><span class="type">(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7618" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.7618" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">(</span></a><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
    <a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.«tacticNext_=>_»-13882" data-verso-hover="1320">next</span></a> <span class="tactic"><label for="tactic-state-7523696603166466572-13887-13889"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7523696603166466572-13887-13889"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.679" data-verso-hover="1323">h✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.927" data-verso-hover="1324">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> 0<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">(</span></a><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
      <a href="Tactic-Proofs/The-Tactic-Language/#have"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-13896" data-verso-hover="1243">have</span></a> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-16703994356377171746-13912-13914"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-13912" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16703994356377171746-13912-13914"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span>.<span class="const token" data-binding="const-List.findIndex" data-verso-hover="1307">findIndex</span> <span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-13915-13923"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-13915" data-verso-hover="557">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-13915-13923"><span class="tactic-state">All goals completed! 🐙</span></span>
      <span class="tactic"><label for="tactic-state-7-13930-13938"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-13930" data-verso-hover="557">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-13930-13938"><span class="tactic-state">All goals completed! 🐙</span></span>
    <a href="Tactic-Proofs/The-Tactic-Language/#next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.«tacticNext_=>_»-13943" data-verso-hover="1320">next</span></a> <span class="tactic"><label for="tactic-state-7278960809539119632-13948-13950"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7278960809539119632-13948-13950"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.674" data-verso-hover="1325">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1092" data-verso-hover="1326">hsome</span></span><span class="colon">:</span><span class="type">(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7618" data-verso-hover="7">x</span> =&gt; <span class="var token" data-binding="var-_uniq.7618" data-verso-hover="7">x</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1)<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308"> &lt;$&gt; </span></a><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">(</span></a><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
      <span class="tactic"><label for="tactic-state-7998035611149369947-13957-14016"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-13957" data-verso-hover="36">simp</span></a> <span class="keyword token" data-binding="kw-occ-null-13962">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Option.map_eq_map" data-verso-hover="1327">Option.map_eq_map</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-Option.map_eq_some'" data-verso-hover="1328">Option.map_eq_some'</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-14008" data-verso-hover="313">at</span> <span class="var token" data-binding="var-_uniq.1092" data-verso-hover="1326">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7998035611149369947-13957-14016"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.674" data-verso-hover="1325">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.5998" data-verso-hover="1329">hsome</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="7">a</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="7">a</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="7">a</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">(</span></a><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.474" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span>
      <span class="tactic"><label for="tactic-state-16249285575312685695-14023-14056"><a href="Tactic-Proofs/Tactic-Reference/#obtain"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-14023" data-verso-hover="1330">obtain</span></a> <span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.6028" data-verso-hover="7">r'</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.6050" data-verso-hover="1331">hr</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.6051" data-verso-hover="1332">rfl</span><span class="unknown token" data-binding="">⟩</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.5998" data-verso-hover="1329">hsome</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16249285575312685695-14023-14056"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-173" checked="checked"><span for="--verso-unique-173" class="goal-name">intro.intro</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span> : <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span>) (<span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span> → <a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.7604" data-verso-hover="51">xs</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.7606" data-verso-hover="7">r</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7608" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.674" data-verso-hover="1325">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6028" data-verso-hover="7">r'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6050" data-verso-hover="1331">hr</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.6028" data-verso-hover="7">r'</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">(</span></a><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.6028" data-verso-hover="7">r'</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
      <span class="tactic"><label for="tactic-state-18122321944351671156-14063-14083"><a href="Tactic-Proofs/Tactic-Reference/#specialize"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.specialize-14063" data-verso-hover="1333">specialize</span></a> <span class="var token" data-binding="var-_uniq.468" data-verso-hover="1316">ih</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.6050" data-verso-hover="1331">hr</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18122321944351671156-14063-14083"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-174" checked="checked"><span for="--verso-unique-174" class="goal-name">intro.intro</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.256" data-verso-hover="7">i</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="51">xs</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span> → <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.488" data-verso-hover="51">xs✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.255" data-verso-hover="44">α</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.674" data-verso-hover="1325">h✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Logical-Connectives/#Not"><span class="const token" data-binding="const-Not" data-verso-hover="526">¬</span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6028" data-verso-hover="7">r'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6050" data-verso-hover="1331">hr</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.465" data-verso-hover="1312">findIndex</span> <span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.6028" data-verso-hover="7">r'</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6072" data-verso-hover="1334">ih</span></span><span class="colon">:</span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.6028" data-verso-hover="7">r'</span><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">∃</span></a><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314"> </span></a><span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Quantifiers/#Exists___intro"><span class="const token" data-binding="const-Exists" data-verso-hover="1314">, </span></a><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">(</span></a><span class="var token" data-binding="var-_uniq.537" data-verso-hover="46">x</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330"> :: </span></a><span class="var token" data-binding="var-_uniq.538" data-verso-hover="51">ys</span><a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List.cons" data-verso-hover="330">)</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">[</span></a><span class="var token" data-binding="var-_uniq.6028" data-verso-hover="7">r'</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">]</span></a><a href="Type-Classes/Basic-Classes/#GetElem______mk"><span class="const token" data-binding="const-GetElem?.getElem?" data-verso-hover="1315">?</span></a><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Logical-Connectives/#And___intro"><span class="const token" data-binding="const-And" data-verso-hover="347"> ∧ </span></a><span class="var token" data-binding="var-_uniq.36" data-verso-hover="169">p</span> <span class="var token" data-binding="var-_uniq.7603" data-verso-hover="46">x_1</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></span></span></span></span></span></span>
      <span class="tactic"><label for="tactic-state-7-14090-14095"><a href="Tactic-Proofs/Tactic-Reference/#simpa"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-14090" data-verso-hover="1335">simpa</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-14090-14095"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></details></section>
            <section>
              <h2 id="mutual-partial-fixpoint">
                6.4.4. Mutual Recursion with Partial Fixpoints<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-partial-fixpoint" title="Permalink">🔗</a></span></h2>
              <p>
                Lean supports the definition of <a class="technical-term" href="Recursive-Definitions/Mutual-Recursion/#--tech-term-mutually-recursive">mutually recursive</a> functions using <a class="technical-term" href="Recursive-Definitions/Partial-Fixpoint-Recursion/#--tech-term-partial-fixpoint">partial fixpoint</a>.
Mutual recursion may be introduced using a <a class="technical-term" href="Recursive-Definitions/Mutual-Recursion/#--tech-term-mutual-block">mutual block</a>, but it also results from <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.letrec : term</code></code><code class="kw">let rec</code></span> expressions and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">where</code></span> blocks.
The rules for mutual well-founded recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the <a href="Recursive-Definitions/Mutual-Recursion/#mutual-syntax">elaboration steps</a> for mutual groups.</p>
              <p>
                If all functions in the mutual group have the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span> clause, then this strategy is used.</p>
              </section>
            <section>
              <h2 id="partial-fixpoint-theory">
                6.4.5. Theory and Construction<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=partial-fixpoint-theory" title="Permalink">🔗</a></span></h2>
              <p>
                The construction builds on a variant of the Knaster–Tarski theorem: In a chain-complete partial order, every monotone function has a least fixed point.</p>
              <p>
                The necessary theory is found in the <code>Lean.Order</code> namespace.
This is not meant to be a general purpose library of order theoretic results.
Instead, the definitions and theorems in <code>Lean.Order</code> are only intended as implementation details of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial_fixpoint</code></span> feature, and they should be considered a private API that may change without notice.</p>
              <p>
                The notion of a partial order, and that of a chain-complete partial order, are represented by the type classes <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1336">Lean.Order.PartialOrder</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1337">Lean.Order.CCPO</span></a></code>, respectively.</p>
              <div class="namedocs" id="Lean___Order___PartialOrder___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.PartialOrder.mk" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block">Lean.Order.PartialOrder.{u} (<span class="var token" data-binding="var-_uniq.216" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>) :
  <span class="sort token" data-binding="" data-verso-hover="96">Sort (max 1 u)</span></pre><div class="text">
                  <p>
                    A partial order is a reflexive, transitive and antisymmetric relation.</p>
                  <p>
                    This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                  <h1>
                    Instance Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.mk" data-verso-hover="1338">Lean.Order.PartialOrder.mk</span></a>.{u}</pre><div class="docs"></div>
                    </section>
                  <h1>
                    Methods</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1339">rel</span> : <span class="var token" data-binding="var-_uniq.144" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.144" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></pre><div class="docs">
                      <p>
                        A “less-or-equal-to” or “approximates” relation.</p>
                      <p>
                        This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                      </div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel_refl" data-verso-hover="1340">rel_refl</span> : ∀ {<span class="var token" data-binding="var-_uniq.149" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.144" data-verso-hover="95">α</span>}, <span class="var token" data-binding="var-_uniq.149" data-verso-hover="46">x</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.149" data-verso-hover="46">x</span></pre><div class="docs"></div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel_trans" data-verso-hover="1342">rel_trans</span> : ∀ {<span class="var token" data-binding="var-_uniq.155" data-verso-hover="46">x </span><span class="var token" data-binding="var-_uniq.157" data-verso-hover="46">y </span><span class="var token" data-binding="var-_uniq.159" data-verso-hover="46">z</span> : <span class="var token" data-binding="var-_uniq.144" data-verso-hover="95">α</span>}, <span class="var token" data-binding="var-_uniq.155" data-verso-hover="46">x</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.157" data-verso-hover="46">y</span> → <span class="var token" data-binding="var-_uniq.157" data-verso-hover="46">y</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="46">z</span> → <span class="var token" data-binding="var-_uniq.155" data-verso-hover="46">x</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.159" data-verso-hover="46">z</span></pre><div class="docs"></div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel_antisymm" data-verso-hover="1343">rel_antisymm</span> : ∀ {<span class="var token" data-binding="var-_uniq.176" data-verso-hover="46">x </span><span class="var token" data-binding="var-_uniq.178" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.144" data-verso-hover="95">α</span>}, <span class="var token" data-binding="var-_uniq.176" data-verso-hover="46">x</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.178" data-verso-hover="46">y</span> → <span class="var token" data-binding="var-_uniq.178" data-verso-hover="46">y</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.176" data-verso-hover="46">x</span> → <span class="var token" data-binding="var-_uniq.176" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.178" data-verso-hover="46">y</span></pre><div class="docs"></div>
                    </section>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Order___CCPO___mk">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.CCPO" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block">Lean.Order.CCPO.{u} (<span class="var token" data-binding="var-_uniq.342" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>) :
  <span class="sort token" data-binding="" data-verso-hover="96">Sort (max 1 u)</span></pre><div class="text">
                  <p>
                    A chain-complete partial order (CCPO) is a partial order where every chain has a least upper bound.</p>
                  <p>
                    This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                  <h1>
                    Instance Constructor</h1>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO.mk" data-verso-hover="1344">Lean.Order.CCPO.mk</span></a>.{u}</pre><div class="docs"></div>
                    </section>
                  <h1>
                    Extends</h1>
                  <ul class="extends">
                    <li>
                      <input type="checkbox" id="0-Lean.Order.PartialOrder-Lean.Order.CCPO" checked="checked" data-parent-idx="0"><label for="0-Lean.Order.PartialOrder-Lean.Order.CCPO"><code class="hl lean inline"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1336">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.231" data-verso-hover="95">α</span></code></label></li>
                    </ul>
                  <h1>
                    Methods</h1>
                  <section class="subdocs" data-inherited-from="0">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">rel</span> : <span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></pre><div class="inheritance docs" data-inherited-from="0">
                      Inherited from <ol>
                        <li>
                          <code class="hl lean inline"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1336">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.231" data-verso-hover="95">α</span></code></li>
                        </ol>
                      </div>
                    <div class="docs"></div>
                    </section>
                  <section class="subdocs" data-inherited-from="0">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">rel_refl</span> : ∀ {<span class="var token" data-binding="var-_uniq.241" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span>}, <span class="var token" data-binding="var-_uniq.241" data-verso-hover="46">x</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.241" data-verso-hover="46">x</span></pre><div class="inheritance docs" data-inherited-from="0">
                      Inherited from <ol>
                        <li>
                          <code class="hl lean inline"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1336">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.231" data-verso-hover="95">α</span></code></li>
                        </ol>
                      </div>
                    <div class="docs"></div>
                    </section>
                  <section class="subdocs" data-inherited-from="0">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">rel_trans</span> : ∀ {<span class="var token" data-binding="var-_uniq.248" data-verso-hover="46">x </span><span class="var token" data-binding="var-_uniq.250" data-verso-hover="46">y </span><span class="var token" data-binding="var-_uniq.252" data-verso-hover="46">z</span> : <span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span>}, <span class="var token" data-binding="var-_uniq.248" data-verso-hover="46">x</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.250" data-verso-hover="46">y</span> → <span class="var token" data-binding="var-_uniq.250" data-verso-hover="46">y</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.252" data-verso-hover="46">z</span> → <span class="var token" data-binding="var-_uniq.248" data-verso-hover="46">x</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.252" data-verso-hover="46">z</span></pre><div class="inheritance docs" data-inherited-from="0">
                      Inherited from <ol>
                        <li>
                          <code class="hl lean inline"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1336">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.231" data-verso-hover="95">α</span></code></li>
                        </ol>
                      </div>
                    <div class="docs"></div>
                    </section>
                  <section class="subdocs" data-inherited-from="0">
                    <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">rel_antisymm</span> : ∀ {<span class="var token" data-binding="var-_uniq.270" data-verso-hover="46">x </span><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span>}, <span class="var token" data-binding="var-_uniq.270" data-verso-hover="46">x</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">y</span> → <span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">y</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.270" data-verso-hover="46">x</span> → <span class="var token" data-binding="var-_uniq.270" data-verso-hover="46">x</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.272" data-verso-hover="46">y</span></pre><div class="inheritance docs" data-inherited-from="0">
                      Inherited from <ol>
                        <li>
                          <code class="hl lean inline"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1336">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.231" data-verso-hover="95">α</span></code></li>
                        </ol>
                      </div>
                    <div class="docs"></div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.CCPO.csup" data-verso-hover="1345">csup</span> : (<span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>) → <span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span></pre><div class="docs">
                      <p>
                        The least upper bound of a chain.</p>
                      <p>
                        This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                      </div>
                    </section>
                  <section class="subdocs">
                    <pre class="name-and-type hl lean"><span class="const token" data-binding="const-Lean.Order.CCPO.csup_spec" data-verso-hover="1346">csup_spec</span> : ∀ {<span class="var token" data-binding="var-_uniq.288" data-verso-hover="46">x</span> : <span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span>} {<span class="var token" data-binding="var-_uniq.290" data-verso-hover="397">c</span> : <span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>}, <span class="const token" data-binding="const-Lean.Order.chain" data-verso-hover="1347">chain</span> <span class="var token" data-binding="var-_uniq.290" data-verso-hover="397">c</span> → <a href="Basic-Propositions/Logical-Connectives/#Iff___intro"><span class="const token" data-binding="const-Iff" data-verso-hover="132">(</span></a><span class="const token" data-binding="const-Lean.Order.CCPO.csup" data-verso-hover="1348">CCPO.csup</span> <span class="var token" data-binding="var-_uniq.290" data-verso-hover="397">c</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.288" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#Iff___intro"><span class="const token" data-binding="const-Iff" data-verso-hover="132"> ↔ </span></a>∀ (<span class="var token" data-binding="var-_uniq.304" data-verso-hover="46">y</span> : <span class="var token" data-binding="var-_uniq.234" data-verso-hover="95">α</span>), <span class="var token" data-binding="var-_uniq.290" data-verso-hover="397">c</span> <span class="var token" data-binding="var-_uniq.304" data-verso-hover="46">y</span> → <span class="var token" data-binding="var-_uniq.304" data-verso-hover="46">y</span><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341"> ⊑ </span></a><span class="var token" data-binding="var-_uniq.288" data-verso-hover="46">x</span><a href="Basic-Propositions/Logical-Connectives/#Iff___intro"><span class="const token" data-binding="const-Iff" data-verso-hover="132">)</span></a></pre><div class="docs"></div>
                    </section>
                  </div>
                </div>
              <p>
                A function is monotone if it preserves partial orders.
That is, if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.368" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">⊑</span> <span class="var token" data-binding="var-_uniq.370" data-verso-hover="46">y</span></code> then <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.393" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.395" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">⊑</span> <span class="var token" data-binding="var-_uniq.393" data-verso-hover="107">f</span> <span class="var token" data-binding="var-_uniq.397" data-verso-hover="46">y</span></code>.
The operator <code>⊑</code> represent <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder.rel" data-verso-hover="1341">Lean.Order.PartialOrder.rel</span></a></code>.</p>
              <div class="namedocs" id="Lean___Order___monotone">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.monotone" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block">Lean.Order.monotone.{u, v} {<span class="var token" data-binding="var-_uniq.443" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>}
  [<a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1336">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.443" data-verso-hover="95">α</span>] {<span class="var token" data-binding="var-_uniq.446" data-verso-hover="104">β</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort v</span>} [<a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___PartialOrder___mk"><span class="const token" data-binding="const-Lean.Order.PartialOrder" data-verso-hover="1336">PartialOrder</span></a> <span class="var token" data-binding="var-_uniq.446" data-verso-hover="104">β</span>]
  (<span class="var token" data-binding="var-_uniq.450" data-verso-hover="107">f</span> : <span class="var token" data-binding="var-_uniq.443" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.446" data-verso-hover="104">β</span>) : <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></pre><div class="text">
                  <p>
                    A function is monotone if it maps related elements to related elements.</p>
                  <p>
                    This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                  </div>
                </div>
              <p>
                The fixpoint of a monotone function can be taken using <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1349">fix</span></a></code>, which indeed constructs a fixpoint, as shown by <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___fix_eq"><span class="const token" data-binding="const-Lean.Order.fix_eq" data-verso-hover="1350">fix_eq</span></a></code>,</p>
              <div class="namedocs" id="Lean___Order___fix">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.fix" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block">Lean.Order.fix.{u} {<span class="var token" data-binding="var-_uniq.581" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>} [<a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1337">CCPO</span></a> <span class="var token" data-binding="var-_uniq.581" data-verso-hover="95">α</span>]
  (<span class="var token" data-binding="var-_uniq.585" data-verso-hover="1351">f</span> : <span class="var token" data-binding="var-_uniq.581" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.581" data-verso-hover="95">α</span>) (<span class="var token" data-binding="var-_uniq.591" data-verso-hover="1352">hmono</span> : <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1353">monotone</span></a> <span class="var token" data-binding="var-_uniq.585" data-verso-hover="1351">f</span>) : <span class="var token" data-binding="var-_uniq.581" data-verso-hover="95">α</span></pre><div class="text">
                  <p>
                    The least fixpoint of a monotone function is the least upper bound of its transfinite iteration.</p>
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1353">monotone</span></a> <span class="var token" data-binding="var-_uniq.528" data-verso-hover="1351">f</span></code> assumption is not strictly necessarily for the definition, but without this the
definition is not very meaningful and it simplifies applying theorems like <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___fix_eq"><span class="const token" data-binding="const-Lean.Order.fix_eq" data-verso-hover="1350">fix_eq</span></a></code> if every use of
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1349">fix</span></a></code> already has the monotonicty requirement.</p>
                  <p>
                    This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Order___fix_eq">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=Lean.Order.fix_eq" title="Permalink">🔗</a></span><span class="label"></span><pre class="signature hl lean block">Lean.Order.fix_eq.{u} {<span class="var token" data-binding="var-_uniq.600" data-verso-hover="95">α</span> : <span class="sort token" data-binding="" data-verso-hover="96">Sort u</span>} [<a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1337">CCPO</span></a> <span class="var token" data-binding="var-_uniq.600" data-verso-hover="95">α</span>]
  {<span class="var token" data-binding="var-_uniq.604" data-verso-hover="1351">f</span> : <span class="var token" data-binding="var-_uniq.600" data-verso-hover="95">α</span> → <span class="var token" data-binding="var-_uniq.600" data-verso-hover="95">α</span>} (<span class="var token" data-binding="var-_uniq.610" data-verso-hover="1352">hf</span> : <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1353">monotone</span></a> <span class="var token" data-binding="var-_uniq.604" data-verso-hover="1351">f</span>) :
  <a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1349">fix</span></a> <span class="var token" data-binding="var-_uniq.604" data-verso-hover="1351">f</span> <span class="var token" data-binding="var-_uniq.610" data-verso-hover="1352">hf</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.604" data-verso-hover="1351">f</span> (<a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1349">fix</span></a> <span class="var token" data-binding="var-_uniq.604" data-verso-hover="1351">f</span> <span class="var token" data-binding="var-_uniq.610" data-verso-hover="1352">hf</span>)</pre><div class="text">
                  <p>
                    The main fixpoint theorem for fixedpoints of monotone functions in chain-complete partial orders.</p>
                  <p>
                    This is intended to be used in the construction of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">partial_fixpoint</span></code>, and not meant to be used otherwise.</p>
                  </div>
                </div>
              <div class="paragraph">
                <p>
                  To construct the partial fixpoint, Lean first synthesizes a suitable <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___CCPO___mk"><span class="const token" data-binding="const-Lean.Order.CCPO" data-verso-hover="1337">CCPO</span></a></code> instance.</p>
                <ul>
                  <li>
                    <p>
                      If the function's result type has a dedicated instance, like <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> has with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.instCCPOOption" data-verso-hover="1354">instCCPOOption</span></code>, this is used together with the instance for the function type, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.instCCPOPi" data-verso-hover="1355">instCCPOPi</span></code>, to construct an instance for the whole function's type.</p>
                    </li>
                  <li>
                    <p>
                      Otherwise, if the function's type can be shown to be inhabited by a witness <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.784" data-verso-hover="46">w</span></code>, then the instance <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.FlatOrder.instCCPO" data-verso-hover="1356">FlatOrder.instCCPO</span></code> for the wrapper type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.FlatOrder" data-verso-hover="1357">FlatOrder</span> <span class="var token" data-binding="var-_uniq.857" data-verso-hover="46">w</span></code> is used. In this order, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.893" data-verso-hover="46">w</span></code> is a least element and all other elements are incomparable.</p>
                    </li>
                  </ul>
                </div>
              <p>
                Next, the recursive calls in the right-hand side of the function definitions are abstracted; this turns into the argument <code>f</code> of <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___fix"><span class="const token" data-binding="const-Lean.Order.fix" data-verso-hover="1349">fix</span></a></code>. The monotonicity requirement is solved by the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1358">monotonicity</span></code> tactic, which applies compositional monotonicity lemmas in a syntax-driven way.</p>
              <p>
                The tactic solves goals of the form <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#Lean___Order___monotone"><span class="const token" data-binding="const-Lean.Order.monotone" data-verso-hover="1353">monotone</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-17711">fun</span> <span class="var token" data-binding="var-_uniq.966" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">…</span> <span class="var token" data-binding="var-_uniq.966" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">…</span><span class="unknown token" data-binding="">)</span></code> using the following steps:</p>
              <ul>
                <li>
                  <p>
                    Applying <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.monotone_const" data-verso-hover="1359">monotone_const</span></code> when there is no dependency on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1063" data-verso-hover="46">x</span></code> left.</p>
                  </li>
                <li>
                  <p>
                    Splitting on <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expressions.</p>
                  </li>
                <li>
                  <p>
                    Splitting on <span class="hl lean keyword-of"><code class="hover-info"><code>termIfThenElse : term</code><span class="sep"></span><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></code><a href="Terms/Conditionals/#termIfThenElse"><code class="kw">if</code></a></span> expressions.</p>
                  </li>
                <li>
                  <p>
                    Moving <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.let : term</code><span class="sep"></span><code class="docstring">`let` is used to declare a local definition. Example:
```
let x := 1
let y := x + 1
x + y
```
Since functions are first class citizens in Lean, you can use `let` to declare
local functions too.
```
let double := fun x =&gt; 2*x
double (double 3)
```
For recursive definitions, you should use `let rec`.
You can also perform pattern matching using `let`. For example,
assume `p` has type `Nat × Nat`, then you can write
```
let (x, y) := p
x + y
```
</code></code><code class="kw">let</code></span> expression to the context, if the value and type do not depend on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1098" data-verso-hover="46">x</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Zeta-reducing a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.let : term</code><span class="sep"></span><code class="docstring">`let` is used to declare a local definition. Example:
```
let x := 1
let y := x + 1
x + y
```
Since functions are first class citizens in Lean, you can use `let` to declare
local functions too.
```
let double := fun x =&gt; 2*x
double (double 3)
```
For recursive definitions, you should use `let rec`.
You can also perform pattern matching using `let`. For example,
assume `p` has type `Nat × Nat`, then you can write
```
let (x, y) := p
x + y
```
</code></code><code class="kw">let</code></span> expression when value and type do depend on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1133" data-verso-hover="46">x</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Applying lemmas annotated with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="" data-verso-hover="1360">partial_fixpoint_monotone</span></code></p>
                  </li>
                </ul>
              <p>
                The following monotonicity lemmas are registered, and should allow recursive calls under the given higher-order functions in the arguments indicated by <code>·</code> (but not the other arguments, shown as <code>_</code>).</p>
              <style>
table#--monotonicity-lemma-table {
  border-collapse: collapse;
}
table#--monotonicity-lemma-table th {
  text-align: center;
}
table#--monotonicity-lemma-table th, table#--monotonicity-lemma-table th p {
  font-family: var(--verso-structure-font-family);
}
table#--monotonicity-lemma-table td:first-child {
  padding-bottom: 0.25em;
  padding-top: 0.25em;
  padding-left: 0;
  padding-right: 1.5em;
}
  </style><table class="tabular" id="--monotonicity-lemma-table"><tr><th><p>
                      Theorem</p>
                    </th><th><p>
                      Pattern</p>
                    </th></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_allM" data-verso-hover="1361">monotone_allM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___allM"><span class="const token" data-binding="const-Array.allM" data-verso-hover="1362">Array.allM</span></a> · _ _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_anyM" data-verso-hover="1363">monotone_anyM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___anyM"><span class="const token" data-binding="const-Array.anyM" data-verso-hover="1364">Array.anyM</span></a> · _ _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_anyM_loop" data-verso-hover="1365">monotone_anyM_loop</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array.anyM.loop" data-verso-hover="1366">Array.anyM.loop</span> · _ _ ⋯ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_array_filterMapM" data-verso-hover="1367">monotone_array_filterMapM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___filterMapM"><span class="const token" data-binding="const-Array.filterMapM" data-verso-hover="1368">Array.filterMapM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_array_forM" data-verso-hover="1369">monotone_array_forM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___forM"><span class="const token" data-binding="const-Array.forM" data-verso-hover="1370">Array.forM</span></a> · _ _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_array_forRevM" data-verso-hover="1371">monotone_array_forRevM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___forRevM"><span class="const token" data-binding="const-Array.forRevM" data-verso-hover="1372">Array.forRevM</span></a> · _ _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findIdxM?" data-verso-hover="1373">monotone_findIdxM?</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findIdxM___"><span class="const token" data-binding="const-Array.findIdxM?" data-verso-hover="1374">Array.findIdxM?</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findM?" data-verso-hover="1375">monotone_findM?</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findM___"><span class="const token" data-binding="const-Array.findM?" data-verso-hover="1376">Array.findM?</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findRevM?" data-verso-hover="1377">monotone_findRevM?</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findRevM___"><span class="const token" data-binding="const-Array.findRevM?" data-verso-hover="1378">Array.findRevM?</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findSomeM?" data-verso-hover="1379">monotone_findSomeM?</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findSomeM___"><span class="const token" data-binding="const-Array.findSomeM?" data-verso-hover="1380">Array.findSomeM?</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_findSomeRevM?" data-verso-hover="1381">monotone_findSomeRevM?</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___findSomeRevM___"><span class="const token" data-binding="const-Array.findSomeRevM?" data-verso-hover="1382">Array.findSomeRevM?</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_flatMapM" data-verso-hover="1383">monotone_flatMapM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___flatMapM"><span class="const token" data-binding="const-Array.flatMapM" data-verso-hover="1384">Array.flatMapM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_foldlM" data-verso-hover="1385">monotone_foldlM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___foldlM"><span class="const token" data-binding="const-Array.foldlM" data-verso-hover="1386">Array.foldlM</span></a> · _ _ _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_foldlM_loop" data-verso-hover="1387">monotone_foldlM_loop</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array.foldlM.loop" data-verso-hover="1388">Array.foldlM.loop</span> · _ _ ⋯ _ _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_foldrM" data-verso-hover="1389">monotone_foldrM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___foldrM"><span class="const token" data-binding="const-Array.foldrM" data-verso-hover="1390">Array.foldrM</span></a> · _ _ _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_foldrM_fold" data-verso-hover="1391">monotone_foldrM_fold</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array.foldrM.fold" data-verso-hover="1392">Array.foldrM.fold</span> · _ _ _ ⋯ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_forIn" data-verso-hover="1393">monotone_forIn</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1394">forIn</span></a> _ _ ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_forIn'" data-verso-hover="1395">monotone_forIn'</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1396">forIn'</span></a> _ _ ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_forIn'_loop" data-verso-hover="1397">monotone_forIn'_loop</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array.forIn'.loop" data-verso-hover="1398">Array.forIn'.loop</span> _ · _ ⋯ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_mapFinIdxM" data-verso-hover="1399">monotone_mapFinIdxM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">_.<a href="Basic-Types/Arrays/#Array___mapFinIdxM"><span class="const token" data-binding="const-Array.mapFinIdxM" data-verso-hover="1400">mapFinIdxM</span></a> ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_mapM" data-verso-hover="1401">monotone_mapM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___mapM"><span class="const token" data-binding="const-Array.mapM" data-verso-hover="1402">Array.mapM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Array.monotone_modifyM" data-verso-hover="1403">monotone_modifyM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">_.<a href="Basic-Types/Arrays/#Array___modifyM"><span class="const token" data-binding="const-Array.modifyM" data-verso-hover="1404">modifyM</span></a> _ ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Functor.monotone_map" data-verso-hover="1405">monotone_map</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">_<a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308"> &lt;$&gt; </span></a>·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_allM" data-verso-hover="1406">monotone_allM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___allM"><span class="const token" data-binding="const-List.allM" data-verso-hover="1407">List.allM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_anyM" data-verso-hover="1408">monotone_anyM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___anyM"><span class="const token" data-binding="const-List.anyM" data-verso-hover="1409">List.anyM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_filterAuxM" data-verso-hover="1410">monotone_filterAuxM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.filterAuxM" data-verso-hover="1411">List.filterAuxM</span> · _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_filterM" data-verso-hover="1412">monotone_filterM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___filterM"><span class="const token" data-binding="const-List.filterM" data-verso-hover="1413">List.filterM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_filterRevM" data-verso-hover="1414">monotone_filterRevM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___filterRevM"><span class="const token" data-binding="const-List.filterRevM" data-verso-hover="1415">List.filterRevM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_findM?" data-verso-hover="1416">monotone_findM?</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___findM___"><span class="const token" data-binding="const-List.findM?" data-verso-hover="1417">List.findM?</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_findSomeM?" data-verso-hover="1418">monotone_findSomeM?</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___findSomeM___"><span class="const token" data-binding="const-List.findSomeM?" data-verso-hover="1419">List.findSomeM?</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_foldlM" data-verso-hover="1420">monotone_foldlM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___foldlM"><span class="const token" data-binding="const-List.foldlM" data-verso-hover="1421">List.foldlM</span></a> · _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_foldrM" data-verso-hover="1422">monotone_foldrM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___foldrM"><span class="const token" data-binding="const-List.foldrM" data-verso-hover="1423">List.foldrM</span></a> · _ _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_forIn" data-verso-hover="1424">monotone_forIn</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1394">forIn</span></a> _ _ ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_forIn'" data-verso-hover="1425">monotone_forIn'</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1396">forIn'</span></a> _ _ ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_forIn'_loop" data-verso-hover="1426">monotone_forIn'_loop</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.forIn'.loop" data-verso-hover="1427">List.forIn'.loop</span> _ · _ _ ⋯</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_forM" data-verso-hover="1428">monotone_forM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">_.<a href="Basic-Types/Linked-Lists/#List___forM"><span class="const token" data-binding="const-List.forM" data-verso-hover="1429">forM</span></a> ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.List.monotone_mapM" data-verso-hover="1430">monotone_mapM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___mapM"><span class="const token" data-binding="const-List.mapM" data-verso-hover="1298">List.mapM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Option.monotone_bindM" data-verso-hover="1431">monotone_bindM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___bindM"><span class="const token" data-binding="const-Option.bindM" data-verso-hover="1432">Option.bindM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Option.monotone_elimM" data-verso-hover="1433">monotone_elimM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___elimM"><span class="const token" data-binding="const-Option.elimM" data-verso-hover="1434">Option.elimM</span></a> · · ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Option.monotone_getDM" data-verso-hover="1435">monotone_getDM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">_.<a href="Basic-Types/Optional-Values/#Option___getDM"><span class="const token" data-binding="const-Option.getDM" data-verso-hover="1436">getDM</span></a> ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Option.monotone_mapM" data-verso-hover="1437">monotone_mapM</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___mapM"><span class="const token" data-binding="const-Option.mapM" data-verso-hover="1438">Option.mapM</span></a> · _</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.PProd.monotone_fst" data-verso-hover="1439">monotone_fst</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">·.<a href="Basic-Types/Tuples/#PProd___mk"><span class="const token" data-binding="const-PProd.fst" data-verso-hover="1440">fst</span></a></code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.PProd.monotone_mk" data-verso-hover="1441">monotone_mk</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">⟨·, ·⟩</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.PProd.monotone_snd" data-verso-hover="1442">monotone_snd</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">·.<a href="Basic-Types/Tuples/#PProd___mk"><span class="const token" data-binding="const-PProd.snd" data-verso-hover="1443">snd</span></a></code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.Seq.monotone_seq" data-verso-hover="1444">monotone_seq</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">· &lt;*&gt; ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.SeqLeft.monotone_seqLeft" data-verso-hover="1445">monotone_seqLeft</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">· &lt;* ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.SeqRight.monotone_seqRight" data-verso-hover="1446">monotone_seqRight</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">· *&gt; ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.monotone_bind" data-verso-hover="1447">monotone_bind</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples">·<a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1297"> &gt;&gt;= </span></a>·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.monotone_dite" data-verso-hover="1448">monotone_dite</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dite" data-verso-hover="1449">dite</span> _ · ·</code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Order.monotone_ite" data-verso-hover="1450">monotone_ite</span></code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ite" data-verso-hover="520">if </span>_<span class="const token" data-binding="const-ite" data-verso-hover="520"> then</span><span class="const token" data-binding="const-ite" data-verso-hover="520"> </span>·<span class="const token" data-binding="const-ite" data-verso-hover="520"> </span><span class="const token" data-binding="const-ite" data-verso-hover="520">else </span>·</code></p>
                    </td></tr></table></section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion" rel="prev" title="6.3. Well-Founded Recursion"><span class="arrow">←</span><span class="where">6.3. Well-Founded Recursion</span></a><a class="local-button active" href="Recursive-Definitions/Partial-and-Unsafe-Recursive-Definitions/#partial-unsafe" rel="next" title="6.5. Partial and Unsafe Recursive Definitions"><span class="where">6.5. Partial and Unsafe Recursive Definitions</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

