<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Structural Recursion</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 5%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
dl.toml-table-field-spec {
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
div.planned {
  font-style: italic;
}
div.planned .label {
  font-size: large;
  text-align: center;
  font-family: var(--verso-structure-font-family);
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: larger;
  margin-top: 0;
  margin-left: 1.5em;
  margin-right: 1.5em;
  margin-bottom: 0.5em;
  display: inline-block;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>.example {
  padding: 1.5em;
  border: 1px solid #98B2C0;
  border-radius: 0.5em;
  margin-bottom: 0.75em;
  margin-top: 0.75em;
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example p:last-child {margin-bottom:0;}
.example .description::before {
  content: "Example: ";
}
.example[open] .description {
  margin-bottom: 1em;
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 2px #99b3c0;
  background-color: #99b3c0;
  padding-left: 1px;
  padding-right: 1px;
  padding-bottom: 1px;
  padding-top: 1.5rem;
  margin-bottom: 1rem;
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  background-color: white;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 1.5rem;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: 1.5rem !important;
  margin-right: 1.5rem;
}

.namedocs .label {
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  right: 0.5rem;
  top: 0.5rem;
}

/* Sticking content into the right margin is not good on narrow screens,
   so move the label to the left to make space for the permalink widget. */

@media screen and (max-width: 700px) {
  .namedocs:has(.permalink-widget.block) .label {
    right: 1.5rem;
  }
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold;
}

.namedocs > .text .constructor {
  padding-left: 0.5rem;
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: 1.5rem;
}
.namedocs .text > :last-child {
  margin-bottom: 1.5rem;
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files/#The-Lean-Language-Reference--Source-Files">Source Files</a></td></tr><tr class="current numbered"><td class="num">6.</td><td><a href="Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="Output-from-Lean/#The-Lean-Language-Reference--Output-from-Lean">Output from Lean</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Elan/#elan">Elan</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-recursive-definitions" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-recursive-definitions" checked="checked"></label><span class="number">6.</span> <span class=""><a href="Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></span></div>
              <table><tr class="numbered"><td class="num">6.1.</td><td><a href="Recursive-Definitions/Mutual-Recursion/#mutual-syntax">Mutual Recursion</a></td></tr><tr class="current numbered"><td class="num">6.2.</td><td><a href="Recursive-Definitions/Structural-Recursion/#structural-recursion">Structural Recursion</a></td></tr><tr class="numbered"><td class="num">6.3.</td><td><a href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion">Well-Founded Recursion</a></td></tr><tr class="numbered"><td class="num">6.4.</td><td><a href="Recursive-Definitions/Partial-Fixpoint-Recursion/#partial-fixpoint">Partial Fixpoint Recursion</a></td></tr><tr class="numbered"><td class="num">6.5.</td><td><a href="Recursive-Definitions/Partial-and-Unsafe-Recursive-Definitions/#partial-unsafe">Partial and Unsafe Recursive Definitions</a></td></tr><tr class="numbered"><td class="num">6.6.</td><td><a href="Recursive-Definitions/Controlling-Reduction/#The-Lean-Language-Reference--Recursive-Definitions--Controlling-Reduction">Controlling Reduction</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-structural-recursion" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-structural-recursion" checked="checked"></label><span class="number">6.2.</span> <span class="current"><a href="Recursive-Definitions/Structural-Recursion/#structural-recursion">Structural Recursion</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Recursive-Definitions/Structural-Recursion/#The-Lean-Language-Reference--Recursive-Definitions--Structural-Recursion--Explicit-Structural-Recursion">Explicit Structural Recursion</a></span></li>
                <li>
                  <a href="Recursive-Definitions/Structural-Recursion/#Lean___Parser___Termination___terminationBy-next"><span class="syntax"><span class="keyword">termination_by</span><span class="ws"> </span><span class="keyword">structural</span><span class="ws"> </span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Recursive-Definitions/Structural-Recursion/#mutual-structural-recursion">Mutual Structural Recursion</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Recursive-Definitions/Structural-Recursion/#inferring-structural-recursion">Inferring Structural Recursion</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Recursive-Definitions/Structural-Recursion/#elab-as-course-of-values">Elaboration Using Course-of-Values Recursion</a></span></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Recursive-Definitions/Mutual-Recursion/#mutual-syntax" rel="prev" title="6.1. Mutual Recursion"><span class="arrow">←</span><span class="where">6.1. Mutual Recursion</span></a><a class="local-button active" href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion" rel="next" title="6.3. Well-Founded Recursion"><span class="where">6.3. Well-Founded Recursion</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              6.2. Structural Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=structural-recursion" title="Permalink">🔗</a></span></h1>
            <p>
              Structurally recursive functions are those in which each recursive call is on a structurally smaller term than the argument.
The same parameter must decrease in all recursive calls; this parameter is called the <span id="--tech-term-decreasing-parameter"><em>decreasing parameter</em></span>.
Structural recursion is stronger than the primitive recursion that recursors provide, because the recursive call can use more deeply nested sub-terms of the argument, rather than only an immediate sub-term.
The constructions used to implement structural recursion are, however, implemented using the recursor; these helper constructions are described in the <a href="The-Type-System/Inductive-Types/#recursor-elaboration-helpers">section on inductive types</a>.</p>
            <p>
              The rules that govern structural recursion are fundamentally <em>syntactic</em> in nature.
There are many recursive definitions that exhibit structurally recursive computational behavior, but which are not accepted by these rules; this is a fundamental consequence of the analysis being fully automatic.
<a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-recursion-next">Well-founded recursion</a> provides a semantic approach to demonstrating termination that can be used in situations where a recursive function is not structurally recursive, but it can also be used when a function that computes according to structural recursion doesn't satisfy the syntactic requirements.</p>
            <details class="example"><summary class="description">Structural Recursion vs Subtraction</summary><p>
                The function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-countdown" data-verso-hover="1036">countdown</span></code> is structurally recursive.
The parameter <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.7" data-verso-hover="7">n</span></code> was matched against the pattern <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span></code>, which means that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.72" data-verso-hover="7">n'</span></code> is a direct subterm of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.74" data-verso-hover="7">n</span></code> in the second branch of the pattern match:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2143">def</span> <span class="const token" data-binding="const-countdown" data-verso-hover="1036">countdown</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2183" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2183" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.99" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.99" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown" data-verso-hover="1036">countdown</span> <span class="var token" data-binding="var-_uniq.99" data-verso-hover="7">n'</span>
<span class="unknown token" data-binding=""></span></code><p>
                Replacing pattern matching with an equivalent Boolean test and subtraction results in an error:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2403">def</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">fail to show termination for
  countdown'
with errors
failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    countdown' n'


failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
n : Nat
h✝ : ¬(n == 0) = true
n' : Nat := n - 1
⊢ n - 1 &lt; n</code></span></span><span class="const token" data-binding="const-countdown'" data-verso-hover="1037">countdown'</span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-2444" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">==</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-2444" data-verso-hover="81">then</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-2444" data-verso-hover="81">else</span></a>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-2473" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.195" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
    <span class="var token" data-binding="var-_uniq.195" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown'" data-verso-hover="1037">countdown'</span> <span class="var token" data-binding="var-_uniq.195" data-verso-hover="7">n'</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                <pre>fail to show termination for
  countdown'
with errors
failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    countdown' n'


failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
n : Nat
h✝ : ¬(n == 0) = true
n' : Nat := n - 1
⊢ n - 1 &lt; n
</pre></div>
              <p>
                This is because there was no pattern matching on the parameter <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.78" data-verso-hover="7">n</span></code>.
While this function indeed terminates, the argument that it does so is based on properties of if, the equality test, and subtraction, rather than being a generic feature of <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> being an <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Inductive-types">inductive type</a>.
These arguments are expressed using <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-recursion-next">well-founded recursion</a>, and a slight change to the function definition allows Lean's automatic support for well-founded recursion to construct an alternative termination proof.
This version branches on the decidability of <a class="technical-term" href="Basic-Propositions/Propositional-Equality/#--tech-term-Propositional-equality">propositional equality</a> for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> rather than the result of a Boolean equality test:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3716">def</span> <span class="const token" data-binding="const-countdown'" data-verso-hover="1037">countdown'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3757" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3757" data-verso-hover="81">then</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-3757" data-verso-hover="81">else</span></a>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3785" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.100" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">-</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
    <span class="var token" data-binding="var-_uniq.100" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown'" data-verso-hover="1037">countdown'</span> <span class="var token" data-binding="var-_uniq.100" data-verso-hover="7">n'</span>
<span class="unknown token" data-binding=""></span></code><p>
                Here, Lean's automation automatically constructs a termination proof from facts about propositional equality and subtraction.
It uses well-founded recursion rather than structure recursion behind the scenes.</p>
              </details><p>
              Structural recursion may be used explicitly or automatically.
With explicit structural recursion, the function definition declares which parameter is the <a class="technical-term" href="Recursive-Definitions/Structural-Recursion/#--tech-term-decreasing-parameter">decreasing parameter</a>.
If no termination strategy is explicitly declared, Lean performs a search for a decreasing parameter as well as a decreasing measure for use with <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-recursion-next">well-founded recursion</a>.
Explicitly annotating structural recursion has the following benefits:</p>
            <ul>
              <li>
                <p>
                  It can speed up elaboration, because no search occurs.</p>
                </li>
              <li>
                <p>
                  It documents the termination argument for readers.</p>
                </li>
              <li>
                <p>
                  In situations where structural recursion is explicitly desired, it prevents the accidental use of well-founded recursion.</p>
                </li>
              </ul>
            <section>
              <h2 id="The-Lean-Language-Reference--Recursive-Definitions--Structural-Recursion--Explicit-Structural-Recursion">
                6.2.1. Explicit Structural Recursion</h2>
              <p>
                To explicitly use structural recursion, a function or theorem definition can be annotated with a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by structural</code></span> clause that specifies the <a class="technical-term" href="Recursive-Definitions/Structural-Recursion/#--tech-term-decreasing-parameter">decreasing parameter</a>.
The decreasing parameter may be a reference to a parameter named in the signature.
When the signature specifies a function type, the decreasing parameter may additionally be a parameter not named in the signature; in this case, names for the remaining parameters may be introduced by writing them before an arrow (<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">=&gt;</code></span>).</p>
              <details class="example"><summary class="description">Specifying Decreasing Parameters</summary><p>
                  When the decreasing parameter is a named parameter to the function, it can be specified by referring to its name.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5554">def</span> <span class="const token" data-binding="const-half" data-verso-hover="1038">half</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-5584" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-5584" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="1038">half</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-5636" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-5651">structural</span> <span class="var token" data-binding="var-_uniq.225" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                  When the decreasing parameter is not named in the signature, a name can be introduced locally in the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">termination_by</code></span> clause.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5863">def</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-5925" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-5940">structural</span> <span class="var token" data-binding="var-_uniq.230" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.230" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code></details><div class="namedocs" id="Lean___Parser___Termination___terminationBy">
                <span class="label">syntax</span><span class="title">Explicit Structural Recursion</span><div class="text">
                  <p>
                    The <code>termination_by structural</code> clause introduces a decreasing parameter.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Termination___terminationBy-next"><span class="nonterminal documented" data-kind="Lean.Parser.Termination.terminationBy"><code class="hover-info"><code class="docstring">Specify a termination measure for recursive functions.
```
termination_by a - b
```
indicates that termination of the currently defined recursive function follows
because the difference between the arguments `a` and `b` decreases.

If the function takes further argument after the colon, you can name them as follows:
```
def example (a : Nat) : Nat → Nat → Nat :=
termination_by b c =&gt; a - b
```

By default, a `termination_by` clause will cause the function to be constructed using well-founded
recursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the `termination_by` clause must be one of the function's parameters.

If omitted, a termination measure will be inferred. If written as `termination_by?`,
the inferrred termination measure will be suggested.

</code></code>terminationBy</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.terminationBy"><code class="hover-info"><code class="docstring">Specify a termination measure for recursive functions.
```
termination_by a - b
```
indicates that termination of the currently defined recursive function follows
because the difference between the arguments `a` and `b` decreases.

If the function takes further argument after the colon, you can name them as follows:
```
def example (a : Nat) : Nat → Nat → Nat :=
termination_by b c =&gt; a - b
```

By default, a `termination_by` clause will cause the function to be constructed using well-founded
recursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the `termination_by` clause must be one of the function's parameters.

If omitted, a termination measure will be inferred. If written as `termination_by?`,
the inferrred termination measure will be suggested.

</code></code><span class="keyword">termination_by</span> <span class="from-nonterminal" data-kind="null"><span class="keyword">structural</span> </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span><span class="bnf">*</span> </span><span class="keyword">=&gt;</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                    The identifiers before the optional <code>=&gt;</code> can bring function parameters into scope that are not
already bound in the declaration header, and the mandatory term must indicate one of the function's parameters, whether introduced in the header or locally in the clause.</p>
                  </div>
                </div>
              <p>
                The decreasing parameter must satisfy the following conditions:</p>
              <ul>
                <li>
                  <p>
                    Its type must be an <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-Inductive-types">inductive type</a>.</p>
                  </li>
                <li>
                  <p>
                    If its type is an <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-indexed-families">indexed family</a>, then all indices must be parameters of the function.</p>
                  </li>
                <li>
                  <p>
                    If the inductive or indexed family of the decreasing parameter has data type parameters, then these data type parameters may themselves only depend on function parameters that are part of the <a class="technical-term" href="Recursive-Definitions/Structural-Recursion/#--tech-term-fixed-prefix">fixed prefix</a>.</p>
                  </li>
                </ul>
              <p>
                A <span id="--tech-term-fixed-parameter"><em>fixed parameter</em></span> is a function parameter that is passed unmodified in all recursive calls and is not an index of the recursive parameter's type.
The <span id="--tech-term-fixed-prefix"><em>fixed prefix</em></span> is the longest prefix of the function's parameters in which all are fixed.</p>
              <details class="example"><summary class="description">Ineligible decreasing parameters</summary><p>
                  The decreasing parameter's type must be an inductive type.
In <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#notInductive"><span class="const token" data-binding="const-notInductive" data-verso-hover="1041">notInductive</span></a></code>, a function is specified as the decreasing parameter:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7388">def</span> <span class="const token" data-binding="const-notInductive" data-verso-hover="1041" id="notInductive">notInductive</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1042">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Recursive-Definitions/Structural-Recursion/#notInductive"><span class="const token" data-binding="const-notInductive" data-verso-hover="1041">notInductive</span></a> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-7446">fun</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="1042">x</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">cannot use specified measure for structural recursion:
  its type is not an inductive</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-7464" data-verso-hover="1039">termination_by</span></span> <span class="keyword token" data-binding="kw-occ-null-7479">structural</span> <span class="var token" data-binding="var-_uniq.71" data-verso-hover="1042">x</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>cannot use specified measure for structural recursion:
  its type is not an inductive
</pre></div>
                <p>
                  If the decreasing parameter is an indexed family, all the indices must be variables.
In <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#Fin______zero"><span class="const token" data-binding="const-constantIndex" data-verso-hover="1043">constantIndex</span></a></code>, the indexed family <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="1044">Fin'</span></a></code> is instead applied to a constant value:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-7837" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Fin'" data-verso-hover="1044" id="Fin______zero">Fin'</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="keyword token" data-binding="kw-occ-null-7867">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Fin'.zero" data-verso-hover="1045" id="Fin______zero">zero</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="1044">Fin'</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Fin'.succ" data-verso-hover="1046" id="Fin______zero">succ</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="1044">Fin'</span></a> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">→</span> <a href="Recursive-Definitions/Structural-Recursion/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="1044">Fin'</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.74" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7929">def</span> <span class="const token" data-binding="const-constantIndex" data-verso-hover="1043" id="Fin______zero">constantIndex</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.475" data-verso-hover="1047">x</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#Fin______zero"><span class="const token" data-binding="const-Fin'" data-verso-hover="1044">Fin'</span></a> <span class="typed token" data-binding="" data-verso-hover="7">100</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Recursive-Definitions/Structural-Recursion/#Fin______zero"><span class="const token" data-binding="const-constantIndex" data-verso-hover="1043">constantIndex</span></a> <a href="Recursive-Definitions/Structural-Recursion/#Fin______zero"><span class="const token" data-binding="const-Fin'.zero" data-verso-hover="1045">.zero</span></a>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">cannot use specified measure for structural recursion:
  its type Fin' is an inductive family and indices are not variables
    Fin' 100</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-7991" data-verso-hover="1039">termination_by</span></span> <span class="keyword token" data-binding="kw-occ-null-8006">structural</span> <span class="var token" data-binding="var-_uniq.482" data-verso-hover="1047">x</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>cannot use specified measure for structural recursion:
  its type Fin' is an inductive family and indices are not variables
    Fin' 100
</pre></div>
                <p>
                  The parameters of the decreasing parameter's type must not depend on function parameters that come after varying parameters or indices.
In <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#WithParam______zero"><span class="const token" data-binding="const-afterVarying" data-verso-hover="1048">afterVarying</span></a></code>, the <a class="technical-term" href="Recursive-Definitions/Structural-Recursion/#--tech-term-fixed-prefix">fixed prefix</a> is empty, because the first parameter <code>n</code> varies, so <code>p</code> is not part of the fixed prefix:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-8506" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-WithParam'" data-verso-hover="1049" id="WithParam______zero">WithParam'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">p</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="50">Type</span> <span class="keyword token" data-binding="kw-occ-null-8552">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-WithParam'.zero" data-verso-hover="1050" id="WithParam______zero">zero</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#WithParam______zero"><span class="const token" data-binding="const-WithParam'" data-verso-hover="1049">WithParam'</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-WithParam'.succ" data-verso-hover="1051" id="WithParam______zero">succ</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#WithParam______zero"><span class="const token" data-binding="const-WithParam'" data-verso-hover="1049">WithParam'</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">p</span> <span class="var token" data-binding="var-_uniq.77" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">→</span> <a href="Recursive-Definitions/Structural-Recursion/#WithParam______zero"><span class="const token" data-binding="const-WithParam'" data-verso-hover="1049">WithParam'</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.77" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>

<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter x:
  failed to eliminate recursive application
    afterVarying (n + 1) p WithParam'.zero
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8638">def</span></span> <span class="const token" data-binding="const-afterVarying" data-verso-hover="1048" id="WithParam______zero">afterVarying</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.529" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.531" data-verso-hover="7">p</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.533" data-verso-hover="1052">x</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#WithParam______zero"><span class="const token" data-binding="const-WithParam'" data-verso-hover="1049">WithParam'</span></a> <span class="var token" data-binding="var-_uniq.531" data-verso-hover="7">p</span> <span class="var token" data-binding="var-_uniq.529" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Recursive-Definitions/Structural-Recursion/#WithParam______zero"><span class="const token" data-binding="const-afterVarying" data-verso-hover="1048">afterVarying</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.529" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.531" data-verso-hover="7">p</span> <a href="Recursive-Definitions/Structural-Recursion/#WithParam______zero"><span class="const token" data-binding="const-WithParam'.zero" data-verso-hover="1050">.zero</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-8734" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-8749">structural</span> <span class="var token" data-binding="var-_uniq.612" data-verso-hover="1052">x</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>failed to infer structural recursion:
Cannot use parameter x:
  failed to eliminate recursive application
    afterVarying (n + 1) p WithParam'.zero
</pre></div>
                </details><p>
                Furthermore, every recursive call of the functions must be on a <span id="--tech-term-strict-sub-term"><em>strict sub-term</em></span> of the decreasing
parameter.</p>
              <ul>
                <li>
                  <p>
                    The decreasing parameter itself is a sub-term, but not a strict sub-term.</p>
                  </li>
                <li>
                  <p>
                    If a sub-term is the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression or other pattern-matching syntax, the pattern that matches the discriminant is a sub-term in the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-right-hand-side">right-hand side</a> of each <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-alternatives">match alternative</a>.
   In particular, the rules of <a href="Terms/Pattern-Matching/#match-generalization">match generalization</a> are used to connect the discriminant to the occurrences of the pattern term in the right-hand side; thus, it respects <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitional equality</a>.
   The pattern is a <em>strict</em> sub-term if and only if the discriminant is a strict sub-term.</p>
                  </li>
                <li>
                  <p>
                    If a sub-term is a constructor applied to arguments, then its recursive arguments are strict sub-terms.</p>
                  </li>
                </ul>
              <details class="example"><summary class="description">Nested Patterns and Sub-Terms</summary><p>
                  In the following example, the decreasing parameter <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.96" data-verso-hover="7">n</span></code> is matched against the nested pattern <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span></code>. Therefore <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.101" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span></code> is a (non-strict) sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.104" data-verso-hover="7">n</span></code>, and consequently  both <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.107" data-verso-hover="7">n</span></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">n</span></code> are strict sub-terms, and the definition is accepted.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10336">def</span> <span class="const token" data-binding="const-fib" data-verso-hover="1053">fib</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>  <span class="const token" data-binding="const-fib" data-verso-hover="1053">fib</span> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-fib" data-verso-hover="1053">fib</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-10419" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-10434">structural</span> <span class="var token" data-binding="var-_uniq.168" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.168" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                  For clarity, this example uses <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.113" data-verso-hover="7">n</span></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span></code> instead of the equivalent <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>-specific <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.121" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">1</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.178" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="7">2</span></code>.</p>
                </details><details class="example"><summary class="description">Matching on Complex Expressions Can Prevent Elaboration</summary><p>
                  In the following example, the decreasing parameter <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.217" data-verso-hover="7">n</span></code> is not directly the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression.
Therefore, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.228" data-verso-hover="7">n'</span></code> is not considered a sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.235" data-verso-hover="7">n</span></code>.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    half n'
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11205">def</span></span> <span class="const token" data-binding="const-half" data-verso-hover="1038">half</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11235" data-verso-hover="52">match</span></a> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">Option.some</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11235" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">.some</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="1038">half</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-11305" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-11320">structural</span> <span class="var token" data-binding="var-_uniq.246" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    half n'
</pre></div>
                <p>
                  Using <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-recursion-next">well-founded recursion</a>, and explicitly connecting the discriminant to the pattern of the match, this definition can be accepted.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11636">def</span> <span class="const token" data-binding="const-half" data-verso-hover="1038">half</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11666" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.99" data-verso-hover="1054">h</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">Option.some</span></a> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-11666" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">.some</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="1038">half</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-11740" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.274" data-verso-hover="7">n</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.decreasingBy-11757" data-verso-hover="1055">decreasing_by</span> <span class="tactic"><label for="tactic-state-11507949139507674980-11771-11779"><a href="Tactic-Proofs/Tactic-Reference/#simp_all"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpAll-11771" data-verso-hover="557">simp_all</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11507949139507674980-11771-11779"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.358" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.380" data-verso-hover="7">n'</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.1512" data-verso-hover="1056">h</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.358" data-verso-hover="7">n</span><a href="Basic-Propositions/Propositional-Equality/#Eq___refl"><span class="const token" data-binding="const-Eq" data-verso-hover="16"> = </span></a><span class="var token" data-binding="var-_uniq.380" data-verso-hover="7">n'</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.380" data-verso-hover="7">n'</span><a href="Type-Classes/Basic-Classes/#LT___mk"><span class="const token" data-binding="const-LT.lt" data-verso-hover="521"> &lt; </span></a><span class="var token" data-binding="var-_uniq.380" data-verso-hover="7">n'</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1</span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-11781-11786"><a href="Tactic-Proofs/Tactic-Reference/#omega"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-11781" data-verso-hover="320">omega</span></a></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-11781-11786"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                  Similarly, the following example fails: although <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.249" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___tail"><span class="const token" data-binding="const-List.tail" data-verso-hover="1057">tail</span></a></code> would reduce to a strict sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.263" data-verso-hover="51">xs</span></code>, this is not visible to Lean according to the rules above.
In particular, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.272" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___tail"><span class="const token" data-binding="const-List.tail" data-verso-hover="1057">tail</span></a></code> is not <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally equal</a> to a strict sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.285" data-verso-hover="51">xs</span></code>.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter #2:
  failed to eliminate recursive application
    listLen xs.tail
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-12137">def</span></span> <span class="const token" data-binding="const-listLen" data-verso-hover="1058" id="listLen">listLen</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Recursive-Definitions/Structural-Recursion/#listLen"><span class="const token" data-binding="const-listLen" data-verso-hover="1058">listLen</span></a> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___tail"><span class="const token" data-binding="const-List.tail" data-verso-hover="1057">tail</span></a> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-12209" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-12224">structural</span> <span class="var token" data-binding="var-_uniq.168" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.168" data-verso-hover="51">xs</span>
<span class="unknown token" data-binding=""></span></code></details><details class="example"><summary class="description">Simultaneous Matching vs Matching Pairs for Structural Recursion</summary><p>
                  An important consequence of the strategies that are used to prove termination is that <strong>simultaneous matching of two <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminants</a> is not equivalent to matching a pair</strong>.
Simultaneous matching maintains the connection between the discriminants and the patterns, allowing the pattern matching to refine the types of the assumptions in the local context as well as the expected type of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span>.
Essentially, the elaboration rules for <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> treat the discriminants specially, and changing discriminants in a way that preserves the run-time meaning of a program does not necessarily preserve the compile-time meaning.</p>
                <p>
                  This function that finds the minimum of two natural numbers is defined by structural recursion on its first parameter:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13230">def</span> <span class="const token" data-binding="const-min'" data-verso-hover="1059">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13262" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13262" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="1060">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.169" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.170" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-min'" data-verso-hover="1059">min'</span> <span class="var token" data-binding="var-_uniq.169" data-verso-hover="7">n'</span> <span class="var token" data-binding="var-_uniq.170" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-13343" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-13358">structural</span> <span class="var token" data-binding="var-_uniq.350" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Replacing the simultaneous pattern match on both parameters with a match on a pair causes termination analysis to fail:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    min' n' k'
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13536">def</span></span> <span class="const token" data-binding="const-min'" data-verso-hover="1059">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13568" data-verso-hover="52">match</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13568" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="1060">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.204" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-min'" data-verso-hover="1059">min'</span> <span class="var token" data-binding="var-_uniq.204" data-verso-hover="7">n'</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-13657" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-13672">structural</span> <span class="var token" data-binding="var-_uniq.407" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    min' n' k'
</pre></div>
                <p>
                  This is because the analysis only considers direct pattern matching on parameters when matching recursive calls to strictly-smaller argument values.
Wrapping the discriminants in a pair breaks the connection.</p>
                </details><details class="example"><summary class="description">Structural Recursion Under Pairs</summary><p>
                  This function that finds the minimum of the two components of a pair can't be elaborated via structural recursion.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter nk:
  the type Nat × Nat does not have a `.brecOn` recursor
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14269">def</span></span> <span class="const token" data-binding="const-min'" data-verso-hover="1061">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="588">nk</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">×</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14307" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="588">nk</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14307" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.198" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-min'" data-verso-hover="1061">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.198" data-verso-hover="7">n'</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="7">k'</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-14395" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-14410">structural</span> <span class="var token" data-binding="var-_uniq.404" data-verso-hover="588">nk</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>failed to infer structural recursion:
Cannot use parameter nk:
  the type Nat × Nat does not have a `.brecOn` recursor
</pre></div>
                <p>
                  This is because the parameter's type, <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Tuples/#Prod___mk"><span class="const token" data-binding="const-Prod" data-verso-hover="116">Prod</span></a></code>, is not recursive.
Thus, its constructor has no recursive parameters that can be exposed by pattern matching.</p>
                <p>
                  This definition is accepted using <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-recursion-next">well-founded recursion</a>, however:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14820">def</span> <span class="const token" data-binding="const-min'" data-verso-hover="1061">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="588">nk</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">×</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14858" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="588">nk</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14858" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.198" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-min'" data-verso-hover="1061">min'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.198" data-verso-hover="7">n'</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="7">k'</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-14946" data-verso-hover="1039">termination_by</span> <span class="var token" data-binding="var-_uniq.404" data-verso-hover="588">nk</span>
<span class="unknown token" data-binding=""></span></code></details><details class="example"><summary class="description">Structural Recursion and Definitional Equality</summary><p>
                  Even though the recursive occurrence of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-countdown" data-verso-hover="1036">countdown</span></code> is applied to a term that is not a strict sub-term of the decreasing parameter, the following definition is accepted:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15276">def</span> <span class="const token" data-binding="const-countdown" data-verso-hover="1036">countdown</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15316" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15316" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.99" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.99" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown" data-verso-hover="1036">countdown</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.99" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-15380" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-15395">structural</span> <span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                  This is because <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.296" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span></code> is <a class="technical-term" href="The-Type-System/#--tech-term-definitional-equality">definitionally equal</a> to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.358" data-verso-hover="7">n'</span></code>, which is a strict sub-term of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.360" data-verso-hover="7">n</span></code>.
<a class="technical-term" href="Recursive-Definitions/Structural-Recursion/#--tech-term-strict-sub-term">Sub-terms</a> that result from pattern matching are connected to the <a class="technical-term" href="Terms/Pattern-Matching/#--tech-term-match-discriminants">discriminant</a> using the rules for <a href="Terms/Pattern-Matching/#match-generalization">match generalization</a>, which respect definitional equality.</p>
                <p>
                  In <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-countdown'" data-verso-hover="1037">countdown'</span></code>, the recursive occurrence is applied to <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.371" data-verso-hover="7">n'</span></code>, which is not definitionally equal to <code>n'</code> because addition on natural numbers is structurally recursive in its second parameter:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    countdown' (0 + n')
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-16073">def</span></span> <span class="const token" data-binding="const-countdown'" data-verso-hover="1037">countdown'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16114" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">n</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16114" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.99" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.99" data-verso-hover="7">n'</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-countdown'" data-verso-hover="1037">countdown'</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.99" data-verso-hover="7">n'</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-16179" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-16194">structural</span> <span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    countdown' (0 + n')
</pre></div>
                </details></section>
            <section>
              <h2 id="mutual-structural-recursion">
                6.2.2. Mutual Structural Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=mutual-structural-recursion" title="Permalink">🔗</a></span></h2>
              <p>
                Lean supports the definition of <a class="technical-term" href="Recursive-Definitions/Mutual-Recursion/#--tech-term-mutually-recursive">mutually recursive</a> functions using structural recursion.
Mutual recursion may be introduced using a <a class="technical-term" href="Recursive-Definitions/Mutual-Recursion/#--tech-term-mutual-block">mutual block</a>, but it also results from <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.letrec : term</code></code><code class="kw">let rec</code></span> expressions and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">where</code></span> blocks.
The rules for mutual structural recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the <a href="Recursive-Definitions/Mutual-Recursion/#mutual-syntax">elaboration steps</a> for mutual groups.
If every function in the mutual group has a <code class="plain-keyword">termination_by structural</code> annotation indicating that function’s decreasing argument, then structural recursion is used to translate the definitions.</p>
              <p>
                The requirements on the decreasing argument above are extended:</p>
              <ul>
                <li>
                  <p>
                    All the types of all the decreasing arguments must be from the same inductive type, or more generally from the same <a href="The-Type-System/Inductive-Types/#mutual-inductive-types">mutual group of inductive types</a>.</p>
                  </li>
                <li>
                  <p>
                    The parameters of the decreasing parameter's types must be the same for all functions, and may depend only on the <em>common</em> fixed prefix of function arguments.</p>
                  </li>
                </ul>
              <p>
                The functions do not have to be in a one-to-one correspondence to the mutual inductive types.
Multiple functions can have a decreasing argument of the same type, and not all types that are mutually recursive with the decreasing argument need have a corresponding function.</p>
              <details class="example"><summary class="description">Mutual Structural Recursion Over Non-Mutual Types</summary><p>
                  The following example demonstrates mutual recursion over a non-mutual inductive data type:</p>
                <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18055">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18064">def</span> <span class="const token" data-binding="const-even" data-verso-hover="1062" id="odd">even</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>
    <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Propositions/Truth/#True___intro"><span class="const token" data-binding="const-True" data-verso-hover="188">True</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.97" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Recursive-Definitions/Structural-Recursion/#odd"><span class="const token" data-binding="const-odd" data-verso-hover="1063">odd</span></a> <span class="var token" data-binding="var-_uniq.97" data-verso-hover="7">n</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18125" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-18140">structural</span> <span class="var token" data-binding="var-_uniq.298" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.298" data-verso-hover="7">n</span>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18161">def</span> <span class="const token" data-binding="const-odd" data-verso-hover="1063" id="odd">odd</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span>
    <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Propositions/Truth/#False"><span class="const token" data-binding="const-False" data-verso-hover="9">False</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.238" data-verso-hover="7">n</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Recursive-Definitions/Structural-Recursion/#odd"><span class="const token" data-binding="const-even" data-verso-hover="1062">even</span></a> <span class="var token" data-binding="var-_uniq.238" data-verso-hover="7">n</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18223" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-18238">structural</span> <span class="var token" data-binding="var-_uniq.303" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.303" data-verso-hover="7">n</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18055">end</span></a>
<span class="unknown token" data-binding=""></span></code></details><details class="example"><summary class="description">Mutual Structural Recursion Over Mutual Types</summary><p>
                  The following example demonstrates recursion over mutually inductive types.
The functions <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-Exp.size" data-verso-hover="1064">Exp.size</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App.size" data-verso-hover="1065">App.size</span></a></code> are mutually recursive.</p>
                <code class="hl lean block" data-lean-context="examples"><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18490">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-18499" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Exp" data-verso-hover="1066" id="Exp___app">Exp</span> <span class="keyword token" data-binding="kw-occ-null-18513">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Exp.var" data-verso-hover="1067" id="Exp___app">var</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <span class="unknown token" data-binding="">→</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-Exp" data-verso-hover="1066">Exp</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Exp.app" data-verso-hover="1068" id="Exp___app">app</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="1069">App</span></a> <span class="unknown token" data-binding="">→</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-Exp" data-verso-hover="1066">Exp</span></a>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-18573" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-App" data-verso-hover="1069" id="Exp___app">App</span> <span class="keyword token" data-binding="kw-occ-null-18587">where</span>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-App.fn" data-verso-hover="1070" id="Exp___app">fn</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <span class="unknown token" data-binding="">→</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="1069">App</span></a>
    <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-App.app" data-verso-hover="1071" id="Exp___app">app</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="1069">App</span></a> <span class="unknown token" data-binding="">→</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-Exp" data-verso-hover="1066">Exp</span></a> <span class="unknown token" data-binding="">→</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="1069">App</span></a>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18490">end</span></a>

<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18656">mutual</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18665">def</span> <span class="const token" data-binding="const-Exp.size" data-verso-hover="1064" id="Exp___app">Exp.size</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-Exp" data-verso-hover="1066">Exp</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
    <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-Exp.var" data-verso-hover="1067">.var</span></a> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
    <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-Exp.app" data-verso-hover="1068">.app</span></a> <span class="var token" data-binding="var-_uniq.1053" data-verso-hover="1072">a</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1053" data-verso-hover="1072">a</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App.size" data-verso-hover="1065">size</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18735" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-18750">structural</span> <span class="var token" data-binding="var-_uniq.1293" data-verso-hover="1073">e</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1293" data-verso-hover="1073">e</span>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18771">def</span> <span class="const token" data-binding="const-App.size" data-verso-hover="1065" id="Exp___app">App.size</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="1069">App</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
    <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App.fn" data-verso-hover="1070">.fn</span></a> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
    <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App.app" data-verso-hover="1071">.app</span></a> <span class="var token" data-binding="var-_uniq.1143" data-verso-hover="1072">a</span> <span class="var token" data-binding="var-_uniq.1144" data-verso-hover="1073">e</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1143" data-verso-hover="1072">a</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App.size" data-verso-hover="1065">size</span></a> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.1144" data-verso-hover="1073">e</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-Exp.size" data-verso-hover="1064">size</span></a> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-18855" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-18870">structural</span> <span class="var token" data-binding="var-_uniq.1298" data-verso-hover="1072">a</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1298" data-verso-hover="1072">a</span>
<a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-18656">end</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                  The definition of <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#App___numArgs"><span class="const token" data-binding="const-App.numArgs" data-verso-hover="1074">App.numArgs</span></a></code> is structurally recursive over type <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="1069">App</span></a></code>.
It demonstrates that not all inductive types in the mutual group need to be handled.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-19078">def</span> <span class="const token" data-binding="const-App.numArgs" data-verso-hover="1074" id="App___numArgs">App.numArgs</span> <span class="unknown token" data-binding="">:</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App" data-verso-hover="1069">App</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App.fn" data-verso-hover="1070">.fn</span></a> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Structural-Recursion/#Exp___app"><span class="const token" data-binding="const-App.app" data-verso-hover="1071">.app</span></a> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="1072">a</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="1072">a</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#App___numArgs"><span class="const token" data-binding="const-App.numArgs" data-verso-hover="1074">numArgs</span></a> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy-19153" data-verso-hover="1039">termination_by</span> <span class="keyword token" data-binding="kw-occ-null-19168">structural</span> <span class="var token" data-binding="var-_uniq.164" data-verso-hover="1072">a</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.164" data-verso-hover="1072">a</span>
<span class="unknown token" data-binding=""></span></code></details><div class="planned">
                <div class="label">
                  Planned Content</div>
                <p>
                  Describe mutual structural recursion over <a href="The-Type-System/Inductive-Types/#nested-inductive-types">nested inductive types</a>.</p>
                <p>
                  Tracked at issue <a href="https://github.com/leanprover/reference-manual/issues/235">#235</a></p>
                </div>
              </section>
            <section>
              <h2 id="inferring-structural-recursion">
                6.2.3. Inferring Structural Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=inferring-structural-recursion" title="Permalink">🔗</a></span></h2>
              <p>
                If no <code class="plain-keyword">termination_by</code> clauses are present in a recursive or mutually recursive function definition, then Lean attempts to infer a suitable structurally decreasing argument, effectively by trying all suitable parameters in sequence.
If this search fails, Lean then attempts to infer <a class="technical-term" href="Recursive-Definitions/Well-Founded-Recursion/#--tech-term-well-founded-recursion-next">well-founded recursion</a>.</p>
              <p>
                For mutually recursive functions, all combinations of parameters are tried, up to a limit to avoid combinatorial explosion.
If only some of the mutually recursive functions have <code class="plain-keyword">termination_by structural</code> clauses, then only those parameters are considered, while for the other functions all parameters are considered for structural recursion.</p>
              <p>
                A <code class="plain-keyword">termination_by?</code> clause causes the inferred termination annotation to be shown.
It can be automatically added to the source file using the offered suggestion or code action.</p>
              <details class="example"><summary class="description">Inferred Termination Annotations</summary><p>
                  Lean automatically infers that the function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half" data-verso-hover="1040">half</span></code> is structurally recursive.
The <code class="plain-keyword">termination_by?</code> clause causes the inferred termination annotation to be displayed, and it can be automatically added to the source file with a single click.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20599">def</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Try this: termination_by structural x =&gt; x</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Termination.terminationBy?-20661" data-verso-hover="1039">termination_by?</span></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                  <pre>Try this: termination_by structural x =&gt; x
</pre></div>
                </details></section>
            <section>
              <h2 id="elab-as-course-of-values">
                6.2.4. Elaboration Using Course-of-Values Recursion<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=elab-as-course-of-values" title="Permalink">🔗</a></span></h2>
              <p>
                In this section, the construction used to elaborate structurally recursive functions is explained in more detail.
This elaboration uses the <a href="The-Type-System/Inductive-Types/#recursor-elaboration-helpers"><code>below</code> and <code>brecOn</code> constructions</a> that are automatically generated from inductive types' recursors.</p>
              <details class="example"><summary class="description">Recursion vs Recursors</summary><p>
                  Addition of natural numbers can be defined via recursion on the second argument.
This function is straightforwardly structurally recursive.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-606">def</span> <span class="const token" data-binding="const-add" data-verso-hover="1075">add</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-add" data-verso-hover="1075">add</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="7">k</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Defined using <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.rec" data-verso-hover="1024">Nat.rec</span></code>, it is much further from the notations that most people are used to.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-796">def</span> <span class="const token" data-binding="const-add'" data-verso-hover="1077">add'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <span class="const token" data-binding="const-Nat.rec" data-verso-hover="1024">Nat.rec</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-839">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
    <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span>
    <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-864">fun</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="7">k</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="1078">soFar</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="1078">soFar</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Structural recursive calls made on data that isn't the immediate child of the function parameter requires either creativity or a complex yet systematic encoding.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1067">def</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.118" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="var token" data-binding="var-_uniq.118" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="unknown token" data-binding=""></span></code><p>
                  One way to think about this function is as a structural recursion that flips a bit at each call, only incrementing the result when the bit is set.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1288">def</span> <span class="const token" data-binding="const-helper" data-verso-hover="1079" id="half___">helper</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="const token" data-binding="const-Nat.rec" data-verso-hover="1024">Nat.rec</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1346">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool" data-verso-hover="80">Bool</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1374">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1391">fun</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="1080">soFar</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1412">fun</span> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="79">b</span> <span class="unknown token" data-binding="">=&gt;</span>
        <span class="unknown token" data-binding="">(</span><a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-1430" data-verso-hover="81">if</span></a> <span class="var token" data-binding="var-_uniq.60" data-verso-hover="79">b</span> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-1430" data-verso-hover="81">then</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a> <a href="Terms/Conditionals/#termIfThenElse"><span class="keyword token" data-binding="kw-occ-termIfThenElse-1430" data-verso-hover="81">else</span></a> <span class="const token" data-binding="const-id" data-verso-hover="139">id</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="1080">soFar</span> <span class="unknown token" data-binding="">!</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="79">b</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1471">def</span> <span class="const token" data-binding="const-half'" data-verso-hover="1081">half'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.189" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Recursive-Definitions/Structural-Recursion/#half___"><span class="const token" data-binding="const-helper" data-verso-hover="1079">helper</span></a> <span class="var token" data-binding="var-_uniq.189" data-verso-hover="7">n</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.false" data-verso-hover="40">false</span></a>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[0, 0, 1, 1, 2, 2, 3, 3, 4]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-1546" data-verso-hover="6">#eval</span></a></span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">4</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">6</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">7</span><span class="unknown token" data-binding="">,</span> <span class="typed token" data-binding="" data-verso-hover="7">8</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">map</span></a> <span class="const token" data-binding="const-half'" data-verso-hover="1081">half'</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                  <pre>[0, 0, 1, 1, 2, 2, 3, 3, 4]
</pre></div>
                <p>
                  Instead of creativity, a general technique called <span id="--tech-term-course-of-values-recursion">course-of-values recursion</span> can be used.
Course-of-values recursion uses helpers that can be systematically derived for every inductive type, defined in terms of the recursor; Lean derives them automatically.
For every <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="7">n</span></code>, the type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="1082">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="1083">mot</span><span class="unknown token" data-binding="">)</span></code> provides a value of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="1083">mot</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="7">k</span></code> for all <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.59" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.57" data-verso-hover="7">n</span></code>, represented as an iterated  dependent pair type.
The course-of-values recursor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="1084">Nat.brecOn</span></code> allows a function to use the result for any smaller <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code>.
Using it to define the function is inconvenient:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-2293">noncomputable</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2307">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="1085">half''</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="1084">Nat.brecOn</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2363">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2381">fun</span> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">k</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="1086">soFar</span> <span class="unknown token" data-binding="">=&gt;</span>
      <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2402" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">k</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="1086">soFar</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2402" data-verso-hover="52">with</span></a>
      <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="1087">0</span>
      <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.239" data-verso-hover="1088">h</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">⟩</span><span class="unknown token" data-binding="">⟩</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.239" data-verso-hover="1088">h</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="1089">1</span>
<span class="unknown token" data-binding=""></span></code><p>
                  The function is marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">noncomputable</code></span> because the compiler doesn't support generating code for course-of-values recursion, which is intended for reasoning rather that efficient code.
The kernel can still be used to test the function, however:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[0, 0, 1, 1, 2, 2, 3, 3, 4]</code></span></span><a href="Interacting-with-Lean/#Lean___reduceCmd"><span class="keyword token" data-binding="kw-occ-Lean.reduceCmd-2810" data-verso-hover="708">#reduce</span></a></span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">4</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">6</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">7</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">8</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">map</span></a> <span class="const token" data-binding="const-half''" data-verso-hover="1085">half''</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                  <pre>[0, 0, 1, 1, 2, 2, 3, 3, 4]
</pre></div>
                <p>
                  The dependent pattern matching in the body of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half''" data-verso-hover="1085">half''</span></code> can also be encoded using recursors (specifically, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="1090">Nat.casesOn</span></code>), if necessary:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-3066">noncomputable</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3080">def</span> <span class="const token" data-binding="const-half'''" data-verso-hover="1091" id="half_________">half'''</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="var token" data-binding="var-_uniq.10" data-verso-hover="7">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="1084">brecOn</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3133">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3151">fun</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="var token" data-binding="var-_uniq.33" data-verso-hover="7">k</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="1090">casesOn</span>
        <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
          <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3205">fun</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">=&gt;</span>
            <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="7">k'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="1082">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3248">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
            <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3293">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3314">fun</span> <span class="var token" data-binding="var-_uniq.92" data-verso-hover="7">k'</span> <span class="unknown token" data-binding="">=&gt;</span>
          <span class="var token" data-binding="var-_uniq.92" data-verso-hover="7">k'</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="1090">casesOn</span>
            <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
              <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3382">fun</span> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">k''</span> <span class="unknown token" data-binding="">=&gt;</span>
                <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">k''</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="1082">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3436">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
                <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
            <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3489">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span>
            <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3514">fun</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.144" data-verso-hover="1092">soFar</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.144" data-verso-hover="1092">soFar</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  This definition still works.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[0, 0, 1, 1, 2, 2, 3, 3, 4]</code></span></span><a href="Interacting-with-Lean/#Lean___reduceCmd"><span class="keyword token" data-binding="kw-occ-Lean.reduceCmd-3608" data-verso-hover="708">#reduce</span></a></span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">3</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">4</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">6</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">7</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="7">8</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___map"><span class="const token" data-binding="const-List.map" data-verso-hover="126">map</span></a> <span class="const token" data-binding="const-half''" data-verso-hover="1085">half''</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                  <pre>[0, 0, 1, 1, 2, 2, 3, 3, 4]
</pre></div>
                <p>
                  However, it is now far from the original definition and it has become difficult for most people to understand.
Recursors are an excellent logical foundation, but not an easy way to write programs or proofs.</p>
                </details><p>
                The structural recursion analysis attempts to translate the recursive pre-definition into a use of the appropriate structural recursion constructions.
At this step, pattern matching has already been translated into the use of matcher functions; these are treated specially by the termination checker.
Next, for each group of parameters, a translation using <code>brecOn</code> is attempted.</p>
              <details class="example"><summary class="description">Course-of-Values Tables</summary><p>
                  This definition is equivalent to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.below" data-verso-hover="1093">List.below</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-439">def</span> <span class="const token" data-binding="const-List.below'" data-verso-hover="1094" id="List___below___">List.below'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-461" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-491" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span>
    <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-517" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Level.max-523">max</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="70">PUnit</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">×'</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="1094">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  In other words, for a given <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-motive">motive</a>, <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="1094">List.below'</span></a></code> is a type that contains a realization of the motive for all suffixes of the list.</p>
                <p>
                  More recursive arguments require further nested iterations of the product type.
For instance, binary trees have two recursive occurrences.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-1073" data-verso-hover="20">inductive</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-1094" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-1104" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span> <span class="keyword token" data-binding="kw-occ-null-1111">where</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1095">leaf</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.branch" data-verso-hover="1096" id="Tree">branch</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="1097">left</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="46">val</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="1097">right</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Its corresponding course-of-values table contains the realizations of the motive for all subtrees:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1295">def</span> <span class="const token" data-binding="const-Tree.below'" data-verso-hover="1098" id="Tree___below___">Tree.below'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-1317" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-1347" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span>
    <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-1373" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Level.max-1379">max</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1095">.leaf</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="70">PUnit</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Structural-Recursion/#Tree"><span class="const token" data-binding="const-Tree.branch" data-verso-hover="1096">.branch</span></a> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="1097">left</span> <span class="var token" data-binding="var-_uniq.45" data-verso-hover="46">_val</span> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="1097">right</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="1097">left</span> <span class="unknown token" data-binding="">×'</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="1097">left</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="1098">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">×'</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="1097">right</span> <span class="unknown token" data-binding="">×'</span> <span class="var token" data-binding="var-_uniq.46" data-verso-hover="1097">right</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="1098">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  For both lists and trees, the <code>brecOn</code> operator expects just a single case, rather than one per constructor.
This case accepts a list or tree along with a table of results for all smaller values; from this, it should satisfy the motive for the provided value.
Dependent case analysis of the provided value automatically refines the type of the memo table, providing everything needed.</p>
                <p>
                  The following definitions are equivalent to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.brecOn" data-verso-hover="1100">List.brecOn</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Tree.brecOn" data-verso-hover="1101">Tree.brecOn</span></code>, respectively.
The primitive recursive helpers <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#List___brecOnTable"><span class="const token" data-binding="const-List.brecOnTable" data-verso-hover="1102">List.brecOnTable</span></a></code>  and <code class="hl lean inline" data-lean-context="examples"><a href="Recursive-Definitions/Structural-Recursion/#Tree___brecOnTable"><span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="1103">Tree.brecOnTable</span></a></code> compute the course-of-values tables along with the final results, and the actual definitions of the <code>brecOn</code> operators simply project out the result.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2526">def</span> <span class="const token" data-binding="const-List.brecOnTable" data-verso-hover="1104" id="List___brecOnTable">List.brecOnTable</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-2553" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-2587" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1105">step</span> <span class="unknown token" data-binding="">:</span>
      <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
      <span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="1094">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
      <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">×'</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="1094">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2761" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2761" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟨</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1105">step</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="1107">PUnit.unit</span></a><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">,</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="1107">PUnit.unit</span></a><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟩</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.106" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.107" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-2841" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.128" data-verso-hover="1108">res</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.107" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#List___brecOnTable"><span class="const token" data-binding="const-List.brecOnTable" data-verso-hover="1104">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="1105">step</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-2895" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.139" data-verso-hover="1109">val</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="1105">step</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.106" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.107" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.128" data-verso-hover="1108">res</span>
    <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟨</span><span class="var token" data-binding="var-_uniq.139" data-verso-hover="1109">val</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">,</span> <span class="var token" data-binding="var-_uniq.128" data-verso-hover="1108">res</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟩</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2957">def</span> <span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="1110" id="Tree___brecOnTable">Tree.brecOnTable</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-2984" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-3018" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="1097">t</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1111">step</span> <span class="unknown token" data-binding="">:</span>
      <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="1097">ys</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
      <span class="var token" data-binding="var-_uniq.14" data-verso-hover="1097">ys</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="1098">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
      <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="1097">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="1097">t</span> <span class="unknown token" data-binding="">×'</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="1097">t</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="1098">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-3189" data-verso-hover="52">match</span></a> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="1097">t</span> <a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-3189" data-verso-hover="52">with</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1095">.leaf</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟨</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1111">step</span> <span class="const token" data-binding="const-Tree.leaf" data-verso-hover="1095">.leaf</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="1107">PUnit.unit</span></a><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">,</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit.unit" data-verso-hover="1107">PUnit.unit</span></a><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟩</span>
  <span class="unknown token" data-binding="">|</span> <a href="Recursive-Definitions/Structural-Recursion/#Tree"><span class="const token" data-binding="const-Tree.branch" data-verso-hover="1096">.branch</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="1097">left</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="46">val</span> <span class="var token" data-binding="var-_uniq.104" data-verso-hover="1097">right</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3289" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.125" data-verso-hover="1112">resLeft</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="1097">left</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Tree___brecOnTable"><span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="1110">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="1111">step</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3349" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.142" data-verso-hover="1113">resRight</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.104" data-verso-hover="1097">right</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Tree___brecOnTable"><span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="1110">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="1111">step</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3411" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.146" data-verso-hover="1114">branchRes</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟨</span><span class="var token" data-binding="var-_uniq.125" data-verso-hover="1112">resLeft</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">,</span> <span class="var token" data-binding="var-_uniq.142" data-verso-hover="1113">resRight</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟩</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3456" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.153" data-verso-hover="1115">val</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="1111">step</span> <span class="unknown token" data-binding="">(</span><a href="Recursive-Definitions/Structural-Recursion/#Tree"><span class="const token" data-binding="const-Tree.branch" data-verso-hover="1096">.branch</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="1097">left</span> <span class="var token" data-binding="var-_uniq.103" data-verso-hover="46">val</span> <span class="var token" data-binding="var-_uniq.104" data-verso-hover="1097">right</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.146" data-verso-hover="1114">branchRes</span>
    <span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟨</span><span class="var token" data-binding="var-_uniq.153" data-verso-hover="1115">val</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">,</span> <span class="var token" data-binding="var-_uniq.146" data-verso-hover="1116">branchRes</span><span class="unknown token" data-binding="const-PProd.mk" data-verso-hover="1106">⟩</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3545">def</span> <span class="const token" data-binding="const-List.brecOn'" data-verso-hover="1117" id="List___brecOn___">List.brecOn'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-3568" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-3602" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1105">step</span> <span class="unknown token" data-binding="">:</span>
      <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
      <span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#List___below___"><span class="const token" data-binding="const-List.below'" data-verso-hover="1094">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
      <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="51">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:=</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#List___brecOnTable"><span class="const token" data-binding="const-List.brecOnTable" data-verso-hover="1104">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="331">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="1105">step</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3799">def</span> <span class="const token" data-binding="const-Tree.brecOn'" data-verso-hover="1118" id="Tree___brecOn___">Tree.brecOn'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-3822" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-3856" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="1097">t</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1111">step</span> <span class="unknown token" data-binding="">:</span>
      <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="1097">ys</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Tree" data-verso-hover="737">Tree</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
      <span class="var token" data-binding="var-_uniq.14" data-verso-hover="1097">ys</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Tree___below___"><span class="const token" data-binding="const-Tree.below'" data-verso-hover="1098">below'</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
      <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="1097">ys</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="1097">t</span> <span class="unknown token" data-binding="">:=</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="1097">t</span><span class="unknown token" data-binding="">.</span><a href="Recursive-Definitions/Structural-Recursion/#Tree___brecOnTable"><span class="const token" data-binding="const-Tree.brecOnTable" data-verso-hover="1110">brecOnTable</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="1099">motive</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="1111">step</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span>
<span class="unknown token" data-binding=""></span></code></details><p>
                The <code>below</code> construction is a mapping from each value of a type to the results of some function call on <em>all</em> smaller values; it can be understood as a memoization table that already contains the results for all smaller values.
The notion of “smaller value” that is expressed in the <code>below</code> construction corresponds directly to the definition of <a class="technical-term" href="Recursive-Definitions/Structural-Recursion/#--tech-term-strict-sub-term">strict sub-terms</a>.</p>
              <p>
                Recursors expect an argument for each of the inductive type's constructors; these arguments are called with the constructor's arguments (and the result of recursion on recursive parameters) during <a class="technical-term" href="The-Type-System/Inductive-Types/#--tech-term-___-reduction">ι-reduction</a>.
The course-of-values recursion operator <code>brecOn</code>, on the other hand, expects just a single case that covers all constructors at once.
This case is provided with a value and a <code>below</code> table that contains the results of recursion on all values smaller than the given value; it should use the contents of the table to satisfy the motive for the provided value.
If the function is structurally recursive over a given parameter (or parameter group), then the results of all recursive calls will be present in this table already.</p>
              <p>
                When the body of the recursive function is transformed into an invocation of <code>brecOn</code> on one of the function's parameters, the parameter and its course-of-values table are in scope.
The analysis traverses the body of the function, looking for recursive calls.
If the parameter is matched against, then its occurrences in the local context are <a href="Terms/Pattern-Matching/#match-generalization">generalized</a> and then instantiated with the pattern; this is also true for the type of the course-of-values table.
Typically, this pattern matching results in the type of the course-of-values table becoming more specific, which gives access to the recursive results for smaller values.
This generalization process implements the rule that patterns are <a class="technical-term" href="Recursive-Definitions/Structural-Recursion/#--tech-term-strict-sub-term">sub-terms</a> of match discriminants.
When an recursive occurrence of the function is detected, the course-of-values table is consulted to see whether it contains a result for the argument being checked.
If so, the recursive call can be replaced with a projection from the table.
If not, then the parameter in question doesn't support structural recursion.</p>
              <details class="example"><summary class="description">Elaboration Walkthrough</summary><p>
                  The first step in walking through the elaboration of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half" data-verso-hover="1040">half</span></code> is to manually desugar it to a simpler form.
This doesn't match the way Lean works, but its output is much easier to read when there are fewer <code class="hl lean inline" data-lean-context="examples"><a href="Terms/Literals/#OfNat___mk"><span class="const token" data-binding="const-OfNat" data-verso-hover="507">OfNat</span></a></code> instances present.
This readable definition:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-24244">def</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span> <span class="unknown token" data-binding="">|</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="var token" data-binding="var-_uniq.110" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span>
<span class="unknown token" data-binding=""></span></code><p>
                  can be rewritten to this somewhat lower-level version:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-24389">def</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a> <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">|&gt;.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                  The elaborator begins by elaborating a pre-definition in which recursion is still present but the definition is otherwise in Lean's core type theory.
Turning on the compiler's tracing of pre-definitions, as well as making the pretty printer more explicit, makes the resulting pre-definition visible:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-25340" data-verso-hover="160">set_option</span> <span class="option token" data-binding="option-trace.Elab.definition.body" data-verso-hover="1119">trace.Elab.definition.body</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-25340" data-verso-hover="160">true</span> <a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-25340">in</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-25386" data-verso-hover="160">set_option</span> <span class="option token" data-binding="option-pp.all" data-verso-hover="1120">pp.all</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-25386" data-verso-hover="160">true</span> <a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-25386">in</span></a>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[Elab.definition.body] half : Nat → Nat :=
    fun (x : Nat) =&gt;
      half.match_1.{1} (fun (x : Nat) =&gt; Nat) x (fun (_ : Unit) =&gt; Nat.zero) (fun (_ : Unit) =&gt; Nat.zero)
        fun (n : Nat) =&gt; Nat.succ (half n)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25413">def</span></span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a> <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">.succ</span></a> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-half" data-verso-hover="1040">half</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">|&gt;.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                  The returned trace message is:</p>
                <pre>[Elab.definition.body] half : Nat → Nat :=
    fun (x : Nat) =&gt;
      half.match_1.{1} (fun (x : Nat) =&gt; Nat) x
        (fun (_ : Unit) =&gt; Nat.zero)
        (fun (_ : Unit) =&gt; Nat.zero)
        fun (n : Nat) =&gt; Nat.succ (half n)
</pre><p>
                  The auxiliary match function's definition is:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def half.match_1.{u_1} : (motive : Nat → Sort u_1) →
  (x : Nat) → (Unit → motive Nat.zero) → (Unit → motive 1) → ((n : Nat) → motive n.succ.succ) → motive x :=
fun motive x h_1 h_2 h_3 =&gt; Nat.casesOn x (h_1 ()) fun n =&gt; Nat.casesOn n (h_2 ()) fun n =&gt; h_3 n</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-26000">#print</span></span> <span class="const token" data-binding="const-half.match_1" data-verso-hover="1121">half.match_1</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                  <pre>def half.match_1.{u_1} : (motive : Nat → Sort u_1) →
  (x : Nat) → (Unit → motive Nat.zero) → (Unit → motive 1) → ((n : Nat) → motive n.succ.succ) → motive x :=
fun motive x h_1 h_2 h_3 =&gt; Nat.casesOn x (h_1 ()) fun n =&gt; Nat.casesOn n (h_2 ()) fun n =&gt; h_3 n
</pre></div>
                <p>
                  Formatted more readably, this definition is:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-26436">def</span> <span class="const token" data-binding="const-half.match_1'" data-verso-hover="1122">half.match_1'</span><span class="unknown token" data-binding="">.{</span><span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="1083">motive</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sort-26482" data-verso-hover="96">Sort</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
    <span class="unknown token" data-binding="">(</span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="1083">motive</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">Nat.zero</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="1083">motive</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
    <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="1083">motive</span> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="7">n</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
    <span class="var token" data-binding="var-_uniq.5" data-verso-hover="1083">motive</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-26628">fun</span> <span class="var token" data-binding="var-_uniq.45" data-verso-hover="1083">motive</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="7">x</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="1123">h_1</span> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="1124">h_2</span> <span class="var token" data-binding="var-_uniq.59" data-verso-hover="1125">h_3</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="1090">Nat.casesOn</span> <span class="var token" data-binding="var-_uniq.48" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="1123">h_1</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-26683">fun</span> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="const token" data-binding="const-Nat.casesOn" data-verso-hover="1090">Nat.casesOn</span> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.55" data-verso-hover="1124">h_2</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-26721">fun</span> <span class="var token" data-binding="var-_uniq.111" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span>
        <span class="var token" data-binding="var-_uniq.59" data-verso-hover="1125">h_3</span> <span class="var token" data-binding="var-_uniq.111" data-verso-hover="7">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                  In other words, the specific configuration of patterns used in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half" data-verso-hover="1040">half</span></code> are captured in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half.match_1" data-verso-hover="1121">half.match_1</span></code>.</p>
                <p>
                  This definition is a more readable version of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half" data-verso-hover="1040">half</span></code>'s pre-definition:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-26948">def</span> <span class="const token" data-binding="const-half'" data-verso-hover="1126">half'</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-26977">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="const token" data-binding="const-half.match_1" data-verso-hover="1121">half.match_1</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27022">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span>
      <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27045">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="1127">0</span><span class="unknown token" data-binding="">)</span> -- Case for 0
      <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27078">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="typed token" data-binding="" data-verso-hover="1128">0</span><span class="unknown token" data-binding="">)</span> -- Case for 1
      <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27111">fun</span> <span class="var token" data-binding="var-_uniq.43" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-half'" data-verso-hover="1126">half'</span> <span class="var token" data-binding="var-_uniq.43" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> -- Case for n + 2
<span class="unknown token" data-binding=""></span></code><p>
                  To elaborate it as a structurally recursive function, the first step is to establish the <code>bRecOn</code> invocation.
The definition must be marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">noncomputable</code></span> because Lean does not support code generation for recursors such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="1084">Nat.brecOn</span></code>.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-27490">noncomputable</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-27504">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="1129">half''</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27534">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="1084">brecOn</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-27564">fun</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="1130">table</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
x n : Nat
table : Nat.below n
⊢ Nat</code></span></span><span class="unknown token" data-binding="">_</span></span>
/- To translate:
    half.match_1 (motive := fun _ =&gt; Nat) x
      (fun _ =&gt; 0) -- Case for 0
      (fun _ =&gt; 0) -- Case for 1
      (fun n =&gt; Nat.succ (half' n)) -- Case for n + 2
-/
<span class="unknown token" data-binding=""></span></code><p>
                  The next step is to replace occurrences of <code>x</code> in the original function body with the <code>n</code> provided by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="1084">brecOn</span></code>.
Because <code>table</code>'s type depends on <code>x</code>, it must also be generalized when splitting cases with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-half.match_1" data-verso-hover="1121">half.match_1</span></code>, leading to a motive with an extra parameter.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-28127">noncomputable</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28141">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="1129">half''</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-28171">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="1084">brecOn</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-28201">fun</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="1130">table</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-half.match_1" data-verso-hover="1121">half.match_1</span>
        <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
          <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-28265">fun</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span>
            <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">k</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="1082">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-28305">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
            <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
        <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span>
        <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder for argument 'h_1'
context:
x n : Nat
table : Nat.below n
⊢ Unit → (fun k =&gt; Nat.below k → Nat) Nat.zero</code></span></span><span class="unknown token" data-binding="">_</span></span>
        <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder for argument 'h_2'
context:
x n : Nat
table : Nat.below n
⊢ Unit → (fun k =&gt; Nat.below k → Nat) 1</code></span></span><span class="unknown token" data-binding="">_</span></span>
        <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder for argument 'h_3'
context:
x n : Nat
table : Nat.below n
⊢ (n : Nat) → (fun k =&gt; Nat.below k → Nat) n.succ.succ</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="unknown token" data-binding="">)</span>
      <span class="var token" data-binding="var-_uniq.31" data-verso-hover="1130">table</span>
/- To translate:
      (fun _ =&gt; 0) -- Case for 0
      (fun _ =&gt; 0) -- Case for 1
      (fun n =&gt; Nat.succ (half' n)) -- Case for n + 2
-/
<span class="unknown token" data-binding=""></span></code><p>
                  The three cases' placeholders expect the following types:</p>
                <div class="error">
                  <pre>don't know how to synthesize placeholder for argument 'h_1'
context:
x n : Nat
table : Nat.below n
⊢ Unit → (fun k =&gt; Nat.below k → Nat) Nat.zero
</pre></div>
                <div class="error">
                  <pre>don't know how to synthesize placeholder for argument 'h_2'
context:
x n : Nat
table : Nat.below n
⊢ Unit → (fun k =&gt; Nat.below k → Nat) 1
</pre></div>
                <div class="error">
                  <pre>don't know how to synthesize placeholder for argument 'h_3'
context:
x n : Nat
table : Nat.below n
⊢ (n : Nat) → (fun k =&gt; Nat.below k → Nat) n.succ.succ
</pre></div>
                <p>
                  The first two cases in the pre-definition are constant functions, with no recursion to check:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-29295">noncomputable</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-29309">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="1129">half''</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29339">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.6" data-verso-hover="7">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="1084">brecOn</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29369">fun</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="1130">table</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-half.match_1" data-verso-hover="1121">half.match_1</span>
        <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
          <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29433">fun</span> <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span>
            <span class="var token" data-binding="var-_uniq.35" data-verso-hover="7">k</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="1082">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29473">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
            <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
        <span class="var token" data-binding="var-_uniq.28" data-verso-hover="7">n</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29527">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29555">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a><span class="unknown token" data-binding="">)</span>
        <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder for argument 'h_3'
context:
x n : Nat
table : Nat.below n
⊢ (n : Nat) → (fun k =&gt; Nat.below k → Nat) n.succ.succ</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="unknown token" data-binding="">)</span>
      <span class="var token" data-binding="var-_uniq.31" data-verso-hover="1130">table</span>
/- To translate:
      (fun n =&gt; Nat.succ (half' n)) -- Case for n + 2
-/
<span class="unknown token" data-binding=""></span></code><p>
                  The final case contains a recursive call.
It should be translated into a lookup into the course-of-values table.
A more readable representation of the last hole's type is:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.481" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
<span class="const token" data-binding="const-Nat.below" data-verso-hover="1082">Nat.below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-29895">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.481" data-verso-hover="7">n</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">succ</span></a> <span class="unknown token" data-binding="">→</span>
<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code><p>
                  which is equivalent to</p>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.495" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">×'</span> <span class="unknown token" data-binding="">(</span><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">×'</span> <span class="const token" data-binding="const-Nat.below" data-verso-hover="1082">Nat.below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30020">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.495" data-verso-hover="7">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
<a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code><p>
                  The first <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></code> in the course-of-values table is the result of recursion on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.512" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span></code>, and the second is the result of recursion on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.569" data-verso-hover="7">n</span></code>.
The recursive call can thus be replaced by a lookup, and the elaboration is successful:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.noncomputable-30597">noncomputable</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-30611">def</span> <span class="const token" data-binding="const-half''" data-verso-hover="1129">half''</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30641">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">x</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="var token" data-binding="var-_uniq.8" data-verso-hover="7">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.brecOn" data-verso-hover="1084">brecOn</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30671">fun</span> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="1130">table</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-half.match_1" data-verso-hover="1121">half.match_1</span>
        <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span>
          <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30735">fun</span> <span class="var token" data-binding="var-_uniq.37" data-verso-hover="7">k</span> <span class="unknown token" data-binding="">=&gt;</span>
            <span class="var token" data-binding="var-_uniq.37" data-verso-hover="7">k</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.below" data-verso-hover="1082">below</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">motive</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30775">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span>
            <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="unknown token" data-binding="">)</span>
        <span class="var token" data-binding="var-_uniq.30" data-verso-hover="7">n</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30829">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30857">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="1076">.zero</span></a><span class="unknown token" data-binding="">)</span>
        <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-30885">fun</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="1092">table</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="12">Nat.succ</span></a> <span class="var token" data-binding="var-_uniq.87" data-verso-hover="1092">table</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span>
      <span class="var token" data-binding="var-_uniq.33" data-verso-hover="1130">table</span>
<span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unexpected end of input; expected ')', ',' or ':'</code></span></span><span class="unknown token" data-binding=""></span></span></code><p>
                  The actual elaborator keeps track of the relationship between the parameter being checked for structural recursion and the positions in the course-of-values tables by inserting sentinel types with fresh names into the motive.</p>
                </details><div class="planned">
                <div class="label">
                  Planned Content</div>
                <p>
                  A description of the elaboration of mutually recursive functions</p>
                <p>
                  Tracked at issue <a href="https://github.com/leanprover/reference-manual/issues/56">#56</a></p>
                </div>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Recursive-Definitions/Mutual-Recursion/#mutual-syntax" rel="prev" title="6.1. Mutual Recursion"><span class="arrow">←</span><span class="where">6.1. Mutual Recursion</span></a><a class="local-button active" href="Recursive-Definitions/Well-Founded-Recursion/#well-founded-recursion" rel="next" title="6.3. Well-Founded Recursion"><span class="where">6.3. Well-Founded Recursion</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

