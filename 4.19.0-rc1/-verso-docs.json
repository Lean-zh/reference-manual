{"999": "<code>i + 1 &lt; (head✝ :: tail✝).length</code>",
 "998": "<code>Env tail✝</code>",
 "997": "<code>head✝.interp</code>",
 "996":
 "<code>Env.get {Γ : List Ty} (i : Fin Γ.length) (ρ : Env Γ) : Γ[i].interp</code>",
 "995": "<code>t.interp</code>",
 "994": "<code>Env Γ</code>",
 "993":
 "<code>Env.extend {Γ : List Ty} {t : Ty} (ρ : Env Γ) (v : t.interp) : Env (t :: Γ)</code>",
 "992": "<code>Env.empty : Env []</code>",
 "991": "<code>Env : List Ty → Type</code>",
 "990": "<code>Fin ([Ty.nat, Ty.nat, Ty.nat].length + 1)</code>",
 "99": "<code>∀ (x : α), f x = g x</code>",
 "989": "<code>Fin ([Ty.nat].length + 1)</code>",
 "988": "<code>plus : Tm [] (Ty.nat.arr (Ty.nat.arr Ty.nat))</code>",
 "987": "<code>Fin (Γ.length + 1)</code>",
 "986":
 "<code>Tm.v {t : Ty} {Γ : List Ty} (i : Fin (Γ.length + 1)) : Tm (t :: Γ) (t :: Γ)[i]</code>",
 "985":
 "<code>List.length.{u_1} {α : Type u_1} : List α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The length of a list.\n\nThis function is overridden in the compiler to `lengthTR`, which uses constant stack space.\n\nExamples:\n* `([] : List String).length = 0`\n* `[\"green\", \"brown\"].length = 2`\n</code>",
 "984": "<code>Fin Γ.length</code>",
 "983": "<code>Tm.var {Γ : List Ty} (i : Fin Γ.length) : Tm Γ Γ[i]</code>",
 "982": "<code>Tm Γ (t.arr t')</code>",
 "981":
 "<code>Tm.app {Γ : List Ty} {t t' : Ty} (f : Tm Γ (t.arr t')) (arg : Tm Γ t) : Tm Γ t'</code>",
 "980": "<code>Tm (t :: Γ) t'</code>",
 "98": "<code>(x : α) → β x</code>",
 "979":
 "<code>Tm.lam {t : Ty} {Γ : List Ty} {t' : Ty} (body : Tm (t :: Γ) t') : Tm Γ (t.arr t')</code>",
 "978": "<code>Tm Γ (Ty.nat.arr (t.arr t))</code>",
 "977": "<code>Tm Γ t</code>",
 "976":
 "<code>Tm.rep {Γ : List Ty} {t : Ty} (n : Tm Γ Ty.nat) (start : Tm Γ t) (f : Tm Γ (Ty.nat.arr (t.arr t))) : Tm Γ t</code>",
 "975": "<code>Tm Γ Ty.nat</code>",
 "974": "<code>Tm.succ {Γ : List Ty} (n : Tm Γ Ty.nat) : Tm Γ Ty.nat</code>",
 "973": "<code>List Ty</code>",
 "972": "<code>Tm.zero {Γ : List Ty} : Tm Γ Ty.nat</code>",
 "971": "<code>Tm : List Ty → Ty → Type</code>",
 "970": "<code>Ty.interp : Ty → Type</code>",
 "97": "<code>α → Sort v</code>",
 "969": "<code>Ty</code>",
 "968": "<code>Ty.arr (dom cod : Ty) : Ty</code>",
 "967": "<code>Ty.nat : Ty</code>",
 "966": "<code>Ty : Type</code>",
 "965":
 "<code><span class=\"literal string\">\" hello\"</span> : String</code>",
 "964": "<code>Writer</code>",
 "963":
 "<code>(w : Writer) → w.Writes → String → String</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "962": "<code>stringWriter : Writer</code>",
 "961": "<code>Nat → String → String</code>",
 "960": "<code>natWriter : Writer</code>",
 "96":
 "<code class=\"docstring\">A specific universe in Lean's infinite hierarchy of universes. </code>",
 "959":
 "<code>Writer.write.{u} (self : Writer) : self.Writes → String → String</code>",
 "958": "<code>Writer.Writes.{u} (self : Writer) : Type u</code>",
 "957": "<code>Writer.{u} : Type (u + 1)</code>",
 "956": "<code>α → α''</code>",
 "955":
 "<code>NamedFun α α'' → α → α''</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "954": "<code>NamedFun α α''</code>",
 "953": "<code>NamedFun α α'' → String</code>",
 "952": "<code><span class=\"literal string\">\" ∘ \"</span> : String</code>",
 "951": "<code>α → γ</code>",
 "950": "<code>NamedFun α β</code>",
 "95": "<code>Sort u</code>",
 "949": "<code>NamedFun β γ</code>",
 "948":
 "<code>NamedFun.comp.{u, v, u_1} {α : Type u} {β : Type v} {γ : Type u_1} (f : NamedFun β γ) (g : NamedFun α β) : NamedFun α γ</code>",
 "947":
 "<code><span class=\"literal string\">\"append\"</span> : String</code>",
 "946": "<code>List α → List α → List α</code>",
 "945":
 "<code>append.{u} {α : Type u} : NamedFun (List α) (List α → List α)</code>",
 "944":
 "<code><span class=\"literal string\">\"asString\"</span> : String</code>",
 "943": "<code>α → String</code>",
 "942":
 "<code>asString.{u} {α : Type u} [ToString α] : NamedFun α String</code>",
 "941": "<code><span class=\"literal string\">\"succ\"</span> : String</code>",
 "940": "<code>Nat → Nat</code>",
 "94":
 "<code class=\"docstring\">Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n</code>",
 "939": "<code>succ : NamedFun Nat Nat</code>",
 "938":
 "<code>NamedFun.name.{u, v} {α : Type u} {β : Type v} (self : NamedFun α β) : String</code>",
 "937":
 "<code>NamedFun.function.{u, v} {α : Type u} {β : Type v} (self : NamedFun α β) : α → β</code>",
 "936":
 "<code>NamedFun.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code>",
 "935":
 "<code>(f : α) → γ f</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "934":
 "<code>CoeFun.mk.{u, v} {α : Sort u} {γ : outParam (α → Sort v)} (coe : (f : α) → γ f) : CoeFun α γ</code>",
 "933": "<code>outParam (α → Sort v)</code>",
 "932":
 "<code>CoeFun.{u, v} (α : Sort u) (γ : outParam (α → Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeFun α (γ : α → Sort v)` is a coercion to a function. `γ a` should be a\n(coercion-to-)function type, and this is triggered whenever an element\n`f : α` appears in an application like `f x`, which would not make sense since\n`f` does not have a function type.\n`CoeFun` instances apply to `CoeOut` as well.\n</code>",
 "931": "<code>y : Option Type</code>",
 "930": "<code>↑nat</code>",
 "93":
 "<code class=\"docstring\">Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool =&gt; ...) = (fun x =&gt; ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n</code>",
 "929": "<code>x : ↑nat</code>",
 "928":
 "<code>NatOrBool → Type</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to `β`, which must be a universe. </code>",
 "927": "<code>NatOrBool.asType : NatOrBool → Type</code>",
 "926": "<code>NatOrBool.bool : NatOrBool</code>",
 "925": "<code>NatOrBool.nat : NatOrBool</code>",
 "924": "<code>NatOrBool : Type</code>",
 "923": "<code><span class=\"literal string\">\"hello\"</span> : String</code>",
 "922": "<code>Monoid</code>",
 "921":
 "<code>Monoid → Type 1</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to `β`, which must be a universe. </code>",
 "920": "<code>∀ (x : String), (fun x1 x2 =&gt; x1 ++ x2) x \"\" = x</code>",
 "92":
 "<code>funext.{u, v} {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x} (h : ∀ (x : α), f x = g x) : f = g</code><span class=\"sep\"></span><code class=\"docstring\">**Function extensionality.** If two functions return equal results for all possible arguments, then\nthey are equal.\n\nIt is called “extensionality” because it provides a way to prove two objects equal based on the\nproperties of the underlying mathematical functions, rather than based on the syntax used to denote\nthem. Function extensionality is a theorem that can be [proved using quotient\ntypes](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=quotient-funext).\n</code>",
 "919": "<code>∀ (x : String), (fun x1 x2 =&gt; x1 ++ x2) \"\" x = x</code>",
 "918":
 "<code>String.append_assoc (s₁ s₂ s₃ : String) : s₁ ++ s₂ ++ s₃ = s₁ ++ (s₂ ++ s₃)</code>",
 "917":
 "<code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `++` in identifiers is `append`.</code>",
 "916":
 "<code>∀ (x y z : String),\n  (fun x1 x2 =&gt; x1 ++ x2) x ((fun x1 x2 =&gt; x1 ++ x2) y z) = (fun x1 x2 =&gt; x1 ++ x2) ((fun x1 x2 =&gt; x1 ++ x2) x y) z</code>",
 "915": "<code>String → String → String</code>",
 "914": "<code>StringMonoid : Monoid</code>",
 "913":
 "<code>Monoid.op_id_identity.{u} (self : Monoid) (x : self.Carrier) : self.op x self.id = x</code>",
 "912":
 "<code>Monoid.id_op_identity.{u} (self : Monoid) (x : self.Carrier) : self.op self.id x = x</code>",
 "911": "<code>Carrier → Carrier → Carrier</code>",
 "910": "<code>Carrier</code>",
 "91": "<code>β : α → Type</code>",
 "909":
 "<code>Monoid.op_assoc.{u} (self : Monoid) (x y z : self.Carrier) : self.op x (self.op y z) = self.op (self.op x y) z</code>",
 "908": "<code>Monoid.id.{u} (self : Monoid) : self.Carrier</code>",
 "907":
 "<code>Monoid.op.{u} (self : Monoid) : self.Carrier → self.Carrier → self.Carrier</code>",
 "906": "<code>Monoid.Carrier.{u} (self : Monoid) : Type u</code>",
 "905": "<code>Monoid.{u} : Type (u + 1)</code>",
 "904":
 "<code>α → β</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to `β`, which must be a universe. </code>",
 "903":
 "<code>CoeSort.mk.{u, v} {α : Sort u} {β : outParam (Sort v)} (coe : α → β) : CoeSort α β</code>",
 "902":
 "<code>outParam.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (α : outParam (Type u)) (γ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?α ?γ` comes\nup, Lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\n\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`List α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\n</code>",
 "901": "<code>outParam (Sort v)</code>",
 "900":
 "<code>CoeSort.{u, v} (α : Sort u) (β : outParam (Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeSort α β` is a coercion to a sort. `β` must be a universe, and this is\ntriggered when `a : α` appears in a place where a type is expected, like\n`(x : a)` or `a → a`.\n`CoeSort` instances apply to `CoeOut` as well.\n</code>",
 "90": "<code>α : Type</code>",
 "9":
 "<code>False : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "899":
 "<code>Int → R</code><span class=\"sep\"></span><code class=\"docstring\">The canonical map `Int → R`. </code>",
 "898":
 "<code>IntCast.mk.{u} {R : Type u} (intCast : Int → R) : IntCast R</code>",
 "897":
 "<code>Int.ofNat : Nat → Int</code><span class=\"sep\"></span><code class=\"docstring\">A natural number is an integer.\n\nThis constructor covers the non-negative integers (from `0` to `∞`).\n</code>",
 "896":
 "<code>Nat → R</code><span class=\"sep\"></span><code class=\"docstring\">The canonical map `Nat → R`. </code>",
 "895":
 "<code>NatCast.mk.{u} {R : Type u} (natCast : Nat → R) : NatCast R</code>",
 "894":
 "<code>IntCast.{u} (R : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The canonical homomorphism `Int → R`.\nIn most use cases `R` will have a ring structure and this will be a ring homomorphism.\n</code>",
 "893": "<code>friday : Weekday</code>",
 "892": "<code>wednesday : Weekday</code>",
 "891":
 "<code>Fin 7 → Weekday</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "890":
 "<code>Weekday → Fin 7</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "89": "<code>f (x : α) : β x</code>",
 "889": "<code>Weekday.fromFin : Fin 7 → Weekday</code>",
 "888": "<code>Fin 7</code>",
 "887": "<code>Weekday.toFin : Weekday → Fin 7</code>",
 "886": "<code>Weekday.su : Weekday</code>",
 "885": "<code>Weekday.sa : Weekday</code>",
 "884": "<code>Weekday.fr : Weekday</code>",
 "883": "<code>Weekday.th : Weekday</code>",
 "882": "<code>Weekday.we : Weekday</code>",
 "881": "<code>Weekday.tu : Weekday</code>",
 "880": "<code>Weekday.mo : Weekday</code>",
 "88": "<code>Type</code>",
 "879": "<code>Weekday : Type</code>",
 "878":
 "<code class=\"docstring\">The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b &lt; (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b &lt; 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n</code>",
 "877": "<code>sub' (n k : Nat) : Int</code>",
 "876":
 "<code>Sub.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HSub`: `a - b : α` where `a b : α`. </code>",
 "875": "<code>sub (n k : Nat) : Int</code>",
 "874": "<code>List Nat</code>",
 "873": "<code>Type ?u.31</code>",
 "872":
 "<code>NonEmptyList α</code><span class=\"sep\"></span><code class=\"docstring\">The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. </code>",
 "871":
 "<code>List α → NonEmptyList α</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "870":
 "<code>NonEmptyList.mk.{u} {α : Type u} (contents : List α) (non_empty : contents ≠ []) : NonEmptyList α</code>",
 "87":
 "<code>Array.size.{u} {α : Type u} (a : Array α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Gets the number of elements stored in an array.\n\nThis is a cached value, so it is `O(1)` to access. The space allocated for an array, referred to as\nits _capacity_, is at least as large as its size, but may be larger. The capacity of an array is an\ninternal detail that's not observable by Lean code.\n</code>",
 "869": "<code>oneTwoThree : NonEmptyList Nat</code>",
 "868": "<code>NonEmptyList α</code>",
 "867":
 "<code>NonEmptyList α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "866":
 "<code>NonEmptyList.non_empty.{u} {α : Type u} (self : NonEmptyList α) : self.contents ≠ []</code>",
 "865":
 "<code>NonEmptyList.contents.{u} {α : Type u} (self : NonEmptyList α) : List α</code>",
 "864": "<code>NonEmptyList.{u} (α : Type u) : Type u</code>",
 "863":
 "<code>CoeDep.mk.{u, v} {α : Sort u} {x✝ : α} {β : Sort v} (coe : β) : CoeDep α x✝ β</code>",
 "862": "<code>Sort ?u.3750</code>",
 "861": "<code>Sort ?u.3735</code>",
 "860":
 "<code>β</code><span class=\"sep\"></span><code class=\"docstring\">The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. </code>",
 "86": "<code>i &lt; xs.size</code>",
 "859":
 "<code>CoeT.mk.{u, v} {α : Sort u} {x✝ : α} {β : Sort v} (coe : β) : CoeT α x✝ β</code>",
 "858":
 "<code>CoeT.{u, v} (α : Sort u) : α → Sort v → Sort (max 1 v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeT` is the core typeclass which is invoked by Lean to resolve a type error.\nIt can also be triggered explicitly with the notation `↑x` or by double type\nascription `((x : α) : β)`.\n\nA `CoeT` chain has the grammar `CoeHead? CoeOut* Coe* CoeTail? | CoeDep`.\n</code>",
 "857":
 "<code>NatCast.{u} (R : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Type class for the canonical homomorphism `Nat → R`. </code>",
 "856":
 "<code>CoeTail.mk.{u, v} {α : semiOutParam (Sort u)} {β : Sort v} (coe : α → β) : CoeTail α β</code>",
 "855":
 "<code>CoeHead.mk.{u, v} {α : Sort u} {β : semiOutParam (Sort v)} (coe : α → β) : CoeHead α β</code>",
 "854": "<code>semiOutParam (Sort v)</code>",
 "853": "<code>Bool</code>",
 "852":
 "<code>CoeOut.mk.{u, v} {α : Sort u} {β : semiOutParam (Sort v)} (coe : α → β) : CoeOut α β</code>",
 "851": "<code>Decision.ofBool {α : Type} : Bool → Decision α</code>",
 "850": "<code>Truthy.toBool {α : Type} : Truthy α → Bool</code>",
 "85":
 "<code>Array.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array) with elements\nfrom `α`. This type has special support in the runtime.\n\nArrays perform best when unshared. As long as there is never more than one reference to an array,\nall updates will be performed _destructively_. This results in performance comparable to mutable\narrays in imperative programming languages.\n\nAn array has a size and a capacity. The size is the number of elements present in the array, while\nthe capacity is the amount of memory currently allocated for elements. The size is accessible via\n`Array.size`, but the capacity is not observable from Lean code. `Array.emptyWithCapacity n` creates\nan array which is equal to `#[]`, but internally allocates an array of capacity `n`. When the size\nexceeds the capacity, allocation is required to grow the array.\n\nFrom the point of view of proofs, `Array α` is just a wrapper around `List α`.\n</code>",
 "849": "<code>Truthy.isTrue {α : Type} (self : Truthy α) : Bool</code>",
 "848": "<code>Truthy.val {α : Type} (self : Truthy α) : α</code>",
 "847": "<code>Decision.maybe {α : Type} (val : α) : Decision α</code>",
 "846": "<code>Decision.no {α : Type} : Decision α</code>",
 "845": "<code>Decision.yes {α : Type} : Decision α</code>",
 "844": "<code>Decision (α : Type) : Type</code>",
 "843": "<code>Truthy (α : Type) : Type</code>",
 "842":
 "<code>CoeOut.{u, v} (α : Sort u) (β : semiOutParam (Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeOut α β` is for coercions that are applied from left-to-right.\n</code>",
 "841":
 "<code>CoeHead.{u, v} (α : Sort u) (β : semiOutParam (Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeHead α β` is for coercions that are applied from left-to-right at most once\nat beginning of the coercion chain.\n</code>",
 "840": "<code>Sort ?u.996</code>",
 "84": "<code>Array Nat</code>",
 "839": "<code>Sort ?u.933</code>",
 "838": "<code>Sort ?u.906</code>",
 "837": "<code>Sort ?u.852</code>",
 "836": "<code>Sort ?u.807</code>",
 "835": "<code>Sort ?u.753</code>",
 "834": "<code><span class=\"literal string\">\"three\"</span> : String</code>",
 "833":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. </code>",
 "832": "<code><span class=\"literal string\">\"four\"</span> : String</code>",
 "831":
 "<code>CoeDep.{u, v} (α : Sort u) : α → (β : Sort v) → Sort (max 1 v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeDep α (x : α) β` is a typeclass for dependent coercions, that is, the type `β`\ncan depend on `x` (or rather, the value of `x` is available to typeclass search\nso an instance that relates `β` to `x` is allowed).\n\nDependent coercions do not participate in the transitive chaining process of\nregular coercions: they must exactly match the type mismatch on both sides.\n</code>",
 "830":
 "<code>HMod.hMod.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMod α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int` it satisfies `a % b + b * (a / b) = a`,\n  and `a % 0` is defined to be `a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `%` in identifiers is `mod`.</code>",
 "83": "<code>AllNonZero (xs : Array Nat) : Prop</code>",
 "829": "<code>Even.mk (number : Nat) (isEven : number % 2 = 0) : Even</code>",
 "828": "<code>four : Even</code>",
 "827":
 "<code>Even → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "826": "<code>Even.isEven (self : Even) : self.number % 2 = 0</code>",
 "825": "<code>Even.number (self : Even) : Nat</code>",
 "824": "<code>Even : Type</code>",
 "823":
 "<code>CoeT.{u, v} (α : Sort u) : α → (β : Sort v) → Sort (max 1 v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeT` is the core typeclass which is invoked by Lean to resolve a type error.\nIt can also be triggered explicitly with the notation `↑x` or by double type\nascription `((x : α) : β)`.\n\nA `CoeT` chain has the grammar `CoeHead? CoeOut* Coe* CoeTail? | CoeDep`.\n</code>",
 "822":
 "<code>Twice.mk.{u} {α : Type u} (first second : α) (first_eq_second : first = second) : Twice α</code>",
 "821":
 "<code>α → Twice α</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "820":
 "<code class=\"docstring\">`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n</code>",
 "82":
 "<code>rfl.{u} {α : Sort u} {a : α} : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>",
 "819": "<code>x = x</code>",
 "818": "<code>α</code>",
 "817": "<code>twice.{u} {α : Type u} (x : α) : Twice α</code>",
 "816":
 "<code>Twice.first_eq_second.{u} {α : Type u} (self : Twice α) : self.first = self.second</code>",
 "815": "<code>Twice.second.{u} {α : Type u} (self : Twice α) : α</code>",
 "814": "<code>Twice.first.{u} {α : Type u} (self : Twice α) : α</code>",
 "813": "<code>Twice.{u} (α : Type u) : Type u</code>",
 "812":
 "<code><span class=\"literal string\">\"tomorrow\"</span> : String</code>",
 "811":
 "<code>Nat.fold.{u} {α : Type u} (n : Nat) (f : (i : Nat) → i &lt; n → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Iterates the application of a function `f` to a starting value `init`, `n` times. At each step, `f`\nis applied to the current value and to the next natural number less than `n`, in increasing order.\n\nExamples:\n* `Nat.fold 3 f init = (init |&gt; f 0 (by simp) |&gt; f 1 (by simp) |&gt; f 2 (by simp))`\n* `Nat.fold 4 (fun i _ xs =&gt; xs.push i) #[] = #[0, 1, 2, 3]`\n* `Nat.fold 0 (fun i _ xs =&gt; xs.push i) #[] = #[]`\n</code>",
 "810": "<code>tomorrow : Later String</code>",
 "81":
 "<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>",
 "809":
 "<code>CoeTail.coe.{u, v} {α : semiOutParam (Sort u)} {β : Sort v} [self : CoeTail α β] : α → β</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "808": "<code>Unit → α</code>",
 "807":
 "<code>α → Later α</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "806":
 "<code>CoeTail.{u, v} (α : semiOutParam (Sort u)) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeTail α β` is for coercions that can only appear at the end of a\nsequence of coercions. That is, `α` can be further coerced via `Coe σ α` and\n`CoeHead τ σ` instances but `β` will only be the expected type of the expression.\n</code>",
 "805": "<code>Later.get.{u} {α : Type u} (self : Later α) : Unit → α</code>",
 "804": "<code>Later.{u} (α : Type u) : Type u</code>",
 "803":
 "<code>Coe.coe.{u, v} {α : semiOutParam (Sort u)} {β : Sort v} [self : Coe α β] : α → β</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "802":
 "<code>α → β</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "801":
 "<code>Coe.mk.{u, v} {α : semiOutParam (Sort u)} {β : Sort v} (coe : α → β) : Coe α β</code>",
 "800": "<code>?m.280</code>",
 "80":
 "<code>Bool : Type</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean values, `true` and `false`.\n\nLogically speaking, this is equivalent to `Prop` (the type of propositions). The distinction is\nimportant for programming: both propositions and their proofs are erased in the code generator,\nwhile `Bool` corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.\n</code>",
 "8": "<code>bogus : False</code>",
 "799": "<code>semiOutParam (Sort u)</code>",
 "798": "<code>one : Decimal</code>",
 "797": "<code>Array (Fin 10)</code>",
 "796": "<code>twoHundredThirteen : Decimal</code>",
 "795":
 "<code>Decimal → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "794":
 "<code>Fin.val {n : Nat} (self : Fin n) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number that is strictly less than `n`.\n\n`Fin.val` is a coercion, so any `Fin n` can be used in a position where a `Nat` is expected.\n</code>",
 "793": "<code>Fin 10</code>",
 "792":
 "<code>Array.foldl.{u, v} {α : Type u} {β : Type v} (f : β → α → β) (init : β) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over an array from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the array in order, using `f`.\n\nThe optional parameters `start` and `stop` control the region of the array to be folded. Folding\nproceeds from `start` (inclusive) to `stop` (exclusive), so no folding occurs unless `start &lt; stop`.\nBy default, the entire array is used.\n\nExamples:\n * `#[a, b, c].foldl f z  = f (f (f z a) b) c`\n * `#[1, 2, 3].foldl (· ++ toString ·) \"\" = \"123\"`\n * `#[1, 2, 3].foldl (s!\"({·} {·})\") \"\" = \"((( 1) 2) 3)\"`\n</code>",
 "791": "<code>Decimal</code>",
 "790": "<code>Decimal.toNat (d : Decimal) : Nat</code>",
 "79": "<code>Bool</code>",
 "789": "<code>Decimal.digits (self : Decimal) : Array (Fin 10)</code>",
 "788": "<code>Decimal : Type</code>",
 "787": "<code class=\"docstring\">Adds a definition as a coercion</code>",
 "786":
 "<code>Bin</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "785":
 "<code>Nat → Bin</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "784":
 "<code>Coe.{u, v} (α : semiOutParam (Sort u)) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`Coe α β` is the typeclass for coercions from `α` to `β`. It can be transitively\nchained with other `Coe` instances, and coercion is automatically used when\n`x` has type `α` but it is used in a context where `β` is expected.\nYou can use the `↑x` operator to explicitly trigger coercion.\n</code>",
 "783":
 "<code class=\"docstring\">The `@[coe]` attribute on a function (which should also appear in a\n`instance : Coe A B := ⟨myFn⟩` declaration) allows the delaborator to show\napplications of this function as `↑` when printing expressions.\n</code>",
 "782": "<code>Bin.ofNat (n : Nat) : Bin</code>",
 "781": "<code>Bin.succ (b : Bin) : Bin</code>",
 "780": "<code>Bin → String</code>",
 "78": "<code>two (b : Bool) : if b = true then Unit × Unit else String</code>",
 "779": "<code><span class=\"literal string\">\"1\"</span> : String</code>",
 "778": "<code>Bin</code>",
 "777": "<code>Bin.toString : Bin → String</code>",
 "776": "<code>Bin.one : Bin → Bin</code>",
 "775": "<code>Bin.zero : Bin → Bin</code>",
 "774": "<code>Bin.done : Bin</code>",
 "773": "<code>Bin : Type</code>",
 "772":
 "<code>Int.bdiv (x : Int) (m : Nat) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Balanced division.\n\nThis returns the unique integer so that `b * (Int.bdiv a b) + Int.bmod a b = a`.\n\nExamples:\n* `(7 : Int).bdiv 0 = 0`\n* `(0 : Int).bdiv 7 = 0`\n* `(12 : Int).bdiv 6 = 2`\n* `(12 : Int).bdiv 7 = 2`\n* `(12 : Int).bdiv 8 = 2`\n* `(12 : Int).bdiv 9 = 1`\n* `(-12 : Int).bdiv 6 = -2`\n* `(-12 : Int).bdiv 7 = -2`\n* `(-12 : Int).bdiv 8 = -1`\n* `(-12 : Int).bdiv 9 = -1`\n</code>",
 "771":
 "<code>Lean.Syntax.Term : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a Lean term.\n</code>",
 "770":
 "<code>Lean.Syntax.Ident : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents an identifier.\n</code>",
 "77":
 "<code>Quot.{u} {α : Sort u} (r : α → α → Prop) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Low-level quotient types. Quotient types coarsen the propositional equality for a type `α`, so that\nterms related by some relation `r` are considered equal in `Quot r`.\n\nSet-theoretically, `Quot r` can seen as the set of equivalence classes of `α` modulo `r`. Functions\nfrom `Quot r` must prove that they respect `r`: to define a function `f : Quot r → β`, it is\nnecessary to provide `f' : α → β` and prove that for all `x : α` and `y : α`, `r x y → f' x = f' y`.\n\n`Quot` is a built-in primitive:\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.sound` asserts the equality of elements related by `r`.\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`.\n\nThe relation `r` is not required to be an equivalence relation; the resulting quotient type's\nequality extends `r` to an equivalence as a consequence of the rules for equality and quotients.\nWhen `r` is an equivalence relation, it can be more convenient to use the higher-level type\n`Quotient`.\n</code>",
 "769": "<code>Ident</code>",
 "768": "<code>Int → String</code>",
 "767": "<code>th (f : Int → String) (x : Nat) : Thunk String</code>",
 "766": "<code>Fin k</code>",
 "765":
 "<code>Lean.TSyntax (ks : Lean.SyntaxNodeKinds) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Typed syntax, which tracks the potential kinds of the `Syntax` it contains.\n\nWhile syntax quotations produce or expect `TSyntax` values of the correct kinds, this is not\notherwise enforced; it can easily be circumvented by direct use of the constructor.\n</code>",
 "764": "<code>Name</code>",
 "763":
 "<code>Thunk.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Delays evaluation. The delayed code is evaluated at most once.\n\nA thunk is code that constructs a value when it is requested via `Thunk.get`, `Thunk.map`, or\n`Thunk.bind`. The resulting value is cached, so the code is executed at most once. This is also\nknown as lazy or call-by-need evaluation.\n\nThe Lean runtime has special support for the `Thunk` type in order to implement the caching\nbehavior.\n</code>",
 "762": "<code>?m.83</code>",
 "761": "<code>Dynamic</code>",
 "760":
 "<code>TypeName.mk.{u} (α : Type u) (typeName : Lean.Name) : TypeName α</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `TypeName` instance.\n\nFor safety, it is required that the constant `typeName` is definitionally equal\nto `α`.\n</code>",
 "76": "<code><span class=\"literal string\">\"number\"</span> : String</code>",
 "759":
 "<code>TypeName.{u} (α : Type u) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Dynamic type name information.\nTypes with an instance of `TypeName` can be stored in an `Dynamic`.\nThe type class contains the declaration name of the type,\nwhich must not have any universe parameters\nand be of type `Sort ..` (i.e., monomorphic).\n\nThe preferred way to declare instances of this type is using the derive\nhandler, which will internally use the unsafe `TypeName.mk` function.\n\nMorally, this is the same as:\n```lean\nclass TypeName (α : Type) where unsafe mk ::\n  typeName : Name\n```\n</code>",
 "758":
 "<code>p_all {p : Nat → Prop} (pZero : p 0) (pStep : ∀ (n : Nat), p n → p (n + 1)) (n : Nat) : p n</code>",
 "757":
 "<code class=\"docstring\">`omit` instructs Lean to not include a variable previously `include`d. Apart from variable names, it\ncan also refer to typeclass instance variables by type using the syntax `omit [TypeOfInst]`, in\nwhich case all instance variables that unify with the given type are omitted. `omit` should usually\nonly be used in conjunction with `in` in order to keep the section structure simple.\n</code>",
 "756": "<code>p✝ 15</code>",
 "755":
 "<code>p_all {p : Nat → Prop} (pFifteen : p 15) {p✝ : Nat → Prop} (pZero : p✝ 0) (pStep : ∀ (n : Nat), p✝ n → p✝ (n + 1))\n  (n : Nat) : p✝ n</code>",
 "754":
 "<code class=\"docstring\">`include eeny meeny` instructs Lean to include the section `variable`s `eeny` and `meeny` in all\ntheorems in the remainder of the current section, differing from the default behavior of\nconditionally including variables based on use in the theorem header. Other commands are\nnot affected. `include` is usually followed by `in theorem ...` to limit the inclusion\nto the subsequent declaration.\n</code>",
 "753": "<code>p n✝</code>",
 "752": "<code>p_all {p : Nat → Prop} (n : Nat) : p n</code>",
 "751": "<code>p 15</code>",
 "750": "<code>∀ (n : Nat), p n → p (n + 1)</code>",
 "75": "<code><span class=\"literal string\">\"Wrong\"</span> : String</code>",
 "749": "<code>p 0</code>",
 "748": "<code>Nat → Prop</code>",
 "747":
 "<code>addAll.{u} {α : Type u} (xs : List α) [Zero α] [Add α] : α</code>",
 "746":
 "<code>List.foldr.{u, v} {α : Type u} {β : Type v} (f : α → β → β) (init : β) (l : List α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a list from the right, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in reverse order, using `f`.\n\n`O(|l|)`. Replaced at runtime with `List.foldrTR`.\n\nExamples:\n * `[a, b, c].foldr f init  = f a (f b (f c init))`\n * `[1, 2, 3].foldr (toString · ++ ·) \"\" = \"123\"`\n * `[1, 2, 3].foldr (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"`\n</code>",
 "745": "<code>addAll.{u_1, u_2} (lst : List sorry) : sorry</code>",
 "744":
 "<code>Zero.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type with a zero element. </code>",
 "743":
 "<code><span class=\"literal string\">\"delicious\"</span> : String</code>",
 "742": "<code>Dessert.cupcake : String</code>",
 "741": "<code>Greetings.english : String</code>",
 "740": "<code>Tree.branches.{u} {α : Type u} : List (Tree α) → Tree α</code>",
 "74": "<code><span class=\"literal string\">\"there\"</span> : String</code>",
 "739": "<code>Tree.val.{u} {α : Type u} : α → Tree α</code>",
 "738": "<code>Tree.big (n : Nat) : Tree Nat</code>",
 "737": "<code>Tree.{u} (α : Type u) : Type u</code>",
 "736":
 "<code>guard_msgs.diff</code><span class=\"sep\"></span><code class=\"docstring\">When true, show a diff between expected and actual messages if they don't match. </code>",
 "735":
 "<code>String.toList (s : String) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a string to a list of characters.\n\nEven though the logical model of strings is as a structure that wraps a list of characters, this\noperation takes time and space linear in the length of the string. At runtime, strings are\nrepresented as dynamic arrays of bytes.\n\nExamples:\n * `\"abc\".toList = ['a', 'b', 'c']`\n * `\"\".toList = []`\n * `\"\\n\".toList = ['\\n']`\n</code>",
 "734": "<code><span class=\"literal string\">\"abc\"</span> : String</code>",
 "733":
 "<code>reverse.helper.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code>",
 "732": "<code>reverse.{u_1} {α : Type u_1} : List α → List α</code>",
 "731":
 "<code class=\"docstring\">`/-- ... -/ #guard_msgs in cmd` captures the messages generated by the command `cmd`\nand checks that they match the contents of the docstring.\n\nBasic example:\n```lean\n/--\nerror: unknown identifier 'x'\n-/\n#guard_msgs in\nexample : α := x\n```\nThis checks that there is such an error and then consumes the message.\n\nBy default, the command captures all messages, but the filter condition can be adjusted.\nFor example, we can select only warnings:\n```lean\n/--\nwarning: declaration uses 'sorry'\n-/\n#guard_msgs(warning) in\nexample : α := sorry\n```\nor only errors\n```lean\n#guard_msgs(error) in\nexample : α := sorry\n```\nIn the previous example, since warnings are not captured there is a warning on `sorry`.\nWe can drop the warning completely with\n```lean\n#guard_msgs(error, drop warning) in\nexample : α := sorry\n```\n\nIn general, `#guard_msgs` accepts a comma-separated list of configuration clauses in parentheses:\n```\n#guard_msgs (configElt,*) in cmd\n```\nBy default, the configuration list is `(all, whitespace := normalized, ordering := exact)`.\n\nMessage filters (processed in left-to-right order):\n- `info`, `warning`, `error`: capture messages with the given severity level.\n- `all`: capture all messages (the default).\n- `drop info`, `drop warning`, `drop error`: drop messages with the given severity level.\n- `drop all`: drop every message.\n\nWhitespace handling (after trimming leading and trailing whitespace):\n- `whitespace := exact` requires an exact whitespace match.\n- `whitespace := normalized` converts all newline characters to a space before matching\n  (the default). This allows breaking long lines.\n- `whitespace := lax` collapses whitespace to a single space before matching.\n\nMessage ordering:\n- `ordering := exact` uses the exact ordering of the messages (the default).\n- `ordering := sorted` sorts the messages in lexicographic order.\n  This helps with testing commands that are non-deterministic in their ordering.\n\nFor example, `#guard_msgs (error, drop all) in cmd` means to check warnings and drop\neverything else.\n\nThe command elaborator has special support for `#guard_msgs` for linting.\nThe `#guard_msgs` itself wants to capture linter warnings,\nso it elaborates the command it is attached to as if it were a top-level command.\nHowever, the command elaborator runs linters for *all* top-level commands,\nwhich would include `#guard_msgs` itself, and would cause duplicate and/or uncaptured linter warnings.\nThe top-level command elaborator only runs the linters if `#guard_msgs` is not present.\n</code>",
 "730": "<code>Lean.versionString : String</code>",
 "73": "<code><span class=\"literal string\">\"Hello\"</span> : String</code>",
 "729":
 "<code class=\"docstring\">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed\nwith `end &lt;id&gt;`. The `end` command is optional at the end of a file.\n</code>",
 "728":
 "<code class=\"docstring\">`#where` gives a description of the state of the current scope scope.\nThis includes the current namespace, `open` namespaces, `universe` and `variable` commands,\nand options set with `set_option`.\n</code>",
 "727":
 "<code>pp.funBinderTypes</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display types of lambda parameters</code>",
 "726":
 "<code class=\"docstring\">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside\nthe section:\n* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the\n  full name `Nat.seventeen`.\n* Names introduced by `export` declarations are also prefixed by the identifier.\n* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names\n  are preferred over names introduced by outer namespaces or `open`.\n* Within a namespace, declarations can be `protected`, which excludes them from the effects of\n  opening the namespace.\n\nAs with `section`, namespaces can be nested and the scope of a namespace is terminated by a\ncorresponding `end &lt;id&gt;` or the end of the file.\n\n`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.\n</code>",
 "725":
 "<code class=\"docstring\">Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ =&gt; a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" =&gt; BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n</code>",
 "724":
 "<code class=\"docstring\">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`\ncommands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear\nwith the matching `end`. In either case, the `end` can be omitted, in which case the section is\nclosed at the end of the file.\n</code>",
 "723":
 "<code>intersperse.eq_unfold.{u_1} :\n  @intersperse = fun {α} x x_1 =&gt;\n    match x_1 with\n    | y :: z :: zs =&gt; y :: x :: intersperse x (z :: zs)\n    | xs =&gt; xs</code>",
 "722":
 "<code>intersperse.eq_def.{u_1} {α : Type u_1} (x : α) (x✝ : List α) :\n  intersperse x x✝ =\n    match x✝ with\n    | y :: z :: zs =&gt; y :: x :: intersperse x (z :: zs)\n    | xs =&gt; xs</code>",
 "721":
 "<code>intersperse.{u_1} {α : Type u_1} (x : α) : List α → List α</code>",
 "720":
 "<code>HXor.hXor.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HXor α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^^^` in identifiers is `xor`.</code>",
 "72":
 "<code>String : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string is a sequence of Unicode code points.\n\nAt runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nof bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters\n(`String.length`) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.\n</code>",
 "719":
 "<code>Prod.mk.injEq.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) (fst✝ : α) (snd✝ : β) :\n  ((fst, snd) = (fst✝, snd✝)) = (fst = fst✝ ∧ snd = snd✝)</code>",
 "718": "<code>swap_eq_swap' : swap = swap'</code>",
 "717":
 "<code class=\"docstring\">Close fixed-width `BitVec` and `Bool` goals by obtaining a proof from an external SAT solver and\nverifying it inside Lean. The solvable goals are currently limited to\n- the Lean equivalent of [`QF_BV`](https://smt-lib.org/logics-all.shtml#QF_BV)\n- automatically splitting up `structure`s that contain information about `BitVec` or `Bool`\n```lean\nexample : ∀ (a b : BitVec 64), (a &&& b) + (a ^^^ b) = a ||| b := by\n  intros\n  bv_decide\n```\n\nIf `bv_decide` encounters an unknown definition it will be treated like an unconstrained `BitVec`\nvariable. Sometimes this enables solving goals despite not understanding the definition because\nthe precise properties of the definition do not matter in the specific proof.\n\nIf `bv_decide` fails to close a goal it provides a counter-example, containing assignments for all\nterms that were considered as variables.\n\nIn order to avoid calling a SAT solver every time, the proof can be cached with `bv_decide?`.\n\nIf solving your problem relies inherently on using associativity or commutativity, consider enabling\nthe `bv.ac_nf` option.\n\n\nNote: `bv_decide` uses `ofReduceBool` and thus trusts the correctness of the code generator.\n\nNote: include `import Std.Tactic.BVDecide`\n</code>",
 "716": "<code>swap' (x y : BitVec 32) : BitVec 32 × BitVec 32</code>",
 "715":
 "<code>BitVec (w : Nat) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A bitvector of the specified width.\n\nThis is represented as the underlying `Nat` number in both the runtime\nand the kernel, inheriting all the special support for `Nat`.\n</code>",
 "714": "<code>BitVec 32</code>",
 "713": "<code>swap (x y : BitVec 32) : BitVec 32 × BitVec 32</code>",
 "712": "<code><span class=\"literal string\">\"one\"</span> : String</code>",
 "711": "<code>?m.12</code>",
 "710":
 "<code>HAdd.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous addition.\nThis enables the notation `a + b : γ` where `a : α`, `b : β`.\n</code>",
 "71":
 "<code>Int : Type</code><span class=\"sep\"></span><code class=\"docstring\">The integers.\n\nThis type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for `Int` that stores “small” signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)). A “small number” is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).\n</code>",
 "709": "<code>?m.9</code>",
 "708":
 "<code class=\"docstring\">`#reduce &lt;expression&gt;` reduces the expression `&lt;expression&gt;` to its normal form. This\ninvolves applying reduction rules until no further reduction is possible.\n\nBy default, proofs and types within the expression are not reduced. Use modifiers\n`(proofs := true)`  and `(types := true)` to reduce them.\nRecall that propositions are types in Lean.\n\n**Warning:** This can be a computationally expensive operation,\nespecially for complex expressions.\n\nConsider using `#eval &lt;expression&gt;` for simple evaluation/execution\nof expressions.\n</code>",
 "707":
 "<code>MonadEvalT.mk.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} (monadEval : {α : Type u} → m α → n α) :\n  MonadEvalT m n</code>",
 "706": "<code>Type u → Type v</code>",
 "705":
 "<code>{α : Type u} → m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Evaluates a value from monad `m` into monad `n`. </code>",
 "704":
 "<code>MonadEval.mk.{u, v, w} {m : semiOutParam (Type u → Type v)} {n : Type u → Type w}\n  (monadEval : {α : Type u} → m α → n α) : MonadEval m n</code>",
 "703": "<code>Type u → Type u_1</code>",
 "702": "<code>Type u → Type w</code>",
 "701":
 "<code>semiOutParam.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n</code>",
 "700": "<code>semiOutParam (Type u → Type v)</code>",
 "70":
 "<code>PUnit.{u} : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">The canonical universe-polymorphic type with just one element.\n\nIt should be used in contexts that require a type to be universe polymorphic, thus disallowing\n`Unit`.\n</code>",
 "7": "<code>Nat</code>",
 "699":
 "<code>MonadLift.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">Computations in the monad `m` can be run in the monad `n`. These translations are inserted\nautomatically by the compiler.\n\nUsually, `n` consists of some number of monad transformers applied to `m`, but this is not\nmandatory.\n\nNew instances should use this class, `MonadLift`. Clients that require one monad to be liftable into\nanother should instead request `MonadLiftT`, which is the reflexive, transitive closure of\n`MonadLift`.\n</code>",
 "698": "<code>Quadrant.ne : Quadrant</code>",
 "697": "<code>Quadrant.se : Quadrant</code>",
 "696": "<code>Quadrant.sw : Quadrant</code>",
 "695": "<code>Quadrant.nw : Quadrant</code>",
 "694": "<code>Quadrant : Type</code>",
 "693":
 "<code>Lean.ToExpr.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">We use the `ToExpr` type class to convert values of type `α` into\nexpressions that denote these values in Lean.\n\nExamples:\n```\ntoExpr true = .const ``Bool.true []\n\ntoTypeExpr Bool = .const ``Bool []\n```\n\nSee also `ToLevel` for representing universe levels as `Level` expressions.\n</code>",
 "692":
 "<code>MonadEvalT.monadEval.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} [self : MonadEvalT m n] {α : Type u} :\n  m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Evaluates a value from monad `m` into monad `n`. </code>",
 "691":
 "<code>MonadLiftT.monadLift.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} [self : MonadLiftT m n] {α : Type u} :\n  m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Translates an action from monad `m` into monad `n`. </code>",
 "690":
 "<code>MonadEvalT.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The transitive closure of `MonadEval`. </code>",
 "69": "<code>LengthList.{u} (α : Type u) : Nat → Type u</code>",
 "689":
 "<code>MonadLiftT.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">Computations in the monad `m` can be run in the monad `n`. These translations are inserted\nautomatically by the compiler.\n\nUsually, `n` consists of some number of monad transformers applied to `m`, but this is not\nmandatory.\n\nThis is the reflexive, transitive closure of `MonadLift`. Clients that require one monad to be\nliftable into another should request an instance of `MonadLiftT`. New instances should instead be\ndefined for `MonadLift` itself.\n</code>",
 "688": "<code>Type → Type</code>",
 "687":
 "<code>Lean.Core.CoreM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">CoreM is a monad for manipulating the Lean environment.\nIt is the base monad for `MetaM`.\nThe main features it provides are:\n- name generator state\n- environment state\n- Lean options context\n- the current open namespace\n</code>",
 "686":
 "<code>Lean.Meta.MetaM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The `MetaM` monad is a core component of Lean's metaprogramming framework, facilitating the\nconstruction and manipulation of expressions (`Lean.Expr`) within Lean.\n\nIt builds on top of `CoreM` and additionally provides:\n- A `LocalContext` for managing free variables.\n- A `MetavarContext` for managing metavariables.\n- A `Cache` for caching results of the key `MetaM` operations.\n\nThe key operations provided by `MetaM` are:\n- `inferType`, which attempts to automatically infer the type of a given expression.\n- `whnf`, which reduces an expression to the point where the outermost part is no longer reducible\n  but the inside may still contain unreduced expression.\n- `isDefEq`, which determines whether two expressions are definitionally equal, possibly assigning\n  meta variables in the process.\n- `forallTelescope` and `lambdaTelescope`, which make it possible to automatically move into\n  (nested) binders while updating the local context.\n\nThe following is a small example that demonstrates how to obtain and manipulate the type of a\n`Fin` expression:\n```\nimport Lean\n\nopen Lean Meta\n\ndef getFinBound (e : Expr) : MetaM (Option Expr) := do\n  let type ← whnf (← inferType e)\n  let_expr Fin bound := type | return none\n  return bound\n\ndef a : Fin 100 := 42\n\nrun_meta\n  match ← getFinBound (.const ``a []) with\n  | some limit =&gt; IO.println (← ppExpr limit)\n  | none =&gt; IO.println \"no limit found\"\n```\n</code>",
 "685": "<code>Lean.Elab.Term.TermElabM (α : Type) : Type</code>",
 "684": "<code>Lean.Elab.Command.CommandElabM (α : Type) : Type</code>",
 "683":
 "<code class=\"docstring\">The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n</code>",
 "682":
 "<code>eval.derive.repr</code><span class=\"sep\"></span><code class=\"docstring\">('#eval' command) enables auto-deriving 'Repr' instances as a fallback</code>",
 "681":
 "<code>eval.type</code><span class=\"sep\"></span><code class=\"docstring\">('#eval' command) enables pretty printing the type of the result</code>",
 "680":
 "<code>eval.pp</code><span class=\"sep\"></span><code class=\"docstring\">('#eval' command) enables using 'ToExpr' instances to pretty print the result, otherwise uses 'Repr' or 'ToString' instances</code>",
 "68": "<code>S : Type</code>",
 "679":
 "<code>MonadEval.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">Typeclass used for adapting monads. This is similar to `MonadLift`, but instances are allowed to\nmake use of default state for the purpose of synthesizing such an instance, if necessary.\nEvery `MonadLift` instance gives a `MonadEval` instance.\n\nThe purpose of this class is for the `#eval` command,\nwhich looks for a `MonadEval m CommandElabM` or `MonadEval m IO` instance.\n</code>",
 "678": "<code>?m.38</code>",
 "677": "<code>Lean.MessageSeverity.error : Lean.MessageSeverity</code>",
 "676": "<code>Lean.MessageSeverity.warning : Lean.MessageSeverity</code>",
 "675": "<code>Lean.MessageSeverity.information : Lean.MessageSeverity</code>",
 "674":
 "<code>Squash.mk.{u} {α : Sort u} (x : α) : Squash α</code><span class=\"sep\"></span><code class=\"docstring\">Places a value into its squash type, in which it cannot be distinguished from any other.\n</code>",
 "673": "<code>∀ (a : α), motive (Squash.mk a)</code>",
 "672": "<code>Squash α → Prop</code>",
 "671": "<code>Squash α</code>",
 "670":
 "<code>Nonempty.rec.{u} {α : Sort u} {motive : Nonempty α → Prop} (intro : ∀ (val : α), motive ⋯) (t : Nonempty α) : motive t</code>",
 "67": "<code>S.f2 (self : S) : β</code>",
 "669":
 "<code>Squash.lift.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} [Subsingleton β] (s : Squash α) (f : α → β) : β</code><span class=\"sep\"></span><code class=\"docstring\">Extracts a squashed value into any subsingleton type.\n\nIf `β` is a subsingleton, a function `α → β` cannot distinguish between elements of `α` and thus\nautomatically respects the universal relation that `Squash` quotients with.\n</code>",
 "668":
 "<code>Nonempty.{u} (α : Sort u) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nonempty α` is a typeclass that says that `α` is not an empty type,\nthat is, there exists an element in the type. It differs from `Inhabited α`\nin that `Nonempty α` is a `Prop`, which means that it does not actually carry\nan element of `α`, only a proof that *there exists* such an element.\nGiven `Nonempty α`, you can construct an element of `α` *nonconstructively*\nusing `Classical.choice`.\n</code>",
 "667":
 "<code>Squash.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">The quotient of `α` by the universal relation. The elements of `Squash α` are those of `α`, but all\nof them are equal and cannot be distinguished.\n\n`Squash α` is a `Subsingleton`: it is empty if `α` is empty, otherwise it has just one element. It\nis the “universal `Subsingleton`” mapped from `α`.\n\n`Nonempty α` also has these properties. It is a proposition, which means that its elements (i.e.\nproofs) are erased from compiled code and represented by a dummy value. `Squash α` is a `Type u`,\nand its representation in compiled code is identical to that of `α`.\n\nConsequently, `Squash.lift` may extract an `α` value into any subsingleton type `β`, while\n`Nonempty.rec` can only do the same when `β` is a proposition.\n</code>",
 "666":
 "<code>congrArg.{u, v} {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β) (h : a₁ = a₂) : f a₁ = f a₂</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in the function argument: if `a₁ = a₂` then `f a₁ = f a₂` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`&lt;something containing a₁&gt; = &lt;something containing a₂&gt;`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "665": "<code>Quot.mk extEq f = Quot.mk extEq g</code>",
 "664": "<code>(fun x =&gt; f x) = fun x =&gt; g x</code>",
 "663":
 "<code>(fun x =&gt; Quot.lift (fun x_1 =&gt; x_1 x) ⋯ (Quot.mk extEq f)) = fun x =&gt; Quot.lift (fun x_1 =&gt; x_1 x) ⋯ (Quot.mk extEq g)</code>",
 "662":
 "<code class=\"docstring\">* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n</code>",
 "661": "<code>extApp (Quot.mk extEq f) = extApp (Quot.mk extEq g)</code>",
 "660":
 "<code class=\"docstring\">Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n </code>",
 "66": "<code>S.f1 (self : S) : α</code>",
 "659":
 "<code>funext'.{u, v} {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x} (h : ∀ (x : α), f x = g x) : f = g</code>",
 "658": "<code>extEq x✝¹ x✝</code>",
 "657":
 "<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>",
 "656": "<code>extEq g g'</code>",
 "655": "<code>ExtFun α β</code>",
 "654":
 "<code>extApp.{u, v} {α : Sort u} {β : α → Sort v} (f : ExtFun α β) (x : α) : β x</code>",
 "653":
 "<code>ExtFun.{u, v} (α : Sort u) (β : α → Sort v) : Sort (imax u v)</code>",
 "652":
 "<code>extEq.{u, v} {α : Sort u} {β : α → Sort v} (f g : (x : α) → β x) : Prop</code>",
 "651": "<code>∀ (a b : α), r a b → HEq (f a) (f b)</code>",
 "650":
 "<code>Quot.recOn.{u, v} {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (q : Quot r)\n  (f : (a : α) → motive (Quot.mk r a)) (h : ∀ (a b : α) (p : r a b), ⋯ ▸ f a = f b) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quot` that takes the quotient first. It is analogous to the\n[recursor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can be used when the resulting type\nis not necessarily a proposition.\n\nWhile it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:\n * `Quot.lift` is useful for defining non-dependent functions.\n * `Quot.ind` is useful for proving theorems about quotients.\n * `Quot.recOnSubsingleton` can be used whenever the target type is a `Subsingleton`.\n * `Quot.hrecOn` uses [heterogeneous equality](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=HEq) instead of rewriting with\n   `Quot.sound`.\n\n`Quot.rec` is a version of this recursor that takes the quotient parameter last.\n</code>",
 "65": "<code>x : S</code>",
 "649":
 "<code>Quot.hrecOn.{u, v} {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (q : Quot r)\n  (f : (a : α) → motive (Quot.mk r a)) (c : ∀ (a b : α), r a b → HEq (f a) (f b)) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quot` that uses [heterogeneous\nequality](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=HEq), analogous to a [recursor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=recursors) for\na structure.\n\n`Quot.recOn` is a version of this recursor that uses `Eq` instead of `HEq`.\n</code>",
 "648":
 "<code>Quot.recOnSubsingleton.{u, v} {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v}\n  [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))] (q : Quot r) (f : (a : α) → motive (Quot.mk r a)) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">An alternative induction principle for quotients that can be used when the target type is a\nsubsingleton, in which all elements are equal.\n\nIn these cases, the proof that the function respects the quotient's relation is trivial, so any\nfunction can be lifted.\n\n`Quot.rec` does not assume that the type is a subsingleton.\n</code>",
 "647": "<code>r a b</code>",
 "646": "<code>∀ (a b : α) (p : r a b), ⋯ ▸ f a = f b</code>",
 "645": "<code>(a : α) → motive (Quot.mk r a)</code>",
 "644": "<code>∀ (a : α), Subsingleton (motive (Quot.mk r a))</code>",
 "643": "<code>Quot r → Sort v</code>",
 "642": "<code>List (SetTree α)</code>",
 "641": "<code>Type u → Type u</code>",
 "640":
 "<code>RoseTree.branch.{u} {α : Type u} : List (RoseTree α) → RoseTree α</code>",
 "64": "<code>S.mk (f1 : α) (f2 : β) : S</code>",
 "639": "<code>RoseTree.leaf.{u} {α : Type u} : α → RoseTree α</code>",
 "638": "<code>RoseTree.{u} (α : Type u) : Type u</code>",
 "637":
 "<code>Quot.liftOn.{u, v} {α : Sort u} {β : Sort v} {r : α → α → Prop} (q : Quot r) (f : α → β)\n  (c : ∀ (a b : α), r a b → f a = f b) : β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's relation.\n\nGiven a relation `r : α → α → Prop` and a quotient's value `q : Quot r`, applying a `f : α → β`\nrequires a proof `c` that `f` respects `r`. In this case, `Quot.liftOn q f h : β` evaluates\nto the result of applying `f` to the underlying value in `α` from `q`.\n\n`Quot.liftOn` is a version of the built-in primitive `Quot.lift` with its parameters re-ordered.\n\n[Quotient types](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=quotients) are described in more detail in the Lean Language\nReference.\n</code>",
 "636": "<code>Sort ?u.26</code>",
 "635": "<code>Sort ?u.19</code>",
 "634":
 "<code class=\"docstring\">Declares one or more typed variables, or modifies whether already-declared variables are\n  implicit.\n\nIntroduces variables that can be used in definitions within the same `namespace` or `section` block.\nWhen a definition mentions a variable, Lean will add it as an argument of the definition. This is\nuseful in particular when writing many definitions that have parameters in common (see below for an\nexample).\n\nVariable declarations have the same flexibility as regular function parameters. In particular they\ncan be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they\ncan be anonymous). This can be changed, for instance one can turn explicit variable `x` into an\nimplicit one with `variable {x}`. Note that currently, you should avoid changing how variables are\nbound and declare new variables at the same time; see [issue 2789] for more on this topic.\n\nIn *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that\nchanges to the proof cannot change the statement of the overall theorem. Instead, variables are only\navailable to the proof if they have been mentioned in the theorem header or in an `include` command\nor are instance implicit and depend only on such variables.\n\nSee [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed\ndiscussion.\n\n[tpil vars]:\nhttps://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections\n(Variables and Sections on Theorem Proving in Lean) [tpil classes]:\nhttps://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in\nLean) [binder docs]:\nhttps://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation\nfor the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789\non github)\n\n## Examples\n\n```lean\nsection\n  variable\n    {α : Type u}      -- implicit\n    (a : α)           -- explicit\n    [instBEq : BEq α] -- instance implicit, named\n    [Hashable α]      -- instance implicit, anonymous\n\n  def isEqual (b : α) : Bool :=\n    a == b\n\n  #check isEqual\n  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool\n\n  variable\n    {a} -- `a` is implicit now\n\n  def eqComm {b : α} := a == b ↔ b == a\n\n  #check eqComm\n  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop\nend\n```\n\nThe following shows a typical use of `variable` to factor out definition arguments:\n\n```lean\nvariable (Src : Type)\n\nstructure Logger where\n  trace : List (Src × String)\n#check Logger\n-- Logger (Src : Type) : Type\n\nnamespace Logger\n  -- switch `Src : Type` to be implicit until the `end Logger`\n  variable {Src}\n\n  def empty : Logger Src where\n    trace := []\n  #check empty\n  -- Logger.empty {Src : Type} : Logger Src\n\n  variable (log : Logger Src)\n\n  def len :=\n    log.trace.length\n  #check len\n  -- Logger.len {Src : Type} (log : Logger Src) : Nat\n\n  variable (src : Src) [BEq Src]\n\n  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments\n\n  def filterSrc :=\n    log.trace.filterMap\n      fun (src', str') =&gt; if src' == src then some str' else none\n  #check filterSrc\n  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String\n\n  def lenSrc :=\n    log.filterSrc src |&gt;.length\n  #check lenSrc\n  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat\nend Logger\n```\n\nThe following example demonstrates availability of variables in proofs:\n```lean\nvariable\n  {α : Type}    -- available in the proof as indirectly mentioned through `a`\n  [ToString α]  -- available in the proof as `α` is included\n  (a : α)       -- available in the proof as mentioned in the header\n  {β : Type}    -- not available in the proof\n  [ToString β]  -- not available in the proof\n\ntheorem ex : a = a := rfl\n```\nAfter elaboration of the proof, the following warning will be generated to highlight the unused\nhypothesis:\n```\nincluded section variable '[ToString α]' is not used in 'ex', consider excluding it\n```\nIn such cases, the offending variable declaration should be moved down or into a section so that\nonly theorems that do depend on it follow it until the end of the section.\n</code>",
 "633": "<code>∀ (x y : α), r x y → f x = f y</code>",
 "632":
 "<code>Quot.rec.{u, v} {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (f : (a : α) → motive (Quot.mk r a))\n  (h : ∀ (a b : α) (p : r a b), ⋯ ▸ f a = f b) (q : Quot r) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quot`. It is analogous to the\n[recursor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can be used when the resulting type\nis not necessarily a proposition.\n\nWhile it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:\n * `Quot.lift` is useful for defining non-dependent functions.\n * `Quot.ind` is useful for proving theorems about quotients.\n * `Quot.recOnSubsingleton` can be used whenever the target type is a `Subsingleton`.\n * `Quot.hrecOn` uses [heterogeneous equality](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=HEq) instead of rewriting with\n   `Quot.sound`.\n\n`Quot.recOn` is a version of this recursor that takes the quotient parameter first.\n</code>",
 "631": "<code>∀ (a : α), β (Quot.mk r a)</code>",
 "630": "<code>Quot r → Prop</code>",
 "63": "<code>f : α → β</code>",
 "629": "<code>Quot r</code>",
 "628": "<code>∀ (a b : α), r a b → f a = f b</code>",
 "627": "<code>Sort ?u.3426</code>",
 "626": "<code>Quot r → β</code>",
 "625":
 "<code>Quot.ind.{u} {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} (mk : ∀ (a : α), β (Quot.mk r a)) (q : Quot r) : β q</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with `Quot.mk`.\n\n`Quot.rec` is analogous to the [recursor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can\nbe used when the resulting type is not necessarily a proposition.\n\n`Quot.ind` is a built-in primitive:\n * `Quot` is the built-in quotient type.\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.sound` asserts the equality of elements related by `r`.\n</code>",
 "624":
 "<code>Quot.lift.{u, v} {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) (a : ∀ (a b : α), r a b → f a = f b) :\n  Quot r → β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's relation.\n\nGiven a relation `r : α → α → Prop` and a quotient `Quot r`, applying a function `f : α → β`\nrequires a proof `a` that `f` respects `r`. In this case, `Quot.lift f a : Quot r → β` computes the\nsame values as `f`.\n\nLean's type theory includes a [definitional reduction](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=type-theory) from\n`Quot.lift f h (Quot.mk r v)` to `f v`.\n\n`Quot.lift` is a built-in primitive:\n * `Quot` is the built-in quotient type.\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.sound` asserts the equality of elements related by `r`\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`; it is analogous to the [recursor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=recursors) for a\n   structure.\n</code>",
 "623":
 "<code>Quot.mk.{u} {α : Sort u} (r : α → α → Prop) (a : α) : Quot r</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to the provided relation.\n\nGiven `v : α` and relation `r : α → α → Prop`, `Quot.mk r v : Quot r` is like `v`, except all\nobservations of `v`'s value must respect `r`.\n\n`Quot.mk` is a built-in primitive:\n * `Quot` is the built-in quotient type.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.sound` asserts the equality of elements related by `r`.\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`.\n</code>",
 "622":
 "<code>Quotient.exact.{u} {α : Sort u} {s : Setoid α} {a b : α} : Quotient.mk s a = Quotient.mk s b → a ≈ b</code><span class=\"sep\"></span><code class=\"docstring\">If two values are equal in a quotient, then they are related by its equivalence relation.\n</code>",
 "621":
 "<code>HEq.{u} {α : Sort u} : α → {β : Sort u} → β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Heterogeneous equality. `HEq a b` asserts that `a` and `b` have the same\ntype, and casting `a` across the equality yields `b`, and vice versa.\n\nYou should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as `Eq`, because the assumption that the types of\n`a` and `b` are equal is often too weak to prove theorems of interest. One\nimportant non-theorem is the analogue of `congr`: If `HEq f g` and `HEq x y`\nand `f x` and `g y` are well typed it does not follow that `HEq (f x) (g y)`.\n(This does follow if you have `f = g` instead.) However if `a` and `b` have\nthe same type then `a = b` and `HEq a b` are equivalent.\n</code>",
 "620": "<code>∀ (a b : α), a ≈ b → HEq (f a) (f b)</code>",
 "62":
 "<code>everyOther.eq_3.{u_1} {α : Type u_1} (x_1 head : α) (xs : List α) :\n  everyOther (x_1 :: head :: xs) = x_1 :: everyOther xs</code>",
 "619":
 "<code>Quotient.ind.{u} {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} :\n  (∀ (a : α), motive (Quotient.mk s a)) → ∀ (q✝ : Quotient s), motive q✝</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with `Quotient.mk`.\n</code>",
 "618":
 "<code>Eq.ndrec.{u1, u2} {α : Sort u2} {a : α} {motive : α → Sort u1} (m : motive a) {b : α} (h : a = b) : motive b</code><span class=\"sep\"></span><code class=\"docstring\">Non-dependent recursor for the equality type. </code>",
 "617": "<code>∀ (a b : α) (p : a ≈ b), ⋯ ▸ f a = f b</code>",
 "616":
 "<code>Quotient.hrecOn.{u, v} {α : Sort u} {s : Setoid α} {motive : Quotient s → Sort v} (q : Quotient s)\n  (f : (a : α) → motive (Quotient.mk s a)) (c : ∀ (a b : α), a ≈ b → HEq (f a) (f b)) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quotient` that uses [heterogeneous\nequality](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=HEq), analogous to a [recursor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=recursors) for\na structure.\n\n`Quotient.recOn` is a version of this recursor that uses `Eq` instead of `HEq`.\n</code>",
 "615":
 "<code>Quotient.recOn.{u, v} {α : Sort u} {s : Setoid α} {motive : Quotient s → Sort v} (q : Quotient s)\n  (f : (a : α) → motive (Quotient.mk s a)) (h : ∀ (a b : α) (p : a ≈ b), ⋯ ▸ f a = f b) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quotient`. It is analogous to the\n[recursor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can be used when the resulting type\nis not necessarily a proposition.\n\nWhile it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:\n\n * `Quotient.lift` is useful for defining non-dependent functions.\n * `Quotient.ind` is useful for proving theorems about quotients.\n * `Quotient.recOnSubsingleton` can be used whenever the target type is a `Subsingleton`.\n * `Quotient.hrecOn` uses heterogeneous equality instead of rewriting with `Quotient.sound`.\n\n`Quotient.rec` is a version of this recursor that takes the quotient parameter last.\n</code>",
 "614": "<code>Z.add_neg_inverse (n : Z) : n + -n = 0</code>",
 "613":
 "<code class=\"docstring\">`simp_arith` has been deprecated. It was a shorthand for `simp +arith +decide`.\nNote that `+decide` is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n</code>",
 "612": "<code>Quotient s → Prop</code>",
 "611":
 "<code>Quot.sound.{u} {α : Sort u} {r : α → α → Prop} {a b : α} : r a b → Quot.mk r a = Quot.mk r b</code><span class=\"sep\"></span><code class=\"docstring\">The **quotient axiom**, which asserts the equality of elements related by the quotient's relation.\n\nThe relation `r` does not need to be an equivalence relation to use this axiom. When `r` is not an\nequivalence relation, the quotient is with respect to the equivalence relation generated by `r`.\n\n`Quot.sound` is part of the built-in primitive quotient type:\n * `Quot` is the built-in quotient type.\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`; it is analogous to the [recursor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=recursors) for a\n   structure.\n\n[Quotient types](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=quotients) are described in more detail in the Lean Language\nReference.\n</code>",
 "610":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n</code>",
 "61":
 "<code>everyOther.eq_2.{u_1} {α : Type u_1} (x_1 : α) : everyOther [x_1] = [x_1]</code>",
 "609":
 "<code>(a : α) → (b : β) → motive (Quotient.mk s₁ a) (Quotient.mk s₂ b)</code>",
 "608":
 "<code>∀ (a : α) (b : β), Subsingleton (motive (Quotient.mk s₁ a) (Quotient.mk s₂ b))</code>",
 "607": "<code>Quotient s₁ → Quotient s₂ → Sort uC</code>",
 "606":
 "<code>Quotient.rec.{u, v} {α : Sort u} {s : Setoid α} {motive : Quotient s → Sort v} (f : (a : α) → motive (Quotient.mk s a))\n  (h : ∀ (a b : α) (p : a ≈ b), ⋯ ▸ f a = f b) (q : Quotient s) : motive q</code><span class=\"sep\"></span><code class=\"docstring\">A dependent recursion principle for `Quotient`. It is analogous to the\n[recursor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can be used when the resulting type\nis not necessarily a proposition.\n\nWhile it is very general, this recursor can be tricky to use. The following simpler alternatives may\nbe easier to use:\n\n * `Quotient.lift` is useful for defining non-dependent functions.\n * `Quotient.ind` is useful for proving theorems about quotients.\n * `Quotient.recOnSubsingleton` can be used whenever the target type is a `Subsingleton`.\n * `Quotient.hrecOn` uses heterogeneous equality instead of rewriting with `Quotient.sound`.\n\n`Quotient.recOn` is a version of this recursor that takes the quotient parameter first.\n</code>",
 "605": "<code>(a : α) → motive (Quotient.mk s a)</code>",
 "604":
 "<code>Subsingleton.{u} (α : Sort u) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A _subsingleton_ is a type with at most one element. It is either empty or has a unique element.\n\nAll propositions are subsingletons because of proof irrelevance: false propositions are empty, and\nall proofs of a true proposition are equal to one another. Some non-propositional types are also\nsubsingletons.\n</code>",
 "603": "<code>∀ (a : α), Subsingleton (motive (Quotient.mk s a))</code>",
 "602": "<code>Quotient s → Sort v</code>",
 "601":
 "<code>Quotient.recOnSubsingleton₂.{uA, uB, uC} {α : Sort uA} {β : Sort uB} {s₁ : Setoid α} {s₂ : Setoid β}\n  {motive : Quotient s₁ → Quotient s₂ → Sort uC}\n  [s : ∀ (a : α) (b : β), Subsingleton (motive (Quotient.mk s₁ a) (Quotient.mk s₂ b))] (q₁ : Quotient s₁)\n  (q₂ : Quotient s₂) (g : (a : α) → (b : β) → motive (Quotient.mk s₁ a) (Quotient.mk s₂ b)) : motive q₁ q₂</code><span class=\"sep\"></span><code class=\"docstring\">An alternative induction or recursion operator for defining binary operations on quotients that can\nbe used when the target type is a subsingleton.\n\nIn these cases, the proof that the function respects the quotient's equivalence relation is trivial,\nso any function can be lifted.\n</code>",
 "600":
 "<code>Quotient.recOnSubsingleton.{u, v} {α : Sort u} {s : Setoid α} {motive : Quotient s → Sort v}\n  [h : ∀ (a : α), Subsingleton (motive (Quotient.mk s a))] (q : Quotient s) (f : (a : α) → motive (Quotient.mk s a)) :\n  motive q</code><span class=\"sep\"></span><code class=\"docstring\">An alternative recursion or induction principle for quotients that can be used when the target type\nis a subsingleton, in which all elements are equal.\n\nIn these cases, the proof that the function respects the quotient's equivalence relation is trivial,\nso any function can be lifted.\n\n`Quotient.rec` does not assume that the target type is a subsingleton.\n</code>",
 "60": "<code>everyOther.eq_1.{u_1} {α : Type u_1} : everyOther [] = []</code>",
 "6":
 "<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>",
 "599": "<code>fst✝² + snd✝ = snd✝² + fst✝</code>",
 "598": "<code>fst✝³ + snd✝¹ = snd✝³ + fst✝¹</code>",
 "597": "<code>(fst✝³, snd✝³) ≈ (fst✝¹, snd✝¹)</code>",
 "596": "<code>(fst✝², snd✝²) ≈ (fst✝, snd✝)</code>",
 "595": "<code>(fst✝¹, snd✝¹) ≈ k'</code>",
 "594": "<code>(fst✝, snd✝) ≈ k'</code>",
 "593": "<code>(fst✝¹, snd✝¹) ≈ n'</code>",
 "592": "<code>(fst✝, snd✝) ≈ n'</code>",
 "591": "<code>k ≈ k'</code>",
 "590": "<code>n ≈ n'</code>",
 "59":
 "<code>everyOther.eq_def.{u_1} {α : Type u_1} (x✝ : List α) :\n  everyOther x✝ =\n    match x✝ with\n    | [] =&gt; []\n    | [x] =&gt; [x]\n    | x :: head :: xs =&gt; x :: everyOther xs</code>",
 "589":
 "<code>Z → Quotient Z.instSetoid → Z</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "588": "<code>Nat × Nat</code>",
 "587": "<code>add' (n k : Nat × Nat) : Z</code>",
 "586": "<code>n.fst + k.snd = n.snd + k.fst</code>",
 "585":
 "<code>Prod.fst.{u, v} {α : Type u} {β : Type v} (self : α × β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first element of a pair. </code>",
 "584":
 "<code>Prod.snd.{u, v} {α : Type u} {β : Type v} (self : α × β) : β</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "583":
 "<code class=\"docstring\">`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n</code>",
 "582": "<code>n ≈ k</code>",
 "581":
 "<code>Quotient Z.instSetoid → Z</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "580": "<code>neg' : Z' → Z</code>",
 "58":
 "<code>everyOther.eq_unfold.{u_1} :\n  @everyOther = fun {α} x =&gt;\n    match x with\n    | [] =&gt; []\n    | [x] =&gt; [x]\n    | x :: head :: xs =&gt; x :: everyOther xs</code>",
 "579": "<code>Quotient s₂</code>",
 "578": "<code>Quotient s₁</code>",
 "577":
 "<code>∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂</code>",
 "576": "<code>α → β → φ</code>",
 "575": "<code>Setoid β</code>",
 "574": "<code>Sort uC</code>",
 "573": "<code>Sort uB</code>",
 "572": "<code>Sort uA</code>",
 "571": "<code>Quotient s</code>",
 "570": "<code>∀ (a b : α), a ≈ b → f a = f b</code>",
 "57": "<code>everyOther.{u_1} {α : Type u_1} : List α → List α</code>",
 "569": "<code>?m.1735</code>",
 "568":
 "<code>Quotient.liftOn₂.{uA, uB, uC} {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β}\n  (q₁ : Quotient s₁) (q₂ : Quotient s₂) (f : α → β → φ)\n  (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) : φ</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.\n\n`Quotient.liftOn` is a version of this operation for unary functions. `Quotient.lift₂` is a version\nthat take the quotient parameters last.\n</code>",
 "567":
 "<code>Quotient.liftOn.{u, v} {α : Sort u} {β : Sort v} {s : Setoid α} (q : Quotient s) (f : α → β)\n  (c : ∀ (a b : α), a ≈ b → f a = f b) : β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.\n\nGiven `s : Setoid α` and a quotient value `q : Quotient s`, applying a function `f : α → β` requires\na proof `c` that `f` respects the equivalence relation `s.r`. In this case, the term\n`Quotient.liftOn q f h : β` reduces to the result of applying `f` to the underlying `α` value.\n\n`Quotient.lift` is a version of this operation that takes the quotient value last, rather than\nfirst.\n</code>",
 "566":
 "<code>Quotient.lift₂.{uA, uB, uC} {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ)\n  (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) (q₁ : Quotient s₁)\n  (q₂ : Quotient s₂) : φ</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.\n\n`Quotient.lift` is a version of this operation for unary functions. `Quotient.liftOn₂` is a version\nthat take the quotient parameters first.\n</code>",
 "565": "<code>Z.mk (n : Z') : Z</code>",
 "564":
 "<code>Equivalence eq</code><span class=\"sep\"></span><code class=\"docstring\">The relation `x ≈ y` is an equivalence relation. </code>",
 "563":
 "<code>Z' → Z' → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` is the distinguished equivalence relation of a setoid. </code>",
 "562": "<code>Z.instSetoid : Setoid Z'</code>",
 "561": "<code>x' + y'' = y' + x''</code>",
 "560": "<code>eq (x', y') (x'', y'')</code>",
 "56":
 "<code>thirdOfFive.eq_2.{u_1} {α : Type u_1} (x✝ : List α)\n  (x_2 : ∀ (head head_1 x head_2 head_3 : α), x✝ = [head, head_1, x, head_2, head_3] → False) : thirdOfFive x✝ = none</code>",
 "559":
 "<code>∀ {x y z : Z'}, eq x y → eq y z → eq x z</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is transitive: `r x y` and `r y z` implies `r x z` </code>",
 "558": "<code>x + y' = y + x'</code>",
 "557":
 "<code class=\"docstring\">`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n</code>",
 "556": "<code>eq (x, y) (x', y')</code>",
 "555":
 "<code>∀ {x y : Z'}, eq x y → eq y x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is symmetric: `r x y` implies `r y x` </code>",
 "554":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), simplifies simple arithmetic expressions. </code>",
 "553":
 "<code class=\"docstring\">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 =&gt; tac\n  | ...\n  ```\n</code>",
 "552":
 "<code>∀ (x : Z'), eq x x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is reflexive: `r x x` </code>",
 "551": "<code>Z.eq.eqv : Equivalence eq</code>",
 "550": "<code>Z'</code>",
 "55": "<code>Type u</code>",
 "549": "<code>Z' : Type</code>",
 "548": "<code>Z.eq (n k : Z') : Prop</code>",
 "547":
 "<code>Quotient.mk'.{u} {α : Sort u} [s : Setoid α] (a : α) : Quotient s</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to an equivalence\nrelation.\n\nThe equivalence relation is found by synthesizing a `Setoid` instance. `Quotient.mk` instead expects\nthe instance to be provided explicitly.\n\nGiven `v : α`, `Quotient.mk' v : Quotient s` is like `v`, except all observations of `v`'s value\nmust respect `s.r`. `Quotient.lift` allows values in a quotient to be mapped to other types, so long\nas the mapping respects `s.r`.\n\n</code>",
 "546":
 "<code>inferInstance.{u} {α : Sort u} [i : α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n</code>",
 "545":
 "<code>∀ {x y z : α}, r x y → r y z → r x z</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is transitive: `r x y` and `r y z` implies `r x z` </code>",
 "544":
 "<code>∀ {x y : α}, r x y → r y x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is symmetric: `r x y` implies `r y x` </code>",
 "543":
 "<code>∀ (x : α), r x x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is reflexive: `r x x` </code>",
 "542":
 "<code>Equivalence.mk.{u} {α : Sort u} {r : α → α → Prop} (refl : ∀ (x : α), r x x) (symm : ∀ {x y : α}, r x y → r y x)\n  (trans : ∀ {x y z : α}, r x y → r y z → r x z) : Equivalence r</code>",
 "541": "<code>?m.1124</code>",
 "540":
 "<code>α → α → Sort v</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≈` in identifiers is `equiv`.</code>",
 "54":
 "<code>thirdOfFive.eq_1.{u_1} {α : Type u_1} (head head_1 x_1 head_2 head_3 : α) :\n  thirdOfFive [head, head_1, x_1, head_2, head_3] = some x_1</code>",
 "539":
 "<code>HasEquiv.mk.{u, v} {α : Sort u} (Equiv : α → α → Sort v) : HasEquiv α</code>",
 "538":
 "<code>HasEquiv.{u, v} (α : Sort u) : Sort (max u (v + 1))</code><span class=\"sep\"></span><code class=\"docstring\">`HasEquiv α` is the typeclass which supports the notation `x ≈ y` where `x y : α`.</code>",
 "537": "<code>b ≈ c</code>",
 "536": "<code>a ≈ b</code>",
 "535":
 "<code>HasEquiv.Equiv.{u, v} {α : Sort u} [self : HasEquiv α] : α → α → Sort v</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≈` in identifiers is `equiv`.</code>",
 "534":
 "<code>Equivalence.{u} {α : Sort u} (r : α → α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation `r : α → α → Prop` is a relation that is\n\n* reflexive: `r x x`,\n* symmetric: `r x y` implies `r y x`, and\n* transitive: `r x y` and `r y z` implies `r x z`.\n\nEquality is an equivalence relation, and equivalence relations share many of the properties of\nequality.\n</code>",
 "533":
 "<code>Equivalence Setoid.r</code><span class=\"sep\"></span><code class=\"docstring\">The relation `x ≈ y` is an equivalence relation. </code>",
 "532":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` is the distinguished equivalence relation of a setoid. </code>",
 "531":
 "<code>Setoid.mk.{u} {α : Sort u} (r : α → α → Prop) (iseqv : Equivalence r) : Setoid α</code>",
 "530": "<code>¬n' &lt; k'</code>",
 "53":
 "<code>thirdOfFive.eq_def.{u_1} {α : Type u_1} (x✝ : List α) :\n  thirdOfFive x✝ =\n    match x✝ with\n    | [head, head_1, x, head_2, head_3] =&gt; some x\n    | x =&gt; none</code>",
 "529": "<code>n' &lt; k'</code>",
 "528": "<code>¬n = k</code>",
 "527": "<code>n = k</code>",
 "526":
 "<code>Not (a : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `¬` in identifiers is `not`.</code>",
 "525": "<code>¬n &lt; k</code>",
 "524": "<code>n &lt; k</code>",
 "523":
 "<code class=\"docstring\">The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n</code>",
 "522":
 "<code>Neg.neg.{u} {α : Type u} [self : Neg α] : α → α</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "521":
 "<code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-than relation: `x &lt; y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;` in identifiers is `lt`.</code>",
 "520":
 "<code>ite.{u} {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>",
 "52":
 "<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>",
 "519":
 "<code>toInt_sound {n k' k n' : Nat} : n + k' = k + n' ↔ toInt n k = toInt n' k'</code>",
 "518":
 "<code>Int.subNatNat (m n : Nat) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Non-truncating subtraction of two natural numbers.\n\nExamples:\n* `Int.subNatNat 5 2 = 3`\n* `Int.subNatNat 2 5 = -3`\n* `Int.subNatNat 0 13 = -13`\n</code>",
 "517": "<code>toInt (n k : Nat) : Int</code>",
 "516":
 "<code>Z → Z → Z</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "515":
 "<code>Add.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAdd`: `a + b : α` where `a b : α`. </code>",
 "514":
 "<code>ToString.toString.{u} {α : Type u} [self : ToString α] : α → String</code>",
 "513": "<code><span class=\"literal string\">\"0\"</span> : String</code>",
 "512": "<code>Z → String</code>",
 "511":
 "<code>Z</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "510": "<code>Z</code>",
 "51": "<code>List α</code>",
 "509":
 "<code>Z → Z</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "508": "<code>ToString.{u} (α : Type u) : Type u</code>",
 "507":
 "<code>OfNat.{u} (α : Type u) : Nat → Type u</code><span class=\"sep\"></span><code class=\"docstring\">The class `OfNat α n` powers the numeric literal parser. If you write\n`37 : α`, Lean will attempt to synthesize `OfNat α 37`, and will generate\nthe term `(OfNat.ofNat 37 : α)`.\n\nThere is a bit of infinite regress here since the desugaring apparently\nstill contains a literal `37` in it. The type of expressions contains a\nprimitive constructor for \"raw natural number literals\", which you can directly\naccess using the macro `nat_lit 37`. Raw number literals are always of type `Nat`.\nSo it would be more correct to say that Lean looks for an instance of\n`OfNat α (nat_lit 37)`, and it generates the term `(OfNat.ofNat (nat_lit 37) : α)`.\n</code>",
 "506":
 "<code>Neg.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for negation.\nThis enables the notation `-a : α` where `a : α`.\n</code>",
 "505":
 "<code>Z_mk'_respects_eq {n k n' k' : Nat} : Z.mk' n k = Z.mk' n' k' ↔ n + k' = n' + k</code>",
 "504":
 "<code>HSub.hSub.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HSub α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).</code>",
 "503": "<code>n - k = 0 ∨ k - n = 0</code>",
 "502": "<code>Z.mk' (n k : Nat) : Z</code>",
 "501": "<code>Z.canonical (self : Z) : self.a = 0 ∨ self.b = 0</code>",
 "500": "<code>Z.b (self : Z) : Nat</code>",
 "50":
 "<code class=\"docstring\">A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. </code>",
 "5":
 "<code><span class=\"literal string\">\"Hello, world!\"</span> : String</code>",
 "499": "<code>Z.a (self : Z) : Nat</code>",
 "498": "<code>Z : Type</code>",
 "497":
 "<code>Quotient.ind.{u} {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} :\n  (∀ (a : α), motive (Quotient.mk s a)) → ∀ (q : Quotient s), motive q</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with `Quotient.mk`.\n</code>",
 "496":
 "<code>Quotient.sound.{u} {α : Sort u} {s : Setoid α} {a b : α} : a ≈ b → Quotient.mk s a = Quotient.mk s b</code><span class=\"sep\"></span><code class=\"docstring\">The **quotient axiom**, which asserts the equality of elements related in the setoid.\n\nBecause `Quotient` is built on a lower-level type `Quot`, `Quotient.sound` is implemented as a\ntheorem. It is derived from `Quot.sound`, the soundness axiom for the lower-level quotient type\n`Quot`.\n</code>",
 "495":
 "<code>Quotient.mk.{u} {α : Sort u} (s : Setoid α) (a : α) : Quotient s</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to an equivalence\nrelation.\n\nThe setoid instance is provided explicitly. `Quotient.mk'` uses instance synthesis instead.\n\nGiven `v : α`, `Quotient.mk s v : Quotient s` is like `v`, except all observations of `v`'s value\nmust respect `s.r`. `Quotient.lift` allows values in a quotient to be mapped to other types, so long\nas the mapping respects `s.r`.\n</code>",
 "494":
 "<code>Quotient.lift.{u, v} {α : Sort u} {β : Sort v} {s : Setoid α} (f : α → β) :\n  (∀ (a b : α), a ≈ b → f a = f b) → Quotient s → β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.\n\nGiven `s : Setoid α` and a quotient `Quotient s`, applying a function `f : α → β` requires a proof\n`h` that `f` respects the equivalence relation `s.r`. In this case, the function\n`Quotient.lift f h : Quotient s → β` computes the same values as `f`.\n\n`Quotient.liftOn` is a version of this operation that takes the quotient value as its first explicit\nparameter.\n</code>",
 "493": "<code>Sort ?u.169</code>",
 "492": "<code>Quotient s → β</code>",
 "491":
 "<code>Setoid.r.{u} {α : Sort u} [self : Setoid α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` is the distinguished equivalence relation of a setoid. </code>",
 "490":
 "<code>Quotient.{u} {α : Sort u} (s : Setoid α) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Quotient types coarsen the propositional equality for a type so that terms related by some\nequivalence relation are considered equal. The equivalence relation is given by an instance of\n`Setoid`.\n\nSet-theoretically, `Quotient s` can seen as the set of equivalence classes of `α` modulo the\n`Setoid` instance's relation `s.r`. Functions from `Quotient s` must prove that they respect `s.r`:\nto define a function `f : Quotient s → β`, it is necessary to provide `f' : α → β` and prove that\nfor all `x : α` and `y : α`, `s.r x y → f' x = f' y`. `Quotient.lift` implements this operation.\n\nThe key quotient operators are:\n * `Quotient.mk` places elements of the underlying type `α` into the quotient.\n * `Quotient.lift` allows the definition of functions from the quotient to some other type.\n * `Quotient.sound` asserts the equality of elements related by `r`\n * `Quotient.ind` is used to write proofs about quotients by assuming that all elements are\n   constructed with `Quotient.mk`.\n\n`Quotient` is built on top of the primitive quotient type `Quot`, which does not require a proof\nthat the relation is an equivalence relation. `Quotient` should be used instead of `Quot` for\nrelations that actually are equivalence relations.\n</code>",
 "49":
 "<code>thirdOfFive.eq_unfold.{u_1} :\n  @thirdOfFive = fun {α} x =&gt;\n    match x with\n    | [head, head_1, x, head_2, head_3] =&gt; some x\n    | x =&gt; none</code>",
 "489":
 "<code>Setoid.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A setoid is a type with a distinguished equivalence relation, denoted `≈`.\n\nThe `Quotient` type constructor requires a `Setoid` instance.\n</code>",
 "488": "<code>Setoid α</code>",
 "487": "<code>Two α</code>",
 "486": "<code>(a a_1 : α) → motive_1 (Two.mk a a_1)</code>",
 "485": "<code>Three α → Sort u</code>",
 "484": "<code>Two α → Sort u</code>",
 "483":
 "<code>Two.rec.{u} {α : Type} {motive_1 : Two α → Sort u} {motive_2 : Three α → Sort u}\n  (mk : (a a_1 : α) → motive_1 (Two.mk a a_1)) :\n  ((a a_1 a_2 : α) → motive_2 (Three.mk a a_1 a_2)) → (t : Two α) → motive_1 t</code>",
 "482": "<code>Three.mk {α : Type} : α → α → α → Three α</code>",
 "481": "<code>Two.mk {α : Type} : α → α → Two α</code>",
 "480": "<code>Three (α : Type) : Type</code>",
 "48":
 "<code>Option.none.{u} {α : Type u} : Option α</code><span class=\"sep\"></span><code class=\"docstring\">No value. </code>",
 "479": "<code>Two (α : Type) : Type</code>",
 "478": "<code>Odd a</code>",
 "477":
 "<code>Odd.rec {motive_1 : (a : Nat) → Even a → Prop} {motive_2 : (a : Nat) → Odd a → Prop} (zero : motive_1 0 Even.zero)\n  (succ : ∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) ⋯) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) ⋯) → ∀ {a : Nat} (t : Odd a), motive_2 a t</code>",
 "476": "<code>Even a</code>",
 "475": "<code>Even n</code>",
 "474": "<code>Odd n</code>",
 "473":
 "<code>∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) ⋯</code>",
 "472": "<code>motive_1 0 Even.zero</code>",
 "471": "<code>(a : Nat) → Odd a → Prop</code>",
 "470": "<code>(a : Nat) → Even a → Prop</code>",
 "47":
 "<code>Option.some.{u} {α : Type u} (val : α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Some value of type `α`. </code>",
 "4692":
 "<code>Lake.ExternLib : Type</code><span class=\"sep\"></span><code class=\"docstring\">An external library -- its package plus its configuration. </code>",
 "4691":
 "<code>Lake.LeanLib : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lean library -- its package plus its configuration. </code>",
 "4690":
 "<code>Lake.LeanExe : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lean executable -- its package plus its configuration. </code>",
 "469":
 "<code>Even.rec {motive_1 : (a : Nat) → Even a → Prop} {motive_2 : (a : Nat) → Odd a → Prop} (zero : motive_1 0 Even.zero)\n  (succ : ∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) ⋯) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) ⋯) → ∀ {a : Nat} (t : Even a), motive_1 a t</code>",
 "4689":
 "<code>Lake.Module : Type</code><span class=\"sep\"></span><code class=\"docstring\">A buildable Lean module of a `LeanLib`. </code>",
 "4688":
 "<code>Lake.NPackage (n : Lean.Name) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A package with a name known at type-level. </code>",
 "4687":
 "<code>Lake.Package : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lake package -- its location plus its configuration. </code>",
 "4686":
 "<code>Lake.Workspace : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lake workspace -- the top-level package directory. </code>",
 "4685": "<code>m Lake.Workspace</code>",
 "4684":
 "<code>Lake.MonadWorkspace.mk.{u} {m : Type → Type u} (getWorkspace : m Lake.Workspace) : Lake.MonadWorkspace m</code>",
 "4683":
 "<code>Lake.LakeM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad equipped with a `Lake.Context`. </code>",
 "4682": "<code>Manual.lake : Verso.Doc.Elab.DirectiveExpander</code>",
 "4681":
 "<code>Lake.LakeInstall : Type</code><span class=\"sep\"></span><code class=\"docstring\">Path information about the local Lake installation. </code>",
 "4680":
 "<code>Lake.LeanInstall : Type</code><span class=\"sep\"></span><code class=\"docstring\">Path information about the local Lean installation. </code>",
 "468": "<code>Odd.succ {n : Nat} : Even n → Odd (n + 1)</code>",
 "4679":
 "<code>Lake.ElanInstall : Type</code><span class=\"sep\"></span><code class=\"docstring\">Information about the local Elan setup. </code>",
 "4678": "<code>System.SearchPath : Type</code>",
 "4677":
 "<code>Lake.MonadBuild.{u} (m : Type → Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A monad equipped with a Lake build context. </code>",
 "4676":
 "<code>Lake.Env : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lake environment. </code>",
 "4675":
 "<code>Lake.MonadLakeEnv.{u} (m : Type → Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A monad equipped with a (read-only) detected environment for Lake. </code>",
 "4674": "<code>Lake.ExitCode</code>",
 "4673": "<code>0 &lt; args.length</code>",
 "4672": "<code>«script-name» : Lake.ScriptFn</code>",
 "4671":
 "<code>Lake.MonadWorkspace.{u} (m : Type → Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A monad equipped with a (read-only) Lake `Workspace`. </code>",
 "4670":
 "<code>Lean.LeanOptionValue : Type</code><span class=\"sep\"></span><code class=\"docstring\">Restriction of `DataValue` that covers exactly those cases that Lean is able to handle when passed via the `-D` flag. </code>",
 "467": "<code>Odd : Nat → Prop</code>",
 "4669": "<code>Lean.LeanOptionValue</code>",
 "4668": "<code>Lean.Name</code>",
 "4667":
 "<code>Lake.LeanOption.mk (name : Lean.Name) (value : Lean.LeanOptionValue) : Lake.LeanOption</code>",
 "4666":
 "<code>Lake.BuildType.release : BuildType</code><span class=\"sep\"></span><code class=\"docstring\">High optimization level and no debug info, code, or asserts\n(e.g., passes `-O3 -DNDEBUG` when compiling C code).\n</code>",
 "4665":
 "<code>Lake.nameToStaticLib (name : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Convert a library name into its static library file name for the `Platform`. </code>",
 "4664":
 "<code>Lake.PackageConfig.precompileModules {name : Lean.Name} (self : Lake.PackageConfig name) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Whether to compile each of the package's module into a native shared library\nthat is loaded whenever the module is imported. This speeds up evaluation of\nmetaprograms and enables the interpreter to run functions marked `@[extern]`.\n\nDefaults to `false`.\n</code>",
 "4663":
 "<code>Lake.Job.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A Lake job. </code>",
 "4662":
 "<code>Lake.FetchM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The top-level monad for Lake build functions. </code>",
 "4661":
 "<code>Bool → Array (Lake.ModuleFacet System.FilePath)</code><span class=\"sep\"></span><code class=\"docstring\">The module facets to build and combine into the executable.\nIf `shouldExport` is true, the module facets should export any symbols\na user may expect to lookup in the executable. For example, the Lean\ninterpreter will use exported symbols in the executable. Thus, `shouldExport`\nwill be `true` if `supportInterpreter := true`.\n\nDefaults to a singleton of `Module.oExportFacet` (if `shouldExport`) or\n`Module.oFacet`. That is, the  object file compiled from the Lean source,\npotentially with exported Lean symbols.\n</code>",
 "4660":
 "<code>Lean.Elab.runFrontend (input : String) (opts : Lean.Options) (fileName : String) (mainModuleName : Lean.Name)\n  (trustLevel : UInt32 := 0) (ileanFileName? : Option String := none) (jsonOutput : Bool := false)\n  (errorOnKinds : Array Lean.Name := #[]) (plugins : Array System.FilePath := #[]) : IO (Lean.Environment × Bool)</code>",
 "466": "<code>Even.succ {n : Nat} : Odd n → Even (n + 1)</code>",
 "4659":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Enables the executable to interpret Lean files (e.g., via\n`Lean.Elab.runFrontend`) by exposing symbols within the  executable\nto the Lean interpreter.\n\nImplementation-wise, on Windows, the Lean shared libraries are linked\nto the executable and, on other systems, the executable is linked with\n`-rdynamic`. This increases the size of the binary on Linux and, on Windows,\nrequires `libInit_shared.dll` and `libleanshared.dll` to  be co-located\nwith the executable or part of `PATH` (e.g., via `lake exe`). Thus, this\nfeature should only be enabled when necessary.\n\nDefaults to `false`.\n</code>",
 "4658":
 "<code>Array Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">An `Array` of target names to build before the executable's modules. </code>",
 "4657":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The name of the binary executable.\nDefaults to the target name with any `.` replaced with a `-`.\n</code>",
 "4656":
 "<code>Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">The root module of the binary executable.\nShould include a `main` definition that will serve\nas the entry point of the program.\n\nThe root is built by recursively building its\nlocal imports (i.e., fellow modules of the workspace).\n\nDefaults to the name of the target.\n</code>",
 "4655":
 "<code>System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">The subdirectory of the package's source directory containing the executable's\nLean source file. Defaults simply to said `srcDir`.\n\n(This will be passed to `lean` as the `-R` option.)\n</code>",
 "4654":
 "<code>Lake.LeanExeConfig.mk {name : Lean.Name} (toLeanConfig : Lake.LeanConfig) (srcDir : System.FilePath) (root : Lean.Name)\n  (exeName : String) (extraDepTargets : Array Lean.Name) (supportInterpreter : Bool)\n  (nativeFacets : Bool → Array (Lake.ModuleFacet System.FilePath)) : Lake.LeanExeConfig name</code>",
 "4653":
 "<code>Lake.LeanExeConfig (name : Lean.Name) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lean executable's declarative configuration. </code>",
 "4652":
 "<code>Lake.ModuleFacet (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A module facet name along with proof of its data type. </code>",
 "4651":
 "<code>Bool → Array (Lake.ModuleFacet System.FilePath)</code><span class=\"sep\"></span><code class=\"docstring\">The module facets to build and combine into the library's static\nand shared libraries. If `shouldExport` is true, the module facets should\nexport any symbols a user may expect to lookup in the library. For example,\nthe Lean interpreter will use exported symbols in linked libraries.\n\nDefaults to a singleton of `Module.oExportFacet` (if `shouldExport`) or\n`Module.oFacet`. That is, the  object files compiled from the Lean sources,\npotentially with exported Lean symbols.\n</code>",
 "4650":
 "<code>Array Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">An `Array` of library facets to build on a bare `lake build` of the library.\nFor example, `#[LeanLib.sharedLib]` will build the shared library facet.\n</code>",
 "465": "<code>List LocatedStx</code>",
 "4649":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Whether to compile each of the library's modules into a native shared library\nthat is loaded whenever the module is imported. This speeds up evaluation of\nmetaprograms and enables the interpreter to run functions marked `@[extern]`.\n\nDefaults to `false`.\n</code>",
 "4648":
 "<code>Array Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">An `Array` of target names to build before the library's modules. </code>",
 "4647":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The name of the library.\nUsed as a base for the file names of its static and dynamic binaries.\nDefaults to the name of the target.\n</code>",
 "4646": "<code>Array Lean.Name</code>",
 "4645":
 "<code>Lake.Glob : Type</code><span class=\"sep\"></span><code class=\"docstring\">A specification of a set of module names. </code>",
 "4644":
 "<code>Array Lake.Glob</code><span class=\"sep\"></span><code class=\"docstring\">An `Array` of module `Glob`s to build for the library.\nDefaults to a `Glob.one` of each of the library's  `roots`.\n\nSubmodule globs build every source file within their directory.\nLocal imports of glob'ed files (i.e., fellow modules of the workspace) are\nalso recursively built.\n</code>",
 "4643":
 "<code>Array Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">The root module(s) of the library.\nSubmodules of these roots (e.g., `Lib.Foo` of `Lib`) are considered\npart of the library.\nDefaults to a single root of the target's name.\n</code>",
 "4642": "<code>Manual.lean : Verso.Doc.Elab.CodeBlockExpander</code>",
 "4641":
 "<code>System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">The subdirectory of the package's source directory containing the library's\nLean source files. Defaults simply to said `srcDir`.\n\n(This will be passed to `lean` as the `-R` option.)\n</code>",
 "4640":
 "<code>Lake.Dynlib : Type</code><span class=\"sep\"></span><code class=\"docstring\">A dynamic/shared library for linking. </code>",
 "464": "<code>Stx.node (kind : String) (args : List LocatedStx) : Stx</code>",
 "4639":
 "<code>Lake.TargetArray (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Shorthand for `Array (Target α)` that supports\ndot notation for Lake-specific operations (e.g., `fetch`).\n</code>",
 "4638":
 "<code>Lake.Backend : Type</code><span class=\"sep\"></span><code class=\"docstring\">Compiler backend with which to compile Lean.\n</code>",
 "4637":
 "<code>Lake.LeanOption : Type</code><span class=\"sep\"></span><code class=\"docstring\">Option that is used by Lean as if it was passed using `-D`. </code>",
 "4636":
 "<code>Lake.BuildType : Type</code><span class=\"sep\"></span><code class=\"docstring\">Lake equivalent of CMake's\n[`CMAKE_BUILD_TYPE`](https://stackoverflow.com/a/59314670).\n</code>",
 "4635":
 "<code>Lake.LeanConfig : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration options common to targets that build modules. </code>",
 "4634":
 "<code>Lake.LeanLibConfig.mk {name : Lean.Name} (toLeanConfig : Lake.LeanConfig) (srcDir : System.FilePath)\n  (roots : Array Lean.Name) (globs : Array Lake.Glob) (libName : String) (extraDepTargets : Array Lean.Name)\n  (precompileModules : Bool) (defaultFacets : Array Lean.Name)\n  (nativeFacets : Bool → Array (Lake.ModuleFacet System.FilePath)) : Lake.LeanLibConfig name</code>",
 "4633":
 "<code>Lake.LeanLibConfig (name : Lean.Name) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A Lean library's declarative configuration. </code>",
 "4632":
 "<code class=\"docstring\">mark a Lake target as the package's default</code>",
 "4631": "<code>Lean.NameMap (α : Type) : Type</code>",
 "4630":
 "<code>Lake.PackageConfig.version {name : Lean.Name} (self : Lake.PackageConfig name) : Lake.StdVer</code><span class=\"sep\"></span><code class=\"docstring\">The package version. Versions have the form:\n\n```\nv!\"&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;[-&lt;specialDescr&gt;]\"\n```\n\nA version with a `-` suffix is considered a \"prerelease\".\n\nLake suggest the following guidelines for incrementing versions:\n\n* **Major version increment** *(e.g., v1.3.0 → v2.0.0)*\n  Indicates significant breaking changes in the package.\n  Package users are not expected to update to the new version\n  without manual intervention.\n\n* **Minor version increment** *(e.g., v1.3.0 → v1.4.0)*\n  Denotes notable changes that are expected to be\n  generally backwards compatible.\n  Package users are expected to update to this version automatically\n  and should be able to fix any breakages and/or warnings easily.\n\n* **Patch version increment** *(e.g., v1.3.0 → v1.3.1)*\n  Reserved for bug fixes and small touchups.\n  Package users are expected to update automatically and should not expect\n  significant breakage, except in the edge case of users relying on the\n  behavior of patched bugs.\n\n**Note that backwards-incompatible changes may occur at any version increment.**\nThe is because the current nature of Lean (e.g., transitive imports,\nrich metaprogramming, reducibility in proofs), makes it infeasible to\ndefine a completely stable interface for a package.\nInstead, the different version levels indicate a change's intended significance\nand how difficult migration is expected to be.\n\nVersions of form the `0.x.x` are considered development versions prior to\nfirst official release. Like prerelease, they are not expected to closely\nfollow the above guidelines.\n\nPackages without a defined version default to `0.0.0`.\n</code>",
 "463": "<code>Stx.atom (str : String) : Stx</code>",
 "4629": "<code>main : List String → IO UInt32</code>",
 "4628": "<code>out-file</code>",
 "4627": "<code>lang</code>",
 "4626": "<code>archive.tgz</code>",
 "4625": "<code>archive.tar.gz</code>",
 "4624": "<code>tag</code>",
 "4623": "<code>script</code>",
 "4622": "<code>file</code>",
 "4621": "<code>cmd</code>",
 "4620": "<code>packages</code>",
 "462": "<code>Stx</code>",
 "4619": "<code>args</code>",
 "4618": "<code>exe-target</code>",
 "4617": "<code>facet</code>",
 "4616": "<code>module</code>",
 "4615": "<code>target</code>",
 "4614": "<code>package</code>",
 "4613": "<code>targets</code>",
 "4612": "<code>language</code>",
 "4611": "<code>template</code>",
 "4610": "<code>name</code>",
 "461": "<code>LocatedStx.mk (line col : Nat) (val : Stx) : LocatedStx</code>",
 "4609":
 "<code class=\"docstring\">mark a Lake script or executable as package's linter</code>",
 "4608":
 "<code class=\"docstring\">mark a Lake script, executable, or library as package's test driver</code>",
 "4607": "<code>ExitCode</code>",
 "4606":
 "<code><span class=\"literal string\">\"Dependencies:\"</span> : String</code>",
 "4605":
 "<code>Array.qsort.{u_1} {α : Type u_1} (as : Array α) (lt : α → α → Bool := by exact (· &lt; ·)) (low : Nat := 0)\n  (high : Nat := as.size - 1) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Sorts an array using the Quicksort algorithm.\n\nThe optional parameter `lt` specifies an ordering predicate. It defaults to `LT.lt`, which must be\ndecidable to be used for sorting. Use `Array.qsortOrd` to sort the array according to the `Ord α`\ninstance.\n\nThe optional parameters `low` and `high` delimit the region of the array that is sorted. Both are\ninclusive, and default to sorting the entire array.\n</code>",
 "4604":
 "<code>Lake.Package.remoteUrl (self : Package) : String</code><span class=\"sep\"></span><code class=\"docstring\">The URL to this package's Git remote. </code>",
 "4603":
 "<code>Lean.Name.toString (n : Lean.Name) (escape : Bool := true) (isToken : String → Bool := fun x =&gt; false) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a name to a string.\n\n- If `escape` is `true`, then escapes name components using `«` and `»` to ensure that\n  those names that can appear in source files round trip.\n  Names with number components, anonymous names, and names containing `»` might not round trip.\n  Furthermore, \"pseudo-syntax\" produced by the delaborator, such as `_`, `#0` or `?u`, is not escaped.\n- The optional `isToken` function is used when `escape` is `true` to determine whether more\n  escaping is necessary to avoid parser tokens.\n  The insertion algorithm works so long as parser tokens do not themselves contain `«` or `»`.\n</code>",
 "4602":
 "<code>Lake.Workspace.root (self : Workspace) : Package</code><span class=\"sep\"></span><code class=\"docstring\">The root package of the workspace. </code>",
 "4601":
 "<code>Lake.Package.name (self : Package) : Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">The name of the package. </code>",
 "4600":
 "<code>Lake.Workspace.packages (self : Workspace) : Array Package</code><span class=\"sep\"></span><code class=\"docstring\">The packages within the workspace (in `require` declaration order). </code>",
 "460": "<code>Stx : Type</code>",
 "46": "<code>α</code>",
 "4599":
 "<code>Lake.MonadWorkspace.getWorkspace.{u} {m : Type → Type u} [self : MonadWorkspace m] : m Workspace</code>",
 "4598": "<code>Package</code>",
 "4597": "<code>Array (String × String)</code>",
 "4596":
 "<code><span class=\"literal string\">\"list-deps\"</span> : String</code>",
 "4595":
 "<code class=\"docstring\">Define a new Lake script for the package.\n\n**Example**\n\n```\n/-- Display a greeting -/\nscript «script-name» (args) do\n  if h : 0 &lt; args.length then\n    IO.println s!\"Hello, {args[0]'h}!\"\n  else\n    IO.println \"Hello, world!\"\n  return 0\n```\n</code>",
 "4594":
 "<code>Lake.ScriptM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of a `Script`'s monad.\n`IO` equipped information about the Lake configuration.\n</code>",
 "4593":
 "<code>Lean.TSyntax.getNat (s : NumLit) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a numeric literal as a natural number.\n\nReturns `0` if the syntax is malformed.\n</code>",
 "4592":
 "<code>Lean.Macro : Type</code><span class=\"sep\"></span><code class=\"docstring\">A `macro` has type `Macro`, which is a `Syntax → MacroM Syntax`: it\nreceives an input syntax and is supposed to \"expand\" it into another piece of\nsyntax.\n</code>",
 "4591": "<code>expandRep : Macro</code>",
 "4590":
 "<code><span class=\"literal string\">\" !!! \"</span> : String</code>",
 "459": "<code>LocatedStx : Type</code>",
 "4589":
 "<code>Lean.Parser.numLit : Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `num` parses a numeric literal in several bases:\n\n* Decimal: `129`\n* Hexadecimal: `0xdeadbeef`\n* Octal: `0o755`\n* Binary: `0b1101`\n\nThis parser has arity 1: it produces a `numLitKind` node containing an atom with the text of the\nliteral.\nYou can use `TSyntax.getNat` to extract the number from the resulting syntax object. </code>",
 "4588":
 "<code>rep : ParserDescr</code><span class=\"sep\"></span><code class=\"docstring\">Generate a list based on N syntactic copies of a term </code>",
 "4587":
 "<code>Lean.Name.anonymous : Name</code><span class=\"sep\"></span><code class=\"docstring\">The \"anonymous\" name. </code>",
 "4586":
 "<code><span class=\"literal string\">\"arbitrary! \"</span> : String</code>",
 "4585": "<code>arbitrary! : Lean.ParserDescr</code>",
 "4584":
 "<code>Lean.Syntax.getHeadInfo (stx : Syntax) : Lean.SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">Retrieve the left-most leaf's info in the Syntax tree, or `none` if there is no token. </code>",
 "4583":
 "<code>Lean.TSyntax.raw {ks : Lean.SyntaxNodeKinds} (self : Lean.TSyntax ks) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The underlying `Syntax` value. </code>",
 "4582":
 "<code>Lean.Syntax.mkNumLit (val : String) (info : Lean.SourceInfo := Lean.SourceInfo.none) : Lean.NumLit</code>",
 "4581":
 "<code>Lean.Macro.throwUnsupported {α : Type} : MacroM α</code><span class=\"sep\"></span><code class=\"docstring\">Throw an `unsupportedSyntax` exception. </code>",
 "4580":
 "<code>Lean.TSyntax.getNat (s : Lean.NumLit) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a numeric literal as a natural number.\n\nReturns `0` if the syntax is malformed.\n</code>",
 "458": "<code>Sort u_1</code>",
 "4579": "<code>Lean.TSyntax `num</code>",
 "4578":
 "<code>addFirstThird.{u_1} {α : Type u_1} [Add α] (xs : List α) : Option α</code>",
 "4577": "<code>Lean.TSyntaxArray `term</code>",
 "4576": "<code>idiom : Lean.ParserDescr</code>",
 "4575": "<code>Option Term</code>",
 "4574":
 "<code>mkStx {m : Type → Type} [Monad m] [MonadQuotation m] (e : Option Term) : m Term</code>",
 "4573": "<code><span class=\"literal string\">\" |⟩\"</span> : String</code>",
 "4572": "<code><span class=\"literal string\">\"⟨| \"</span> : String</code>",
 "4571": "<code>Syntax.TSepArray `num \"**\"</code>",
 "4570": "<code>Syntax.TSepArray `num \"—\"</code>",
 "457": "<code>NonZero [(1, 2), (2, 2), (3, 1), (1, 3)]</code>",
 "4569": "<code><span class=\"literal string\">\" ** \"</span> : String</code>",
 "4568": "<code><span class=\"literal string\">\"⟧\"</span> : String</code>",
 "4567": "<code><span class=\"literal string\">\" — \"</span> : String</code>",
 "4566":
 "<code>Lean.Parser.numLit : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `num` parses a numeric literal in several bases:\n\n* Decimal: `129`\n* Hexadecimal: `0xdeadbeef`\n* Octal: `0o755`\n* Binary: `0b1101`\n\nThis parser has arity 1: it produces a `numLitKind` node containing an atom with the text of the\nliteral.\nYou can use `TSyntax.getNat` to extract the number from the resulting syntax object. </code>",
 "4565": "<code><span class=\"literal string\">\"⟦\"</span> : String</code>",
 "4564": "<code>ex3 (size : Nat) : CommandElabM Unit</code>",
 "4563": "<code>Array (TSyntax `term)</code>",
 "4562":
 "<code>ex2 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Array (TSyntax `term)) : m (TSyntax `term)</code>",
 "4561": "<code>Syntax.TSepArray `term \",\"</code>",
 "4560":
 "<code>ex1 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Syntax.TSepArray `term \",\") : m (TSyntax `term)</code>",
 "456":
 "<code>RunsMatch [(1, 2), (2, 2), (3, 1), (1, 3)] [1, 1, 2, 2, 3, 1, 1, 1]</code>",
 "4559":
 "<code>Lean.Syntax.node3 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ a₂ a₃ : Lean.Syntax) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 3 children </code>",
 "4558":
 "<code>Lean.TSyntax.raw {ks : Lean.SyntaxNodeKinds} (self : Lean.TSyntax ks) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The underlying `Syntax` value. </code>",
 "4557":
 "<code>Lean.Syntax.node2 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ a₂ : Lean.Syntax) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 2 children </code>",
 "4556":
 "<code>Lean.Syntax.node1 (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (a₁ : Lean.Syntax) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Create syntax node with 1 child </code>",
 "4555":
 "<code>f {m : Type → Type} [Monad m] [Lean.MonadQuotation m] (x : Lean.Term) (n : Nat) : m Syntax</code>",
 "4554":
 "<code>f {m : Type → Type} [Monad m] [MonadQuotation m] (x : Term) (n : Nat) : m Syntax</code>",
 "4553":
 "<code>f {m : Type → Type} [Monad m] [Lean.MonadQuotation m] (x : Lean.Term) (n : Nat) : m Lean.Syntax</code>",
 "4552": "<code>TSyntax `num</code>",
 "4551":
 "<code>ex2 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `num) : m (TSyntax `term)</code>",
 "4550":
 "<code>ex1 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `term) : m (TSyntax `term)</code>",
 "455":
 "<code>Prod.mk.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) : α × β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a pair. This is usually written `(x, y)` instead of `Prod.mk x y`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `(a, b)` in identifiers is `mk`.</code>",
 "4549": "<code>Term</code>",
 "4548":
 "<code>Lean.Quote.quote {α : Type} {k : optParam Lean.SyntaxNodeKind `term} [self : Lean.Quote α k] : α → Lean.TSyntax k</code>",
 "4547": "<code>SyntaxNodeKinds</code>",
 "4546":
 "<code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class=\"sep\"></span><code class=\"docstring\">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.\nThis is used to keep track of the location where we are working; if an exception\nis thrown, the `ref` gives the location where the error will be reported,\nassuming no more specific location is provided.\n</code>",
 "4545":
 "<code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class=\"sep\"></span><code class=\"docstring\">A monad that supports syntax quotations. Syntax quotations (in term\nposition) are monadic values that when executed retrieve the current \"macro\nscope\" from the monad and apply it to every identifier they introduce\n(independent of whether this identifier turns out to be a reference to an\nexisting declaration, or an actually fresh binding during further\nelaboration). We also apply the position of the result of `getRef` to each\nintroduced symbol, which results in better error positions than not applying\nany position. </code>",
 "4544":
 "<code><span class=\"literal string\">\"hello!\"</span> : String</code>",
 "4543": "<code>Lean.MacroM α</code>",
 "4542":
 "<code>Verso.Genre.Manual.ref (content : Array (Verso.Doc.Inline Manual)) (canonicalName : String)\n  (domain : Option Lean.Name := none) : Verso.Doc.Inline Manual</code>",
 "4541":
 "<code>Lean.Macro.Exception : Type</code><span class=\"sep\"></span><code class=\"docstring\">An exception in the `MacroM` monad. </code>",
 "4540":
 "<code>Lean.Macro.throwErrorAt {α : Type} (ref : Lean.Syntax) (msg : String) : Lean.MacroM α</code><span class=\"sep\"></span><code class=\"docstring\">Throw an error with the given message and location information. </code>",
 "454": "<code>NoRepeats [(1, 2), (2, 2), (3, 1), (1, 3)]</code>",
 "4539":
 "<code>Lean.Macro.throwError {α : Type} (msg : String) : Lean.MacroM α</code><span class=\"sep\"></span><code class=\"docstring\">Throw an error with the given message,\nusing the `ref` for the location information.\n</code>",
 "4538": "<code>?m.96</code>",
 "4537":
 "<code><span class=\"literal string\">\"'5' is not allowed here\"</span> : String</code>",
 "4536":
 "<code>Lean.Macro.throwError {α : Type} (msg : String) : MacroM α</code><span class=\"sep\"></span><code class=\"docstring\">Throw an error with the given message,\nusing the `ref` for the location information.\n</code>",
 "4535":
 "<code>Lean.Parser.Category.term : Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`term` is the builtin syntax category for terms. A term denotes an expression\nin lean's type theory, for example `2 + 2` is a term. The difference between\n`Term` and `Expr` is that the former is a kind of syntax, while the latter is\nthe result of elaboration. For example `by simp` is also a `Term`, but it elaborates\nto different `Expr`s depending on the context. </code>",
 "4534":
 "<code><span class=\"literal string\">\"notFive\"</span> : String</code>",
 "4533":
 "<code>Lean.Macro.Exception.unsupportedSyntax : Lean.Macro.Exception</code><span class=\"sep\"></span><code class=\"docstring\">An unsupported syntax exception. We keep this separate because it is\nused for control flow: if one macro does not support a syntax then we try\nthe next one. </code>",
 "4532":
 "<code>Lean.MacroM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The `MacroM` monad is the main monad for macro expansion. It has the\ninformation needed to handle hygienic name generation, and is the monad that\n`macro` definitions live in.\n\nNotably, this is a (relatively) pure monad: there is no `IO` and no access to\nthe `Environment`. That means that things like declaration lookup are\nimpossible here, as well as `IO.Ref` or other side-effecting operations.\nFor more capabilities, macros can instead be written as `elab` using `adaptExpander`.\n</code>",
 "4531": "<code><span class=\"literal string\">\"Two\"</span> : String</code>",
 "4530": "<code><span class=\"literal string\">\"One\"</span> : String</code>",
 "453": "<code>List (Nat × Nat)</code>",
 "4529":
 "<code>Lean.Parser.strLit : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `str` parses a string literal, such as `\"foo\"` or `\"\\r\\n\"`. Strings can contain\nC-style escapes like `\\n`, `\\\"`, `\\x00` or `\\u2665`, as well as literal unicode characters like `∈`.\nNewlines in a string are interpreted literally.\n\nThis parser has arity 1: it produces a `strLitKind` node containing an atom with the raw\nliteral (including the quote marks and without interpreting the escapes).\nYou can use `TSyntax.getString` to decode the string from the resulting syntax object. </code>",
 "4528": "<code><span class=\"literal string\">\"• \"</span> : String</code>",
 "4527":
 "<code>Lean.Parser.ppLine : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">No-op parser that advises the pretty printer to emit a hard line break. </code>",
 "4526":
 "<code><span class=\"literal string\">\"note \"</span> : String</code>",
 "4525":
 "<code class=\"docstring\">The `lineEq` parser requires that the current token is on the same line as the saved position\n(see `withPosition`). This can be used to ensure that composite tokens are not \"broken up\" across\ndifferent lines. For example, `else if` is parsed using `lineEq` to ensure that the two tokens\nare on the same line.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "4524":
 "<code class=\"docstring\">The `colEq` parser ensures that the next token starts at exactly the column of the saved\nposition (see `withPosition`). This can be used to do whitespace sensitive syntax like\na `by` block or `do` block, where all the lines have to line up.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "4523":
 "<code class=\"docstring\">The `colGe` parser requires that the next token starts from at least the column of the saved\nposition (see `withPosition`), but allows it to be more indented.\nThis can be used for whitespace sensitive syntax to ensure that a block does not go outside a\ncertain indentation scope. For example it is used in the lean grammar for `else if`, to ensure\nthat the `else` is not less indented than the `if` it matches with.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "4522":
 "<code class=\"docstring\">The `colGt` parser requires that the next token starts a strictly greater column than the saved\nposition (see `withPosition`). This can be used for whitespace sensitive syntax for the arguments\nto a tactic, to ensure that the following tactic is not interpreted as an argument.\n```\nexample (x : False) : False := by\n  revert x\n  exact id\n```\nHere, the `revert` tactic is followed by a list of `colGt ident`, because otherwise it would\ninterpret `exact` as an identifier and try to revert a variable named `exact`.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "4521":
 "<code class=\"docstring\">`withoutPosition(p)` runs `p` without the saved position, meaning that position-checking\nparsers like `colGt` will have no effect. This is usually used by bracketing constructs like\n`(...)` so that the user can locally override whitespace sensitivity.\n\nThis parser has the same arity as `p` - it just forwards the results of `p`. </code>",
 "4520":
 "<code class=\"docstring\">`withPosition(p)` runs `p` while setting the \"saved position\" to the current position.\nThis has no effect on its own, but various other parsers access this position to achieve some\ncomposite effect:\n\n* `colGt`, `colGe`, `colEq` compare the column of the saved position to the current position,\n  used to implement Python-style indentation sensitive blocks\n* `lineEq` ensures that the current position is still on the same line as the saved position,\n  used to implement composite tokens\n\nThe saved position is only available in the read-only state, which is why this is a scoping parser:\nafter the `withPosition(..)` block the saved position will be restored to its original value.\n\nThis parser has the same arity as `p` - it just forwards the results of `p`. </code>",
 "452":
 "<code>RLE.nonZero.{u_1} {α : Type u_1} {xs : List α} (self : RLE xs) : NonZero self.rle</code>",
 "4519":
 "<code>Lean.Parser.checkLineEq (errorMsg : String := \"checkLineEq\") : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The `lineEq` parser requires that the current token is on the same line as the saved position\n(see `withPosition`). This can be used to ensure that composite tokens are not \"broken up\" across\ndifferent lines. For example, `else if` is parsed using `lineEq` to ensure that the two tokens\nare on the same line.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "4518":
 "<code>Lean.Parser.checkColEq (errorMsg : String := \"checkColEq\") : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The `colEq` parser ensures that the next token starts at exactly the column of the saved\nposition (see `withPosition`). This can be used to do whitespace sensitive syntax like\na `by` block or `do` block, where all the lines have to line up.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "4517":
 "<code>Lean.Parser.checkColGe (errorMsg : String := \"checkColGe\") : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The `colGe` parser requires that the next token starts from at least the column of the saved\nposition (see `withPosition`), but allows it to be more indented.\nThis can be used for whitespace sensitive syntax to ensure that a block does not go outside a\ncertain indentation scope. For example it is used in the lean grammar for `else if`, to ensure\nthat the `else` is not less indented than the `if` it matches with.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "4516":
 "<code>Lean.Parser.checkColGt (errorMsg : String := \"checkColGt\") : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The `colGt` parser requires that the next token starts a strictly greater column than the saved\nposition (see `withPosition`). This can be used for whitespace sensitive syntax for the arguments\nto a tactic, to ensure that the following tactic is not interpreted as an argument.\n```\nexample (x : False) : False := by\n  revert x\n  exact id\n```\nHere, the `revert` tactic is followed by a list of `colGt ident`, because otherwise it would\ninterpret `exact` as an identifier and try to revert a variable named `exact`.\n\nThis parser has arity 0 - it does not capture anything. </code>",
 "4515":
 "<code>Lean.Parser.withPositionAfterLinebreak : Lean.Parser.Parser → Lean.Parser.Parser</code>",
 "4514":
 "<code>Lean.Parser.withPosition : Lean.Parser.Parser → Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">`withPosition(p)` runs `p` while setting the \"saved position\" to the current position.\nThis has no effect on its own, but various other parsers access this position to achieve some\ncomposite effect:\n\n* `colGt`, `colGe`, `colEq` compare the column of the saved position to the current position,\n  used to implement Python-style indentation sensitive blocks\n* `lineEq` ensures that the current position is still on the same line as the saved position,\n  used to implement composite tokens\n\nThe saved position is only available in the read-only state, which is why this is a scoping parser:\nafter the `withPosition(..)` block the saved position will be restored to its original value.\n\nThis parser has the same arity as `p` - it just forwards the results of `p`. </code>",
 "4513":
 "<code><span class=\"literal string\">\"Thistle\"</span> : String</code>",
 "4512":
 "<code><span class=\"literal string\">\"Dandelion\"</span> : String</code>",
 "4511": "<code>Lean.Syntax.TSepArray `term \",\"</code>",
 "4510": "<code><span class=\"literal string\">\"]]\"</span> : String</code>",
 "451":
 "<code>RLE.runsMatch.{u_1} {α : Type u_1} {xs : List α} (self : RLE xs) : RunsMatch self.rle xs</code>",
 "4509": "<code><span class=\"literal string\">\"[[\"</span> : String</code>",
 "4508":
 "<code>Lean.Parser.Category.term : Lean.Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`term` is the builtin syntax category for terms. A term denotes an expression\nin lean's type theory, for example `2 + 2` is a term. The difference between\n`Term` and `Expr` is that the former is a kind of syntax, while the latter is\nthe result of elaboration. For example `by simp` is also a `Term`, but it elaborates\nto different `Expr`s depending on the context. </code>",
 "4507":
 "<code><span class=\"literal string\">\"balanced \"</span> : String</code>",
 "4506": "<code>termBalanced : Lean.ParserDescr</code>",
 "4505": "<code><span class=\"literal string\">\")\"</span> : String</code>",
 "4504": "<code><span class=\"literal string\">\"(\"</span> : String</code>",
 "4503": "<code>Lean.Parser.Category.balanced : Lean.Parser.Category</code>",
 "4502":
 "<code>Lean.Parser.LeadingIdentBehavior : Type</code><span class=\"sep\"></span><code class=\"docstring\">Specifies how the parsing table lookup function behaves for identifiers.\n\nThe function `Lean.Parser.prattParser` uses two tables: one each for leading and trailing parsers.\nThese tables map tokens to parsers. Because keyword tokens are distinct from identifier tokens,\nkeywords and identifiers cannot be confused, even when they are syntactically identical.\nSpecifying an alternative leading identifier behavior allows greater flexiblity and makes it\npossible to avoid reserved keywords in some situations.\n\nWhen the leading token is syntactically an identifier, the current syntax category's\n`LeadingIdentBehavior` specifies how the parsing table lookup function behaves, and allows\ncontrolled “punning” between identifiers and keywords. This feature is used to avoid creating a\nreserved symbol for each built-in tactic (e.g., `apply` or `assumption`). As a result, tactic names\ncan be used as identifiers.\n</code>",
 "4501":
 "<code>Lean.Parser.prattParser (kind : Lean.Name) (tables : Lean.Parser.PrattParsingTables)\n  (behavior : Lean.Parser.LeadingIdentBehavior) (antiquotParser : Lean.Parser.ParserFn) : Lean.Parser.ParserFn</code><span class=\"sep\"></span><code class=\"docstring\">Implements a variant of Pratt's algorithm. In Pratt's algorithms tokens have a right and left binding power.\nIn our implementation, parsers have precedence instead. This method selects a parser (or more, via\n`longestMatchFn`) from `leadingTable` based on the current token. Note that the unindexed `leadingParsers` parsers\nare also tried. We have the unidexed `leadingParsers` because some parsers do not have a \"first token\". Example:\n```\nsyntax term:51 \"≤\" ident \"&lt;\" term \"|\" term : index\n```\nExample, in principle, the set of first tokens for this parser is any token that can start a term, but this set\nis always changing. Thus, this parsing rule is stored as an unindexed leading parser at `leadingParsers`.\nAfter processing the leading parser, we chain with parsers from `trailingTable`/`trailingParsers` that have precedence\nat least `c.prec` where `c` is the `ParsingContext`. Recall that `c.prec` is set by `categoryParser`.\n\nNote that in the original Pratt's algorithm, precedences are only checked before calling trailing parsers. In our\nimplementation, leading *and* trailing parsers check the precedence. We claim our algorithm is more flexible,\nmodular and easier to understand.\n\n`antiquotParser` should be a `mkAntiquot` parser (or always fail) and is tried before all other parsers.\nIt should not be added to the regular leading parsers because it would heavily\noverlap with antiquotation parsers nested inside them. </code>",
 "4500":
 "<code>Lean.Syntax.HygieneInfo : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents macro hygiene info.\n</code>",
 "450": "<code>RunLengths α</code>",
 "45":
 "<code>Option.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Optional values, which are either `some` around a value from the underlying type or `none`.\n\n`Option` can represent nullable types or computations that might fail. In the codomain of a function\ntype, it can also represent partiality.\n</code>",
 "4499": "<code>Lean.HygieneInfo</code>",
 "4498":
 "<code>Lean.Syntax.CharLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a character literal.\n</code>",
 "4497": "<code>Lean.CharLit</code>",
 "4496":
 "<code>Lean.Syntax.StrLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a string literal.\n</code>",
 "4495": "<code>Lean.StrLit</code>",
 "4494": "<code>?m.5546</code>",
 "4493":
 "<code>Lean.Syntax.ScientificLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a scientific numeric literal that may have decimal and exponential parts.\n</code>",
 "4492": "<code>Lean.ScientificLit</code>",
 "4491":
 "<code>Lean.Syntax.NumLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a numeric literal.\n</code>",
 "4490": "<code>Lean.NumLit</code>",
 "449":
 "<code>RLE.noRepeats.{u_1} {α : Type u_1} {xs : List α} (self : RLE xs) : NoRepeats self.rle</code>",
 "4489":
 "<code>Lean.Name.anonymous : Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">The \"anonymous\" name. </code>",
 "4488":
 "<code>Lean.Syntax.NameLit : Type</code><span class=\"sep\"></span><code class=\"docstring\">Syntax that represents a quoted name literal that begins with a back-tick.\n</code>",
 "4487": "<code>Lean.NameLit</code>",
 "4486": "<code>Lean.Ident</code>",
 "4485": "<code>?m.2476</code>",
 "4484":
 "<code>Array Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The array of elements and separators, ordered like\n`#[el1, sep1, el2, sep2, el3]`. </code>",
 "4483":
 "<code>Lean.Syntax.TSepArray.mk {ks : Lean.SyntaxNodeKinds} {sep : String} (elemsAndSeps : Array Lean.Syntax) :\n  Lean.Syntax.TSepArray ks sep</code>",
 "4482":
 "<code>Lean.Syntax.SepArray (sep : String) : Type</code><span class=\"sep\"></span><code class=\"docstring\">An array of syntax elements interspersed with the given separators.\n\nSeparator arrays result from repetition operators such as `,*`.\n[Coercions](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=coercions) to and from `Array Syntax` insert or remove separators\nas required.\n\nThe typed equivalent is `Lean.Syntax.TSepArray`.\n</code>",
 "4481":
 "<code>Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The underlying `Syntax` value. </code>",
 "4480":
 "<code>Lean.TSyntax.mk {ks : Lean.SyntaxNodeKinds} (raw : Lean.Syntax) : Lean.TSyntax ks</code>",
 "448":
 "<code>RLE.rle.{u_1} {α : Type u_1} {xs : List α} (self : RLE xs) : RunLengths α</code>",
 "4479":
 "<code>Lean.SyntaxNodeKinds : Type</code><span class=\"sep\"></span><code class=\"docstring\">`SyntaxNodeKinds` is a set of `SyntaxNodeKind`, implemented as a list.\n\nSingleton `SyntaxNodeKinds` are extremely common. They are written as name literals, rather than as\nlists; list syntax is required only for empty or non-singleton sets of kinds.\n</code>",
 "4478": "<code>Lean.SyntaxNodeKinds</code>",
 "4477":
 "<code>Std.Format.pretty (f : Format) (width : Nat := Std.Format.defWidth) (indent column : Nat := 0) : String</code><span class=\"sep\"></span><code class=\"docstring\">Renders a `Format` to a string.\n* `width`: the total width\n* `indent`: the initial indentation to use for wrapped lines\n  (subsequent wrapping may increase the indentation)\n* `column`: begin the first line wrap `column` characters earlier than usual\n  (this is useful when the output String will be printed starting at `column`)\n</code>",
 "4476":
 "<code>Std.Format.pretty (f : Std.Format) (width : Nat := Std.Format.defWidth) (indent column : Nat := 0) : String</code><span class=\"sep\"></span><code class=\"docstring\">Renders a `Format` to a string.\n* `width`: the total width\n* `indent`: the initial indentation to use for wrapped lines\n  (subsequent wrapping may increase the indentation)\n* `column`: begin the first line wrap `column` characters earlier than usual\n  (this is useful when the output String will be printed starting at `column`)\n</code>",
 "4475":
 "<code>Lean.logInfo {m : Type → Type} [Monad m] [Lean.MonadLog m] [Lean.AddMessageContext m] [Lean.MonadOptions m]\n  (msgData : Lean.MessageData) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Log a new information message using the given message data. The position is provided by `getRef`. </code>",
 "4474":
 "<code>Lean.ppTerm (ctx : PPContext) (stx : Term) : BaseIO Format</code>",
 "4473": "<code>Format</code>",
 "4472":
 "<code>Lean.MonadResolveName.getOpenDecls {m : Type → Type} [self : MonadResolveName m] : m (List OpenDecl)</code>",
 "4471": "<code>List OpenDecl</code>",
 "4470":
 "<code>Lean.MonadResolveName.getCurrNamespace {m : Type → Type} [self : MonadResolveName m] : m Name</code>",
 "447": "<code>RLE.{u_1} {α : Type u_1} (xs : List α) : Type u_1</code>",
 "4469": "<code>Name</code>",
 "4468":
 "<code>Lean.MonadOptions.getOptions {m : Type → Type} [self : MonadOptions m] : m Options</code>",
 "4467": "<code>Options</code>",
 "4466": "<code>Environment</code>",
 "4465": "<code>Lean.PPContext : Type</code>",
 "4464": "<code>getPPContext : CommandElabM PPContext</code>",
 "4463":
 "<code>Lean.ppTerm (ctx : Lean.PPContext) (stx : Lean.Term) : BaseIO Std.Format</code>",
 "4462":
 "<code>Lean.Syntax.missing : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A portion of the syntax tree that is missing because of a parse error.\n\nThe indexing operator on `Syntax` also returns `Syntax.missing` when the index is out of bounds.\n</code>",
 "4461":
 "<code>Lean.Syntax.ident (info : Lean.SourceInfo) (rawVal : Substring) (val : Lean.Name)\n  (preresolved : List Lean.Syntax.Preresolved) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">An identifier.\n\nIn addition to source information, identifiers have the following fields:\n* `rawVal` is the literal substring from the input file\n* `val` is the parsed Lean name, potentially including macro scopes.\n* `preresolved` is the list of possible declarations this could refer to, populated by\n  [quotations](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=quasiquotation).\n</code>",
 "4460": "<code><span class=\"literal string\">\"Lily\"</span> : String</code>",
 "446": "<code>NonZero.{u_1} {α : Type u_1} : RunLengths α → Prop</code>",
 "4459":
 "<code><span class=\"literal string\">\"Daffodil\"</span> : String</code>",
 "4458": "<code><span class=\"literal string\">\"Rose\"</span> : String</code>",
 "4457":
 "<code>Lean.TSyntax.raw {ks : SyntaxNodeKinds} (self : TSyntax ks) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">The underlying `Syntax` value. </code>",
 "4456":
 "<code>repr.{u_1} {α : Type u_1} [Repr α] (a : α) : Format</code><span class=\"sep\"></span><code class=\"docstring\">Turn `a` into `Format` using its `Repr` instance. The precedence level is initially set to 0.\n</code>",
 "4455":
 "<code>Lean.logInfo {m : Type → Type} [Monad m] [MonadLog m] [AddMessageContext m] [MonadOptions m] (msgData : MessageData) :\n  m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Log a new information message using the given message data. The position is provided by `getRef`. </code>",
 "4454":
 "<code>Lean.TSyntax.mk {ks : SyntaxNodeKinds} (raw : Syntax) : TSyntax ks</code>",
 "4453": "<code>TSyntax `term</code>",
 "4452": "<code>Array Syntax</code>",
 "4451":
 "<code>Lean.Syntax.node (info : SourceInfo) (kind : SyntaxNodeKind) (args : Array Syntax) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A node in the syntax tree that may have further syntax as child nodes. The node's `kind`\ndetermines its interpretation.\n\nFor nodes produced by the parser, the `info` field is typically `Lean.SourceInfo.none`, and source\ninformation is stored in the corresponding fields of identifiers and atoms. This field is used in\ntwo ways:\n 1. The delaborator uses it to associate nodes with metadata that are used to implement\n    interactive features.\n 2. Nodes created by quotations use the field to mark the syntax as synthetic (storing the result\n    of `Lean.SourceInfo.fromRef`) even when its leading or trailing tokens are not.\n</code>",
 "4450": "<code>List Syntax.Preresolved</code>",
 "445":
 "<code>List.replicate.{u} {α : Type u} (n : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Creates a list that contains `n` copies of `a`.\n\n* `List.replicate 5 \"five\" = [\"five\", \"five\", \"five\", \"five\", \"five\"]`\n* `List.replicate 0 \"zero\" = []`\n* `List.replicate 2 ' ' = [' ', ' ']`\n</code>",
 "4449":
 "<code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">An identifier.\n\nIn addition to source information, identifiers have the following fields:\n* `rawVal` is the literal substring from the input file\n* `val` is the parsed Lean name, potentially including macro scopes.\n* `preresolved` is the list of possible declarations this could refer to, populated by\n  [quotations](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=quasiquotation).\n</code>",
 "4448":
 "<code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A non-identifier atomic component of syntax.\n\nAll of the following are atoms:\n * keywords, such as `def`, `fun`, and `inductive`\n * literals, such as numeric or string literals\n * punctuation and delimiters, such as `(`, `)`, and `=&gt;`.\n\nIdentifiers are represented by the `Lean.Syntax.ident` constructor. Atoms also correspond to\nquoted strings inside `syntax` declarations.\n</code>",
 "4447": "<code>removeSourceInfo : Syntax → Syntax</code>",
 "4446":
 "<code>Lean.Syntax.updateLeading : Syntax → Syntax</code><span class=\"sep\"></span><code class=\"docstring\">Set `SourceInfo.leading` according to the trailing stop of the preceding token.\nThe result is a round-tripping syntax tree IF, in the input syntax tree,\n* all leading stops, atom contents, and trailing starts are correct\n* trailing stops are between the trailing start and the next leading stop.\n\nRemark: after parsing, all `SourceInfo.leading` fields are empty.\nThe `Syntax` argument is the output produced by the parser for `source`.\nThis function \"fixes\" the `source.leading` field.\n\nAdditionally, we try to choose \"nicer\" splits between leading and trailing stops\naccording to some heuristics so that e.g. comments are associated to the (intuitively)\ncorrect token.\n\nNote that the `SourceInfo.trailing` fields must be correct.\nThe implementation of this Function relies on this property. </code>",
 "4445":
 "<code>Lean.HygieneInfo.mkIdent (s : Lean.HygieneInfo) (val : Lean.Name) (canonical : Bool := false) : Lean.Ident</code>",
 "4444":
 "<code>Lean.Parser.hygieneInfo : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `hygieneInfo` parses no text, but captures the current macro scope information\nas though it parsed an identifier at the current position. It returns a `hygieneInfoKind` node\naround an `.ident` which is `Name.anonymous` but with macro scopes like a regular identifier.\n\nThis is used to implement `have := ...` syntax: the `hygieneInfo` between the `have` and `:=`\nsubstitutes for the identifier which would normally go there as in `have x :=`, so that we\ncan expand `have :=` to `have this :=` while retaining the usual macro name resolution behavior.\nSee [doc/macro_overview.md](https://github.com/leanprover/lean4/blob/master/doc/macro_overview.md)\nfor more information about macro hygiene.\n\nThis parser has arity 1: it produces a `Syntax.ident` node containing the parsed identifier.\nYou can use `TSyntax.getHygieneInfo` to extract the name from the resulting syntax object. </code>",
 "4443":
 "<code>Manual.many.{u_1, u_2} {f : Type u_1 → Type u_2} {α : Type u_1} [Inhabited (f (List α))] [Applicative f] [Alternative f]\n  (x : f α) : f (List α)</code>",
 "4442":
 "<code>optional.{u, v} {f : Type u → Type v} [Alternative f] {α : Type u} (x : f α) : f (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Returns `some x` if `f` succeeds with value `x`, else returns `none`.\n</code>",
 "4441":
 "<code>Lean.Parser.group (p : Lean.Parser.Parser) : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `group(p)` parses the same thing as `p`, but it wraps the results in a `groupKind`\nnode.\n\nThis parser always has arity 1, even if `p` does not. Parsers like `p*` are automatically\nrewritten to `group(p)*` if `p` does not have arity 1, so that the results from separate invocations\nof `p` can be differentiated. </code>",
 "4440":
 "<code><span class=\"literal string\">\"value = {x}\"</span> : String</code>",
 "444":
 "<code>List.take.{u} {α : Type u} (n : Nat) (xs : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the first `n` elements of `xs`, or the whole list if `n` is greater than `xs.length`.\n\n`O(min n |xs|)`.\n\nExamples:\n* `[a, b, c, d, e].take 0 = []`\n* `[a, b, c, d, e].take 3 = [a, b, c]`\n* `[a, b, c, d, e].take 6 = [a, b, c, d, e]`\n</code>",
 "4439":
 "<code>Lean.TSyntax.getString (s : Lean.StrLit) : String</code><span class=\"sep\"></span><code class=\"docstring\">Decodes a string literal, removing quotation marks and unescaping escaped characters.\n\nReturns `\"\"` if the syntax is malformed.\n</code>",
 "4438": "<code><span class=\"literal string\">\"0x\"</span> : String</code>",
 "4437":
 "<code>Lean.Syntax.atom (info : Lean.SourceInfo) (val : String) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A non-identifier atomic component of syntax.\n\nAll of the following are atoms:\n * keywords, such as `def`, `fun`, and `inductive`\n * literals, such as numeric or string literals\n * punctuation and delimiters, such as `(`, `)`, and `=&gt;`.\n\nIdentifiers are represented by the `Lean.Syntax.ident` constructor. Atoms also correspond to\nquoted strings inside `syntax` declarations.\n</code>",
 "4436":
 "<code>Lean.Syntax.node (info : Lean.SourceInfo) (kind : Lean.SyntaxNodeKind) (args : Array Lean.Syntax) : Lean.Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A node in the syntax tree that may have further syntax as child nodes. The node's `kind`\ndetermines its interpretation.\n\nFor nodes produced by the parser, the `info` field is typically `Lean.SourceInfo.none`, and source\ninformation is stored in the corresponding fields of identifiers and atoms. This field is used in\ntwo ways:\n 1. The delaborator uses it to associate nodes with metadata that are used to implement\n    interactive features.\n 2. Nodes created by quotations use the field to mark the syntax as synthetic (storing the result\n    of `Lean.SourceInfo.fromRef`) even when its leading or trailing tokens are not.\n</code>",
 "4435":
 "<code>Lean.Syntax.getKind (stx : Lean.Syntax) : Lean.SyntaxNodeKind</code><span class=\"sep\"></span><code class=\"docstring\">Gets the kind of a `Syntax.node` value, or the pseudo-kind of any other `Syntax` value.\n\n“Pseudo-kinds” are kinds that are assigned by convention to non-`Syntax.node` values:\n`identKind` for `Syntax.ident`, `` `missing `` for `Syntax.missing`, and the atom's string literal\nfor atoms.\n</code>",
 "4434":
 "<code>Lean.identKind : Lean.SyntaxNodeKind</code><span class=\"sep\"></span><code class=\"docstring\">The pseudo-kind assigned to identifiers: `` `ident ``.\n\nThe name `` `ident `` is not actually used as a kind for `Syntax.node` values. It is used by\nconvention as the kind of `Syntax.ident` values.\n</code>",
 "4433": "<code>List Preresolved</code>",
 "4432":
 "<code>Lean.Syntax.Preresolved : Type</code><span class=\"sep\"></span><code class=\"docstring\">A possible binding of an identifier in the context in which it was quoted.\n\nIdentifiers in quotations may refer to either global declarations or to namespaces that are in scope\nat the site of the quotation. These are saved in the `Syntax.ident` constructor and are part of the\nimplementation of hygienic macros.\n</code>",
 "4431": "<code>List Lean.Syntax.Preresolved</code>",
 "4430": "<code>Substring</code>",
 "443":
 "<code>RunsMatch.{u_1} {α : Type u_1} : RunLengths α → List α → Prop</code>",
 "4429":
 "<code>Manual.syntax : Verso.Doc.Elab.DirectiveExpander</code><span class=\"sep\"></span><code class=\"docstring\">Display actual Lean syntax, validated by the parser.\n</code>",
 "4428":
 "<code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Preresolved) : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">An identifier.\n\nIn addition to source information, identifiers have the following fields:\n* `rawVal` is the literal substring from the input file\n* `val` is the parsed Lean name, potentially including macro scopes.\n* `preresolved` is the list of possible declarations this could refer to, populated by\n  [quotations](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=quasiquotation).\n</code>",
 "4427":
 "<code class=\"docstring\">`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n</code>",
 "4426":
 "<code>Lean.SourceInfo.fromRef (ref : Syntax) (canonical : Bool := false) : SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a synthetic `SourceInfo` using a `ref : Syntax` for the span. </code>",
 "4425": "<code>SourceInfo</code>",
 "4424": "<code>SyntaxNodeKind</code>",
 "4423":
 "<code>Lean.SyntaxNodeKind : Type</code><span class=\"sep\"></span><code class=\"docstring\">Specifies the interpretation of a `Syntax.node` value. An abbreviation for `Name`.\n\nNode kinds may be any name, and do not need to refer to declarations in the environment.\nConventionally, however, a node's kind corresponds to the `Parser` or `ParserDesc` declaration that\nproduces it. There are also a number of built-in node kinds that are used by the parsing\ninfrastructure, such as `nullKind` and `choiceKind`; these do not correspond to parser declarations.\n</code>",
 "4422": "<code>Lean.SyntaxNodeKind</code>",
 "4421": "<code>Lean.SourceInfo</code>",
 "4420": "<code>e : Nat × Int</code>",
 "442": "<code>List (α × Nat)</code>",
 "4419": "<code><span class=\"literal string\">\"dup!\"</span> : String</code>",
 "4418": "<code>dup : Lean.ParserDescr</code>",
 "4417":
 "<code><span class=\"literal string\">\"whatever\"</span> : String</code>",
 "4416":
 "<code class=\"docstring\">Precedence used for application arguments (`do`, `by`, ...). </code>",
 "4415": "<code>Lean.TSyntax `term</code>",
 "4414":
 "<code><span class=\"literal string\">\"ignore \"</span> : String</code>",
 "4413": "<code>ignore : Lean.ParserDescr</code>",
 "4412":
 "<code>GE.ge.{u} {α : Type u} [LE α] (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a ≥ b` is an abbreviation for `b ≤ a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≥` in identifiers is `ge`.\n\n * The recommended spelling of `&gt;=` in identifiers is `ge` (prefer `≥` over `&gt;=`).</code>",
 "4411": "<code><span class=\"literal string\">\"‽\"</span> : String</code>",
 "4410": "<code>fact : Nat → Nat</code>",
 "441": "<code>NoRepeats.{u_1} {α : Type u_1} : RunLengths α → Prop</code>",
 "4409": "<code>perhapsFactorial (n : Nat) : Option Nat</code>",
 "4408":
 "<code class=\"docstring\">The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. </code>",
 "4407": "<code><span class=\"literal string\">\" + \"</span> : String</code>",
 "4406": "<code>getDOp : Lean.TrailingParserDescr</code>",
 "4405": "<code>«term_⤴_» : Lean.TrailingParserDescr</code>",
 "4404": "<code><span class=\"literal string\">\" ⤴ \"</span> : String</code>",
 "4403":
 "<code class=\"docstring\">inherit documentation from a specified declaration</code>",
 "4402": "<code>B : Prop</code>",
 "4401": "<code>A : Prop</code>",
 "4400": "<code>α → Thunk β</code>",
 "440": "<code>RunLengths.{u_1} (α : Type u_1) : Type u_1</code>",
 "44": "<code>Type u_1</code>",
 "4399": "<code>Thunk α</code>",
 "4398": "<code><span class=\"literal string\">\"ys\"</span> : String</code>",
 "4397": "<code><span class=\"literal string\">\"xs\"</span> : String</code>",
 "4396": "<code>ys : LazyList Nat</code>",
 "4395": "<code>xs : LazyList Nat</code>",
 "4394": "<code>observe {n : Nat} (tag : String) (i : Fin n) : Nat</code>",
 "4393":
 "<code>LazyList.append.{u_1} {α : Type u_1} (xs ys : LazyList α) : LazyList α</code>",
 "4392":
 "<code>LazyList.ofFn.{u_1} {n : Nat} {α : Type u_1} (f : Fin n → α) : LazyList α</code>",
 "4391":
 "<code>LazyList.take.{u_1} {α : Type u_1} : Nat → LazyList α → LazyList α</code>",
 "4390": "<code>Thunk (LazyList α)</code>",
 "439": "<code>Type ?u.24</code>",
 "4389": "<code>LazyList α</code>",
 "4388":
 "<code>LazyList.toList.{u_1} {α : Type u_1} : LazyList α → List α</code>",
 "4387":
 "<code>LazyList.cons.{u} {α : Type u} : α → LazyList α → LazyList α</code>",
 "4386": "<code>LazyList.nil.{u} {α : Type u} : LazyList α</code>",
 "4385": "<code>LazyList.{u} (α : Type u) : Type u</code>",
 "4384":
 "<code>LazyList.delayed.{u} {α : Type u} : Thunk (LazyList α) → LazyList α</code>",
 "4383":
 "<code>Thunk.pure.{u_1} {α : Type u_1} (a : α) : Thunk α</code><span class=\"sep\"></span><code class=\"docstring\">Stores an already-computed value in a thunk.\n\nBecause the value has already been computed, there is no laziness.\n</code>",
 "4382":
 "<code>Thunk.mk.{u} {α : Type u} (fn : Unit → α) : Thunk α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new thunk from a function `Unit → α` that will be called when the thunk is first\nforced.\n\nThe result is cached. It is re-used when the thunk is forced again.\n</code>",
 "4381":
 "<code>Thunk.bind.{u_1, u_2} {α : Type u_1} {β : Type u_2} (x : Thunk α) (f : α → Thunk β) : Thunk β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new thunk that applies `f` to the result of `x` when forced.\n</code>",
 "4380":
 "<code>Thunk.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (x : Thunk α) : Thunk β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new thunk that forces `x` and then applies `x` to the result. Upon forcing, the result\nof `f` is cached and the reference to the thunk `x` is dropped.\n</code>",
 "438": "<code>Type ?u.9</code>",
 "4379":
 "<code>Thunk.get.{u_1} {α : Type u_1} (x : Thunk α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Gets the thunk's value. If the value is cached, it is returned in constant time; if not, it is\ncomputed.\n\nComputed values are cached, so the value is not recomputed.\n</code>",
 "4378": "<code>DivBy3 : Type</code>",
 "4377": "<code>nine : DivBy3</code>",
 "4376": "<code>s1_eq_s2 : s1 = s2</code>",
 "4375":
 "<code>String.data_eq_of_eq {a b : String} (h : a = b) : a.data = b.data</code>",
 "4374":
 "<code>List.cons_ne_nil.{u_1} {α : Type u_1} (a : α) (l : List α) : a :: l ≠ []</code>",
 "4373": "<code>\"equal\" = \"\"</code>",
 "4372":
 "<code>\"equal\" = \"\" → False</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "4371":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "4370":
 "<code>ne_of_beq_false.{u_1} {α : Type u_1} [BEq α] [LawfulBEq α] {a b : α} (h : (a == b) = false) : a ≠ b</code>",
 "437":
 "<code>Ne.{u} {α : Sort u} (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.</code>",
 "4369":
 "<code><span class=\"literal string\">\"equal\"</span> : String</code>",
 "4368": "<code>NonEmptyString : Type</code>",
 "4367": "<code>s2 : NonEmptyString</code>",
 "4366": "<code>s1 : NonEmptyString</code>",
 "4365": "<code>?m.1037</code>",
 "4364": "<code>?m.1027</code>",
 "4363": "<code>Subtype p</code>",
 "4362":
 "<code>p self.val</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "4361":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "4360":
 "<code>Subarray.anyM.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Subarray α) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether any of the elements in a subarray satisfy a monadic Boolean predicate.\n\nThe elements are tested starting at the lowest index and moving up. The search terminates as soon as\nan element that satisfies the predicate is found.\n\nExample:\n```lean example\n#eval #[\"red\", \"green\", \"blue\", \"orange\"].toSubarray.popFront.anyM fun x =&gt; do\n  IO.println x\n  pure (x == \"blue\")\n```\n```output\ngreen\nblue\n```\n```output\ntrue\n```\n</code>",
 "436": "<code>List ?m.260</code>",
 "4359":
 "<code>Subarray.allM.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Subarray α) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether all of the elements in a subarray satisfy a monadic Boolean predicate.\n\nThe elements are tested starting at the lowest index and moving up. The search terminates as soon as\nan element that does not satisfy the predicate is found.\n\nExample:\n```lean example\n#eval #[\"red\", \"green\", \"blue\", \"orange\"].toSubarray.popFront.allM fun x =&gt; do\n  IO.println x\n  pure (x.length == 5)\n```\n```output\ngreen\nblue\n```\n```output\nfalse\n```\n</code>",
 "4358":
 "<code>Subarray.findSomeRevM?.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (as : Subarray α)\n  (f : α → m (Option β)) : m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function to each element in a subarray in reverse order, stopping at the first\nelement for which the function succeeds by returning a value other than `none`. The succeeding value\nis returned, or `none` if there is no success.\n\nExample:\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.findSomeRevM? fun x =&gt; do\n  IO.println x\n  return Option.guard (· = 5) x.length\n```\n```output\nblue\ngreen\n```\n```output\nsome 5\n```\n</code>",
 "4357":
 "<code>Subarray.findRevM?.{w} {α : Type} {m : Type → Type w} [Monad m] (as : Subarray α) (p : α → m Bool) : m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic Boolean predicate to each element in a subarray in reverse order, stopping at the\nfirst element that satisfies the predicate. The element that satisfies the predicate is returned, or\n`none` if no element satisfies it.\n\nExample:\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.findRevM? fun x =&gt; do\n  IO.println x\n  return (x.length = 5)\n```\n```output\nblue\ngreen\n```\n```output\nsome 5\n```\n</code>",
 "4356":
 "<code>Subarray.findRev? {α : Type} (as : Subarray α) (p : α → Bool) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Tests each element in a subarray with a Boolean predicate in reverse order, stopping at the first\nelement that satisfies the predicate. The element that satisfies the predicate is returned, or\n`none` if no element satisfies the predicate.\n\nExamples:\n * `#[\"red\", \"green\", \"blue\"].toSubarray.findRev? (·.length ≠ 4) = some \"green\"`\n * `#[\"red\", \"green\", \"blue\"].toSubarray.findRev? (fun _ =&gt; true) = some \"blue\"`\n * `#[\"red\", \"green\", \"blue\"].toSubarray 0 0 |&gt;.findRev? (fun _ =&gt; true) = none`\n</code>",
 "4355":
 "<code><span class=\"literal string\">\"(4)blue (5)green (3)red \"</span> : String</code>",
 "4354":
 "<code>Subarray.foldrM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → β → m β) (init : β)\n  (as : Subarray α) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic operation from right to left over the elements in a subarray.\n\nAn accumulator of type `β` is constructed by starting with `init` and monadically combining each\nelement of the subarray with the current accumulator value in turn, moving from the end to the\nstart. The monad in question may permit early termination or repetition.\n\nExamples:\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldrM (init := \"\") fun x acc =&gt; do\n  let l ← Option.guard (· ≠ 0) x.length\n  return s!\"{acc}({l}){x} \"\n```\n```output\nsome \"(4)blue (5)green (3)red \"\n```\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldrM (init := 0) fun x acc =&gt; do\n  let l ← Option.guard (· ≠ 5) x.length\n  return s!\"{acc}({l}){x} \"\n```\n```output\nnone\n```\n</code>",
 "4353":
 "<code><span class=\"literal string\">\"(3)red (5)green (4)blue \"</span> : String</code>",
 "4352":
 "<code>Subarray.foldlM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : β → α → m β) (init : β)\n  (as : Subarray α) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic operation from left to right over the elements in a subarray.\n\nAn accumulator of type `β` is constructed by starting with `init` and monadically combining each\nelement of the subarray with the current accumulator value in turn. The monad in question may permit\nearly termination or repetition.\n\nExamples:\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldlM (init := \"\") fun acc x =&gt; do\n  let l ← Option.guard (· ≠ 0) x.length\n  return s!\"{acc}({l}){x} \"\n```\n```output\nsome \"(3)red (5)green (4)blue \"\n```\n```lean example\n#eval #[\"red\", \"green\", \"blue\"].toSubarray.foldlM (init := 0) fun acc x =&gt; do\n  let l ← Option.guard (· ≠ 5) x.length\n  return s!\"{acc}({l}){x} \"\n```\n```output\nnone\n```\n</code>",
 "4351":
 "<code>Subarray.foldl.{u, v} {α : Type u} {β : Type v} (f : β → α → β) (init : β) (as : Subarray α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds an operation from left to right over the elements in a subarray.\n\nAn accumulator of type `β` is constructed by starting with `init` and combining each\nelement of the subarray with the current accumulator value in turn.\n\nExamples:\n * `#[\"red\", \"green\", \"blue\"].toSubarray.foldl (· + ·.length) 0 = 12`\n * `#[\"red\", \"green\", \"blue\"].toSubarray.popFront.foldl (· + ·.length) 0 = 9`\n</code>",
 "4350": "<code>Fin s.size</code>",
 "435": "<code>?m.260</code>",
 "4349":
 "<code>Subarray.size.{u_1} {α : Type u_1} (s : Subarray α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the size of the subarray.\n</code>",
 "4348": "<code>Fin s.size.succ</code>",
 "4347":
 "<code>Subarray.toArray.{u_1} {α : Type u_1} (s : Subarray α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Allocates a new array that contains the contents of the subarray.\n</code>",
 "4346":
 "<code>Subarray.popFront.{u_1} {α : Type u_1} (s : Subarray α) : Subarray α</code><span class=\"sep\"></span><code class=\"docstring\">Shrinks the subarray by incrementing its starting index if possible, returning it unchanged if not.\n\nExamples:\n* `#[1,2,3].toSubarray.popFront.toArray = #[2, 3]`\n* `#[1,2,3].toSubarray.popFront.popFront.toArray = #[3]`\n* `#[1,2,3].toSubarray.popFront.popFront.popFront.toArray = #[]`\n* `#[1,2,3].toSubarray.popFront.popFront.popFront.popFront.toArray = #[]`\n</code>",
 "4345":
 "<code>Array.toSubarray.{u} {α : Type u} (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : Subarray α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a subarray of an array, with the given bounds.\n\nIf `start` or `stop` are not valid bounds for a subarray, then they are clamped to array's size.\nAdditionally, the starting index is clamped to the ending index.\n</code>",
 "4344": "<code>self.stop ≤ self.array.size</code>",
 "4343":
 "<code>Subarray.stop.{u} {α : Type u} (self : Subarray α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The ending index of the region of interest (exclusive). </code>",
 "4342":
 "<code>Subarray.start.{u} {α : Type u} (self : Subarray α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The starting index of the region of interest (inclusive). </code>",
 "4341": "<code>self.start ≤ self.stop</code>",
 "4340":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The ending index of the region of interest (exclusive). </code>",
 "434":
 "<code>PrefixRunOf.succ {α : Type} {n : Nat} {x : α} {xs ys : List α} :\n  PrefixRunOf n x xs ys → PrefixRunOf (n + 1) x (x :: xs) ys</code>",
 "4339":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The starting index of the region of interest (inclusive). </code>",
 "4338":
 "<code>Array α</code><span class=\"sep\"></span><code class=\"docstring\">The underlying array. </code>",
 "4337":
 "<code>Subarray.mk.{u} {α : Type u} (array : Array α) (start stop : Nat) (start_le_stop : start ≤ stop)\n  (stop_le_array_size : stop ≤ array.size) : Subarray α</code>",
 "4336":
 "<code>Array.pmap.{u_1, u_2} {α : Type u_1} {β : Type u_2} {P : α → Prop} (f : (a : α) → P a → β) (xs : Array α)\n  (H : ∀ (a : α), a ∈ xs → P a) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Maps a partially defined function (defined on those terms of `α` that satisfy a predicate `P`) over\nan array `xs : Array α`, given a proof that every element of `xs` in fact satisfies `P`.\n\n`Array.pmap`, named for “partial map,” is the equivalent of `Array.map` for such partial functions.\n</code>",
 "4335": "<code>∀ (a : α), a ∈ xs → P a</code>",
 "4334":
 "<code>Array.attachWith.{u_1} {α : Type u_1} (xs : Array α) (P : α → Prop) (H : ∀ (x : α), x ∈ xs → P x) : Array { x // P x }</code><span class=\"sep\"></span><code class=\"docstring\">“Attaches” individual proofs to an array of values that satisfy a predicate `P`, returning an array\nof elements in the corresponding subtype `{ x // P x }`.\n\n`O(1)`.\n</code>",
 "4333": "<code>Array { x // p x }</code>",
 "4332": "<code>?m.86011</code>",
 "4331":
 "<code>Array.lex.{u_1} {α : Type u_1} [BEq α] (as bs : Array α) (lt : α → α → Bool := by exact (· &lt; ·)) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Compares arrays lexicographically with respect to a comparison `lt` on their elements.\n\nSpecifically, `Array.lex as bs lt` is true if\n* `bs` is larger than `as` and `as` is pairwise equivalent via `==` to the initial segment of `bs`,\n  or\n* there is an index `i` such that `lt as[i] bs[i]`, and for all `j &lt; i`, `as[j] == bs[j]`.\n</code>",
 "4330":
 "<code>Array.isPrefixOf.{u} {α : Type u} [BEq α] (as bs : Array α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Return `true` if `as` is a prefix of `bs`, or `false` otherwise.\n\nExamples:\n* `#[0, 1, 2].isPrefixOf #[0, 1, 2, 3] = true`\n* `#[0, 1, 2].isPrefixOf #[0, 1, 2] = true`\n* `#[0, 1, 2].isPrefixOf #[0, 1] = false`\n* `#[].isPrefixOf #[0, 1] = true`\n</code>",
 "433": "<code>?m.166</code>",
 "4329":
 "<code>Array.isEqv.{u} {α : Type u} (xs ys : Array α) (p : α → α → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `as` and `bs` have the same length and they are pairwise related by `eqv`.\n\nShort-circuits at the first non-related pair of elements.\n\nExamples:\n* `#[1, 2, 3].isEqv #[2, 3, 4] (· &lt; ·) = true`\n* `#[1, 2, 3].isEqv #[2, 2, 4] (· &lt; ·) = false`\n* `#[1, 2, 3].isEqv #[2, 3] (· &lt; ·) = false`\n</code>",
 "4328":
 "<code>Array.allDiff.{u} {α : Type u} [BEq α] (as : Array α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if no two elements of `as` are equal according to the `==` operator.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\"].allDiff = true`\n* `#[\"red\", \"green\", \"red\"].allDiff = false`\n* `(#[] : Array Nat).allDiff = true`\n</code>",
 "4327":
 "<code>Array.any.{u} {α : Type u} (as : Array α) (p : α → Bool) (start : Nat := 0) (stop : Nat := as.size) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `p` returns `true` for any element of `as`.\n\nShort-circuits upon encountering the first `true`.\n\nThe optional parameters `start` and `stop` control the region of the array to be checked. Only the\nelements with indices from `start` (inclusive) to `stop` (exclusive) are checked. By default, the\nentire array is checked.\n\nExamples:\n* `#[2, 4, 6].any (· % 2 = 0) = true`\n* `#[2, 4, 6].any (· % 2 = 1) = false`\n* `#[2, 4, 5, 6].any (· % 2 = 0) = true`\n* `#[2, 4, 5, 6].any (· % 2 = 1) = true`\n</code>",
 "4326":
 "<code>Array.all.{u} {α : Type u} (as : Array α) (p : α → Bool) (start : Nat := 0) (stop : Nat := as.size) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `p` returns `true` for every element of `as`.\n\nShort-circuits upon encountering the first `false`.\n\nThe optional parameters `start` and `stop` control the region of the array to be checked. Only the\nelements with indices from `start` (inclusive) to `stop` (exclusive) are checked. By default, the\nentire array is checked.\n\nExamples:\n* `#[a, b, c].all p = (p a && (p b && p c))`\n* `#[2, 4, 6].all (· % 2 = 0) = true`\n* `#[2, 4, 5, 6].all (· % 2 = 0) = false`\n</code>",
 "4325":
 "<code><span class=\"literal string\">\"Zero!\"</span> : String</code>",
 "4324":
 "<code>Array.findSome?.{u, v} {α : Type u} {β : Type v} (f : α → Option β) (as : Array α) : Option β</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying the function `f` to each element of the\narray, in order. Returns `none` if `f` returns `none` for all elements.\n\nExample:\n```lean example\n#eval #[7, 6, 5, 8, 1, 2, 6].findSome? fun i =&gt;\n  if i &lt; 5 then\n    some (i * 10)\n  else\n    none\n```\n```output\nsome 10\n```\n</code>",
 "4323": "<code>Type → Type w</code>",
 "4322":
 "<code>Array.findFinIdx?.{u} {α : Type u} (p : α → Bool) (as : Array α) : Option (Fin as.size)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element for which `p` returns `true`, or `none` if there is no such\nelement. The index is returned as a `Fin`, which guarantees that it is in bounds.\n\nExamples:\n* `#[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· &lt; 5) = some (4 : Fin 7)`\n* `#[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· &lt; 1) = none`\n</code>",
 "4321":
 "<code>Array.findIdx.{u} {α : Type u} (p : α → Bool) (as : Array α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element for which `p` returns `true`, or the size of the array if\nthere is no such element.\n\nExamples:\n* `#[7, 6, 5, 8, 1, 2, 6].findIdx (· &lt; 5) = 4`\n* `#[7, 6, 5, 8, 1, 2, 6].findIdx (· &lt; 1) = 7`\n</code>",
 "4320":
 "<code>Array.findRev? {α : Type} (p : α → Bool) (as : Array α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of the array for which the predicate `p` returns `true`, or `none` if no\nsuch element is found.\n\nExamples:\n* `#[7, 6, 5, 8, 1, 2, 6].findRev? (· &lt; 5) = some 2`\n* `#[7, 6, 5, 8, 1, 2, 6].findRev? (· &lt; 1) = none`\n</code>",
 "432": "<code>List ?m.166</code>",
 "4319":
 "<code>Array.find?.{u} {α : Type u} (p : α → Bool) (as : Array α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of the array for which the predicate `p` returns `true`, or `none` if no\nsuch element is found.\n\nExamples:\n* `#[7, 6, 5, 8, 1, 2, 6].find? (· &lt; 5) = some 1`\n* `#[7, 6, 5, 8, 1, 2, 6].find? (· &lt; 1) = none`\n</code>",
 "4318":
 "<code>Array.contains.{u} {α : Type u} [BEq α] (as : Array α) (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `a` is an element of `as`, using `==` to compare elements.\n\n`Array.elem` is a synonym that takes the element before the array.\n\nExamples:\n* `#[1, 4, 2, 3, 3, 7].contains 3 = true`\n* `Array.contains #[1, 4, 2, 3, 3, 7] 5 = false`\n</code>",
 "4317":
 "<code>Array.elem.{u} {α : Type u} [BEq α] (a : α) (as : Array α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `a` is an element of `as`, using `==` to compare elements.\n\n`Array.contains` is a synonym that takes the array before the element.\n\nFor verification purposes, `Array.elem` is simplified to `Array.contains`.\n\nExample:\n* `Array.elem 3 #[1, 4, 2, 3, 3, 7] = true`\n* `Array.elem 5 #[1, 4, 2, 3, 3, 7] = false`\n</code>",
 "4316":
 "<code>Array.groupByKey.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (key : β → α) (xs : Array β) :\n  Std.HashMap α (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Groups the elements of an array `xs` according to the function `key`, returning a hash map in which\neach group is associated with its key. Groups preserve the relative order of elements in `xs`.\n\nExample:\n```lean example\n#eval #[0, 1, 2, 3, 4, 5, 6].groupByKey (· % 2)\n```\n```output\nStd.HashMap.ofList [(0, #[0, 2, 4, 6]), (1, #[1, 3, 5])]\n```\n</code>",
 "4315":
 "<code>Array.partition.{u} {α : Type u} (p : α → Bool) (as : Array α) : Array α × Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a pair of arrays that together contain all the elements of `as`. The first array contains\nthose elements for which `p` returns `true`, and the second contains those for which `p` returns\n`false`.\n\n`as.partition p` is equivalent to `(as.filter p, as.filter (not ∘ p))`, but it is\nmore efficient since it only has to do one pass over the array.\n\nExamples:\n * `#[1, 2, 5, 2, 7, 7].partition (· &gt; 2) = (#[5, 7, 7], #[1, 2, 2])`\n * `#[1, 2, 5, 2, 7, 7].partition (fun _ =&gt; false) = (#[], #[1, 2, 5, 2, 7, 7])`\n * `#[1, 2, 5, 2, 7, 7].partition (fun _ =&gt; true) = (#[1, 2, 5, 2, 7, 7], #[])`\n</code>",
 "4314": "<code>Lean.Syntax → m Bool</code>",
 "4313": "<code>Lean.Syntax → Bool</code>",
 "4312":
 "<code>Array.filterMap.{u, u_1} {α : Type u} {β : Type u_1} (f : α → Option β) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns an `Option` to each element of an array, collecting the non-`none`\nvalues.\n\nExample:\n```lean example\n#eval #[1, 2, 5, 2, 7, 7].filterMap fun x =&gt;\n  if x &gt; 2 then some (2 * x) else none\n```\n```output\n#[10, 14, 14]\n```\n</code>",
 "4311":
 "<code>Array.filterRevM.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] (p : α → m Bool) (as : Array α)\n  (start : Nat := as.size) (stop : Nat := 0) : m (Array α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic predicate `p` on every element in the array in reverse order, from right to\nleft, and returns those elements for which `p` returns `true`. The elements of the returned list are\nin the same order as in the input list.\n\nOnly elements from `start` (exclusive) to `stop` (inclusive) are considered. Elements outside that\nrange are discarded. Because the array is examined in reverse order, elements are only examined when\n`start &gt; stop`. By default, the entire array is considered.\n\nExample:\n```lean example\n#eval #[1, 2, 5, 2, 7, 7].filterRevM fun x =&gt; do\n  IO.println s!\"Checking {x}\"\n  return x &lt; 3\n```\n```output\nChecking 7\nChecking 7\nChecking 2\nChecking 5\nChecking 2\nChecking 1\n```\n```output\n#[1, 2, 2]\n```\n</code>",
 "4310": "<code>?m.57667</code>",
 "431": "<code>autoParam (¬∃ zs, xs = x :: zs) _auto✝</code>",
 "4309": "<code>?m.57648</code>",
 "4308":
 "<code>Array.unzip.{u, u_1} {α : Type u} {β : Type u_1} (as : Array (α × β)) : Array α × Array β</code><span class=\"sep\"></span><code class=\"docstring\">Separates an array of pairs into two arrays that contain the respective first and second components.\n\nExamples:\n* `#[(\"Monday\", 1), (\"Tuesday\", 2)].unzip = (#[\"Monday\", \"Tuesday\"], #[1, 2])`\n* `#[(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzip = (#[x₁, x₂, x₃], #[y₁, y₂, y₃])`\n* `(#[] : Array (Nat × String)).unzip = ((#[], #[]) : List Nat × List String)`\n</code>",
 "4307": "<code>Array (α × β)</code>",
 "4306": "<code>?m.55399</code>",
 "4305":
 "<code>Array.zipIdx.{u} {α : Type u} (xs : Array α) (start : Nat := 0) : Array (α × Nat)</code><span class=\"sep\"></span><code class=\"docstring\">Pairs each element of an array with its index, optionally starting from an index other than `0`.\n\nExamples:\n* `#[a, b, c].zipIdx = #[(a, 0), (b, 1), (c, 2)]`\n* `#[a, b, c].zipIdx 5 = #[(a, 5), (b, 6), (c, 7)]`\n</code>",
 "4304": "<code>?m.55270</code>",
 "4303":
 "<code>Array.zipWithAll.{u, u_1, u_2} {α : Type u} {β : Type u_1} {γ : Type u_2} (f : Option α → Option β → γ) (as : Array α)\n  (bs : Array β) : Array γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of both arrays, stopping when there are no more\nelements in either array. If one array is shorter than the other, the function is passed `none` for\nthe missing elements.\n\nExamples:\n* `#[1, 6].zipWithAll min #[5, 2] = #[some 1, some 2]`\n* `#[1, 2, 3].zipWithAll Prod.mk #[5, 6] = #[(some 1, some 5), (some 2, some 6), (some 3, none)]`\n* `#[x₁, x₂].zipWithAll f #[y] = #[f (some x₁) (some y), f (some x₂) none]`\n</code>",
 "4302":
 "<code>Array.zipWith.{u, u_1, u_2} {α : Type u} {β : Type u_1} {γ : Type u_2} (f : α → β → γ) (as : Array α) (bs : Array β) :\n  Array γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of two arrays, stopping at the end of the shorter\narray.\n\nExamples:\n* `#[1, 2].zipWith (· + ·) #[5, 6] = #[6, 8]`\n* `#[1, 2, 3].zipWith (· + ·) #[5, 6, 10] = #[6, 8, 13]`\n* `#[].zipWith (· + ·) #[5, 6] = #[]`\n* `#[x₁, x₂, x₃].zipWith f #[y₁, y₂, y₃, y₄] = #[f x₁ y₁, f x₂ y₂, f x₃ y₃]`\n</code>",
 "4301": "<code>?m.42405</code>",
 "4300": "<code>?m.42404</code>",
 "430":
 "<code>PrefixRunOf.zero {α : Type} {xs : List α} {x : α} (noMore : ¬∃ zs, xs = x :: zs := by simp) : PrefixRunOf 0 x xs xs</code>",
 "43":
 "<code>List.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`.\n* `List α` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array α` will have better performance because it can do destructive\n  updates.\n</code>",
 "4299":
 "<code>Array.zip.{u, u_1} {α : Type u} {β : Type u_1} (as : Array α) (bs : Array β) : Array (α × β)</code><span class=\"sep\"></span><code class=\"docstring\">Combines two arrays into an array of pairs in which the first and second components are the\ncorresponding elements of each input array. The resulting array is the length of the shorter of the\ninput arrays.\n\nExamples:\n* `#[\"Mon\", \"Tue\", \"Wed\"].zip #[1, 2, 3] = #[(\"Mon\", 1), (\"Tue\", 2), (\"Wed\", 3)]`\n* `#[\"Mon\", \"Tue\", \"Wed\"].zip #[1, 2] = #[(\"Mon\", 1), (\"Tue\", 2)]`\n* `#[x₁, x₂, x₃].zip #[y₁, y₂, y₃, y₄] = #[(x₁, y₁), (x₂, y₂), (x₃, y₃)]`\n</code>",
 "4298": "<code>α → m (Array β)</code>",
 "4297":
 "<code>Array.flatMap.{u, u_1} {α : Type u} {β : Type u_1} (f : α → Array β) (as : Array α) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns an array to each element of an array. The resulting arrays are\nappended.\n\nExamples:\n* `#[2, 3, 2].flatMap Array.range = #[0, 1, 0, 1, 2, 0, 1]`\n* `#[['a', 'b'], ['c', 'd', 'e']].flatMap List.toArray = #['a', 'b', 'c', 'd', 'e']`\n</code>",
 "4296": "<code>α → Array β</code>",
 "4295": "<code>?m.37610</code>",
 "4294": "<code>(i : Nat) → α → i &lt; as.size → m β</code>",
 "4293":
 "<code>Array.mapIdx.{u, v} {α : Type u} {β : Type v} (f : Nat → α → β) (as : Array α) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the array along with the index at which that element is found,\nreturning the array of results.\n\n`Array.mapFinIdx` is a variant that additionally provides the function with a proof that the index\nis valid.\n</code>",
 "4292": "<code>(i : Nat) → α → i &lt; as.size → β</code>",
 "4291":
 "<code>Array.mapFinIdx.{u, v} {α : Type u} {β : Type v} (as : Array α) (f : (i : Nat) → α → i &lt; as.size → β) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the array along with the index at which that element is found,\nreturning the array of results. In addition to the index, the function is also provided with a proof\nthat the index is valid.\n\n`Array.mapIdx` is a variant that does not provide the function with evidence that the index is\nvalid.\n</code>",
 "4290": "<code>Array β</code>",
 "429":
 "<code>PrefixRunOf {α : Type} : Nat → α → List α → List α → Type</code>",
 "4289":
 "<code>Array.map.{u, v} {α : Type u} {β : Type v} (f : α → β) (as : Array α) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the array, returning the resulting array of values.\n\nExamples:\n* `#[a, b, c].map f = #[f a, f b, f c]`\n* `#[].map Nat.succ = #[]`\n* `#[\"one\", \"two\", \"three\"].map (·.length) = #[3, 3, 5]`\n* `#[\"one\", \"two\", \"three\"].map (·.reverse) = #[\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "4288":
 "<code>Array.firstM.{u, v, w} {β : Type v} {α : Type u} {m : Type v → Type w} [Alternative m] (f : α → m β) (as : Array α) :\n  m β</code><span class=\"sep\"></span><code class=\"docstring\">Maps `f` over the array and collects the results with `&lt;|&gt;`. The result for the end of the array is\n`failure`.\n\nExamples:\n * `#[[], [1, 2], [], [2]].firstM List.head? = some 1`\n * `#[[], [], []].firstM List.head? = none`\n * `#[].firstM List.head? = none`\n</code>",
 "4287": "<code>β → α → m β</code>",
 "4286":
 "<code>Array.foldr.{u, v} {α : Type u} {β : Type v} (f : α → β → β) (init : β) (as : Array α) (start : Nat := as.size)\n  (stop : Nat := 0) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over an array from the right, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the array in reverse order, using `f`.\n\nThe optional parameters `start` and `stop` control the region of the array to be folded. Folding\nproceeds from `start` (exclusive) to `stop` (inclusive), so no folding occurs unless `start &gt; stop`.\nBy default, the entire array is used.\n\nExamples:\n * `#[a, b, c].foldr f init  = f a (f b (f c init))`\n * `#[1, 2, 3].foldr (toString · ++ ·) \"\" = \"123\"`\n * `#[1, 2, 3].foldr (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"`\n</code>",
 "4285":
 "<code>Array.binInsert.{u} {α : Type u} (lt : α → α → Bool) (as : Array α) (k : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into a sorted array such that the resulting array is sorted. If the element is\nalready present in the array, it is not inserted.\n\nThe ordering predicate `lt` should be a total order on elements, and the array `as` should be sorted\nwith respect to `lt`.\n\n`Array.binInsertM` is a more general operator that provides greater control over the handling of\nduplicate elements in addition to running in a monad.\n\nExamples:\n* `#[0, 1, 3, 5].binInsert (· &lt; ·) 2 = #[0, 1, 2, 3, 5]`\n* `#[0, 1, 3, 5].binInsert (· &lt; ·) 1 = #[0, 1, 3, 5]`\n* `#[].binInsert (· &lt; ·) 1 = #[1]`\n</code>",
 "4284":
 "<code>Array.binInsertM.{u, v} {α : Type u} {m : Type u → Type v} [Monad m] (lt : α → α → Bool) (merge : α → m α)\n  (add : Unit → m α) (as : Array α) (k : α) : m (Array α)</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element `k` into a sorted array `as` such that the resulting array is sorted.\n\nThe ordering predicate `lt` should be a total order on elements, and the array `as` should be sorted\nwith respect to `lt`.\n\nIf an element that `lt` equates to `k` is already present in `as`, then `merge` is applied to the\nexisting element to determine the value of that position in the resulting array. If no element equal\nto `k` is present, then `add` is used to determine the value to be inserted.\n</code>",
 "4283":
 "<code>Array.qsortOrd.{u_1} {α : Type u_1} [ord : Ord α] (xs : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Sorts an array using the Quicksort algorithm, using `Ord.compare` to compare elements.\n</code>",
 "4282": "<code>optParam Nat (as.size - 1)</code>",
 "4281":
 "<code>Array.getEvenElems.{u} {α : Type u} (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a new array that contains the elements at even indices in `as`, starting with the element at\nindex `0`.\n\nExamples:\n* `#[0, 1, 2, 3, 4].getEvenElems = #[0, 2, 4]`\n* `#[1, 2, 3, 4].getEvenElems = #[1, 3]`\n* `#[\"red\", \"green\", \"blue\"].getEvenElems = #[\"red\", \"blue\"]`\n* `(#[] : Array String).getEvenElems = #[]`\n</code>",
 "4280":
 "<code>Array.flatten.{u} {α : Type u} (xss : Array (Array α)) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Appends the contents of array of arrays into a single array. The resulting array contains the same\nelements as the nested arrays in the same order.\n\nExamples:\n * `#[#[5], #[4], #[3, 2]].flatten = #[5, 4, 3, 2]`\n * `#[#[0, 1], #[], #[2], #[1, 0, 1]].flatten = #[0, 1, 2, 1, 0, 1]`\n * `(#[] : Array Nat).flatten = #[]`\n</code>",
 "428":
 "<code>RLE.run {α : Type} {xs ys : List α} (x : α) (n : Nat) : n ≠ 0 → PrefixRunOf n x xs ys → RLE ys → RLE xs</code>",
 "4279": "<code>Array (Array α)</code>",
 "4278":
 "<code>Array.shrink.{u} {α : Type u} (xs : Array α) (n : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first `n` elements of an array. The resulting array is produced by repeatedly calling\n`Array.pop`. If `n` is greater than the size of the array, it is returned unmodified.\n\nIf the reference to the array is unique, then this function uses in-place modification.\n\nExamples:\n* `#[0, 1, 2, 3, 4].shrink 2 = #[0, 1]`\n* `#[0, 1, 2, 3, 4].shrink 0 = #[]`\n* `#[0, 1, 2, 3, 4].shrink 10 = #[0, 1, 2, 3, 4]`\n</code>",
 "4277":
 "<code>Array.drop.{u} {α : Type u} (xs : Array α) (i : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first `i` elements of `xs`. If `xs` has fewer than `i` elements, the new array is empty.\n\nThe returned array is always a new array, even if it contains the same elements as the input array.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\"].drop 1 = #[\"green\", \"blue\"]`\n* `#[\"red\", \"green\", \"blue\"].drop 2 = #[\"blue\"]`\n* `#[\"red\", \"green\", \"blue\"].drop 5 = #[]`\n</code>",
 "4276":
 "<code>Array.takeWhile.{u} {α : Type u} (p : α → Bool) (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a new array that contains the longest prefix of elements that satisfy the predicate `p` from\nan array.\n\nExamples:\n * `#[0, 1, 2, 3, 2, 1].takeWhile (· &lt; 2) = #[0, 1]`\n * `#[0, 1, 2, 3, 2, 1].takeWhile (· &lt; 20) = #[0, 1, 2, 3, 2, 1]`\n * `#[0, 1, 2, 3, 2, 1].takeWhile (· &lt; 0) = #[]`\n</code>",
 "4275":
 "<code>Array.insertIdx!.{u} {α : Type u} (as : Array α) (i : Nat) (a : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into an array at the specified index. Panics if the index is greater than the\nsize of the array.\n\nIn other words, the new element is inserted into the array `as` after the first `i` elements of\n`as`.\n\nThis function takes worst case `O(n)` time because it has to swap the inserted element into place.\n`Array.insertIdx` and `Array.insertIdxIfInBounds` are safer alternatives.\n\nExamples:\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx! 1 \"wed\" = #[\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx! 2 \"wed\" = #[\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx! 3 \"wed\" = #[\"tues\", \"thur\", \"sat\", \"wed\"]`\n</code>",
 "4274":
 "<code>Array.insertIdxIfInBounds.{u} {α : Type u} (as : Array α) (i : Nat) (a : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into an array at the specified index. The array is returned unmodified if the\nindex is greater than the size of the array.\n\nIn other words, the new element is inserted into the array `as` after the first `i` elements of\n`as`.\n\nThis function takes worst case `O(n)` time because it has to swap the inserted element into place.\n\nExamples:\n * `#[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 1 \"wed\" = #[\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 2 \"wed\" = #[\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 3 \"wed\" = #[\"tues\", \"thur\", \"sat\", \"wed\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdxIfInBounds 4 \"wed\" = #[\"tues\", \"thur\", \"sat\"]`\n</code>",
 "4273":
 "<code>Array.insertIdx.{u} {α : Type u} (as : Array α) (i : Nat) (a : α) : autoParam (i ≤ as.size) _auto✝ → Array α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into an array at the specified index. If the index is greater than the size of\nthe array, then the array is returned unmodified.\n\nIn other words, the new element is inserted into the array `as` after the first `i` elements of\n`as`.\n\nThis function takes worst case `O(n)` time because it has to swap the inserted element into place.\n\nExamples:\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx 1 \"wed\" = #[\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx 2 \"wed\" = #[\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `#[\"tues\", \"thur\", \"sat\"].insertIdx 3 \"wed\" = #[\"tues\", \"thur\", \"sat\", \"wed\"]`\n</code>",
 "4272": "<code>_auto✝ : Lean.Syntax</code>",
 "4271":
 "<code>Array.modifyOp.{u} {α : Type u} (xs : Array α) (idx : Nat) (f : α → α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying `f` to it. If the\nindex is invalid, the array is returned unmodified.\n\nExamples:\n * `#[1, 2, 3].modifyOp 0 (· * 10) = #[10, 2, 3]`\n * `#[1, 2, 3].modifyOp 2 (· * 10) = #[1, 2, 30]`\n * `#[1, 2, 3].modifyOp 3 (· * 10) = #[1, 2, 3]`\n</code>",
 "4270":
 "<code>Array.modify.{u} {α : Type u} (xs : Array α) (i : Nat) (f : α → α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying `f` to it. If the\nindex is invalid, the array is returned unmodified.\n\nExamples:\n * `#[1, 2, 3].modify 0 (· * 10) = #[10, 2, 3]`\n * `#[1, 2, 3].modify 2 (· * 10) = #[1, 2, 30]`\n * `#[1, 2, 3].modify 3 (· * 10) = #[1, 2, 3]`\n</code>",
 "427": "<code>RLE.nil {α : Type} : RLE []</code>",
 "4269": "<code>i.toNat &lt; xs.size</code>",
 "4268":
 "<code>Array.setIfInBounds.{u_1} {α : Type u_1} (xs : Array α) (i : Nat) (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the provided index in an array. The array is returned unmodified if the\nindex is out of bounds.\n\nThe array is modified in-place if there are no other references to it.\n\nExamples:\n* `#[0, 1, 2].setIfInBounds 1 5 = #[0, 5, 2]`\n* `#[\"orange\", \"apple\"].setIfInBounds 1 \"grape\" = #[\"orange\", \"grape\"]`\n* `#[\"orange\", \"apple\"].setIfInBounds 5 \"grape\" = #[\"orange\", \"apple\"]`\n</code>",
 "4267":
 "<code>Array.set.{u_1} {α : Type u_1} (xs : Array α) (i : Nat) (v : α) (h : i &lt; xs.size := by get_elem_tactic) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at a given index in an array.\n\nNo bounds check is performed, but the function requires a proof that the index is in bounds. This\nproof can usually be omitted, and will be synthesized automatically.\n\nThe array is modified in-place if there are no other references to it.\n\nExamples:\n* `#[0, 1, 2].set 1 5 = #[0, 5, 2]`\n* `#[\"orange\", \"apple\"].set 1 \"grape\" = #[\"orange\", \"grape\"]`\n</code>",
 "4266":
 "<code>Array.replace.{u} {α : Type u} [BEq α] (xs : Array α) (a b : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first occurrence of `a` with `b` in an array. The modification is performed in-place\nwhen the reference to the array is unique. Returns the array unmodified when `a` is not present.\n\nExamples:\n* `#[1, 2, 3, 2, 1].replace 2 5 = #[1, 5, 3, 2, 1]`\n* `#[1, 2, 3, 2, 1].replace 0 5 = #[1, 2, 3, 2, 1]`\n* `#[].replace 2 5 = #[]`\n</code>",
 "4265":
 "<code>Array.swapAt!.{u} {α : Type u} (xs : Array α) (i : Nat) (v : α) : α × Array α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps a new element with the element at the given index. Panics if the index is out of bounds.\n\nReturns the value formerly found at `i`, paired with an array in which the value at `i` has been\nreplaced with `v`.\n\nExamples:\n* `#[\"spinach\", \"broccoli\", \"carrot\"].swapAt! 1 \"pepper\" = (#[\"spinach\", \"pepper\", \"carrot\"], \"broccoli\")`\n* `#[\"spinach\", \"broccoli\", \"carrot\"].swapAt! 2 \"pepper\" = (#[\"spinach\", \"broccoli\", \"pepper\"], \"carrot\")`\n</code>",
 "4264":
 "<code><span class=\"literal string\">\"pepper\"</span> : String</code>",
 "4263":
 "<code>Array.swapAt.{u} {α : Type u} (xs : Array α) (i : Nat) (v : α) (hi : i &lt; xs.size := by get_elem_tactic) : α × Array α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps a new element with the element at the given index.\n\nReturns the value formerly found at `i`, paired with an array in which the value at `i` has been\nreplaced with `v`.\n\nExamples:\n* `#[\"spinach\", \"broccoli\", \"carrot\"].swapAt 1 \"pepper\" = (\"broccoli\", #[\"spinach\", \"pepper\", \"carrot\"])`\n* `#[\"spinach\", \"broccoli\", \"carrot\"].swapAt 2 \"pepper\" = (\"carrot\", #[\"spinach\", \"broccoli\", \"pepper\"])`\n</code>",
 "4262":
 "<code><span class=\"literal string\">\"spinach\"</span> : String</code>",
 "4261":
 "<code>Array.swapIfInBounds.{u} {α : Type u} (xs : Array α) (i j : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps two elements of an array, returning the array unchanged if either index is out of bounds. The\nmodification is performed in-place when the reference to the array is unique.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 0 3 = #[\"brown\", \"green\", \"blue\", \"red\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 0 2 = #[\"blue\", \"green\", \"red\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 1 2 = #[\"red\", \"blue\", \"green\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 0 4 = #[\"red\", \"green\", \"blue\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swapIfInBounds 9 2 = #[\"red\", \"green\", \"blue\", \"brown\"]`\n</code>",
 "4260": "<code>autoParam (j &lt; xs.size) _auto✝</code>",
 "426": "<code>RLE {α : Type} : List α → Type</code>",
 "4259":
 "<code>Array.eraseReps.{u_1} {α : Type u_1} [BEq α] (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Erases repeated elements, keeping the first element of each run.\n\n`O(|as|)`.\n\nExample:\n* `#[1, 3, 2, 2, 2, 3, 3, 5].eraseReps = #[1, 3, 2, 3, 5]`\n</code>",
 "4258":
 "<code>Array.eraseIdxIfInBounds.{u} {α : Type u} (xs : Array α) (i : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the element at a given index from an array. Does nothing if the index is out of bounds.\n\nThis function takes worst-case `O(n)` time because it back-shifts all elements at positions greater\nthan `i`.\n\nExamples:\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 0 = #[\"pear\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 1 = #[\"apple\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 2 = #[\"apple\", \"pear\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 3 = #[\"apple\", \"pear\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdxIfInBounds 5 = #[\"apple\", \"pear\", \"orange\"]`\n</code>",
 "4257":
 "<code>Array.eraseIdx.{u} {α : Type u} (xs : Array α) (i : Nat) (h : i &lt; xs.size := by get_elem_tactic) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the element at a given index from an array without a run-time bounds check.\n\nThis function takes worst-case `O(n)` time because it back-shifts all elements at positions\ngreater than `i`.\n\nExamples:\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdx 0 = #[\"pear\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdx 1 = #[\"apple\", \"orange\"]`\n* `#[\"apple\", \"pear\", \"orange\"].eraseIdx 2 = #[\"apple\", \"pear\"]`\n</code>",
 "4256": "<code><span class=\"literal string\">\"pear\"</span> : String</code>",
 "4255": "<code>autoParam (i &lt; xs.size) _auto✝</code>",
 "4254":
 "<code>Array.eraseP.{u} {α : Type u} (as : Array α) (p : α → Bool) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first element that satisfies the predicate `p`. If no element satisfies `p`, the array\nis returned unmodified.\n\nThis function takes worst-case `O(n)` time because it back-shifts all later elements.\n\nExamples:\n* `#[\"red\", \"green\", \"\", \"blue\"].eraseP (·.isEmpty) = #[\"red\", \"green\", \"blue\"]`\n* `#[\"red\", \"green\", \"\", \"blue\", \"\"].eraseP (·.isEmpty) = #[\"red\", \"green\", \"blue\", \"\"]`\n* `#[\"red\", \"green\", \"blue\"].eraseP (·.length % 2 == 0) = #[\"red\", \"green\"]`\n* `#[\"red\", \"green\", \"blue\"].eraseP (fun _ =&gt; true) = #[\"green\", \"blue\"]`\n* `(#[] : Array String).eraseP (fun _ =&gt; true) = #[]`\n</code>",
 "4253":
 "<code>Array.erase.{u} {α : Type u} [BEq α] (as : Array α) (a : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first occurrence of a specified element from an array, or does nothing if it is not\npresent.\n\nThis function takes worst-case `O(n)` time because it back-shifts all later elements.\n\nExamples:\n* `#[1, 2, 3].erase 2 = #[1, 3]`\n* `#[1, 2, 3].erase 5 = #[1, 2, 3]`\n* `#[1, 2, 3, 2, 1].erase 2 = #[1, 3, 2, 1]`\n* `(#[] : List Nat).erase 2 = #[]`\n</code>",
 "4252":
 "<code>Array.popWhile.{u} {α : Type u} (p : α → Bool) (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes all the elements that satisfy a predicate from the end of an array.\n\nThe longest contiguous sequence of elements that all satisfy the predicate is removed.\n\nExamples:\n* `#[0, 1, 2, 3, 4].popWhile (· &gt; 2) = #[0, 1, 2]`\n* `#[3, 2, 3, 4].popWhile (· &gt; 2) = #[3, 2]`\n* `(#[] : Array Nat).popWhile (· &gt; 2) = #[]`\n</code>",
 "4251":
 "<code>Array.pop.{u} {α : Type u} (xs : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the last element of an array. If the array is empty, then it is returned unmodified. The\nmodification is performed in-place when the reference to the array is unique.\n\nExamples:\n* `#[1, 2, 3].pop = #[1, 2]`\n* `#[\"orange\", \"yellow\"].pop = #[\"orange\"]`\n* `(#[] : Array String).pop = #[]`\n</code>",
 "4250": "<code>Subarray α</code>",
 "425": "<code>Sort ?u.16</code>",
 "4249":
 "<code>Subarray.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A region of some underlying array.\n\nA subarray contains an array together with the start and end indices of a region of interest.\nSubarrays can be used to avoid copying or allocating space, while being more convenient than\ntracking the bounds by hand. The region of interest consists of every index that is both greater\nthan or equal to `start` and strictly less than `stop`.\n</code>",
 "4248":
 "<code>Array.toListAppend.{u} {α : Type u} (as : Array α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Prepends an array to a list. The elements of the array are at the beginning of the resulting list.\n\nEquivalent to `as.toList ++ l`.\n\nExamples:\n* `#[1, 2].toListAppend [3, 4] = [1, 2, 3, 4]`\n* `#[1, 2].toListAppend [] = [1, 2]`\n* `#[].toListAppend [3, 4, 5] = [3, 4, 5]`\n</code>",
 "4247":
 "<code>Array.toListRev.{u_1} {α : Type u_1} (xs : Array α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an array to a list that contains the same elements in the opposite order.\n\nThis is equivalent to, but more efficient than, `Array.toList ∘ List.reverse`.\n\nExamples:\n* `#[1, 2, 3].toListRev = [3, 2, 1]`\n* `#[\"blue\", \"yellow\"].toListRev = [\"yellow\", \"blue\"]`\n</code>",
 "4246": "<code>Fin #[\"carrot\", \"potato\", \"broccoli\"].size</code>",
 "4245":
 "<code>Array.finIdxOf?.{u} {α : Type u} [BEq α] (xs : Array α) (v : α) : Option (Fin xs.size)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or the size of the array if no element is equal\nto `a`. The index is returned as a `Fin`, which guarantees that it is in bounds.\n\nExamples:\n * `#[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"carrot\" = some 0`\n * `#[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"broccoli\" = some 2`\n * `#[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"tomato\" = none`\n * `#[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"anything else\" = none`\n</code>",
 "4244":
 "<code>Array.idxOf?.{u} {α : Type u} [BEq α] (xs : Array α) (v : α) : Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or `none` if no element is equal to `a`.\n\nExamples:\n* `#[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"carrot\" = some 0`\n* `#[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"broccoli\" = some 2`\n* `#[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"tomato\" = none`\n* `#[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"anything else\" = none`\n</code>",
 "4243":
 "<code>Array.idxOf.{u} {α : Type u} [BEq α] (a : α) : Array α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or the size of the array if no element is equal\nto `a`.\n\nExamples:\n * `#[\"carrot\", \"potato\", \"broccoli\"].idxOf \"carrot\" = 0`\n * `#[\"carrot\", \"potato\", \"broccoli\"].idxOf \"broccoli\" = 2`\n * `#[\"carrot\", \"potato\", \"broccoli\"].idxOf \"tomato\" = 3`\n * `#[\"carrot\", \"potato\", \"broccoli\"].idxOf \"anything else\" = 3`\n</code>",
 "4242":
 "<code>Array.countP.{u} {α : Type u} (p : α → Bool) (as : Array α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Counts the number of elements in the array `as` that satisfy the Boolean predicate `p`.\n\nExamples:\n* `#[1, 2, 3, 4, 5].countP (· % 2 == 0) = 2`\n* `#[1, 2, 3, 4, 5].countP (· &lt; 5) = 4`\n* `#[1, 2, 3, 4, 5].countP (· &gt; 5) = 0`\n</code>",
 "4241":
 "<code>Array.count.{u} {α : Type u} [BEq α] (a : α) (as : Array α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Counts the number of times an element occurs in an array.\n\nExamples:\n* `#[1, 1, 2, 3, 5].count 1 = 2`\n* `#[1, 1, 2, 3, 5].count 5 = 1`\n* `#[1, 1, 2, 3, 5].count 4 = 0`\n</code>",
 "4240":
 "<code>Array.getMax?.{u} {α : Type u} (as : Array α) (lt : α → α → Bool) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the largest element of the array, as determined by the comparison `lt`, or `none` if\nthe array is empty.\n\nExamples:\n* `(#[] : Array Nat).getMax? (· &lt; ·) = none`\n* `#[\"red\", \"green\", \"blue\"].getMax? (·.length &lt; ·.length) = some \"green\"`\n* `#[\"red\", \"green\", \"blue\"].getMax? (· &lt; ·) = some \"red\"`\n</code>",
 "424": "<code>α → sorry → Prop</code>",
 "4239":
 "<code>Array.back.{u} {α : Type u} (xs : Array α) (h : 0 &lt; xs.size := by get_elem_tactic) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of an array, given a proof that the array is not empty.\n\nSee `Array.back!` for the version that panics if the array is empty, or `Array.back?` for the\nversion that returns an option.\n</code>",
 "4238":
 "<code>Array.back?.{u} {α : Type u} (xs : Array α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of an array, or `none` if the array is empty.\n\nSee `Array.back!` for the version that panics if the array is empty, or `Array.back` for the version\nthat requires a proof the array is non-empty.\n</code>",
 "4237":
 "<code>Array.back!.{u} {α : Type u} [Inhabited α] (xs : Array α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of an array, or panics if the array is empty.\n\nSafer alternatives include `Array.back`, which requires a proof the array is non-empty, and\n`Array.back?`, which returns an `Option`.\n</code>",
 "4236": "<code>autoParam (0 &lt; xs.size) _auto✝</code>",
 "4235": "<code>USize.toNat (n : USize) : Nat</code>",
 "4234": "<code>i.toNat &lt; a.size</code>",
 "4233":
 "<code>Array.getD.{u_1} {α : Type u_1} (a : Array α) (i : Nat) (v₀ : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the element at the provided index, counting from `0`. Returns the fallback value `v₀` if the\nindex is out of bounds.\n\nTo return an `Option` depending on whether the index is in bounds, use `a[i]?`. To panic if the\nindex is out of bounds, use `a[i]!`.\n\nExamples:\n * `#[\"spring\", \"summer\", \"fall\", \"winter\"].getD 2 \"never\" = \"fall\"`\n * `#[\"spring\", \"summer\", \"fall\", \"winter\"].getD 0 \"never\" = \"spring\"`\n * `#[\"spring\", \"summer\", \"fall\", \"winter\"].getD 4 \"never\" = \"never\"`\n</code>",
 "4232":
 "<code>Array.extract.{u_1} {α : Type u_1} (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the slice of `as` from indices `start` to `stop` (exclusive). The resulting array has size\n`(min stop as.size) - start`.\n\nIf `start` is greater or equal to `stop`, the result is empty. If `stop` is greater than the size of\n`as`, the size is used instead.\n\nExamples:\n * `#[0, 1, 2, 3, 4].extract 1 3 = #[1, 2]`\n * `#[0, 1, 2, 3, 4].extract 1 30 = #[1, 2, 3, 4]`\n * `#[0, 1, 2, 3, 4].extract 0 0 = #[]`\n * `#[0, 1, 2, 3, 4].extract 2 1 = #[]`\n * `#[0, 1, 2, 3, 4].extract 2 2 = #[]`\n * `#[0, 1, 2, 3, 4].extract 2 3 = #[2]`\n * `#[0, 1, 2, 3, 4].extract 2 4 = #[2, 3]`\n</code>",
 "4231": "<code>optParam Nat as.size</code>",
 "4230":
 "<code>Array.isEmpty.{u} {α : Type u} (xs : Array α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether an array is empty.\n\nAn array is empty if its size is `0`.\n\nExamples:\n* `(#[] : Array String).isEmpty = true`\n* `#[1, 2].isEmpty = false`\n* `#[()].isEmpty = false`\n</code>",
 "423": "<code>α → α → Prop</code>",
 "4229":
 "<code>Array.usize.{u} {α : Type u} (a : Array α) : USize</code><span class=\"sep\"></span><code class=\"docstring\">Returns the size of the array as a platform-native unsigned integer.\n\nThis is a low-level version of `Array.size` that directly queries the runtime system's\nrepresentation of arrays. While this is not provable, `Array.usize` always returns the exact size of\nthe array since the implementation only supports arrays of size less than `USize.size`.\n</code>",
 "4228":
 "<code>Array.rightpad.{u} {α : Type u} (n : Nat) (a : α) (xs : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Pads `xs : Array α` on the right with repeated occurrences of `a : α` until it is of length `n`. If\n`l` already has at least `n` elements, it is returned unmodified.\n\nExamples:\n * `#[1, 2, 3].rightpad 5 0 = #[1, 2, 3, 0, 0]`\n * `#[\"red\", \"green\", \"blue\"].rightpad 4 \"blank\" = #[\"red\", \"green\", \"blue\", \"blank\"]`\n * `#[\"red\", \"green\", \"blue\"].rightpad 3 \"blank\" = #[\"red\", \"green\", \"blue\"]`\n * `#[\"red\", \"green\", \"blue\"].rightpad 1 \"blank\" = #[\"red\", \"green\", \"blue\"]`\n</code>",
 "4227":
 "<code>Array.leftpad.{u} {α : Type u} (n : Nat) (a : α) (xs : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Pads `xs : Array α` on the left with repeated occurrences of `a : α` until it is of size `n`. If `xs`\nalready has at least `n` elements, it is returned unmodified.\n\nExamples:\n * `#[1, 2, 3].leftpad 5 0 = #[0, 0, 1, 2, 3]`\n * `#[\"red\", \"green\", \"blue\"].leftpad 4 \"blank\" = #[\"blank\", \"red\", \"green\", \"blue\"]`\n * `#[\"red\", \"green\", \"blue\"].leftpad 3 \"blank\" = #[\"red\", \"green\", \"blue\"]`\n * `#[\"red\", \"green\", \"blue\"].leftpad 1 \"blank\" = #[\"red\", \"green\", \"blue\"]`\n</code>",
 "4226":
 "<code>Array.appendList.{u} {α : Type u} (as : Array α) (bs : List α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Appends an array and a list.\n\nTakes time proportional to the length of the list..\n\nExamples:\n* `#[1, 2, 3].appendList [4, 5] = #[1, 2, 3, 4, 5]`.\n* `#[].appendList [4, 5] = #[4, 5]`.\n* `#[1, 2, 3].appendList [] = #[1, 2, 3]`.\n</code>",
 "4225":
 "<code><span class=\"literal string\">\"anything\"</span> : String</code>",
 "4224":
 "<code>Array.mkArray.{u} {α : Type u} (n : Nat) (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Creates an array that contains `n` repetitions of `v`.\n\nThe corresponding `List` function is `List.replicate`.\n\nExamples:\n* `Array.mkArray 2 true = #[true, true]`\n* `Array.mkArray 3 () = #[(), (), ()]`\n* `Array.mkArray 0 \"anything\" = #[]`\n</code>",
 "4223":
 "<code>Array.ofFn.{u} {α : Type u} {n : Nat} (f : Fin n → α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Creates an array by applying `f` to each potential index in order, starting at `0`.\n\nExamples:\n* `Array.ofFn (n := 3) toString = #[\"0\", \"1\", \"2\"]`\n* `Array.ofFn (fun i =&gt; #[\"red\", \"green\", \"blue\"].get i.val i.isLt) = #[\"red\", \"green\", \"blue\"]`\n</code>",
 "4222":
 "<code>Array.finRange (n : Nat) : Array (Fin n)</code><span class=\"sep\"></span><code class=\"docstring\">Returns an array of all elements of `Fin n` in order, starting at `0`.\n\nExamples:\n* `Array.finRange 0 = (#[] : Array (Fin 0))`\n* `Array.finRange 2 = (#[0, 1] : Array (Fin 2))`\n</code>",
 "4221":
 "<code>Array.range' (start size : Nat) (step : Nat := 1) : Array Nat</code><span class=\"sep\"></span><code class=\"docstring\">Constructs an array of numbers of size `size`, starting at `start` and increasing by\n`step` at each element.\n\nIn other words, `Array.range' start size step` is `#[start, start+step, ..., start+(len-1)*step]`.\n\nExamples:\n * `Array.range' 0 3 (step := 1) = #[0, 1, 2]`\n * `Array.range' 0 3 (step := 2) = #[0, 2, 4]`\n * `Array.range' 0 4 (step := 2) = #[0, 2, 4, 6]`\n * `Array.range' 3 4 (step := 2) = #[3, 5, 7, 9]`\n</code>",
 "4220":
 "<code>Array.singleton.{u} {α : Type u} (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a single-element array that contains `v`.\n\nExamples:\n* `Array.singleton 5 = #[5]`\n* `Array.singleton \"one\" = #[\"one\"]`\n</code>",
 "422": "<code><span class=\"literal string\">\"z\"</span> : String</code>",
 "4219":
 "<code>Subarray.array.{u} {α : Type u} (self : Subarray α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">The underlying array. </code>",
 "4218":
 "<code>Array.range (n : Nat) : Array Nat</code><span class=\"sep\"></span><code class=\"docstring\">Constructs an array that contains all the numbers from `0` to `n`, exclusive.\n\nExamples:\n* `Array.range 5 := #[0, 1, 2, 3, 4]`\n* `Array.range 0 := #[]`\n* `Array.range 1 := #[0]`\n</code>",
 "4217": "<code>ten : Array Nat</code>",
 "4216": "<code>oneTwoThree : Array Nat</code>",
 "4215":
 "<code>Array.toList.{u} {α : Type u} (self : Array α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an `Array α` into a `List α` that contains the same elements in the same order.\n\nAt runtime, this is implemented by `Array.toListImpl` and is `O(n)` in the length of the\narray.\n</code>",
 "4214":
 "<code>Array.toListImpl.{u} {α : Type u} (as : Array α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Convert a `Array α` into an `List α`. This is O(n) in the size of the array.  </code>",
 "4213":
 "<code>List α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an `Array α` into a `List α` that contains the same elements in the same order.\n\nAt runtime, this is implemented by `Array.toListImpl` and is `O(n)` in the length of the\narray.\n</code>",
 "4212":
 "<code>Array.emptyWithCapacity.{u} {α : Type u} (c : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a new empty array with initial capacity `c`.\n</code>",
 "4211":
 "<code>List.pmap.{u_1, u_2} {α : Type u_1} {β : Type u_2} {P : α → Prop} (f : (a : α) → P a → β) (l : List α)\n  (H : ∀ (a : α), a ∈ l → P a) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Maps a partially defined function (defined on those terms of `α` that satisfy a predicate `P`) over\na list `l : List α`, given a proof that every element of `l` in fact satisfies `P`.\n\n`O(|l|)`. `List.pmap`, named for “partial map,” is the equivalent of `List.map` for such partial\nfunctions.\n</code>",
 "4210": "<code>∀ (a : α), a ∈ l → P a</code>",
 "421": "<code><span class=\"literal string\">\"y\"</span> : String</code>",
 "4209": "<code>(a : α) → P a → β</code>",
 "4208":
 "<code>List.attachWith.{u_1} {α : Type u_1} (l : List α) (P : α → Prop) (H : ∀ (x : α), x ∈ l → P x) : List { x // P x }</code><span class=\"sep\"></span><code class=\"docstring\">“Attaches” individual proofs to a list of values that satisfy a predicate `P`, returning a list of\nelements in the corresponding subtype `{ x // P x }`.\n\n`O(1)`.\n</code>",
 "4207": "<code>List { x // p x }</code>",
 "4206": "<code>∀ (x : α), x ∈ l → P x</code>",
 "4205": "<code>List ?m.133020</code>",
 "4204": "<code>?m.133020</code>",
 "4203": "<code>List ?m.131764</code>",
 "4202": "<code>?m.131764</code>",
 "4201":
 "<code>List.lex.{u} {α : Type u} [BEq α] (l₁ l₂ : List α) (lt : α → α → Bool := by exact (· &lt; ·)) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Compares lists lexicographically with respect to a comparison on their elements.\n\nThe lexicographic order with respect to `lt` is:\n* `[].lex (b :: bs)` is `true`\n* `as.lex [] = false` is `false`\n* `(a :: as).lex (b :: bs)` is true if `lt a b` or `a == b` and `lex lt as bs` is true.\n</code>",
 "4200":
 "<code>List.cons_le_cons_iff.{u_1} {α : Type u_1} [DecidableEq α] [LT α] [DecidableLT α] [i₀ : Std.Irrefl fun x1 x2 =&gt; x1 &lt; x2]\n  [i₁ : Std.Asymm fun x1 x2 =&gt; x1 &lt; x2] [i₂ : Std.Antisymm fun x1 x2 =&gt; ¬x1 &lt; x2] {a b : α} {l₁ l₂ : List α} :\n  a :: l₁ ≤ b :: l₂ ↔ a &lt; b ∨ a = b ∧ l₁ ≤ l₂</code>",
 "420": "<code><span class=\"literal string\">\"x\"</span> : String</code>",
 "42": "<code>thirdOfFive.{u_1} {α : Type u_1} : List α → Option α</code>",
 "4199":
 "<code>List.isSuffixOf?.{u} {α : Type u} [BEq α] (l₁ l₂ : List α) : Option (List α)</code><span class=\"sep\"></span><code class=\"docstring\">If the first list is a suffix of the second, returns the result of dropping the suffix from the\nsecond.\n\nIn other words, `isSuffixOf? l₁ l₂` returns `some t` when `l₂ == t ++ l₁`.\n\nExamples:\n * `[2, 3].isSuffixOf? [1, 2, 3] = some [1]`\n * `[2, 3].isSuffixOf? [1, 2, 3, 4] = none`\n * `[2, 3].isSuffixOf? [1, 2] = none`\n * `[2, 3].isSuffixOf? [1, 1, 2, 3] = some [1, 1]`\n</code>",
 "4198": "<code>?m.121063</code>",
 "4197":
 "<code>List.isSublist.{u} {α : Type u} [BEq α] : List α → List α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">True if the first list is a potentially non-contiguous sub-sequence of the second list, comparing\nelements with the `==` operator.\n\nThe relation `List.Sublist` is a logical characterization of this property.\n\nExamples:\n* `[1, 3].isSublist [0, 1, 2, 3, 4] = true`\n* `[1, 3].isSublist [0, 1, 2, 4] = false`\n</code>",
 "4196":
 "<code>List.isPrefixOf?.{u} {α : Type u} [BEq α] (l₁ l₂ : List α) : Option (List α)</code><span class=\"sep\"></span><code class=\"docstring\">If the first list is a prefix of the second, returns the result of dropping the prefix.\n\nIn other words, `isPrefixOf? l₁ l₂` returns `some t` when `l₂ == l₁ ++ t`.\n\nExamples:\n* `[1, 2].isPrefixOf? [1, 2, 3] = some [3]`\n* `[1, 2].isPrefixOf? [1, 2] = some []`\n* `[1, 2].isPrefixOf? [1] = none`\n* `[1, 2].isPrefixOf? [1, 1, 2, 3] = none`\n</code>",
 "4195": "<code>?m.117220</code>",
 "4194":
 "<code>List.isEqv.{u} {α : Type u} (as bs : List α) (eqv : α → α → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `as` and `bs` have the same length and they are pairwise related by `eqv`.\n\n`O(min |as| |bs|)`. Short-circuits at the first non-related pair of elements.\n\nExamples:\n* `[1, 2, 3].isEqv [2, 3, 4] (· &lt; ·) = true`\n* `[1, 2, 3].isEqv [2, 2, 4] (· &lt; ·) = false`\n* `[1, 2, 3].isEqv [2, 3] (· &lt; ·) = false`\n</code>",
 "4193":
 "<code>List.or (bs : List Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `true` is an element of the list `bs`.\n\n`O(|bs|)`. Short-circuits at the first `true` value.\n\n* `[true, true, true].or = true`\n* `[true, false, true].or = true`\n* `[false, false, false].or = false`\n* `[false, false, true].or = true`\n* `[].or = false`\n</code>",
 "4192":
 "<code>List.and (bs : List Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if every element of `bs` is the value `true`.\n\n`O(|bs|)`. Short-circuits at the first `false` value.\n\n* `[true, true, true].and = true`\n* `[true, false, true].and = false`\n* `[true, false, false].and = false`\n* `[].and = true`\n</code>",
 "4191":
 "<code>List.any.{u} {α : Type u} (l : List α) (p : α → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `p` returns `true` for any element of `l`.\n\n`O(|l|)`. Short-circuits upon encountering the first `true`.\n\nExamples:\n* `[2, 4, 6].any (· % 2 = 0) = true`\n* `[2, 4, 6].any (· % 2 = 1) = false`\n* `[2, 4, 5, 6].any (· % 2 = 0) = true`\n* `[2, 4, 5, 6].any (· % 2 = 1) = true`\n</code>",
 "4190": "<code>?m.110960 → Bool</code>",
 "419":
 "<code>OddList.cons.{u} {α : Type u} : α → EvenList α → OddList α</code>",
 "4189":
 "<code>List.all.{u} {α : Type u} : List α → (α → Bool) → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `p` returns `true` for every element of `l`.\n\n`O(|l|)`. Short-circuits upon encountering the first `false`.\n\nExamples:\n* `[a, b, c].all p = (p a && (p b && p c))`\n* `[2, 4, 6].all (· % 2 = 0) = true`\n* `[2, 4, 5, 6].all (· % 2 = 0) = false`\n</code>",
 "4188": "<code>?m.110960</code>",
 "4187":
 "<code>List.contains.{u} {α : Type u} [BEq α] (as : List α) (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `a` is an element of `as`, using `==` to compare elements.\n\n`O(|as|)`. `List.elem` is a synonym that takes the element before the list.\n\nThe preferred simp normal form is `l.contains a`, and when `LawfulBEq α` is available,\n`l.contains a = true ↔ a ∈ l` and `l.contains a = false ↔ a ∉ l`.\n\nExamples:\n* `[1, 4, 2, 3, 3, 7].contains 3 = true`\n* `List.contains [1, 4, 2, 3, 3, 7] 5 = false`\n</code>",
 "4186": "<code>?m.107392</code>",
 "4185":
 "<code>Std.HashMap.ofList.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (l : List (α × β)) : Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Creates a hash map from a list of mappings. If the same key appears multiple times, the last\noccurrence takes precedence. </code>",
 "4184":
 "<code>List.groupByKey.{u, v} {α : Type u} {β : Type v} [BEq α] [Hashable α] (key : β → α) (xs : List β) :\n  Std.HashMap α (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Groups the elements of a list `xs` according to the function `key`, returning a hash map in which\neach group is associated with its key. Groups preserve the relative order of elements in `xs`.\n\nExample:\n```lean example\n#eval [0, 1, 2, 3, 4, 5, 6].groupByKey (· % 2)\n```\n```output\nStd.HashMap.ofList [(0, [0, 2, 4, 6]), (1, [1, 3, 5])]\n```\n</code>",
 "4183": "<code>β → α</code>",
 "4182":
 "<code>List.partitionMap.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β ⊕ γ) (l : List α) :\n  List β × List γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns a disjoint union to each element of a list, collecting the `Sum.inl`\nand `Sum.inr` results into separate lists.\n\nExamples:\n * `[0, 1, 2, 3].partitionMap (fun x =&gt; if x % 2 = 0 then .inl x else .inr x) = ([0, 2], [1, 3])`\n * `[0, 1, 2, 3].partitionMap (fun x =&gt; if x = 0 then .inl x else .inr x) = ([0], [1, 2, 3])`\n</code>",
 "4181": "<code>α → β ⊕ γ</code>",
 "4180":
 "<code><span class=\"literal string\">\"Zero is not positive or negative\"</span> : String</code>",
 "418":
 "<code>EvenList.cons.{u} {α : Type u} : α → OddList α → EvenList α</code>",
 "4179": "<code>posOrNeg (x : Int) : Except String Bool</code>",
 "4178":
 "<code>List.partition.{u} {α : Type u} (p : α → Bool) (as : List α) : List α × List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a pair of lists that together contain all the elements of `as`. The first list contains\nthose elements for which `p` returns `true`, and the second contains those for which `p` returns\n`false`.\n\n`O(|l|)`. `as.partition p` is equivalent to `(as.filter p, as.filter (not ∘ p))`, but it is slightly\nmore efficient since it only has to do one pass over the list.\n\nExamples:\n * `[1, 2, 5, 2, 7, 7].partition (· &gt; 2) = ([5, 7, 7], [1, 2, 2])`\n * `[1, 2, 5, 2, 7, 7].partition (fun _ =&gt; false) = ([], [1, 2, 5, 2, 7, 7])`\n * `[1, 2, 5, 2, 7, 7].partition (fun _ =&gt; true) = ([1, 2, 5, 2, 7, 7], [])`\n</code>",
 "4177":
 "<code>List.splitBy.{u} {α : Type u} (R : α → α → Bool) : List α → List (List α)</code><span class=\"sep\"></span><code class=\"docstring\">Splits a list into the longest segments in which each pair of adjacent elements are related by `R`.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 1, 2, 2, 2, 3, 2].splitBy (· == ·) = [[1, 1], [2, 2, 2], [3], [2]]`\n* `[1, 2, 5, 4, 5, 1, 4].splitBy (· &lt; ·) = [[1, 2, 5], [4, 5], [1, 4]]`\n* `[1, 2, 5, 4, 5, 1, 4].splitBy (fun _ _ =&gt; true) = [[1, 2, 5, 4, 5, 1, 4]]`\n* `[1, 2, 5, 4, 5, 1, 4].splitBy (fun _ _ =&gt; false) = [[1], [2], [5], [4], [5], [1], [4]]`\n</code>",
 "4176":
 "<code>List.span.{u} {α : Type u} (p : α → Bool) (as : List α) : List α × List α</code><span class=\"sep\"></span><code class=\"docstring\">Splits a list into the the longest initial segment for which `p` returns `true`, paired with the\nremainder of the list.\n\n`O(|l|)`.\n\nExamples:\n* `[6, 8, 9, 5, 2, 9].span (· &gt; 5) = ([6, 8, 9], [5, 2, 9])`\n* `[6, 8, 9, 5, 2, 9].span (· &gt; 10) = ([], [6, 8, 9, 5, 2, 9])`\n* `[6, 8, 9, 5, 2, 9].span (· &gt; 0) = ([6, 8, 9, 5, 2, 9], [])`\n</code>",
 "4175":
 "<code>List.splitAt.{u} {α : Type u} (n : Nat) (l : List α) : List α × List α</code><span class=\"sep\"></span><code class=\"docstring\">Splits a list at an index, resulting in the first `n` elements of `l` paired with the remaining\nelements.\n\nIf `n` is greater than the length of `l`, then the resulting pair consists of `l` and the empty\nlist. `List.splitAt` is equivalent to a combination of `List.take` and `List.drop`, but it is more\nefficient.\n\nExamples:\n* `[\"red\", \"green\", \"blue\"].splitAt 2 = ([\"red\", \"green\"], [\"blue\"])`\n* `[\"red\", \"green\", \"blue\"].splitAt 3 = ([\"red\", \"green\", \"blue], [])`\n* `[\"red\", \"green\", \"blue\"].splitAt 4 = ([\"red\", \"green\", \"blue], [])`\n</code>",
 "4174":
 "<code>List.dropLastTR.{u_1} {α : Type u_1} (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the last element of the list, if one exists.\n\nThis is a tail-recursive version of `List.dropLast`, used at runtime.\n\nExamples:\n* `[].dropLastTR = []`\n* `[\"tea\"].dropLastTR = []`\n* `[\"tea\", \"coffee\", \"juice\"].dropLastTR = [\"tea\", \"coffee\"]`\n</code>",
 "4173":
 "<code>List.dropLast.{u_1} {α : Type u_1} : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the last element of the list, if one exists.\n\nExamples:\n* `[].dropLast = []`\n* `[\"tea\"].dropLast = []`\n* `[\"tea\", \"coffee\", \"juice\"].dropLast = [\"tea\", \"coffee\"]`\n</code>",
 "4172":
 "<code>List.dropWhile.{u} {α : Type u} (p : α → Bool) : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the longest prefix of a list for which `p` returns `true`.\n\nElements are removed from the list until one is encountered for which `p` returns `false`. This\nelement and the remainder of the list are returned.\n\n`O(|l|)`.\n\nExamples:\n * `[1, 3, 2, 4, 2, 7, 4].dropWhile (· &lt; 4) = [4, 2, 7, 4]`\n * `[8, 3, 2, 4, 2, 7, 4].dropWhile (· &lt; 4) = [8, 3, 2, 4, 2, 7, 4]`\n * `[8, 3, 2, 4, 2, 7, 4].dropWhile (· &lt; 100) = []`\n</code>",
 "4171":
 "<code>List.takeWhileTR.{u_1} {α : Type u_1} (p : α → Bool) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the longest initial segment of `xs` for which `p` returns true.\n\n`O(|xs|)`. This is a tail-recursive version of `List.take`, used at runtime.\n\nExamples:\n* `[7, 6, 4, 8].takeWhileTR (· &gt; 5) = [7, 6]`\n* `[7, 6, 6, 5].takeWhileTR (· &gt; 5) = [7, 6, 6]`\n* `[7, 6, 6, 8].takeWhileTR (· &gt; 5) = [7, 6, 6, 8]`\n</code>",
 "4170":
 "<code>List.takeWhile.{u} {α : Type u} (p : α → Bool) (xs : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the longest initial segment of `xs` for which `p` returns true.\n\n`O(|xs|)`.\n\nExamples:\n* `[7, 6, 4, 8].takeWhile (· &gt; 5) = [7, 6]`\n* `[7, 6, 6, 5].takeWhile (· &gt; 5) = [7, 6, 6]`\n* `[7, 6, 6, 8].takeWhile (· &gt; 5) = [7, 6, 6, 8]`\n</code>",
 "417": "<code>EvenList.nil.{u} {α : Type u} : EvenList α</code>",
 "4169": "<code>?m.94492</code>",
 "4168": "<code>?m.94447</code>",
 "4167":
 "<code>List.takeTR.{u_1} {α : Type u_1} (n : Nat) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the first `n` elements of `xs`, or the whole list if `n` is greater than `xs.length`.\n\n`O(min n |xs|)`. This is a tail-recursive version of `List.take`, used at runtime.\n\nExamples:\n* `[a, b, c, d, e].takeTR 0 = []`\n* `[a, b, c, d, e].takeTR 3 = [a, b, c]`\n* `[a, b, c, d, e].takeTR 6 = [a, b, c, d, e]`\n</code>",
 "4166": "<code>?m.94377</code>",
 "4165": "<code>?m.93903</code>",
 "4164": "<code>?m.93858</code>",
 "4163": "<code>?m.93788</code>",
 "4162":
 "<code>List.filterMapM.{u, v, w} {m : Type u → Type v} [Monad m] {α : Type w} {β : Type u} (f : α → m (Option β))\n  (as : List α) : m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function that returns an `Option` to each element of a list, collecting the\nnon-`none` values.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterMapM fun x =&gt; do\n  IO.println s!\"Examining {x}\"\n  if x &gt; 2 then return some (2 * x)\n  else return none\n```\n```output\nExamining 1\nExamining 2\nExamining 5\nExamining 2\nExamining 7\nExamining 7\n```\n```output\n[10, 14, 14]\n```\n</code>",
 "4161":
 "<code>List.filterMapTR.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → Option β) (l : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns an `Option` to each element of a list, collecting the non-`none`\nvalues.\n\n`O(|l|)`. This is a tail-recursive version of `List.filterMap`, used at runtime.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterMapTR fun x =&gt;\n  if x &gt; 2 then some (2 * x) else none\n```\n```output\n[10, 14, 14]\n```\n</code>",
 "4160":
 "<code>List.filterMap.{u, v} {α : Type u} {β : Type v} (f : α → Option β) : List α → List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns an `Option` to each element of a list, collecting the non-`none`\nvalues.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterMap fun x =&gt;\n  if x &gt; 2 then some (2 * x) else none\n```\n```output\n[10, 14, 14]\n```\n</code>",
 "416": "<code>OddList.{u} (α : Type u) : Type u</code>",
 "4159":
 "<code>List.filterTR.{u} {α : Type u} (p : α → Bool) (as : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the list of elements in `l` for which `p` returns `true`.\n\n`O(|l|)`. This is a tail-recursive version of `List.filter`, used at runtime.\n\nExamples:\n* `[1, 2, 5, 2, 7, 7].filterTR (· &gt; 2)  = [5, 7, 7]`\n* `[1, 2, 5, 2, 7, 7].filterTR (fun _ =&gt; false) = []`\n* `[1, 2, 5, 2, 7, 7].filterTR (fun _ =&gt; true) = * [1, 2, 5, 2, 7, 7]`\n</code>",
 "4158": "<code>?m.90898</code>",
 "4157": "<code>?m.90883</code>",
 "4156":
 "<code>List.unzipTR.{u, v} {α : Type u} {β : Type v} (l : List (α × β)) : List α × List β</code><span class=\"sep\"></span><code class=\"docstring\">Separates a list of pairs into two lists that contain the respective first and second components.\n\n`O(|l|)`. This is a tail-recursive version of `List.unzip` that's used at runtime.\n\nExamples:\n* `[(\"Monday\", 1), (\"Tuesday\", 2)].unzipTR = ([\"Monday\", \"Tuesday\"], [1, 2])`\n* `[(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzipTR = ([x₁, x₂, x₃], [y₁, y₂, y₃])`\n* `([] : List (Nat × String)).unzipTR = (([], []) : List Nat × List String)`\n</code>",
 "4155": "<code>?m.88832</code>",
 "4154": "<code>?m.88817</code>",
 "4153":
 "<code>List.unzip.{u, v} {α : Type u} {β : Type v} (l : List (α × β)) : List α × List β</code><span class=\"sep\"></span><code class=\"docstring\">Separates a list of pairs into two lists that contain the respective first and second components.\n\n`O(|l|)`.\n\nExamples:\n* `[(\"Monday\", 1), (\"Tuesday\", 2)].unzip = ([\"Monday\", \"Tuesday\"], [1, 2])`\n* `[(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzip = ([x₁, x₂, x₃], [y₁, y₂, y₃])`\n* `([] : List (Nat × String)).unzip = (([], []) : List Nat × List String)`\n</code>",
 "4152":
 "<code><span class=\"literal string\">\"Tuesday\"</span> : String</code>",
 "4151":
 "<code><span class=\"literal string\">\"Monday\"</span> : String</code>",
 "4150": "<code>List (α × β)</code>",
 "415": "<code>EvenList.{u} (α : Type u) : Type u</code>",
 "4149":
 "<code>List.zipWithAll.{u, v, w} {α : Type u} {β : Type v} {γ : Type w} (f : Option α → Option β → γ) :\n  List α → List β → List γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of both lists, stopping when there are no more\nelements in either list. If one list is shorter than the other, the function is passed `none` for\nthe missing elements.\n\nExamples:\n* `[1, 6].zipWithAll min [5, 2] = [some 1, some 2]`\n* `[1, 2, 3].zipWithAll Prod.mk [5, 6] = [(some 1, some 5), (some 2, some 6), (some 3, none)]`\n* `[x₁, x₂].zipWithAll f [y] = [f (some x₁) (some y), f (some x₂) none]`\n</code>",
 "4148": "<code>Option α → Option β → γ</code>",
 "4147":
 "<code>List.zipWithTR.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (as : List α)\n  (bs : List β) : List γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of two lists, stopping at the end of the shorter\nlist.\n\n`O(min |xs| |ys|)`. This is a tail-recursive version of `List.zipWith` that's used at runtime.\n\nExamples:\n* `[1, 2].zipWithTR (· + ·) [5, 6] = [6, 8]`\n* `[1, 2, 3].zipWithTR (· + ·) [5, 6, 10] = [6, 8, 13]`\n* `[].zipWithTR (· + ·) [5, 6] = []`\n* `[x₁, x₂, x₃].zipWithTR f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]`\n</code>",
 "4146": "<code>?m.66110</code>",
 "4145":
 "<code>List.zipIdxTR.{u_1} {α : Type u_1} (l : List α) (n : Nat := 0) : List (α × Nat)</code><span class=\"sep\"></span><code class=\"docstring\">Pairs each element of a list with its index, optionally starting from an index other than `0`.\n\n`O(|l|)`. This is a tail-recursive version of `List.zipIdx` that's used at runtime.\n\nExamples:\n* `[a, b, c].zipIdxTR = [(a, 0), (b, 1), (c, 2)]`\n* `[a, b, c].zipIdxTR 5 = [(a, 5), (b, 6), (c, 7)]`\n</code>",
 "4144": "<code>?m.65988</code>",
 "4143": "<code>?m.65416</code>",
 "4142":
 "<code>List.zipIdx.{u} {α : Type u} (l : List α) (n : Nat := 0) : List (α × Nat)</code><span class=\"sep\"></span><code class=\"docstring\">Pairs each element of a list with its index, optionally starting from an index other than `0`.\n\n`O(|l|)`.\n\nExamples:\n* `[a, b, c].zipIdx = [(a, 0), (b, 1), (c, 2)]`\n* `[a, b, c].zipIdx 5 = [(a, 5), (b, 6), (c, 7)]`\n</code>",
 "4141": "<code>?m.65292</code>",
 "4140": "<code>?m.64773</code>",
 "414": "<code>S.sc16_2 (self : S) : UInt16</code>",
 "4139": "<code>?m.64772</code>",
 "4138":
 "<code>List.zip.{u, v} {α : Type u} {β : Type v} : List α → List β → List (α × β)</code><span class=\"sep\"></span><code class=\"docstring\">Combines two lists into a list of pairs in which the first and second components are the\ncorresponding elements of each list. The resulting list is the length of the shorter of the input\nlists.\n\n`O(min |xs| |ys|)`.\n\nExamples:\n* `[\"Mon\", \"Tue\", \"Wed\"].zip [1, 2, 3] = [(\"Mon\", 1), (\"Tue\", 2), (\"Wed\", 3)]`\n* `[\"Mon\", \"Tue\", \"Wed\"].zip [1, 2] = [(\"Mon\", 1), (\"Tue\", 2)]`\n* `[x₁, x₂, x₃].zip [y₁, y₂, y₃, y₄] = [(x₁, y₁), (x₂, y₂), (x₃, y₃)]`\n</code>",
 "4137": "<code><span class=\"literal string\">\"Wed\"</span> : String</code>",
 "4136": "<code><span class=\"literal string\">\"Tue\"</span> : String</code>",
 "4135": "<code><span class=\"literal string\">\"Mon\"</span> : String</code>",
 "4134": "<code>α → m (List β)</code>",
 "4133":
 "<code>List.flatMapTR.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → List β) (as : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns a list to each element of a list, and concatenates the resulting\nlists.\n\nThis is the tail-recursive version of `List.flatMap` that's used at runtime.\n\nExamples:\n* `[2, 3, 2].flatMapTR List.range = [0, 1, 0, 1, 2, 0, 1]`\n* `[\"red\", \"blue\"].flatMapTR String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']`\n</code>",
 "4132":
 "<code>List.flatMap.{u, v} {α : Type u} {β : Type v} (b : α → List β) (as : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function that returns a list to each element of a list, and concatenates the resulting\nlists.\n\nExamples:\n* `[2, 3, 2].flatMap List.range = [0, 1, 0, 1, 2, 0, 1]`\n* `[\"red\", \"blue\"].flatMap String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']`\n</code>",
 "4131": "<code>α → List β</code>",
 "4130": "<code>α → m α</code>",
 "413": "<code>S.sc32_1 (self : S) : UInt32</code>",
 "4129":
 "<code>List.mapMono.{u_1} {α : Type u_1} (as : List α) (f : α → α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of a list, returning the list of results. The function is\nmonomorphic: it is required to return a value of the same type. The internal implementation uses\npointer equality, and does not allocate a new list if the result of each function call is\npointer-equal to its argument.\n\nFor verification purposes, `List.mapMono = List.map`.\n</code>",
 "4128":
 "<code>List.mapFinIdxM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Monad m] (as : List α)\n  (f : (i : Nat) → α → i &lt; as.length → m β) : m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function to each element of the list along with the index at which that element is\nfound, returning the list of results. In addition to the index, the function is also provided with a\nproof that the index is valid.\n\n`List.mapIdxM` is a variant that does not provide the function with evidence that the index is\nvalid.\n</code>",
 "4127": "<code>Nat → α → m β</code>",
 "4126":
 "<code>List.mapFinIdx.{u_1, u_2} {α : Type u_1} {β : Type u_2} (as : List α) (f : (i : Nat) → α → i &lt; as.length → β) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list along with the index at which that element is found,\nreturning the list of results. In addition to the index, the function is also provided with a proof\nthat the index is valid.\n\n`List.mapIdx` is a variant that does not provide the function with evidence that the index is valid.\n</code>",
 "4125": "<code>Nat → α → β</code>",
 "4124":
 "<code>List.mapIdxM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Monad m] (f : Nat → α → m β)\n  (as : List α) : m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function to each element of the list along with the index at which that element is\nfound, returning the list of results.\n\n`List.mapFinIdxM` is a variant that additionally provides the function with a proof that the index\nis valid.\n</code>",
 "4123": "<code>(i : Nat) → α → i &lt; as.length → m β</code>",
 "4122":
 "<code>List.mapIdx.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : Nat → α → β) (as : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list along with the index at which that element is found,\nreturning the list of results.\n\n`List.mapFinIdx` is a variant that additionally provides the function with a proof that the index\nis valid.\n</code>",
 "4121": "<code>(i : Nat) → α → i &lt; as.length → β</code>",
 "4120":
 "<code>List.mapM'.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Monad m] (f : α → m β) :\n  List α → m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` on every element in the list, left-to-right, and returns the list of\nresults.\n\nThis is a non-tail-recursive variant of `List.mapM` that's easier to reason about. It cannot be used\nas the main definition and replaced by the tail-recursive version because they can only be proved\nequal when `m` is a `LawfulMonad`.\n</code>",
 "412": "<code>S.ptr_3 (self : S) : Char</code>",
 "4119":
 "<code>List.mapTR.{u, v} {α : Type u} {β : Type v} (f : α → β) (as : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list, returning the resulting list of values.\n\n`O(|l|)`. This is the tail-recursive variant of `List.map`, used in runtime code.\n\nExamples:\n* `[a, b, c].mapTR f = [f a, f b, f c]`\n* `[].mapTR Nat.succ = []`\n* `[\"one\", \"two\", \"three\"].mapTR (·.length) = [3, 3, 5]`\n* `[\"one\", \"two\", \"three\"].mapTR (·.reverse) = [\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "4118":
 "<code><span class=\"literal string\">\"eerht\"</span> : String</code>",
 "4117": "<code><span class=\"literal string\">\"owt\"</span> : String</code>",
 "4116": "<code><span class=\"literal string\">\"eno\"</span> : String</code>",
 "4115":
 "<code>List.foldrRecOn.{u_1, u_2, u_3} {β : Type u_1} {α : Type u_2} {motive : β → Sort u_3} (l : List α) (op : α → β → β)\n  (b : β) : motive b → ((b : β) → motive b → (a : α) → a ∈ l → motive (op a b)) → motive (List.foldr op b l)</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for proving propositions about the result of `List.foldr` by establishing an\ninvariant that is true for the initial data and preserved by the operation being folded.\n\nBecause the motive can return a type in any sort, this function may be used to construct data as\nwell as to prove propositions.\n\nExample:\n```lean example\nexample {xs : List Nat} : xs.foldr (· + ·) 1 &gt; 0 := by\n  apply List.foldrRecOn\n  . show 0 &lt; 1; trivial\n  . show ∀ (b : Nat), 0 &lt; b → ∀ (a : Nat), a ∈ xs → 0 &lt; a + b\n    intros; omega\n```\n</code>",
 "4114": "<code>α → β → m β</code>",
 "4113": "<code>α → s → m s</code>",
 "4112":
 "<code><span class=\"literal string\">\"(1 (2 (3 !)))\"</span> : String</code>",
 "4111":
 "<code>List.foldrTR.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β → β) (init : β) (l : List α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a list from the right, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in reverse order, using `f`.\n\n`O(|l|)`. This is the tail-recursive replacement for `List.foldr` in runtime code.\n\nExamples:\n * `[a, b, c].foldrTR f init  = f a (f b (f c init))`\n * `[1, 2, 3].foldrTR (toString · ++ ·) \"\" = \"123\"`\n * `[1, 2, 3].foldrTR (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"`\n</code>",
 "4110": "<code>α → β → β</code>",
 "411": "<code>S.usize_2 (self : S) : USize</code>",
 "4109": "<code>a✝¹ ∈ xs</code>",
 "4108": "<code>0 &lt; b✝</code>",
 "4107":
 "<code>List.foldlRecOn.{u_1, u_2, u_3} {β : Type u_1} {α : Type u_2} {motive : β → Sort u_3} (l : List α) (op : β → α → β)\n  (b : β) : motive b → ((b : β) → motive b → (a : α) → a ∈ l → motive (op b a)) → motive (List.foldl op b l)</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for proving propositions about the result of `List.foldl` by establishing an\ninvariant that is true for the initial data and preserved by the operation being folded.\n\nBecause the motive can return a type in any sort, this function may be used to construct data as\nwell as to prove propositions.\n\nExample:\n```lean example\nexample {xs : List Nat} : xs.foldl (· + ·) 1 &gt; 0 := by\n  apply List.foldlRecOn\n  . show 0 &lt; 1; trivial\n  . show ∀ (b : Nat), 0 &lt; b → ∀ (a : Nat), a ∈ xs → 0 &lt; b + a\n    intros; omega\n```\n</code>",
 "4106": "<code>β → α → β</code>",
 "4105": "<code>β → Sort u_3</code>",
 "4104": "<code>α → β → m α</code>",
 "4103": "<code>s</code>",
 "4102": "<code>s → α → m s</code>",
 "4101":
 "<code><span class=\"literal string\">\"((( 1) 2) 3)\"</span> : String</code>",
 "4100": "<code><span class=\"literal string\">\"123\"</span> : String</code>",
 "410": "<code>S.sc64_3 (self : S) : UInt64</code>",
 "41":
 "<code>Bool.true : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `true`, not to be confused with the proposition `True`. </code>",
 "4099": "<code>α → β → α</code>",
 "4098":
 "<code>List.firstM.{u, v, w} {m : Type u → Type v} [Alternative m] {α : Type w} {β : Type u} (f : α → m β) : List α → m β</code><span class=\"sep\"></span><code class=\"docstring\">Maps `f` over the list and collects the results with `&lt;|&gt;`. The result for the end of the list is\n`failure`.\n\nExamples:\n * `[[], [1, 2], [], [2]].firstM List.head? = some 1`\n * `[[], [], []].firstM List.head? = none`\n * `[].firstM List.head? = none`\n</code>",
 "4097":
 "<code>List.forA.{u, v, w} {m : Type u → Type v} [Applicative m] {α : Type w} (as : List α) (f : α → m PUnit) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Applies the applicative action `f` to every element in the list, in order.\n\nIf `m` is also a `Monad`, then using `List.forM` can be more efficient.\n\n`List.mapA` is a variant that collects results.\n</code>",
 "4096":
 "<code>List.mapA.{u, v, w} {m : Type u → Type v} [Applicative m] {α : Type w} {β : Type u} (f : α → m β) : List α → m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the applicative action `f` on every element in the list, left-to-right, and returns the list\nof results.\n\nIf `m` is also a `Monad`, then using `mapM` can be more efficient.\n\nSee `List.forA` for the variant that discards the results. See `List.mapM` for the variant that\nworks with `Monad`.\n\nThis function is not tail-recursive, so it may fail with a stack overflow on long lists.\n</code>",
 "4095": "<code>α → m PUnit</code>",
 "4094":
 "<code>List.merge.{u_1} {α : Type u_1} (xs ys : List α) (le : α → α → Bool := by exact fun a b =&gt; a ≤ b) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Merges two lists, using `le` to select the first element of the resulting list if both are\nnon-empty.\n\nIf both input lists are sorted according to `le`, then the resulting list is also sorted according\nto `le`. `O(min |l| |r|)`.\n\nThis implementation is not tail-recursive, but it is replaced at runtime by a proven-equivalent\ntail-recursive merge.\n</code>",
 "4093": "<code>autoParam (α → α → Bool) _auto✝</code>",
 "4092":
 "<code>List.intercalateTR.{u_1} {α : Type u_1} (sep : List α) (xs : List (List α)) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Alternates the lists in `xs` with the separator `sep`.\n\nThis is a tail-recursive version of `List.intercalate` used at runtime.\n\nExamples:\n* `List.intercalateTR sep [] = []`\n* `List.intercalateTR sep [a] = a`\n* `List.intercalateTR sep [a, b] = a ++ sep ++ b`\n* `List.intercalateTR sep [a, b, c] = a ++ sep ++ b ++ sep ++ c`\n</code>",
 "4091":
 "<code>List.intersperseTR.{u} {α : Type u} (sep : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Alternates the elements of `l` with `sep`.\n\n`O(|l|)`.\n\nThis is a tail-recursive version of `List.intersperse`, used at runtime.\n\nExamples:\n* `List.intersperseTR \"then\" [] = []`\n* `List.intersperseTR \"then\" [\"walk\"] = [\"walk\"]`\n* `List.intersperseTR \"then\" [\"walk\", \"run\"] = [\"walk\", \"then\", \"run\"]`\n* `List.intersperseTR \"then\" [\"walk\", \"run\", \"rest\"] = [\"walk\", \"then\", \"run\", \"then\", \"rest\"]`\n</code>",
 "4090": "<code><span class=\"literal string\">\"rest\"</span> : String</code>",
 "409": "<code>S.sc8_2 (self : S) : UInt8</code>",
 "4089": "<code><span class=\"literal string\">\"run\"</span> : String</code>",
 "4088": "<code><span class=\"literal string\">\"walk\"</span> : String</code>",
 "4087": "<code><span class=\"literal string\">\"then\"</span> : String</code>",
 "4086":
 "<code>List.intersperse.{u} {α : Type u} (sep : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Alternates the elements of `l` with `sep`.\n\n`O(|l|)`.\n\n`List.intercalate` is a similar function that alternates a separator list with elements of a list of\nlists.\n\nExamples:\n* `List.intersperse \"then\" [] = []`\n* `List.intersperse \"then\" [\"walk\"] = [\"walk\"]`\n* `List.intersperse \"then\" [\"walk\", \"run\"] = [\"walk\", \"then\", \"run\"]`\n* `List.intersperse \"then\" [\"walk\", \"run\", \"rest\"] = [\"walk\", \"then\", \"run\", \"then\", \"rest\"]`\n</code>",
 "4085":
 "<code>List.intercalate.{u} {α : Type u} (sep : List α) (xs : List (List α)) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Alternates the lists in `xs` with the separator `sep`, appending them. The resulting list is\nflattened.\n\n`O(|xs|)`.\n\n`List.intersperse` is a similar function that alternates a separator element with the elements of a\nlist.\n\nExamples:\n* `List.intercalate sep [] = []`\n* `List.intercalate sep [a] = a`\n* `List.intercalate sep [a, b] = a ++ sep ++ b`\n* `List.intercalate sep [a, b, c] = a ++ sep ++ b ++ sep ++ c`\n</code>",
 "4084":
 "<code>List.insertIdxTR.{u_1} {α : Type u_1} (l : List α) (n : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into a list at the specified index. If the index is greater than the length of\nthe list, then the list is returned unmodified.\n\nIn other words, the new element is inserted into the list `l` after the first `i` elements of `l`.\n\nThis is a tail-recursive version of `List.insertIdx`, used at runtime.\n\nExamples:\n * `[\"tues\", \"thur\", \"sat\"].insertIdxTR 1 \"wed\" = [\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdxTR 2 \"wed\" = [\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdxTR 3 \"wed\" = [\"tues\", \"thur\", \"sat\", \"wed\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdxTR 4 \"wed\" = [\"tues\", \"thur\", \"sat\"]`\n\n</code>",
 "4083": "<code><span class=\"literal string\">\"wed\"</span> : String</code>",
 "4082":
 "<code>List.insertIdx.{u} {α : Type u} (xs : List α) (i : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into a list at the specified index. If the index is greater than the length of\nthe list, then the list is returned unmodified.\n\nIn other words, the new element is inserted into the list `l` after the first `i` elements of `l`.\n\nExamples:\n * `[\"tues\", \"thur\", \"sat\"].insertIdx 1 \"wed\" = [\"tues\", \"wed\", \"thur\", \"sat\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdx 2 \"wed\" = [\"tues\", \"thur\", \"wed\", \"sat\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdx 3 \"wed\" = [\"tues\", \"thur\", \"sat\", \"wed\"]`\n * `[\"tues\", \"thur\", \"sat\"].insertIdx 4 \"wed\" = [\"tues\", \"thur\", \"sat\"]`\n</code>",
 "4081": "<code><span class=\"literal string\">\"sat\"</span> : String</code>",
 "4080": "<code><span class=\"literal string\">\"thur\"</span> : String</code>",
 "408":
 "<code>UInt16 : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of unsigned 16-bit integers. This type has special support in the\ncompiler to make it actually 16 bits rather than wrapping a `Nat`.\n</code>",
 "4079": "<code><span class=\"literal string\">\"tues\"</span> : String</code>",
 "4078":
 "<code>List.insert.{u} {α : Type u} [BEq α] (a : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts an element into a list without duplication.\n\nIf the element is present in the list, the list is returned unmodified. Otherwise, the new element\nis inserted at the head of the list.\n\nExamples:\n * `[1, 2, 3].insert 0 = [0, 1, 2, 3]`\n * `[1, 2, 3].insert 4 = [4, 1, 2, 3]`\n * `[1, 2, 3].insert 2 = [1, 2, 3]`\n</code>",
 "4077":
 "<code>List.rightpad.{u} {α : Type u} (n : Nat) (a : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Pads `l : List α` on the right with repeated occurrences of `a : α` until it is of length `n`. If\n`l` already has at least `n` elements, it is returned unmodified.\n\nExamples:\n * `[1, 2, 3].rightpad 5 0 = [1, 2, 3, 0, 0]`\n * `[\"red\", \"green\", \"blue\"].rightpad 4 \"blank\" = [\"red\", \"green\", \"blue\", \"blank\"]`\n * `[\"red\", \"green\", \"blue\"].rightpad 3 \"blank\" = [\"red\", \"green\", \"blue\"]`\n * `[\"red\", \"green\", \"blue\"].rightpad 1 \"blank\" = [\"red\", \"green\", \"blue\"]`\n</code>",
 "4076":
 "<code><span class=\"literal string\">\"blank\"</span> : String</code>",
 "4075":
 "<code>List.leftpad.{u} {α : Type u} (n : Nat) (a : α) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Pads `l : List α` on the left with repeated occurrences of `a : α` until it is of length `n`. If `l`\nalready has at least `n` elements, it is returned unmodified.\n\nExamples:\n * `[1, 2, 3].leftpad 5 0 = [0, 0, 1, 2, 3]`\n * `[\"red\", \"green\", \"blue\"].leftpad 4 \"blank\" = [\"blank\", \"red\", \"green\", \"blue\"]`\n * `[\"red\", \"green\", \"blue\"].leftpad 3 \"blank\" = [\"red\", \"green\", \"blue\"]`\n * `[\"red\", \"green\", \"blue\"].leftpad 1 \"blank\" = [\"red\", \"green\", \"blue\"]`\n</code>",
 "4074":
 "<code>List.rotateRight.{u} {α : Type u} (xs : List α) (i : Nat := 1) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Rotates the elements of `xs` to the right, moving `i % xs.length` elements from the end of the list\nto the start.\n\nAfter rotation, the element at `xs[n]` is at index `(i + n) % l.length`. `O(|xs|)`.\n\nExamples:\n* `[1, 2, 3, 4, 5].rotateRight 3 = [3, 4, 5, 1, 2]`\n* `[1, 2, 3, 4, 5].rotateRight 5 = [1, 2, 3, 4, 5]`\n* `[1, 2, 3, 4, 5].rotateRight 1 = [5, 1, 2, 3, 4]`\n</code>",
 "4073":
 "<code>List.rotateLeft.{u} {α : Type u} (xs : List α) (i : Nat := 1) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Rotates the elements of `xs` to the left, moving `i % xs.length` elements from the start of the list\nto the end.\n\n`O(|xs|)`.\n\nExamples:\n* `[1, 2, 3, 4, 5].rotateLeft 3 = [4, 5, 1, 2, 3]`\n* `[1, 2, 3, 4, 5].rotateLeft 5 = [1, 2, 3, 4, 5]`\n* `[1, 2, 3, 4, 5].rotateLeft 1 = [2, 3, 4, 5, 1]`\n</code>",
 "4072":
 "<code>List.flattenTR.{u_1} {α : Type u_1} (l : List (List α)) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Concatenates a list of lists into a single list, preserving the order of the elements.\n\n`O(|flatten L|)`. This is a tail-recursive version of `List.flatten`, used in runtime code.\n\nExamples:\n* `[[\"a\"], [\"b\", \"c\"]].flattenTR = [\"a\", \"b\", \"c\"]`\n* `[[\"a\"], [], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]].flattenTR = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]`\n</code>",
 "4071": "<code>List (List α)</code>",
 "4070": "<code><span class=\"literal string\">\"f\"</span> : String</code>",
 "407": "<code>S.sc16_1 (self : S) : UInt16</code>",
 "4069": "<code><span class=\"literal string\">\"d\"</span> : String</code>",
 "4068":
 "<code>List.replaceTR.{u_1} {α : Type u_1} [BEq α] (l : List α) (b c : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first element of the list `l` that is equal to `a` with `b`. If no element is equal to\n`a`, then the list is returned unchanged.\n\n`O(|l|)`. This is a tail-recursive version of `List.replace` that's used in runtime code.\n\nExamples:\n* `[1, 4, 2, 3, 3, 7].replaceTR 3 6 = [1, 4, 2, 6, 3, 7]`\n* `[1, 4, 2, 3, 3, 7].replaceTR 5 6 = [1, 4, 2, 3, 3, 7]`\n</code>",
 "4067":
 "<code>List.replace.{u} {α : Type u} [BEq α] (l : List α) (a b : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first element of the list `l` that is equal to `a` with `b`. If no element is equal to\n`a`, then the list is returned unchanged.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 4, 2, 3, 3, 7].replace 3 6 = [1, 4, 2, 6, 3, 7]`\n* `[1, 4, 2, 3, 3, 7].replace 5 6 = [1, 4, 2, 3, 3, 7]`\n</code>",
 "4066":
 "<code>List.removeAll.{u} {α : Type u} [BEq α] (xs ys : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes all elements of `xs` that are present in `ys`.\n\n`O(|xs| * |ys|)`.\n\nExamples:\n* `[1, 1, 5, 1, 2, 4, 5].removeAll [1, 2, 2] = [5, 4, 5]`\n* `[1, 2, 3, 2].removeAll [] = [1, 2, 3, 2]`\n* `[1, 2, 3, 2].removeAll [3] = [1, 2, 2]`\n</code>",
 "4065": "<code>optParam Nat l.length</code>",
 "4064":
 "<code>List.eraseReps.{u_1} {α : Type u_1} [BEq α] : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Erases repeated elements, keeping the first element of each run.\n\n`O(|l|)`.\n\nExample:\n* `[1, 3, 2, 2, 2, 3, 3, 5].eraseReps = [1, 3, 2, 3, 5]`\n</code>",
 "4063":
 "<code>List.erasePTR.{u_1} {α : Type u_1} (p : α → Bool) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first element of a list for which `p` returns `true`. If no element satisfies `p`, then\nthe list is returned unchanged.\n\nThis is a tail-recursive version of `eraseP`, used at runtime.\n\nExamples:\n  * `[2, 1, 2, 1, 3, 4].erasePTR (· &lt; 2) = [2, 2, 1, 3, 4]`\n  * `[2, 1, 2, 1, 3, 4].erasePTR (· &gt; 2) = [2, 1, 2, 1, 4]`\n  * `[2, 1, 2, 1, 3, 4].erasePTR (· &gt; 8) = [2, 1, 2, 1, 3, 4]`\n</code>",
 "4062":
 "<code>List.eraseP.{u} {α : Type u} (p : α → Bool) : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first element of a list for which `p` returns `true`. If no element satisfies `p`, then\nthe list is returned unchanged.\n\nExamples:\n  * `[2, 1, 2, 1, 3, 4].eraseP (· &lt; 2) = [2, 2, 1, 3, 4]`\n  * `[2, 1, 2, 1, 3, 4].eraseP (· &gt; 2) = [2, 1, 2, 1, 4]`\n  * `[2, 1, 2, 1, 3, 4].eraseP (· &gt; 8) = [2, 1, 2, 1, 3, 4]`\n</code>",
 "4061":
 "<code>List.eraseIdxTR.{u_1} {α : Type u_1} (l : List α) (n : Nat) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the element at the specified index. If the index is out of bounds, the list is returned\nunmodified.\n\n`O(i)`.\n\nThis is a tail-recursive version of `List.eraseIdx`, used at runtime.\n\nExamples:\n* `[0, 1, 2, 3, 4].eraseIdxTR 0 = [1, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].eraseIdxTR 1 = [0, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].eraseIdxTR 5 = [0, 1, 2, 3, 4]`\n</code>",
 "4060":
 "<code>List.eraseIdx.{u} {α : Type u} (l : List α) (i : Nat) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the element at the specified index. If the index is out of bounds, the list is returned\nunmodified.\n\n`O(i)`.\n\nExamples:\n* `[0, 1, 2, 3, 4].eraseIdx 0 = [1, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].eraseIdx 1 = [0, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].eraseIdx 5 = [0, 1, 2, 3, 4]`\n</code>",
 "406": "<code>S.sc8_1 (self : S) : Bool</code>",
 "4059":
 "<code>List.eraseDups.{u_1} {α : Type u_1} [BEq α] (as : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Erases duplicated elements in the list, keeping the first occurrence of duplicated elements.\n\n`O(|l|^2)`.\n\nExamples:\n* `[1, 3, 2, 2, 3, 5].eraseDups = [1, 3, 2, 5]`\n* `[\"red\", \"green\", \"green\", \"blue\"].eraseDups = [\"red\", \"green\", \"blue\"]`\n</code>",
 "4058":
 "<code>List.eraseTR.{u_1} {α : Type u_1} [BEq α] (l : List α) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first occurrence of `a` from `l`. If `a` does not occur in `l`, the list is returned\nunmodified.\n\n`O(|l|)`.\n\nThis is a tail-recursive version of `List.erase`, used in runtime code.\n\nExamples:\n* `[1, 5, 3, 2, 5].eraseTR 5 = [1, 3, 2, 5]`\n* `[1, 5, 3, 2, 5].eraseTR 6 = [1, 5, 3, 2, 5]`\n</code>",
 "4057":
 "<code>List.erase.{u_1} {α : Type u_1} [BEq α] : List α → α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first occurrence of `a` from `l`. If `a` does not occur in `l`, the list is returned\nunmodified.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 5, 3, 2, 5].erase 5 = [1, 3, 2, 5]`\n* `[1, 5, 3, 2, 5].erase 6 = [1, 5, 3, 2, 5]`\n</code>",
 "4056":
 "<code>List.modifyTailIdx.{u} {α : Type u} (l : List α) (i : Nat) (f : List α → List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the `n`th tail of `l` with the result of applying `f` to it. Returns the input without\nusing `f` if the index is larger than the length of the List.\n\nExamples:\n```lean example\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 1 List.reverse\n```\n```output\n[\"circle\", \"triangle\", \"square\"]\n```\n```lean example\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 1 (fun xs =&gt; xs ++ xs)\n```\n```output\n[\"circle\", \"square\", \"triangle\", \"square\", \"triangle\"]\n```\n```lean example\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 2 (fun xs =&gt; xs ++ xs)\n```\n```output\n[\"circle\", \"square\", \"triangle\", \"triangle\"]\n```\n```lean example\n[\"circle\", \"square\", \"triangle\"].modifyTailIdx 5 (fun xs =&gt; xs ++ xs)\n```\n```output\n[\"circle\", \"square\", \"triangle\"]\n```\n</code>",
 "4055":
 "<code><span class=\"literal string\">\"triangle\"</span> : String</code>",
 "4054":
 "<code><span class=\"literal string\">\"square\"</span> : String</code>",
 "4053": "<code>List α → List α</code>",
 "4052":
 "<code>List.modifyHead.{u} {α : Type u} (f : α → α) : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Replace the head of the list with the result of applying `f` to it. Returns the empty list if the\nlist is empty.\n\nExamples:\n * `[1, 2, 3].modifyHead (· * 10) = [10, 2, 3]`\n * `[].modifyHead (· * 10) = []`\n</code>",
 "4051":
 "<code>List.modifyTR.{u_1} {α : Type u_1} (l : List α) (i : Nat) (f : α → α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying `f` to it.\n\nThis is a tail-recursive version of `List.modify`.\n\nExamples:\n* `[1, 2, 3].modifyTR 0 (· * 10) = [10, 2, 3]`\n* `[1, 2, 3].modifyTR 2 (· * 10) = [1, 2, 30]`\n* `[1, 2, 3].modifyTR 3 (· * 10) = [1, 2, 3]`\n</code>",
 "4050":
 "<code>List.modify.{u} {α : Type u} (l : List α) (i : Nat) (f : α → α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying `f` to it. If the\nindex is invalid, the list is returned unmodified.\n\nExamples:\n * `[1, 2, 3].modify 0 (· * 10) = [10, 2, 3]`\n * `[1, 2, 3].modify 2 (· * 10) = [1, 2, 30]`\n * `[1, 2, 3].modify 3 (· * 10) = [1, 2, 3]`\n</code>",
 "405": "<code>S.sc64_2 (self : S) : Float</code>",
 "4049":
 "<code>List.set.{u_1} {α : Type u_1} (l : List α) (n : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the value at (zero-based) index `n` in `l` with `a`. If the index is out of bounds, then\nthe list is returned unmodified.\n\nExamples:\n* `[\"water\", \"coffee\", \"soda\", \"juice\"].set 1 \"tea\" = [\"water\", \"tea\", \"soda\", \"juice\"]`\n* `[\"water\", \"coffee\", \"soda\", \"juice\"].set 4 \"tea\" = [\"water\", \"coffee\", \"soda\", \"juice\"]`\n</code>",
 "4048":
 "<code><span class=\"literal string\">\"juice\"</span> : String</code>",
 "4047": "<code><span class=\"literal string\">\"soda\"</span> : String</code>",
 "4046":
 "<code><span class=\"literal string\">\"[cat, dog, ]\"</span> : String</code>",
 "4045":
 "<code><span class=\"literal string\">\"[cat, dog]\"</span> : String</code>",
 "4044": "<code><span class=\"literal string\">\"dog\"</span> : String</code>",
 "4043":
 "<code><span class=\"literal string\">\"[1, 2, 3]\"</span> : String</code>",
 "4042":
 "<code>List.toString.{u_1} {α : Type u_1} [ToString α] : List α → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a list into a string, using `ToString.toString` to convert its elements.\n\nThe resulting string resembles list literal syntax, with the elements separated by `\", \"` and\nenclosed in square brackets.\n\nThe resulting string may not be valid Lean syntax, because there's no such expectation for\n`ToString` instances.\n\nExamples:\n* `[1, 2, 3].toString = \"[1, 2, 3]\"`\n* `[\"cat\", \"dog\"].toString = \"[cat, dog]\"`\n* `[\"cat\", \"dog\", \"\"].toString = \"[cat, dog, ]\"`\n</code>",
 "4041": "<code>FloatArray : Type</code>",
 "4040": "<code>List Float</code>",
 "404": "<code>UInt64</code>",
 "4039": "<code>List UInt8</code>",
 "4038":
 "<code><span class=\"literal string\">\", friday\"</span> : String</code>",
 "4037":
 "<code><span class=\"literal string\">\"].toArray = #[\"</span> : String</code>",
 "4036":
 "<code><span class=\"literal string\">\"wednesday\"</span> : String</code>",
 "4035":
 "<code><span class=\"literal string\">\"monday\"</span> : String</code>",
 "4034":
 "<code>Array.mk.{u} {α : Type u} (toList : List α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `List α` into an `Array α`.\n\nThe function `List.toArray` is preferred.\n\nAt runtime, this constructor is overridden by `List.toArrayImpl` and is `O(n)` in the length of\nthe list.\n</code>",
 "4033":
 "<code>List.toArrayImpl.{u_1} {α : Type u_1} (xs : List α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `List α` into an `Array α` by repeatedly pushing elements from the list onto an empty\narray. `O(|xs|)`.\n\nUse `List.toArray` instead of calling this function directly. At runtime, this operation implements\nboth `List.toArray` and `Array.mk`.\n</code>",
 "4032": "<code><span class=\"literal string\">\"aaa\"</span> : String</code>",
 "4031":
 "<code>List.asString (s : List Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a string that contains the characters in a list, in order.\n\nExamples:\n* `['L', '∃', '∀', 'N'].asString = \"L∃∀N\"`\n* `[].asString = \"\"`\n* `['a', 'a', 'a'].asString = \"aaa\"`\n</code>",
 "4030": "<code>List Char</code>",
 "403": "<code>S.ptr_2 (self : S) : { x // x &gt; 0 }</code>",
 "4029":
 "<code>List.findSome?.{u, v} {α : Type u} {β : Type v} (f : α → Option β) : List α → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying `f` to each element of the list in order. Returns\n`none` if `f` returns `none` for all elements of the list.\n\n`O(|l|)`.\n\nExamples:\n * `[7, 6, 5, 8, 1, 2, 6].findSome? (fun x =&gt; if x &lt; 5 then some (10 * x) else none) = some 10`\n * `[7, 6, 5, 8, 1, 2, 6].findSome? (fun x =&gt; if x &lt; 1 then some (10 * x) else none) = none`\n</code>",
 "4028": "<code>α → m Bool</code>",
 "4027":
 "<code>List.findIdx.{u} {α : Type u} (p : α → Bool) (l : List α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element for which `p` returns `true`, or the length of the list if\nthere is no such element.\n\nExamples:\n* `[7, 6, 5, 8, 1, 2, 6].findIdx (· &lt; 5) = 4`\n* `[7, 6, 5, 8, 1, 2, 6].findIdx (· &lt; 1) = 7`\n</code>",
 "4026":
 "<code>List.findFinIdx?.{u} {α : Type u} (p : α → Bool) (l : List α) : Option (Fin l.length)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element for which `p` returns `true`, or `none` if there is no such\nelement. The index is returned as a `Fin`, which guarantees that it is in bounds.\n\nExamples:\n* `[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· &lt; 5) = some (4 : Fin 7)`\n* `[7, 6, 5, 8, 1, 2, 6].findFinIdx? (· &lt; 1) = none`\n</code>",
 "4025":
 "<code>List.find?.{u} {α : Type u} (p : α → Bool) : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of the list for which the predicate `p` returns `true`, or `none` if no\nsuch element is found.\n\n`O(|l|)`.\n\nExamples:\n* `[7, 6, 5, 8, 1, 2, 6].find? (· &lt; 5) = some 1`\n* `[7, 6, 5, 8, 1, 2, 6].find? (· &lt; 1) = none`\n</code>",
 "4024": "<code>Fin [\"carrot\", \"potato\", \"broccoli\"].length</code>",
 "4023":
 "<code>List.finIdxOf?.{u} {α : Type u} [BEq α] (a : α) (l : List α) : Option (Fin l.length)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or the length of the list if no element is\nequal to `a`. The index is returned as a `Fin`, which guarantees that it is in bounds.\n\nExamples:\n * `[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"carrot\" = some 0`\n * `[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"broccoli\" = some 2`\n * `[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"tomato\" = none`\n * `[\"carrot\", \"potato\", \"broccoli\"].finIdxOf? \"anything else\" = none`\n</code>",
 "4022":
 "<code>List.idxOf?.{u} {α : Type u} [BEq α] (a : α) : List α → Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or `none` if no element is equal to `a`.\n\nExamples:\n* `[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"carrot\" = some 0`\n* `[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"broccoli\" = some 2`\n* `[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"tomato\" = none`\n* `[\"carrot\", \"potato\", \"broccoli\"].idxOf? \"anything else\" = none`\n</code>",
 "4021":
 "<code><span class=\"literal string\">\"anything else\"</span> : String</code>",
 "4020":
 "<code><span class=\"literal string\">\"tomato\"</span> : String</code>",
 "402": "<code>S.sc64_1 (self : S) : UInt64</code>",
 "4019":
 "<code>List.idxOf.{u} {α : Type u} [BEq α] (a : α) : List α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the index of the first element equal to `a`, or the length of the list if no element is\nequal to `a`.\n\nExamples:\n * `[\"carrot\", \"potato\", \"broccoli\"].idxOf \"carrot\" = 0`\n * `[\"carrot\", \"potato\", \"broccoli\"].idxOf \"broccoli\" = 2`\n * `[\"carrot\", \"potato\", \"broccoli\"].idxOf \"tomato\" = 3`\n * `[\"carrot\", \"potato\", \"broccoli\"].idxOf \"anything else\" = 3`\n</code>",
 "4018":
 "<code><span class=\"literal string\">\"broccoli\"</span> : String</code>",
 "4017":
 "<code><span class=\"literal string\">\"potato\"</span> : String</code>",
 "4016":
 "<code><span class=\"literal string\">\"carrot\"</span> : String</code>",
 "4015":
 "<code>List.countP.{u} {α : Type u} (p : α → Bool) (l : List α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Counts the number of elements in the list `l` that satisfy the Boolean predicate `p`.\n\nExamples:\n* `[1, 2, 3, 4, 5].countP (· % 2 == 0) = 2`\n* `[1, 2, 3, 4, 5].countP (· &lt; 5) = 4`\n* `[1, 2, 3, 4, 5].countP (· &gt; 5) = 0`\n</code>",
 "4014":
 "<code>List.count.{u} {α : Type u} [BEq α] (a : α) : List α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Counts the number of times an element occurs in a list.\n\nExamples:\n* `[1, 1, 2, 3, 5].count 1 = 2`\n* `[1, 1, 2, 3, 5].count 5 = 1`\n* `[1, 1, 2, 3, 5].count 4 = 0`\n</code>",
 "4013":
 "<code>List.min?.{u} {α : Type u} [Min α] : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the smallest element of the list if it is not empty, or `none` if it is empty.\n\nExamples:\n* `[].min? = none`\n* `[4].min? = some 4`\n* `[1, 4, 2, 10, 6].min? = some 1`\n</code>",
 "4012":
 "<code>List.max?.{u} {α : Type u} [Max α] : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the largest element of the list if it is not empty, or `none` if it is empty.\n\nExamples:\n* `[].max? = none`\n* `[4].max? = some 4`\n* `[1, 4, 2, 10, 6].max? = some 10`\n</code>",
 "4011":
 "<code>List.lookup.{u, v} {α : Type u} {β : Type v} [BEq α] : α → List (α × β) → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Treats the list as an association list that maps keys to values, returning the first value whose key\nis equal to the specified key.\n\n`O(|l|)`.\n\nExamples:\n* `[(1, \"one\"), (3, \"three\"), (3, \"other\")].lookup 3 = some \"three\"`\n* `[(1, \"one\"), (3, \"three\"), (3, \"other\")].lookup 2 = none`\n</code>",
 "4010":
 "<code><span class=\"literal string\">\"other\"</span> : String</code>",
 "401": "<code>S.usize_1 (self : S) : USize</code>",
 "4009": "<code><span class=\"literal string\">\"oval\"</span> : String</code>",
 "4008":
 "<code>List.getLast?.{u} {α : Type u} : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element in the list, or `none` if the list is empty.\n\nAlternatives include `List.getLastD`, which takes a fallback value for empty lists, and\n`List.getLast!`, which panics on empty lists.\n\nExamples:\n * `[\"circle\", \"rectangle\"].getLast? = some \"rectangle\"`\n * `[\"circle\"].getLast? = some \"circle\"`\n * `([] : List String).getLast? = none`\n</code>",
 "4007":
 "<code>List.getLast!.{u_1} {α : Type u_1} [Inhabited α] : List α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element in the list. Panics and returns `default` if the list is empty.\n\nSafer alternatives include:\n* `getLast?`, which returns an `Option`,\n* `getLastD`, which takes a fallback value for empty lists, and\n* `getLast`, which requires a proof that the list is non-empty.\n\nExamples:\n* `[\"circle\", \"rectangle\"].getLast! = \"rectangle\"`\n* `[\"circle\"].getLast! = \"circle\"`\n</code>",
 "4006":
 "<code>List.getLastD.{u} {α : Type u} (as : List α) (fallback : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element in the list, or `fallback` if the list is empty.\n\nAlternatives include `List.getLast?`, which returns an `Option`, and `List.getLast!`, which panics\non empty lists.\n\nExamples:\n * `[\"circle\", \"rectangle\"].getLastD \"oval\" = \"rectangle\"`\n * `[\"circle\"].getLastD \"oval\" = \"circle\"`\n * `([] : List String).getLastD \"oval\" = \"oval\"`\n</code>",
 "4005":
 "<code><span class=\"literal string\">\"rectangle\"</span> : String</code>",
 "4004":
 "<code><span class=\"literal string\">\"circle\"</span> : String</code>",
 "4003":
 "<code><span class=\"literal string\">\"never\"</span> : String</code>",
 "4002":
 "<code>List.getD.{u_1} {α : Type u_1} (as : List α) (i : Nat) (fallback : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the element at the provided index, counting from `0`. Returns `fallback` if the index is out\nof bounds.\n\nTo return an `Option` depending on whether the index is in bounds, use `as[i]?`. To panic if the\nindex is out of bounds, use `as[i]!`.\n\nExamples:\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].getD 2 \"never\" = \"fall\"`\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].getD 0 \"never\" = \"spring\"`\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].getD 4 \"never\" = \"never\"`\n</code>",
 "4001":
 "<code><span class=\"literal string\">\"winter\"</span> : String</code>",
 "4000": "<code><span class=\"literal string\">\"fall\"</span> : String</code>",
 "400": "<code>S.ptr_1 (self : S) : Array Nat</code>",
 "40":
 "<code>Bool.false : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `false`, not to be confused with the proposition `False`. </code>",
 "4":
 "<code>IO.println.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it with a trailing newline to\nthe current standard output (as determined by `IO.getStdout`).\n</code>",
 "3999":
 "<code><span class=\"literal string\">\"summer\"</span> : String</code>",
 "3998":
 "<code><span class=\"literal string\">\"spring\"</span> : String</code>",
 "3997":
 "<code>List.get.{u} {α : Type u} (as : List α) : Fin as.length → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the element at the provided index, counting from `0`.\n\nIn other words, for `i : Fin as.length`, `as.get i` returns the `i`'th element of the list `as`.\nBecause the index is a `Fin` bounded by the list's length, the index will never be out of bounds.\n\nExamples:\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].get (2 : Fin 4) = \"fall\"`\n * `[\"spring\", \"summer\", \"fall\", \"winter\"].get (0 : Fin 4) = \"spring\"`\n</code>",
 "3996": "<code>Fin as.length</code>",
 "3995":
 "<code>List.tail?.{u} {α : Type u} : List α → Option (List α)</code><span class=\"sep\"></span><code class=\"docstring\">Drops the first element of a nonempty list, returning the tail. Returns `none` when the argument is\nempty.\n\nAlternatives include `List.tail`, which returns the empty list on failure, `List.tailD`, which\nreturns an explicit fallback value, and `List.tail!`, which panics on the empty list.\n\nExamples:\n * `[\"apple\", \"banana\", \"grape\"].tail? = some [\"banana\", \"grape\"]`\n * `[\"apple\"].tail? = some []`\n * `([] : List String).tail = none`\n</code>",
 "3994":
 "<code>List.tailD.{u} {α : Type u} (l fallback : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Drops the first element of a nonempty list, returning the tail. Returns `none` when the argument is\nempty.\n\nAlternatives include `List.tail`, which returns the empty list on failure, `List.tail?`, which\nreturns an `Option`, and `List.tail!`, which panics on the empty list.\n\nExamples:\n * `[\"apple\", \"banana\", \"grape\"].tailD [\"orange\"] = [\"banana\", \"grape\"]`\n * `[\"apple\"].tailD [\"orange\"] = []`\n * `[].tailD [\"orange\"] = [\"orange\"]`\n</code>",
 "3993":
 "<code>List.tail!.{u_1} {α : Type u_1} : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Drops the first element of a nonempty list, returning the tail. If the list is empty, this function\npanics when executed and returns the empty list.\n\nSafer alternatives include\n * `tail`, which returns the empty list without panicking,\n * `tail?`, which returns an `Option`, and\n * `tailD`, which returns a fallback value when passed the empty list.\n\nExamples:\n * `[\"apple\", \"banana\", \"grape\"].tail! = [\"banana\", \"grape\"]`\n * `[\"banana\", \"grape\"].tail! = [\"grape\"]`\n</code>",
 "3992": "<code><span class=\"literal string\">\"toes\"</span> : String</code>",
 "3991":
 "<code><span class=\"literal string\">\"knees\"</span> : String</code>",
 "3990":
 "<code><span class=\"literal string\">\"shoulders\"</span> : String</code>",
 "399":
 "<code>Subtype.val.{u} {α : Sort u} {p : α → Prop} (self : Subtype p) : α</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "3989": "<code><span class=\"literal string\">\"head\"</span> : String</code>",
 "3988":
 "<code>List.head?.{u} {α : Type u} : List α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element in the list, if there is one. Returns `none` if the list is empty.\n\nUse `List.headD` to provide a fallback value for empty lists, or `List.head!` to panic on empty\nlists.\n\nExamples:\n * `([] : List Nat).head? = none`\n * `[3, 2, 1].head? = some 3`\n</code>",
 "3987":
 "<code>List.headD.{u} {α : Type u} (as : List α) (fallback : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element in the list if there is one, or `fallback` if the list is empty.\n\nUse `List.head?` to return an `Option`, and `List.head!` to panic on empty lists.\n\nExamples:\n* `[].headD \"empty\" = \"empty\"`\n* `[].headD 2 = 2`\n* `[\"head\", \"shoulders\", \"knees\"].headD \"toes\" = \"head\"`\n</code>",
 "3986":
 "<code><span class=\"literal string\">\"grape\"</span> : String</code>",
 "3985":
 "<code>List.isEmpty.{u} {α : Type u} : List α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a list is empty.\n\n`O(1)`.\n\nExamples:\n* `[].isEmpty = true`\n* `[\"grape\"].isEmpty = false`\n* `[\"apple\", \"banana\"].isEmpty = false`\n</code>",
 "3984":
 "<code>List.lengthTR.{u_1} {α : Type u_1} (as : List α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The length of a list.\n\nThis is a tail-recursive version of `List.length`, used to implement `List.length` without running\nout of stack space.\n\nExamples:\n * `([] : List String).lengthTR = 0`\n * `[\"green\", \"brown\"].lengthTR = 2`\n</code>",
 "3983":
 "<code>List.finRange (n : Nat) : List (Fin n)</code><span class=\"sep\"></span><code class=\"docstring\">Lists all elements of `Fin n` in order, starting at `0`.\n\nExamples:\n* `List.finRange 0 = ([] : List (Fin 0))`\n* `List.finRange 2 = ([0, 1] : List (Fin 2))`\n</code>",
 "3982":
 "<code>List.range'TR (s n : Nat) (step : Nat := 1) : List Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns a list of the numbers with the given length `len`, starting at `start` and increasing by\n`step` at each element.\n\nIn other words, `List.range'TR start len step` is `[start, start+step, ..., start+(len-1)*step]`.\n\nThis is a tail-recursive version of `List.range'`.\n\nExamples:\n * `List.range'TR 0 3 (step := 1) = [0, 1, 2]`\n * `List.range'TR 0 3 (step := 2) = [0, 2, 4]`\n * `List.range'TR 0 4 (step := 2) = [0, 2, 4, 6]`\n * `List.range'TR 3 4 (step := 2) = [3, 5, 7, 9]`\n</code>",
 "3981":
 "<code>List.range' (start len : Nat) (step : Nat := 1) : List Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns a list of the numbers with the given length `len`, starting at `start` and increasing by\n`step` at each element.\n\nIn other words, `List.range' start len step` is `[start, start+step, ..., start+(len-1)*step]`.\n\nExamples:\n * `List.range' 0 3 (step := 1) = [0, 1, 2]`\n * `List.range' 0 3 (step := 2) = [0, 2, 4]`\n * `List.range' 0 4 (step := 2) = [0, 2, 4, 6]`\n * `List.range' 3 4 (step := 2) = [3, 5, 7, 9]`\n</code>",
 "3980": "<code>optParam Nat 1</code>",
 "398": "<code>p val</code>",
 "3979":
 "<code>List.append.{u} {α : Type u} (xs ys : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Appends two lists. Normally used via the `++` operator.\n\nAppending lists takes time proportional to the length of the first list: `O(|xs|)`.\n\nExamples:\n* `[1, 2, 3] ++ [4, 5] = [1, 2, 3, 4, 5]`.\n* `[] ++ [4, 5] = [4, 5]`.\n* `[1, 2, 3] ++ [] = [1, 2, 3]`.\n</code>",
 "3978":
 "<code>Fin.isLt {n : Nat} (self : Fin n) : ↑self &lt; n</code><span class=\"sep\"></span><code class=\"docstring\">The number `val` is strictly less than the bound `n`.\n</code>",
 "3977":
 "<code>Array.get.{u} {α : Type u} (a : Array α) (i : Nat) (h : i &lt; a.size) : α</code><span class=\"sep\"></span><code class=\"docstring\">Use the indexing notation `a[i]` instead.\n\nAccess an element from an array without needing a runtime bounds checks,\nusing a `Nat` index and a proof that it is in bounds.\n\nThis function does not use `get_elem_tactic` to automatically find the proof that\nthe index is in bounds. This is because the tactic itself needs to look up values in\narrays.\n</code>",
 "3976": "<code>Fin #[\"red\", \"green\", \"blue\"].size</code>",
 "3975": "<code><span class=\"literal string\">\"2\"</span> : String</code>",
 "3974":
 "<code>List.ofFn.{u_1} {α : Type u_1} {n : Nat} (f : Fin n → α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Creates a list by applying `f` to each potential index in order, starting at `0`.\n\nExamples:\n* `List.ofFn (n := 3) toString = [\"0\", \"1\", \"2\"]`\n* `List.ofFn (fun i =&gt; #[\"red\", \"green\", \"blue\"].get i.val i.isLt) = [\"red\", \"green\", \"blue\"]`\n</code>",
 "3973": "<code>Fin n → α</code>",
 "3972":
 "<code>List.replicateTR.{u} {α : Type u} (n : Nat) (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Creates a list that contains `n` copies of `a`.\n\nThis is a tail-recursive version of `List.replicate`.\n\n* `List.replicateTR 5 \"five\" = [\"five\", \"five\", \"five\", \"five\", \"five\"]`\n* `List.replicateTR 0 \"zero\" = []`\n* `List.replicateTR 2 ' ' = [' ', ' ']`\n</code>",
 "3971": "<code><span class=\"literal string\">\"zero\"</span> : String</code>",
 "3970":
 "<code><span class=\"literal string\">\"yellow\"</span> : String</code>",
 "397": "<code>α → Prop</code>",
 "3969":
 "<code>List.concat.{u} {α : Type u} : List α → α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Adds an element to the *end* of a list.\n\nThe added element is the last element of the resulting list.\n\nExamples:\n* `List.concat [\"red\", \"yellow\"] \"green\" = [\"red\", \"yellow\", \"green\"]`\n* `List.concat [1, 2, 3] 4 = [1, 2, 3, 4]`\n* `List.concat [] () = [()]`\n</code>",
 "3968":
 "<code>List.Mem.{u} {α : Type u} (a : α) : List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">List membership, typically accessed via the `∈` operator.\n\n`a ∈ l` means that `a` is an element of the list `l`. Elements are compared according to Lean's\nlogical equality.\n\nThe related function `List.elem` is a Boolean membership test that uses a `BEq α` instance.\n\nExamples:\n* `a ∈ [x, y, z] ↔ a = x ∨ a = y ∨ a = z`\n</code>",
 "3967":
 "<code>List.elem.{u} {α : Type u} [BEq α] (a : α) (l : List α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `a` is an element of `l`, using `==` to compare elements.\n\n`O(|l|)`. `List.contains` is a synonym that takes the list before the element.\n\nThe preferred simp normal form is `l.contains a`. When `LawfulBEq α` is available,\n`l.contains a = true ↔ a ∈ l` and `l.contains a = false ↔ a ∉ l`.\n\nExample:\n* `List.elem 3 [1, 4, 2, 3, 3, 7] = true`\n* `List.elem 5 [1, 4, 2, 3, 3, 7] = false`\n</code>",
 "3966": "<code>?m.4725</code>",
 "3965": "<code>List.Lex r l₁ l₂</code>",
 "3964": "<code>r a₁ a₂</code>",
 "3963":
 "<code>List.Lex.{u} {α : Type u} (r : α → α → Prop) (as bs : List α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Lexicographic ordering for lists with respect to an ordering of elements.\n\n`as` is lexicographically smaller than `bs` if\n* `as` is empty and `bs` is non-empty, or\n* both `as` and `bs` are non-empty, and the head of `as` is less than the head of `bs` according to\n  `r`, or\n* both `as` and `bs` are non-empty, their heads are equal, and the tail of `as` is less than the\n  tail of `bs`.\n</code>",
 "3962":
 "<code>List.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Each element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· &lt; ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· &lt; ·) [1, 2, 3] ↔ (1 &lt; 2 ∧ 1 &lt; 3) ∧ 2 &lt; 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n</code>",
 "3961":
 "<code>List.Perm.{u} {α : Type u} : List α → List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Two lists are permutations of each other if they contain the same elements, each occurring the same\nnumber of times but not necessarily in the same order.\n\nOne list can be proven to be a permutation of another by showing how to transform one into the other\nby repeatedly swapping adjacent elements.\n\n`List.isPerm` is a Boolean equivalent of this relation.\n</code>",
 "3960":
 "<code>List.isPerm.{u} {α : Type u} [BEq α] : List α → List α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `l₁` and `l₂` are permutations of each other. `O(|l₁| * |l₂|)`.\n\nThe relation `List.Perm` is a logical characterization of permutations. When the `BEq α` instance\ncorresponds to `DecidableEq α`, `isPerm l₁ l₂ ↔ l₁ ~ l₂` (use the theorem `isPerm_iff`).\n</code>",
 "396":
 "<code>Subtype.mk.{u} {α : Sort u} {p : α → Prop} (val : α) (property : p val) : Subtype p</code>",
 "3959":
 "<code>List.Sublist.{u_1} {α : Type u_1} : List α → List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The first list is a non-contiguous sub-list of the second list. Typically written with the `&lt;+`\noperator.\n\nIn other words, `l₁ &lt;+ l₂` means that `l₁` can be transformed into `l₂` by repeatedly inserting new\nelements.\n</code>",
 "3958": "<code>Type ?u.2019</code>",
 "3957": "<code>List ?m.2016</code>",
 "3956": "<code>Type ?u.1639</code>",
 "3955": "<code>List ?m.1636</code>",
 "3954":
 "<code>List.isSuffixOf.{u} {α : Type u} [BEq α] (l₁ l₂ : List α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first list is a suffix of the second.\n\nThe relation `List.IsSuffixOf` expresses this property with respect to logical equality.\n\nExamples:\n* `[2, 3].isSuffixOf [1, 2, 3] = true`\n* `[2, 3].isSuffixOf [1, 2, 3, 4] = false`\n* `[2, 3].isSuffixOf [1, 2] = false`\n* `[2, 3].isSuffixOf [1, 1, 2, 3] = true`\n</code>",
 "3953": "<code>Type ?u.1031</code>",
 "3952": "<code>List ?m.1028</code>",
 "3951":
 "<code>List.isPrefixOf.{u} {α : Type u} [BEq α] : List α → List α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first list is a prefix of the second.\n\nThe relation `List.IsPrefixOf` expresses this property with respect to logical equality.\n\nExamples:\n* `[1, 2].isPrefixOf [1, 2, 3] = true`\n* `[1, 2].isPrefixOf [1, 2] = true`\n* `[1, 2].isPrefixOf [1] = false`\n* `[1, 2].isPrefixOf [1, 1, 2, 3] = false`\n</code>",
 "3950": "<code>split''.{u_1} {α : Type u_1} : List α → List α × List α</code>",
 "395":
 "<code>Subtype.{u} {α : Sort u} (p : α → Prop) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">All the elements of a type that satisfy a predicate.\n\n`Subtype p`, usually written `{ x : α // p x }` or `{ x // p x }`, contains all elements `x : α` for\nwhich `p x` is true. Its constructor is a pair of the value and the proof that it satisfies the\npredicate. In run-time code, `{ x : α // p x }` is represented identically to `α`.\n\nThere is a coercion from `{ x : α // p x }` to `α`, so elements of a subtype may be used where the\nunderlying type is expected.\n\nExamples:\n * `{ n : Nat // n % 2 = 0 }` is the type of even numbers.\n * `{ xs : Array String // xs.size = 5 }` is the type of arrays with five `String`s.\n * Given `xs : List α`, `List { x : α // x ∈ xs }` is the type of lists in which all elements are\n   contained in `xs`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{ x // p x }` in identifiers is `subtype`.</code>",
 "3949":
 "<code>List.singleton.{u} {α : Type u} (a : α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a single-element list.\n\nExamples:\n* `List.singleton 5 = [5]`.\n* `List.singleton \"green\" = [\"green\"]`.\n* `List.singleton [1, 2, 3] = [[1, 2, 3]]`\n</code>",
 "3948": "<code>split'.{u_1} {α : Type u_1} : List α → List α × List α</code>",
 "3947": "<code>split.{u_1} {α : Type u_1} : List α → List α × List α</code>",
 "3946": "<code>List ?m.594</code>",
 "3945": "<code>?m.611</code>",
 "3944": "<code>?m.594</code>",
 "3943": "<code>?m.562</code>",
 "3942": "<code>?m.507</code>",
 "3941": "<code>List ?m.507</code>",
 "3940": "<code>?m.201</code>",
 "394":
 "<code>Fin (n : Nat) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Natural numbers less than some upper bound.\n\nIn particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the\ncanonical type with `n` elements.\n</code>",
 "3939": "<code>?m.190</code>",
 "3938": "<code>?m.178</code>",
 "3937":
 "<code>Singleton.singleton.{u, v} {α : outParam (Type u)} {β : Type v} [self : Singleton α β] : α → β</code><span class=\"sep\"></span><code class=\"docstring\">`singleton x` is a collection with the single element `x` (notation: `{x}`). \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{x}` in identifiers is `singleton`.</code>",
 "3936": "<code>?m.79</code>",
 "3935":
 "<code class=\"docstring\">simplification theorem for the compiler</code>",
 "3934":
 "<code>Sum.inhabitedLeft.{u, v} {α : Type u} {β : Type v} [Inhabited α] : Inhabited (α ⊕ β)</code><span class=\"sep\"></span><code class=\"docstring\">If the left type in a sum is inhabited then the sum is inhabited.\n\nThis is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n</code>",
 "3933":
 "<code><span class=\"literal string\">\"Cant' find it\"</span> : String</code>",
 "3932":
 "<code class=\"docstring\">`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n</code>",
 "3931": "<code>β → β'</code>",
 "3930": "<code>α → α'</code>",
 "393":
 "<code>Fin.mk {n : Nat} (val : Nat) (isLt : val &lt; n) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `Fin n` from `i : Nat` and a proof that `i &lt; n`. </code>",
 "3929":
 "<code>Sum.isRight.{u_1, u_2} {α : Type u_1} {β : Type u_2} : α ⊕ β → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a sum is the right injection `inr`. </code>",
 "3928":
 "<code>Sum.isLeft.{u_1, u_2} {α : Type u_1} {β : Type u_2} : α ⊕ β → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a sum is the left injection `inl`. </code>",
 "3927": "<code>α ⊕ β</code>",
 "3926": "<code>α → γ</code>",
 "3925":
 "<code>PSigma.fst.{u, v} {α : Sort u} {β : α → Sort v} (self : PSigma β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first component of a dependent pair.\n</code>",
 "3924": "<code>PSigma β</code>",
 "3923":
 "<code>PSigma.mk.{u, v} {α : Sort u} {β : α → Sort v} (fst : α) (snd : β fst) : PSigma β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a fully universe-polymorphic dependent pair. </code>",
 "3922": "<code>Sum'.swap {α β : Type} : Sum' α β → Sum' β α</code>",
 "3921": "<code>Sum'.inr {α β : Type} (x : β) : Sum' α β</code>",
 "3920": "<code>Sum'.inl {α β : Type} (x : α) : Sum' α β</code>",
 "392": "<code>α : Prop</code>",
 "3919": "<code>Sum' (α β : Type) : Type</code>",
 "3918":
 "<code>Sigma.snd.{u, v} {α : Type u} {β : α → Type v} (self : Sigma β) : β self.fst</code><span class=\"sep\"></span><code class=\"docstring\">The second component of a dependent pair. Its type depends on the first component.\n</code>",
 "3917": "<code>(n : Nat) × Vector String n</code>",
 "3916":
 "<code><span class=\"literal string\">\"Please enter a number.\"</span> : String</code>",
 "3915":
 "<code><span class=\"literal string\">\"How many lines to read?\"</span> : String</code>",
 "3914": "<code>getValues : IO ((n : Nat) × Vector String n)</code>",
 "3913":
 "<code>Vector.reverse.{u_1} {α : Type u_1} {n : Nat} (xs : Vector α n) : Vector α n</code><span class=\"sep\"></span><code class=\"docstring\">Reverse the elements of a vector. </code>",
 "3912": "<code>getNLines (n : Nat) : IO (Vector String n)</code>",
 "3911":
 "<code>Vector.push.{u_1} {α : Type u_1} {n : Nat} (xs : Vector α n) (x : α) : Vector α (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">Push an element `x` to the end of a vector. </code>",
 "3910": "<code>Vector String n</code>",
 "391":
 "<code>Decidable (p : Prop) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Either a proof that `p` is true or a proof that `p` is false. This is equivalent to a `Bool` paired\nwith a proof that the `Bool` is `true` if and only if `p` is true.\n\n`Decidable` instances are primarily used via `if`-expressions and the tactic `decide`. In\nconditional expressions, the `Decidable` instance for the proposition is used to select a branch. At\nrun time, this case distinction code is identical to that which would be generated for a\n`Bool`-based conditional. In proofs, the tactic `decide` synthesizes an instance of `Decidable p`,\nattempts to reduce it to `isTrue h`, and then succeeds with the proof `h` if it can.\n\nBecause `Decidable` carries data, when writing `@[simp]` lemmas which include a `Decidable` instance\non the LHS, it is best to use `{_ : Decidable p}` rather than `[Decidable p]` so that non-canonical\ninstances can be found via unification rather than instance synthesis.\n</code>",
 "3909":
 "<code class=\"docstring\">Syntax for `Vector α n` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `#v[]` in identifiers is `empty`.\n\n * The recommended spelling of `#v[x]` in identifiers is `singleton`.</code>",
 "3908": "<code>getNLinesRev (n : Nat) : IO (Vector String n)</code>",
 "3907":
 "<code>Sigma.fst.{u, v} {α : Type u} {β : α → Type v} (self : Sigma β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first component of a dependent pair.\n</code>",
 "3906": "<code>Sigma β</code>",
 "3905":
 "<code>β self.fst</code><span class=\"sep\"></span><code class=\"docstring\">The second component of a dependent pair. Its type depends on the first component.\n</code>",
 "3904":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The first component of a dependent pair.\n</code>",
 "3903": "<code>α → Type v</code>",
 "3902":
 "<code>Sigma.mk.{u, v} {α : Type u} {β : α → Type v} (fst : α) (snd : β fst) : Sigma β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a dependent pair.\n\nUsing this constructor in a context in which the type is not known usually requires a type\nascription to determine `β`. This is because the desired relationship between the two values can't\ngenerally be determined automatically.\n</code>",
 "3901": "<code>Fin (n * k)</code>",
 "3900": "<code>α × β</code>",
 "390":
 "<code>USize : Type</code><span class=\"sep\"></span><code class=\"docstring\">A `USize` is an unsigned integer with the size of a word\nfor the platform's architecture.\n\nFor example, if running on a 32-bit machine, USize is equivalent to UInt32.\nOr on a 64-bit machine, UInt64.\n</code>",
 "39":
 "<code>pp.match</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) disable/enable 'match' notation</code>",
 "3899": "<code><span class=\"literal string\">\"6\"</span> : String</code>",
 "3898": "<code><span class=\"literal string\">\"7\"</span> : String</code>",
 "3897":
 "<code>Prod.foldI.{u} {α : Type u} (i : Nat × Nat) (f : (j : Nat) → i.fst ≤ j → j &lt; i.snd → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Combines an initial value with each natural number from in a range, in increasing order.\n\nIn particular, `(start, stop).foldI f init` applies `f`on all the numbers\nfrom `start` (inclusive) to `stop` (exclusive) in increasing order:\n\nExamples:\n* `(5, 8).foldI (fun j _ _ xs =&gt; xs.push j) #[] = (#[] |&gt;.push 5 |&gt;.push 6 |&gt;.push 7)`\n* `(5, 8).foldI (fun j _ _ xs =&gt; xs.push j) #[] = #[5, 6, 7]`\n* `(5, 8).foldI (fun j _ _ xs =&gt; toString j :: xs) [] = [\"7\", \"6\", \"5\"]`\n</code>",
 "3896": "<code>(j : Nat) → i.fst ≤ j → j &lt; i.snd → α → α</code>",
 "3895":
 "<code>Prod.anyI (i : Nat × Nat) (f : (j : Nat) → i.fst ≤ j → j &lt; i.snd → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a predicate holds for any natural number in a range.\n\nIn particular, `(start, stop).allI f` returns true if `f` is true for any natural number from\n`start` (inclusive) to `stop` (exclusive).\n\nExamples:\n * `(5, 8).anyI (fun j _ _ =&gt; j == 6) = (5 == 6) || (6 == 6) || (7 == 6)`\n * `(5, 8).anyI (fun j _ _ =&gt; j % 2 = 0) = true`\n * `(6, 6).anyI (fun j _ _ =&gt; j % 2 = 0) = false`\n</code>",
 "3894":
 "<code>Prod.allI (i : Nat × Nat) (f : (j : Nat) → i.fst ≤ j → j &lt; i.snd → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a predicate holds for all natural numbers in a range.\n\nIn particular, `(start, stop).allI f` returns true if `f` is true for all natural numbers from\n`start` (inclusive) to `stop` (exclusive).\n\nExamples:\n * `(5, 8).allI (fun j _ _ =&gt; j &lt; 10) = (5 &lt; 10) && (6 &lt; 10) && (7 &lt; 10)`\n * `(5, 8).allI (fun j _ _ =&gt; j % 2 = 0) = false`\n * `(6, 7).allI (fun j _ _ =&gt; j % 2 = 0) = true`\n</code>",
 "3893": "<code>(j : Nat) → i.fst ≤ j → j &lt; i.snd → Bool</code>",
 "3892":
 "<code>Prod.map.{u₁, u₂, v₁, v₂} {α₁ : Type u₁} {α₂ : Type u₂} {β₁ : Type v₁} {β₂ : Type v₂} (f : α₁ → α₂) (g : β₁ → β₂) :\n  α₁ × β₁ → α₂ × β₂</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a pair by applying functions to both elements.\n\nExamples:\n* `(1, 2).map (· + 1) (· * 3) = (2, 6)`\n* `(1, 2).map toString (· * 3) = (\"1\", 6)`\n</code>",
 "3891": "<code>β₁ → β₂</code>",
 "3890": "<code>α₁ → α₂</code>",
 "389":
 "<code>Int64 : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of signed 64-bit integers. This type has special support in the\ncompiler to make it actually 64 bits rather than wrapping a `Nat`.\n</code>",
 "3889": "<code>Type v₂</code>",
 "3888": "<code>Type v₁</code>",
 "3887": "<code>Type u₂</code>",
 "3886":
 "<code>MProd.mk.{u} {α β : Type u} (fst : α) (snd : β) : MProd α β</code>",
 "3885":
 "<code>β</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "3884":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The first element of a pair. </code>",
 "3883": "<code>?m.386</code>",
 "3882": "<code>?m.374</code>",
 "3881": "<code>?m.341</code>",
 "3880": "<code>?m.329</code>",
 "388":
 "<code>Int8 : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of signed 8-bit integers. This type has special support in the\ncompiler to make it actually 8 bits rather than wrapping a `Nat`.\n</code>",
 "3879": "<code>Type w</code>",
 "3878":
 "<code>MProd.{u} (α β : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A product type in which both `α` and `β` are in the same universe.\n\nIt is called `MProd` is because it is the *universe-monomorphic* product type.\n</code>",
 "3877": "<code>x✝ ∈ v</code>",
 "3876": "<code>a ∈ v</code>",
 "3875":
 "<code>Option.pmap.{u_1, u_2} {α : Type u_1} {β : Type u_2} {p : α → Prop} (f : (a : α) → p a → β) (o : Option α) :\n  (∀ (a : α), a ∈ o → p a) → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Given a function from the elements of `α` that satisfy `p` to `β` and a proof that an optional value\nsatisfies `p` if it's present, applies the function to the value.\n\nExamples:\n```lean example\ndef attach (v : Option α) : Option { y : α // y ∈ v } :=\n  v.pmap (fun a (h : a ∈ v) =&gt; ⟨_, h⟩) (fun _ h =&gt; h)\n```\n```lean example\n#reduce attach (some 3)\n```\n```output\nsome ⟨3, ⋯⟩\n```\n```lean example\n#reduce attach none\n```\n```output\nnone\n```\n</code>",
 "3874": "<code>(a : α) → p a → β</code>",
 "3873":
 "<code>Option.pelim.{u_1, u_2} {α : Type u_1} {β : Sort u_2} (o : Option α) (b : β) (f : (a : α) → a ∈ o → β) : β</code><span class=\"sep\"></span><code class=\"docstring\">Given an optional value and a function that can be applied when the value is `some`, returns the\nresult of applying the function if this is possible, or a fallback value otherwise.\n\nThe function `f` is _partial_ because it is only defined for the values `a : α` such `a ∈ o`, which\nis equivalent to `o = some a`. This restriction allows the function to use the fact that it can only\nbe called when `o` is not `none`: it can relate its argument to the optional value `o`. Its runtime\nbehavior is equivalent to that of `Option.elim`.\n\nExamples:\n```lean example\ndef attach (v : Option α) : Option { y : α // y ∈ v } :=\n  v.pelim none fun x h =&gt; some ⟨x, h⟩\n```\n```lean example\n#reduce attach (some 3)\n```\n```output\nsome ⟨3, ⋯⟩\n```\n```lean example\n#reduce attach none\n```\n```output\nnone\n```\n</code>",
 "3872": "<code>(a : α) → a ∈ o → β</code>",
 "3871": "<code>x ∈ v</code>",
 "3870":
 "<code>Option.pbind.{u_1, u_2} {α : Type u_1} {β : Type u_2} (o : Option α) (f : (a : α) → a ∈ o → Option β) : Option β</code><span class=\"sep\"></span><code class=\"docstring\">Given an optional value and a function that can be applied when the value is `some`, returns the\nresult of applying the function if this is possible.\n\nThe function `f` is _partial_ because it is only defined for the values `a : α` such `a ∈ o`, which\nis equivalent to `o = some a`. This restriction allows the function to use the fact that it can only\nbe called when `o` is not `none`: it can relate its argument to the optional value `o`. Its runtime\nbehavior is equivalent to that of `Option.bind`.\n\nExamples:\n```lean example\ndef attach (v : Option α) : Option { y : α // y ∈ v } :=\n  v.pbind fun x h =&gt; some ⟨x, h⟩\n```\n```lean example\n#reduce attach (some 3)\n```\n```output\nsome ⟨3, ⋯⟩\n```\n```lean example\n#reduce attach none\n```\n```output\nnone\n```\n</code>",
 "387":
 "<code>UInt64 : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of unsigned 64-bit integers. This type has special support in the\ncompiler to make it actually 64 bits rather than wrapping a `Nat`.\n</code>",
 "3869":
 "<code>attach.{u_1} {α : Type u_1} (v : Option α) : Option { y // y ∈ v }</code>",
 "3868": "<code>(a : α) → a ∈ o → Option β</code>",
 "3867": "<code>Option { x // p x }</code>",
 "3866":
 "<code>Option.attach.{u_1} {α : Type u_1} (xs : Option α) : Option { x // x ∈ xs }</code><span class=\"sep\"></span><code class=\"docstring\">“Attaches” a proof that an optional value, if present, is indeed this value, returning a subtype\nthat expresses this fact.\n\nThis function is primarily used to allow definitions by well-founded recursion that use iteration\noperators (such as `Option.map`) to prove that an optional value drawn from a parameter is smaller\nthan the parameter. This allows the well-founded recursion mechanism to prove that the function\nterminates.\n</code>",
 "3865": "<code>∀ (x : α), x ∈ xs → P x</code>",
 "3864":
 "<code>Option.mapA.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} [Applicative m] {α : Type u_3} {β : Type u_1} (f : α → m β) :\n  Option α → m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function in some applicative functor to an optional value, returning `none` with no\neffects if the value is missing.\n\nThis is analogous to `Option.mapM` for monads.\n</code>",
 "3863":
 "<code>Option.forM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} [Pure m] : Option α → (α → m PUnit) → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Executes a monadic action on an optional value if it is present, or does nothing if there is no\nvalue.\n\nExamples:\n```lean example\n#eval ((some 5).forM set : StateM Nat Unit).run 0\n```\n```output\n((), 5)\n```\n```lean example\n#eval (none.forM (fun x : Nat =&gt; set x) : StateM Nat Unit).run 0\n```\n```output\n((), 0)\n```\n</code>",
 "3862":
 "<code>Array.filter.{u} {α : Type u} (p : α → Bool) (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the array of elements in `as` for which `p` returns `true`.\n\nOnly elements from `start` (inclusive) to `stop` (exclusive) are considered. Elements outside that\nrange are discarded. By default, the entire array is considered.\n\nExamples:\n* `#[1, 2, 5, 2, 7, 7].filter (· &gt; 2) = #[5, 7, 7]`\n* `#[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; false) = #[]`\n* `#[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) = #[1, 2, 5, 2, 7, 7]`\n* `#[1, 2, 5, 2, 7, 7].filter (· &gt; 2) (start := 3) = #[7, 7]`\n* `#[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) (start := 3) = #[2, 7, 7]`\n* `#[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) (stop := 3) = #[1, 2, 5]`\n</code>",
 "3861":
 "<code>List.filter.{u} {α : Type u} (p : α → Bool) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the list of elements in `l` for which `p` returns `true`.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 2, 5, 2, 7, 7].filter (· &gt; 2) = [5, 7, 7]`\n* `[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; false) = []`\n* `[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) = [1, 2, 5, 2, 7, 7]`\n</code>",
 "3860":
 "<code>Option.filter.{u_1} {α : Type u_1} (p : α → Bool) : Option α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Keeps an optional value only if it satisfies a Boolean predicate.\n\nIf `Option` is thought of as a collection that contains at most one element, then `Option.filter` is\nanalogous to `List.filter` or `Array.filter`.\n\nExamples:\n * `(some 5).filter (· % 2 == 0) = none`\n * `(some 4).filter (· % 2 == 0) = some 4`\n * `none.filter (fun x : Nat =&gt; x % 2 == 0) = none`\n * `none.filter (fun x : Nat =&gt; true) = none`\n</code>",
 "386":
 "<code>UInt8 : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of unsigned 8-bit integers. This type has special support in the\ncompiler to make it actually 8 bits rather than wrapping a `Nat`.\n</code>",
 "3859": "<code>?m.9082</code>",
 "3858":
 "<code>OrElse.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HOrElse`: `a &lt;|&gt; b : α` where `a b : α`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → α` to the\nimplementation so it can decide when to evaluate it.\n</code>",
 "3857":
 "<code><span class=\"literal string\">\"succeeded\"</span> : String</code>",
 "3856":
 "<code><span class=\"literal string\">\"handled\"</span> : String</code>",
 "3855":
 "<code>Option.tryCatch.{u_1} {α : Type u_1} (x : Option α) (handle : Unit → Option α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Recover from failing `Option` computations with a handler function.\n\nThis function is usually accessed through the `MonadExceptOf Unit Option` instance.\n\nExamples:\n* `Option.tryCatch none (fun () =&gt; some \"handled\") = some \"handled\"`\n* `Option.tryCatch (some \"succeeded\") (fun () =&gt; some \"handled\") = some \"succeeded\"`\n</code>",
 "3854": "<code>Unit → Option α</code>",
 "3853":
 "<code>Option.sequence.{u, u_1} {m : Type u → Type u_1} [Monad m] {α : Type u} : Option (m α) → m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Converts an optional monadic computation into a monadic computation of an optional value.\n\nExample:\n```lean example\n#eval show IO (Option String) from\n  Option.sequence &lt;| some do\n    IO.println \"hello\"\n    return \"world\"\n```\n```output\nhello\n```\n```output\nsome \"world\"\n```\n</code>",
 "3852": "<code>?m.8942</code>",
 "3851":
 "<code>Option.join.{u_1} {α : Type u_1} (x : Option (Option α)) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Flattens nested optional values, preserving any value found.\n\nThis is analogous to `List.flatten`.\n\nExamples:\n* `none.join = none`\n* `(some none).join = none`\n* `(some (some v)).join = some v`\n</code>",
 "3850":
 "<code>List.flatten.{u} {α : Type u} : List (List α) → List α</code><span class=\"sep\"></span><code class=\"docstring\">Concatenates a list of lists into a single list, preserving the order of the elements.\n\n`O(|flatten L|)`.\n\nExamples:\n* `[[\"a\"], [\"b\", \"c\"]].flatten = [\"a\", \"b\", \"c\"]`\n* `[[\"a\"], [], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]].flatten = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]`\n</code>",
 "385":
 "<code>α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The \"size\" of an element, a natural number which decreases on fields of\neach inductive type. </code>",
 "3849": "<code>Option (Option α)</code>",
 "3848": "<code>α → m (Option β)</code>",
 "3847": "<code>?m.7691</code>",
 "3846":
 "<code>Option.bind.{u_1, u_2} {α : Type u_1} {β : Type u_2} : Option α → (α → Option β) → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Sequencing of `Option` computations.\n\nFrom the perspective of `Option` as computations that might fail, this function sequences\npotentially-failing computations, failing if either fails. From the perspective of `Option` as a\ncollection with at most one element, the function is applied to the element if present, and the\nfinal result is empty if either the initial or the resulting collections are empty.\n\nThis function is often accessed via the `&gt;&gt;=` operator from the `Bind (Option α)` instance, or\nimplicitly via `do`-notation, but it is also idiomatic to call it using [generalized field\nnotation](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=generalized-field-notation).\n\nExamples:\n * `none.bind (fun x =&gt; some x) = none`\n * `(some 4).bind (fun x =&gt; some x) = some 4`\n * `none.bind (Option.guard (· &gt; 2)) = none`\n * `(some 2).bind (Option.guard (· &gt; 2)) = none`\n * `(some 4).bind (Option.guard (· &gt; 2)) = some 4`\n</code>",
 "3845":
 "<code>Option.guard.{u_1} {α : Type u_1} (p : α → Prop) [DecidablePred p] (a : α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns `none` if a value doesn't satisfy a predicate, or the value itself otherwise.\n\nFrom the perspective of `Option` as computations that might fail, this function is a run-time\nassertion operator in the `Option` monad.\n\nExamples:\n * `Option.guard (· &gt; 2) 1 = none`\n * `Option.guard (· &gt; 2) 5 = some 5`\n</code>",
 "3844":
 "<code>Std.ToFormat.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Class for converting a given type α to a `Format` object for pretty-printing.\nSee also `Repr`, which also outputs a `Format` object. </code>",
 "3843":
 "<code>Option.toList.{u_1} {α : Type u_1} : Option α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an optional value to a list with zero or one element.\n\nExamples:\n* `(some \"value\").toList = [\"value\"]`\n* `none.toList = []`\n</code>",
 "3842":
 "<code>Option.toArray.{u_1} {α : Type u_1} : Option α → Array α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an optional value to an array with zero or one element.\n\nExamples:\n* `(some \"value\").toArray = #[\"value\"]`\n* `none.toArray = #[]`\n</code>",
 "3841":
 "<code><span class=\"literal string\">\"value\"</span> : String</code>",
 "3840":
 "<code>Option.lt.{u_1, u_2} {α : Type u_1} {β : Type u_2} (r : α → β → Prop) : Option α → Option β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an ordering relation to `Option`, such that `none` is the least element.\n\nIt can be understood as adding a distinguished least element, represented by `none`, to both `α` and\n`β`.\n\nThis definition is part of the implementation of the `LT (Option α)` instance. However, because it\ncan be used with heterogeneous relations, it is sometimes useful on its own.\n\nExamples:\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) none none = False`\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) none (some 3) = True`\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) (some 3) none = False`\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) (some 4) (some 5) = True`\n * `Option.lt (fun n k : Nat =&gt; n &lt; k) (some 4) (some 4) = False`\n</code>",
 "384": "<code>SizeOf.mk.{u} {α : Sort u} (sizeOf : α → Nat) : SizeOf α</code>",
 "3839":
 "<code>Option.max.{u_1} {α : Type u_1} [Max α] : Option α → Option α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">The maximum of two optional values.\n\nThis function is usually accessed through the `Max (Option α)` instance, rather than directly.\n\nExamples:\n* `Option.max (some 2) (some 5) = some 5`\n* `Option.max (some 5) (some 2) = some 5`\n* `Option.max (some 2) none = some 2`\n* `Option.max none (some 5) = some 5`\n* `Option.max none none = none`\n</code>",
 "3838":
 "<code>Option.min.{u_1} {α : Type u_1} [Min α] : Option α → Option α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">The minimum of two optional values, with `none` treated as the least element. This function is\nusually accessed through the `Min (Option α)` instance, rather than directly.\n\nPrior to `nightly-2025-02-27`, `none` was treated as the greatest element, so\n`min none (some x) = min (some x) none = some x`.\n\nExamples:\n * `Option.min (some 2) (some 5) = some 2`\n * `Option.min (some 5) (some 2) = some 2`\n * `Option.min (some 2) none = none`\n * `Option.min none (some 5) = none`\n * `Option.min none none = none`\n</code>",
 "3837":
 "<code>Option.isEqSome.{u_1} {α : Type u_1} [BEq α] : Option α → α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether an optional value is both present and equal to some other value.\n\nGiven `x? : Option α` and `y : α`, `x?.isEqSome y` is equivalent to `x? == some y`. It is more\nefficient because it avoids an allocation.\n</code>",
 "3836": "<code>?m.4025</code>",
 "3835":
 "<code>Option.isNone.{u_1} {α : Type u_1} : Option α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` on `none` and `false` on `some x`.\n\nThis function is more flexible than `(· == none)` because it does not require a `BEq α` instance.\n\nExamples:\n* `(none : Option Nat).isNone = true`\n* `(some Nat.add).isNone = false`\n</code>",
 "3834": "<code>?m.3383</code>",
 "3833":
 "<code>Option.merge.{u_1} {α : Type u_1} (fn : α → α → α) : Option α → Option α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to a two optional values if both are present. Otherwise, if one value is present,\nit is returned and the function is not used.\n\nThe value is `some (fn a b)` if the inputs are `some a` and `some b`. Otherwise, the behavior is\nequivalent to `Option.orElse`: if only one input is `some x`, then the value is `some x`, and if\nboth are `none`, then the value is `none`.\n\nExamples:\n * `Option.merge (· + ·) none (some 3) = some 3`\n * `Option.merge (· + ·) (some 2) (some 3) = some 5`\n * `Option.merge (· + ·) (some 2) none = some 2`\n * `Option.merge (· + ·) none none = none`\n</code>",
 "3832": "<code>?m.2518</code>",
 "3831":
 "<code>Option.liftOrGet.{u_1} {α : Type u_1} (f : α → α → α) : Option α → Option α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to a two optional values if both are present. Otherwise, if one value is present,\nit is returned and the function is not used.\n\nThe value is `some (f a b)` if the inputs are `some a` and `some b`. Otherwise, the behavior is\nequivalent to `Option.orElse`. If only one input is `some x`, then the value is `some x`. If both\nare `none`, then the value is `none`.\n\nExamples:\n * `Option.liftOrGet (· + ·) none (some 3) = some 3`\n * `Option.liftOrGet (· + ·) (some 2) (some 3) = some 5`\n * `Option.liftOrGet (· + ·) (some 2) none = some 2`\n * `Option.liftOrGet (· + ·) none none = none`\n</code>",
 "3830": "<code>?m.1600</code>",
 "383":
 "<code>SizeOf.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">`SizeOf` is a typeclass automatically derived for every inductive type,\nwhich equips the type with a \"size\" function to `Nat`.\nThe default instance defines each constructor to be `1` plus the sum of the\nsizes of all the constructor fields.\n\nThis is used for proofs by well-founded induction, since every field of the\nconstructor has a smaller size than the constructor itself,\nand in many cases this will suffice to do the proof that a recursive function\nis only called on smaller values.\nIf the default proof strategy fails, it is recommended to supply a custom\nsize measure using the `termination_by` argument on the function definition.\n</code>",
 "3829":
 "<code>Option.orElse.{u_1} {α : Type u_1} : Option α → (Unit → Option α) → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Implementation of `OrElse`'s `&lt;|&gt;` syntax for `Option`. If the first argument is `some a`, returns\n`some a`, otherwise evaluates and returns the second argument.\n\nSee also `or` for a version that is strict in the second argument.\n</code>",
 "3828":
 "<code>Option.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) : Option α → Option β</code><span class=\"sep\"></span><code class=\"docstring\">Apply a function to an optional value, if present.\n\nFrom the perspective of `Option` as a container with at most one value, this is analogous to\n`List.map`. It can also be accessed via the `Functor Option` instance.\n\nExamples:\n * `(none : Option Nat).map (· + 1) = none`\n * `(some 3).map (· + 1) = some 4`\n</code>",
 "3827":
 "<code>Option.recOn.{u_1, u} {α : Type u} {motive : Option α → Sort u_1} (t : Option α) (none : motive none)\n  (some : (val : α) → motive (some val)) : motive t</code>",
 "3826":
 "<code>Option.elim.{u_1, u_2} {α : Type u_1} {β : Sort u_2} : Option α → β → (α → β) → β</code><span class=\"sep\"></span><code class=\"docstring\">A case analysis function for `Option`.\n\nGiven a value for `none` and a function to apply to the contents of `some`, `Option.elim` checks\nwhich constructor a given `Option` consists of, and uses the appropriate argument.\n\n`Option.elim` is an elimination principle for `Option`. In particular, it is a non-dependent version\nof `Option.recOn`. It can also be seen as a combination of `Option.map` and `Option.getD`.\n\nExamples:\n * `(some \"hello\").elim 0 String.length = 5`\n * `none.elim 0 String.length = 0`\n</code>",
 "3825":
 "<code><span class=\"literal string\">\"goodbye\"</span> : String</code>",
 "3824":
 "<code>Option.isSome.{u_1} {α : Type u_1} : Option α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` on `some x` and `false` on `none`. </code>",
 "3823": "<code>getAlpha : IO (Option String)</code>",
 "3822":
 "<code class=\"docstring\">`if let pat := d then t else e` is a shorthand syntax for:\n```\nmatch d with\n| pat =&gt; t\n| _ =&gt; e\n```\nIt matches `d` against the pattern `pat` and the bindings are available in `t`.\nIf the pattern does not match, it returns `e` instead.\n</code>",
 "3821":
 "<code><span class=\"literal string\">\"not found\"</span> : String</code>",
 "3820":
 "<code><span class=\"literal string\">\"Schenectady\"</span> : String</code>",
 "382": "<code>Sort u</code>",
 "3819":
 "<code>Std.HashMap.empty.{u_1, u_2} {α : Type u_1} {β : Type u_2} [BEq α] [Hashable α] (capacity : Nat := 8) : Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new empty hash map. The optional parameter `capacity` can be supplied to presize the\nmap so that it can hold the given number of mappings without reallocating. It is also possible to\nuse the empty collection notations `∅` and `{}` to create an empty hash map with the default\ncapacity.\n</code>",
 "3818": "<code>postalCodes : Std.HashMap Nat String</code>",
 "3817":
 "<code>Option.getD.{u_1} {α : Type u_1} (opt : Option α) (dflt : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Gets an optional value, returning a given default on `none`.\n\nThis function is `@[macro_inline]`, so `dflt` will not be evaluated unless `opt` turns out to be\n`none`.\n\nExamples:\n * `(some \"hello\").getD \"goodbye\" = \"hello\"`\n * `none.getD \"goodbye\" = \"hello\"`\n</code>",
 "3816":
 "<code>Std.HashMap.get?.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : HashMap α β) (a : α) : Option β</code><span class=\"sep\"></span><code class=\"docstring\">The notation `m[a]?` is preferred over calling this function directly.\n\nTries to retrieve the mapping for the given key, returning `none` if no such mapping is present.\n</code>",
 "3815": "<code>Coll</code>",
 "3814": "<code>HashMap α β</code>",
 "3813":
 "<code>Std.HashMap.get?.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashMap α β) (a : α) :\n  Option β</code><span class=\"sep\"></span><code class=\"docstring\">The notation `m[a]?` is preferred over calling this function directly.\n\nTries to retrieve the mapping for the given key, returning `none` if no such mapping is present.\n</code>",
 "3812": "<code>?m.425</code>",
 "3811": "<code>c = true</code>",
 "3810": "<code>c = false → α</code>",
 "381": "<code>Lean.Parser.Command.structure : Lean.Parser.Parser</code>",
 "3809": "<code>c = true → α</code>",
 "3808":
 "<code class=\"docstring\">The conditional function.\n\n`cond c x y` is the same as `if c then x else y`, but optimized for a Boolean condition rather than\na decidable proposition. It can also be written using the notation `bif c then x else y`.\n\nJust like `ite`, `cond` is declared `@[macro_inline]`, which causes applications of `cond` to be\nunfolded. As a result, `x` and `y` are not evaluated at runtime until one of them is selected, and\nonly the selected branch is evaluated.\n</code>",
 "3807":
 "<code class=\"docstring\">mark definition to always be inlined before ANF conversion</code>",
 "3806": "<code>BIG_EXPENSIVE_COMPUTATION : Bool</code>",
 "3805":
 "<code>cond.{u} {α : Sort u} (c : Bool) (x y : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The conditional function.\n\n`cond c x y` is the same as `if c then x else y`, but optimized for a Boolean condition rather than\na decidable proposition. It can also be written using the notation `bif c then x else y`.\n\nJust like `ite`, `cond` is declared `@[macro_inline]`, which causes applications of `cond` to be\nunfolded. As a result, `x` and `y` are not evaluated at runtime until one of them is selected, and\nonly the selected branch is evaluated.\n</code>",
 "3804": "<code>Empty</code>",
 "3803": "<code>f.{u_1} {ε : Type u_1} (n : Nat) : Except ε Nat</code>",
 "3802": "<code>ProofUnitLike</code>",
 "3801": "<code>ProofUnitLike.mk : 2 = 2 → ProofUnitLike</code>",
 "3800": "<code>ProofUnitLike : Prop</code>",
 "380":
 "<code>Lean.Parser.Command.inductive : Lean.Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">In Lean, every concrete type other than the universes\nand every type constructor other than dependent arrows\nis an instance of a general family of type constructions known as inductive types.\nIt is remarkable that it is possible to construct a substantial edifice of mathematics\nbased on nothing more than the type universes, dependent arrow types, and inductive types;\neverything else follows from those.\nIntuitively, an inductive type is built up from a specified list of constructors.\nFor example, `List α` is the list of elements of type `α`, and is defined as follows:\n```\ninductive List (α : Type u) where\n| nil\n| cons (head : α) (tail : List α)\n```\nA list of elements of type `α` is either the empty list, `nil`,\nor an element `head : α` followed by a list `tail : List α`.\nSee [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)\nfor more information.\n</code>",
 "38":
 "<code>Dynamic : Type</code><span class=\"sep\"></span><code class=\"docstring\">Type-tagged union that can store any type with a `TypeName` instance.\n\nThis is roughly equivalent to `(α : Type) × TypeName α × α` but without the\nuniverse bump.\n</code>",
 "3799": "<code>NotUnitLike</code>",
 "3798": "<code>NotUnitLike.mk (u : Unit) : NotUnitLike</code>",
 "3797": "<code>NotUnitLike : Type</code>",
 "3796": "<code>WithParam 3</code>",
 "3795": "<code>WithParam.mk {n : Nat} : WithParam n</code>",
 "3794": "<code>WithParam (n : Nat) : Type</code>",
 "3793": "<code>AlsoUnit</code>",
 "3792": "<code>CustomUnit</code>",
 "3791": "<code>CustomUnit.customUnit : CustomUnit</code>",
 "3790": "<code>AlsoUnit : Type</code>",
 "379":
 "<code>bootstrap.inductiveCheckResultingUniverse</code><span class=\"sep\"></span><code class=\"docstring\">by default the `inductive`/`structure` commands report an error if the resulting universe is not zero, but may be zero for some universe parameters. Reason: unless this type is a subsingleton, it is hardly what the user wants since it can only eliminate into `Prop`. In the `Init` package, we define subsingletons, and we use this option to disable the check. This option may be deleted in the future after we improve the validator</code>",
 "3789": "<code>CustomUnit : Type</code>",
 "3788": "<code>Unit</code>",
 "3787":
 "<code><span class=\"literal string\">\"\\x0d\\n\"</span> : String</code>",
 "3786":
 "<code>String.validateUTF8 (a : ByteArray) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether an array of bytes is a valid UTF-8 encoding of a string.\n</code>",
 "3785": "<code>String.validateUTF8 a = true</code>",
 "3784": "<code>n &lt; s.utf8ByteSize</code>",
 "3783":
 "<code><span class=\"literal string\">\"\\\"\\\\\\\"\\\"\"</span> : String</code>",
 "3782":
 "<code><span class=\"literal string\">\"\\\"abc\\\"\"</span> : String</code>",
 "3781":
 "<code>String.quote (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a string to its corresponding Lean string literal syntax. Double quotes are added to each\nend, and internal characters are escaped as needed.\n\nExamples:\n* `\"abc\".quote = \"\\\"abc\\\"\"`\n* `\"\\\"\".quote = \"\\\"\\\\\\\"\\\"\"`\n</code>",
 "3780":
 "<code>String.toName (s : String) : Lean.Name</code><span class=\"sep\"></span><code class=\"docstring\">Converts a string to the Lean compiler's representation of names. The resulting name is\nhierarchical, and the string is split at the dots (`'.'`).\n\n`\"a.b\".toName` is the name `a.b`, not `«a.b»`. For the latter, use `Name.mkSimple`.\n</code>",
 "378":
 "<code>PEmpty.{u} : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">The universe-polymorphic empty type, with no constructors.\n\n`PEmpty` can be used in any universe, but this flexibility can lead to worse error messages and more\nchallenges with universe level unification. Prefer the type `Empty` or the proposition `False` when\npossible.\n</code>",
 "3779": "<code><span class=\"literal string\">\"a.b\"</span> : String</code>",
 "3778":
 "<code>String.toSubstring (s : String) : Substring</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `String` into a `Substring` that denotes the entire string.\n</code>",
 "3777": "<code>String.Iterator</code>",
 "3776":
 "<code>String.Iterator.curr' (it : String.Iterator) (h : it.hasNext = true) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Gets the character at the iterator's current position.\n\nThe proof of `it.hasNext` ensures that there is, in fact, a character at the current position. This\nfunction is faster that `String.Iterator.curr` due to avoiding a run-time bounds check.\n</code>",
 "3775":
 "<code>String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">The current UTF-8 byte position in the string `s`.\n\nThis position is not guaranteed to be valid for the string. If the position is not valid, then the\ncurrent character is `(default : Char)`, similar to `String.get` on an invalid position.\n</code>",
 "3774":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The string being iterated over. </code>",
 "3773":
 "<code>String.Iterator.mk (s : String) (i : String.Pos) : String.Iterator</code>",
 "3772": "<code>?m.11493</code>",
 "3771": "<code>?m.11465</code>",
 "3770":
 "<code>String.iter (s : String) : String.Iterator</code><span class=\"sep\"></span><code class=\"docstring\">Creates an iterator at the beginning of the string. </code>",
 "377": "<code>Fix : (Type → Type) → Type</code>",
 "3769":
 "<code>String.Iterator.next : String.Iterator → String.Iterator</code><span class=\"sep\"></span><code class=\"docstring\">Moves the iterator's position forward by one character, unconditionally.\n\nIt is only valid to call this function if the iterator is not at the end of the string (i.e.\nif `Iterator.atEnd` is `false`); otherwise, the resulting iterator will be invalid.\n</code>",
 "3768":
 "<code>String.Iterator.prev : String.Iterator → String.Iterator</code><span class=\"sep\"></span><code class=\"docstring\">Moves the iterator's position backward by one character, unconditionally.\n\nThe position is not changed if the iterator is at the beginning of the string.\n</code>",
 "3767":
 "<code>String.Iterator.hasNext : String.Iterator → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the iterator is at or before the string's last character.\n</code>",
 "3766":
 "<code>String.Iterator.hasPrev : String.Iterator → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the iterator is after the beginning of the string.\n</code>",
 "3765":
 "<code>String.Iterator.setCurr : String.Iterator → Char → String.Iterator</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current character in the string.\n\nDoes nothing if the iterator is at the end of the string. If both the replacement character and the\nreplaced character are 7-bit ASCII characters and the string is not shared, then it is updated\nin-place and not copied.\n</code>",
 "3764":
 "<code>String.Iterator.curr : String.Iterator → Char</code><span class=\"sep\"></span><code class=\"docstring\">Gets the character at the iterator's current position.\n\nA run-time bounds check is performed. Use `String.Iterator.curr'` to avoid redundant bounds checks.\n\nIf the position is invalid, returns `(default : Char)`.\n</code>",
 "3763":
 "<code><span class=\"literal string\">\"ABc123\"</span> : String</code>",
 "3762":
 "<code>String.toLower (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces each character in `s` with the result of applying `Char.toLower` to it.\n\n`Char.toLower` has no effect on characters outside of the range `'A'`–`'Z'`.\n\nExamples:\n* `\"ORANGE\".toLower = \"orange\"`\n* `\"Orange\".toLower = \"orange\"`\n* `\"ABc123\".toLower = \"abc123\"`\n</code>",
 "3761":
 "<code>String.toUpper (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces each character in `s` with the result of applying `Char.toUpper` to it.\n\n`Char.toUpper` has no effect on characters outside of the range `'a'`–`'z'`.\n\nExamples:\n* `\"orange\".toUpper = \"ORANGE\"`\n* `\"abc123\".toUpper = \"ABC123\"`\n</code>",
 "3760":
 "<code><span class=\"literal string\">\"oRANGE\"</span> : String</code>",
 "376": "<code>Type u → Type u</code>",
 "3759":
 "<code>String.decapitalize (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first character in `s` with the result of applying `Char.toLower` to it. Returns the\nempty string if the string is empty.\n\n`Char.toLower` has no effect on characters outside of the range `'A'`–`'Z'`.\n\nExamples:\n* `\"Orange\".decapitalize = \"orange\"`\n* `\"ORANGE\".decapitalize = \"oRANGE\"`\n* `\"\".decapitalize = \"\"`\n</code>",
 "3758":
 "<code>Char.toLower (c : Char) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts an uppercase ASCII letter to the corresponding lowercase letter. Letters outside the ASCII\nalphabet are returned unchanged.\n\nThe uppercase ASCII letters are the following: `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n</code>",
 "3757":
 "<code><span class=\"literal string\">\"ORANGE\"</span> : String</code>",
 "3756":
 "<code><span class=\"literal string\">\"Orange\"</span> : String</code>",
 "3755":
 "<code>String.capitalize (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the first character in `s` with the result of applying `Char.toUpper` to it. Returns the\nempty string if the string is empty.\n\n`Char.toUpper` has no effect on characters outside of the range `'a'`–`'z'`.\n\nExamples:\n* `\"orange\".capitalize = \"Orange\"`\n* `\"ORANGE\".capitalize = \"ORANGE\"`\n* `\"\".capitalize = \"\"`\n</code>",
 "3754": "<code><span class=\"literal string\">\"    \"</span> : String</code>",
 "3753":
 "<code><span class=\"literal string\">\"indeed!!\"</span> : String</code>",
 "3752":
 "<code>String.pushn (s : String) (c : Char) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Adds multiple repetitions of a character to the end of a string.\n\nReturns `s`, with `n` repetitions of `c` at the end. Internally, the implementation repeatedly calls\n`String.push`, so the string is modified in-place if there is a unique reference to it.\n\nExamples:\n * `\"indeed\".pushn '!' 2 = \"indeed!!\"`\n * `\"indeed\".pushn '!' 0 = \"indeed\"`\n * `\"\".pushn ' ' 4 = \"    \"`\n</code>",
 "3751":
 "<code><span class=\"literal string\">\"indeed\"</span> : String</code>",
 "3750": "<code><span class=\"literal string\">\"abcd\"</span> : String</code>",
 "375": "<code>(Type u → Type u) → Sort u_1</code>",
 "3749": "<code><span class=\"literal string\">\"bac\"</span> : String</code>",
 "3748": "<code><span class=\"literal string\">\"aba\"</span> : String</code>",
 "3747":
 "<code><span class=\"literal string\">\"ababacabac\"</span> : String</code>",
 "3746":
 "<code><span class=\"literal string\">\" text \"</span> : String</code>",
 "3745":
 "<code><span class=\"literal string\">\"here is \"</span> : String</code>",
 "3744": "<code><span class=\"literal string\">\"text\"</span> : String</code>",
 "3743": "<code><span class=\"literal string\">\"some\"</span> : String</code>",
 "3742": "<code><span class=\"literal string\">\"is\"</span> : String</code>",
 "3741": "<code><span class=\"literal string\">\"here\"</span> : String</code>",
 "3740":
 "<code><span class=\"literal string\">\"here is some text \"</span> : String</code>",
 "374": "<code>Bad.bad : (Bad → Bad) → Bad</code>",
 "3739": "<code>optParam String \" \"</code>",
 "3738":
 "<code><span class=\"literal string\">\"  x + 1\"</span> : String</code>",
 "3737":
 "<code><span class=\"literal string\">\"fun x =&gt;\"</span> : String</code>",
 "3736":
 "<code><span class=\"literal string\">\"fun x =&gt;\\n  x + 1\\n\"</span> : String</code>",
 "3735":
 "<code><span class=\"literal string\">\"coffee  tea  water\"</span> : String</code>",
 "3734":
 "<code><span class=\"literal string\">\"water\"</span> : String</code>",
 "3733":
 "<code>String.split (s : String) (p : Char → Bool) : List String</code><span class=\"sep\"></span><code class=\"docstring\">Splits a string at each character for which `p` returns `true`.\n\nThe characters that satisfy `p` are not included in any of the resulting strings. If multiple\ncharacters in a row satisfy `p`, then the resulting list will contain empty strings.\n\nExamples:\n* `\"coffee tea water\".split (·.isWhitespace) = [\"coffee\", \"tea\", \"water\"]`\n* `\"coffee  tea  water\".split (·.isWhitespace) = [\"coffee\", \"\", \"tea\", \"\", \"water\"]`\n* `\"fun x =&gt;\\n  x + 1\\n\".split (· == '\\n') = [\"fun x =&gt;\", \"  x + 1\", \"\"]`\n</code>",
 "3732":
 "<code>String.endsWith (s post : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first string (`s`) ends with the second (`post`).\n\nExamples:\n* `\"red green blue\".endsWith \"blue\" = true`\n* `\"red green blue\".endsWith \"green\" = false`\n* `\"red green blue\".endsWith \"\" = true`\n* `\"red\".endsWith \"red\" = true`\n</code>",
 "3731": "<code>Manual.post : Verso.Doc.Elab.CodeBlockExpander</code>",
 "3730":
 "<code>String.startsWith (s pre : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first string (`s`) begins with the second (`pre`).\n\n`String.isPrefix` is a version that takes the potential prefix before the string.\n\nExamples:\n* `\"red green blue\".startsWith \"red\" = true`\n* `\"red green blue\".startsWith \"green\" = false`\n* `\"red green blue\".startsWith \"\" = true`\n* `\"red\".startsWith \"red\" = true`\n</code>",
 "373": "<code>Bad : Type</code>",
 "3729": "<code><span class=\"literal string\">\"teas\"</span> : String</code>",
 "3728": "<code><span class=\"literal string\">\"ten\"</span> : String</code>",
 "3727":
 "<code>String.firstDiffPos (a b : String) : String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first position where the two strings differ.\n\nIf one string is a prefix of the other, then the returned position is the end position of the\nshorter string. If the strings are identical, then their end position is returned.\n\nExamples:\n* `\"tea\".firstDiffPos \"ten\" = ⟨2⟩`\n* `\"tea\".firstDiffPos \"tea\" = ⟨3⟩`\n* `\"tea\".firstDiffPos \"teas\" = ⟨3⟩`\n* `\"teas\".firstDiffPos \"tea\" = ⟨3⟩`\n</code>",
 "3726":
 "<code><span class=\"literal string\">\"brown and orange\"</span> : String</code>",
 "3725":
 "<code>String.all (s : String) (p : Char → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the Boolean predicate `p` returns `true` for every character in a string.\n\nShort-circuits at the first character for which `p` returns `false`.\n\nExamples:\n* `\"brown\".all (·.isLetter) = true`\n* `\"brown and orange\".all (·.isLetter) = false`\n* `\"\".all (fun _ =&gt; false) = true`\n</code>",
 "3724":
 "<code><span class=\"literal string\">\"brown\"</span> : String</code>",
 "3723":
 "<code><span class=\"literal string\">\"retaw dna aet eeffoc\"</span> : String</code>",
 "3722":
 "<code>String.foldr.{u} {α : Type u} (f : Char → α → α) (init : α) (s : String) : α</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a string from the right, accumulating a value starting with `init`. The\naccumulated value is combined with the each character in reverse order, using `f`.\n\nExamples:\n * `\"coffee tea water\".foldr (fun c n =&gt; if c.isWhitespace then n + 1 else n) 0 = 2`\n * `\"coffee tea and water\".foldr (fun c n =&gt; if c.isWhitespace then n + 1 else n) 0 = 3`\n * `\"coffee tea water\".foldr (fun c s =&gt; c.push s) \"\" = \"retaw dna aet eeffoc\"`\n</code>",
 "3721": "<code>Char → α → α</code>",
 "3720":
 "<code>String.push : String → Char → String</code><span class=\"sep\"></span><code class=\"docstring\">Adds a character to the end of a string.\n\nThe internal implementation uses dynamic arrays and will perform destructive updates\nif the string is not shared.\n\nExamples:\n* `\"abc\".push 'd' = \"abcd\"`\n* `\"\".push 'a' = \"a\"`\n</code>",
 "372": "<code>Prop</code>",
 "3719":
 "<code><span class=\"literal string\">\"coffee tea and water\"</span> : String</code>",
 "3718":
 "<code>String.foldl.{u} {α : Type u} (f : α → Char → α) (init : α) (s : String) : α</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a string from the left, accumulating a value starting with `init`. The\naccumulated value is combined with character in order, using `f`.\n\nExamples:\n * `\"coffee tea water\".foldl (fun n c =&gt; if c.isWhitespace then n + 1 else n) 0 = 2`\n * `\"coffee tea and water\".foldl (fun n c =&gt; if c.isWhitespace then n + 1 else n) 0 = 3`\n * `\"coffee tea water\".foldl (·.push ·) \"\" = \"coffee tea water\"`\n</code>",
 "3717": "<code>α → Char → α</code>",
 "3716":
 "<code><span class=\"literal string\">\"ABC123\"</span> : String</code>",
 "3715":
 "<code>Char.toUpper (c : Char) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a lowercase ASCII letter to the corresponding uppercase letter. Letters outside the ASCII\nalphabet are returned unchanged.\n\nThe lowercase ASCII letters are the following: `abcdefghijklmnopqrstuvwxyz`.\n</code>",
 "3714":
 "<code>String.map (f : Char → Char) (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Applies the function `f` to every character in a string, returning a string that contains the\nresulting characters.\n\nExamples:\n * `\"abc123\".map Char.toUpper = \"ABC123\"`\n * `\"\".map Char.toUpper = \"\"`\n</code>",
 "3713":
 "<code><span class=\"literal string\">\"abc123\"</span> : String</code>",
 "3712":
 "<code>String.revFind (s : String) (p : Char → Bool) : Option String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Finds the position of the last character in a string for which the Boolean predicate `p` returns\n`true`. If there is no such character in the string, then `none` is returned.\n\nExamples:\n * `\"coffee tea water\".revFind (·.isWhitespace) = some ⟨10⟩`\n * `\"tea\".revFind (· == 'X') = none`\n * `\"\".revFind (· == 'X') = none`\n</code>",
 "3711":
 "<code>String.find (s : String) (p : Char → Bool) : String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Finds the position of the first character in a string for which the Boolean predicate `p` returns\n`true`. If there is no such character in the string, then the end position of the string is\nreturned.\n\nExamples:\n * `\"coffee tea water\".find (·.isWhitespace) = ⟨6⟩`\n * `\"tea\".find (· == 'X') = ⟨3⟩`\n * `\"\".find (· == 'X') = ⟨0⟩`\n</code>",
 "3710":
 "<code><span class=\"literal string\">\"coffee tea water\"</span> : String</code>",
 "371": "<code>Spurious (α : Type 5) : Type</code>",
 "3709":
 "<code><span class=\"literal string\">\"rEd grEEn bluE\"</span> : String</code>",
 "3708":
 "<code><span class=\"literal string\">\"red grEn blue\"</span> : String</code>",
 "3707": "<code><span class=\"literal string\">\"E\"</span> : String</code>",
 "3706":
 "<code><span class=\"literal string\">\"rd grn blu\"</span> : String</code>",
 "3705":
 "<code>String.replace (s pattern replacement : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">In the string `s`, replaces all occurrences of `pattern` with `replacement`.\n\nExamples:\n* `\"red green blue\".replace \"e\" \"\" = \"rd grn blu\"`\n* `\"red green blue\".replace \"ee\" \"E\" = \"red grEn blue\"`\n* `\"red green blue\".replace \"e\" \"E\" = \"rEd grEEn bluE\"`\n</code>",
 "3704":
 "<code>String.offsetOfPos (s : String) (pos : String.Pos) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the character index that corresponds to the provided position (i.e. UTF-8 byte index) in a\nstring.\n\nIf the position is at the end of the string, then the string's length in characters is returned. If\nthe position is invalid due to pointing at the middle of a UTF-8 byte sequence, then the character\nindex of the next character after the position is returned.\n\nExamples:\n* `\"L∃∀N\".offsetOfPos ⟨0⟩ = 0`\n* `\"L∃∀N\".offsetOfPos ⟨1⟩ = 1`\n* `\"L∃∀N\".offsetOfPos ⟨2⟩ = 2`\n* `\"L∃∀N\".offsetOfPos ⟨4⟩ = 2`\n* `\"L∃∀N\".offsetOfPos ⟨5⟩ = 3`\n* `\"L∃∀N\".offsetOfPos ⟨50⟩ = 4`\n</code>",
 "3703":
 "<code>String.contains (s : String) (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a string contains the specified character.\n\nExamples:\n* `\"green\".contains 'e' = true`\n* `\"green\".contains 'x' = false`\n* `\"\".contains 'x' = false`\n</code>",
 "3702":
 "<code>String.revPosOf (s : String) (c : Char) : Option String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Returns the position of the last occurrence of a character, `c`, in a string `s`. If `s` does not\ncontain `c`, returns `none`.\n\nExamples:\n* `\"abcabc\".refPosOf 'a' = some ⟨3⟩`\n* `\"abcabc\".revPosOf 'z' = none`\n* `\"L∃∀N\".revPosOf '∀' = some ⟨4⟩`\n</code>",
 "3701":
 "<code><span class=\"literal string\">\"abcabc\"</span> : String</code>",
 "3700":
 "<code>String.posOf (s : String) (c : Char) : String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Returns the position of the first occurrence of a character, `c`, in a string `s`. If `s` does not\ncontain `c`, returns `s.endPos`.\n\nExamples:\n* `\"abcba\".posOf 'a' = ⟨0⟩`\n* `\"abcba\".posOf 'z' = ⟨5⟩`\n* `\"L∃∀N\".posOf '∀' = ⟨4⟩`\n</code>",
 "370": "<code>CanRepr.mk.{u} (α : Type u) [Repr α] : CanRepr</code>",
 "37":
 "<code>Lean.Elab.Info.ofCustomInfo (i : Lean.Elab.CustomInfo) : Info</code>",
 "3699":
 "<code><span class=\"literal string\">\"abcba\"</span> : String</code>",
 "3698":
 "<code>String.back (s : String) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last character in `s`. If `s = \"\"`, returns `(default : Char)`.\n\nExamples:\n* `\"abc\".back = 'c'`\n* `\"\".back = (default : Char)`\n</code>",
 "3697":
 "<code>String.front (s : String) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first character in `s`. If `s = \"\"`, returns `(default : Char)`.\n\nExamples:\n* `\"abc\".front = 'a'`\n* `\"\".front = (default : Char)`\n</code>",
 "3696": "<code>Char → Char</code>",
 "3695": "<code><span class=\"literal string\">\"L∃XN\"</span> : String</code>",
 "3694": "<code><span class=\"literal string\">\"aBc\"</span> : String</code>",
 "3693":
 "<code>String.set : String → String.Pos → Char → String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the character at a specified position in a string with a new character. If the position is\ninvalid, the string is returned unchanged.\n\nIf both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.\n\nExamples:\n* `\"abc\".set ⟨1⟩ 'B' = \"aBc\"`\n* `\"abc\".set ⟨3⟩ 'D' = \"abc\"`\n* `\"L∃∀N\".set ⟨4⟩ 'X' = \"L∃XN\"`\n* `\"L∃∀N\".set ⟨2⟩ 'X' = \"L∃∀N\"` because `'∃'` is a multi-byte character, so the byte index `2` is an\n  invalid position.\n</code>",
 "3692":
 "<code><span class=\"literal string\">\"Here:\\nfun x =&gt;\\n\\n \\tx + 1\"</span> : String</code>",
 "3691":
 "<code><span class=\"literal string\">\"Here:\\n\\t\\tfun x =&gt;\\n \\n\\t  \\tx + 1\"</span> : String</code>",
 "3690":
 "<code><span class=\"literal string\">\"Here:\\nfun x =&gt;\\n \\tx + 1\"</span> : String</code>",
 "369": "<code>CanRepr.{u} : Type (u + 1)</code>",
 "3689":
 "<code><span class=\"literal string\">\"Here:\\n\\t\\tfun x =&gt;\\n\\t  \\tx + 1\"</span> : String</code>",
 "3688":
 "<code><span class=\"literal string\">\"Here:\\nfun x =&gt;\\n  x + 1\"</span> : String</code>",
 "3687":
 "<code>String.removeLeadingSpaces (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Consistently de-indents the lines in a string, removing the same amount of leading whitespace from\neach line such that the least-indented line has no leading whitespace.\n\nThe number of leading whitespace characters to remove from each line is determined by counting the\nnumber of leading space (`' '`) and tab (`'\\t'`) characters on lines after the first line that also\ncontain non-whitespace characters. No distinction is made between tab and space characters; both\ncount equally.\n\nThe least number of leading whitespace characters found is then removed from the beginning of each\nline. The first line's leading whitespace is not counted when determining how far to de-indent the\nstring, but leading whitespace is removed from it.\n\nExamples:\n* `\"Here:\\n  fun x =&gt;\\n    x + 1\".removeLeadingSpaces = \"Here:\\nfun x =&gt;\\n  x + 1\"`\n* `\"Here:\\n\\t\\tfun x =&gt;\\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =&gt;\\n \\tx + 1\"`\n* `\"Here:\\n\\t\\tfun x =&gt;\\n \\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =&gt;\\n\\n \\tx + 1\"`\n</code>",
 "3686":
 "<code><span class=\"literal string\">\"Here:\\n  fun x =&gt;\\n    x + 1\"</span> : String</code>",
 "3685":
 "<code><span class=\"literal string\">\"  abc\"</span> : String</code>",
 "3684":
 "<code><span class=\"literal string\">\"abc   \"</span> : String</code>",
 "3683":
 "<code>String.trimLeft (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes leading whitespace from a string.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`.\n\nExamples:\n* `\"abc\".trimLeft = \"abc\"`\n* `\"   abc\".trimLeft = \"   abc\"`\n* `\"abc \\t  \".trimLeft = \"abc \\t  \"`\n* `\"  abc   \".trimLeft = \"abc   \"`\n* `\"abc\\ndef\\n\".trimLeft = \"abc\\ndef\\n\"`\n</code>",
 "3682":
 "<code><span class=\"literal string\">\"abc\\ndef\"</span> : String</code>",
 "3681":
 "<code><span class=\"literal string\">\"abc\\ndef\\n\"</span> : String</code>",
 "3680":
 "<code><span class=\"literal string\">\"  abc   \"</span> : String</code>",
 "368":
 "<code>Either.inr.{u, v} {α : Type u} {β : Type v} : β → Either α β</code>",
 "3679":
 "<code><span class=\"literal string\">\"abc \\t  \"</span> : String</code>",
 "3678":
 "<code><span class=\"literal string\">\"   abc\"</span> : String</code>",
 "3677":
 "<code><span class=\"literal string\">\" blu \"</span> : String</code>",
 "3676":
 "<code>String.dropSuffix? (s suff : String) : Option Substring</code><span class=\"sep\"></span><code class=\"docstring\">If `suff` is a suffix of `s`, returns the remainder. Returns `none` otherwise.\n\nThe string `suff` is a suffix of `s` if there exists a `t : String` such that `s = t ++ suff`. If so,\nthe result is `some t`.\n\nUse `String.stripSuffix` to return the string unchanged when `suff` is not a suffix.\n\nExamples:\n * `\"red green blue\".dropSuffix? \" blue\" = some \"red green\"`\n * `\"red green blue\".dropSuffix? \" blu \" = none`\n * `\"red green blue\".dropSuffix? \"\" = some \"red green blue\"`\n</code>",
 "3675":
 "<code>String.stripSuffix (s suff : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">If `suff` is a suffix of `s`, returns the remainder. Returns `s` unmodified otherwise.\n\nThe string `suff` is a suffix of `s` if there exists a `t : String` such that `s = t ++ suff`. If so,\nthe result is `t`. Otherwise, it is `s`.\n\nUse `String.dropSuffix?` to return `none` when `suff` is not a suffix.\n\nExamples:\n * `\"red green blue\".stripSuffix \" blue\" = \"red green\"`\n * `\"red green blue\".stripSuffix \" blu \" = \"red green blue\"`\n * `\"red green blue\".stripSuffix \"\" = \"red green blue\"`\n</code>",
 "3674":
 "<code><span class=\"literal string\">\"reed \"</span> : String</code>",
 "3673": "<code><span class=\"literal string\">\"red \"</span> : String</code>",
 "3672":
 "<code>String.dropPrefix? (s pre : String) : Option Substring</code><span class=\"sep\"></span><code class=\"docstring\">If `pre` is a prefix of `s`, returns the remainder. Returns `none` otherwise.\n\nThe string `pre` is a prefix of `s` if there exists a `t : String` such that `s = pre ++ t`. If so,\nthe result is `some t`.\n\nUse `String.stripPrefix` to return the string unchanged when `pre` is not a prefix.\n\nExamples:\n * `\"red green blue\".dropPrefix? \"red \" = some \"green blue\"`\n * `\"red green blue\".dropPrefix? \"reed \" = none`\n * `\"red green blue\".dropPrefix? \"\" = some \"red green blue\"`\n</code>",
 "3671":
 "<code>String.stripPrefix (s pre : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">If `pre` is a prefix of `s`, returns the remainder. Returns `s` unmodified otherwise.\n\nThe string `pre` is a prefix of `s` if there exists a `t : String` such that `s = pre ++ t`. If so,\nthe result is `t`. Otherwise, it is `s`.\n\nUse `String.dropPrefix?` to return `none` when `pre` is not a prefix.\n\nExamples:\n * `\"red green blue\".stripPrefix \"red \" = \"green blue\"`\n * `\"red green blue\".stripPrefix \"reed \" = \"red green blue\"`\n * `\"red green blue\".stripPrefix \"\" = \"red green blue\"`\n</code>",
 "3670": "<code>Manual.pre : Verso.Doc.Elab.CodeBlockExpander</code>",
 "367":
 "<code>Either.inl.{u, v} {α : Type u} {β : Type v} : α → Either α β</code>",
 "3669":
 "<code>Substring : Type</code><span class=\"sep\"></span><code class=\"docstring\">A `Substring` is a view into some subslice of a `String`.\nThe actual string slicing is deferred because this would require copying the\nstring; here we only store a reference to the original string for\ngarbage collection purposes.\n</code>",
 "3668":
 "<code><span class=\"literal string\">\"red green blu\"</span> : String</code>",
 "3667":
 "<code><span class=\"literal string\">\"red green \"</span> : String</code>",
 "3666":
 "<code>String.dropRightWhile (s : String) (p : Char → Bool) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string by removing the longest suffix from `s` in which `p` returns `true` for all\ncharacters.\n\nExamples:\n* `\"red green blue\".dropRightWhile (·.isLetter) = \"red green \"`\n* `\"red green blue\".dropRightWhile (· == 'e') = \"red green blu\"`\n* `\"red green blue\".dropRightWhile (· != 'n') = \"red green\"`\n* `\"red green blue\".dropRightWhile (fun _ =&gt; true) = \"\"`\n</code>",
 "3665":
 "<code><span class=\"literal string\">\"red green\"</span> : String</code>",
 "3664":
 "<code>String.dropRight (s : String) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes the specified number of characters (Unicode code points) from the end of the string.\n\nIf `n` is greater than `s.length`, returns `\"\"`.\n\nExamples:\n* `\"red green blue\".dropRight 5 = \"red green\"`\n* `\"red green blue\".dropRight 11 = \"red\"`\n* `\"red green blue\".dropRight 50 = \"\"`\n</code>",
 "3663":
 "<code><span class=\"literal string\">\"n blue\"</span> : String</code>",
 "3662":
 "<code><span class=\"literal string\">\"ed green blue\"</span> : String</code>",
 "3661":
 "<code><span class=\"literal string\">\" green blue\"</span> : String</code>",
 "3660":
 "<code>String.dropWhile (s : String) (p : Char → Bool) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string by removing the longest prefix from `s` in which `p` returns `true` for all\ncharacters.\n\nExamples:\n* `\"red green blue\".dropWhile (·.isLetter) = \" green blue\"`\n* `\"red green blue\".dropWhile (· == 'r') = \"ed green blue\"`\n* `\"red green blue\".dropWhile (· != 'n') = \"n blue\"`\n* `\"red green blue\".dropWhile (fun _ =&gt; true) = \"\"`\n</code>",
 "366": "<code>x = y</code>",
 "3659":
 "<code>String.drop (s : String) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes the specified number of characters (Unicode code points) from the start of the string.\n\nIf `n` is greater than `s.length`, returns `\"\"`.\n\nExamples:\n* `\"red green blue\".drop 4 = \"green blue\"`\n* `\"red green blue\".drop 10 = \"blue\"`\n* `\"red green blue\".drop 50 = \"\"`\n</code>",
 "3658":
 "<code><span class=\"literal string\">\" blue\"</span> : String</code>",
 "3657":
 "<code>String.takeRightWhile (s : String) (p : Char → Bool) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string that contains the longest suffix of `s` in which `p` returns `true` for all\ncharacters.\n\nExamples:\n* `\"red green blue\".takeRightWhile (·.isLetter) = \"blue\"`\n* `\"red green blue\".takeRightWhile (· == 'e') = \"e\"`\n* `\"red green blue\".takeRightWhile (· != 'n') = \" blue\"`\n* `\"red green blue\".takeRightWhile (fun _ =&gt; true) = \"red green blue\"`\n</code>",
 "3656": "<code><span class=\"literal string\">\"e\"</span> : String</code>",
 "3655":
 "<code>String.takeRight (s : String) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string that contains the last `n` characters (Unicode code points) of `s`.\n\nIf `n` is greater than `s.length`, returns `s`.\n\nExamples:\n* `\"red green blue\".takeRight 4 = \"blue\"`\n* `\"red green blue\".takeRight 1 = \"e\"`\n* `\"red green blue\".takeRight 0 = \"\"`\n* `\"red green blue\".takeRight 100 = \"red green blue\"`\n</code>",
 "3654":
 "<code><span class=\"literal string\">\"red gree\"</span> : String</code>",
 "3653":
 "<code>String.takeWhile (s : String) (p : Char → Bool) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string that contains the longest prefix of `s` in which `p` returns `true` for all\ncharacters.\n\nExamples:\n* `\"red green blue\".takeWhile (·.isLetter) = \"red\"`\n* `\"red green blue\".takeWhile (· == 'r') = \"r\"`\n* `\"red green blue\".takeWhile (· != 'n') = \"red gree\"`\n* `\"red green blue\".takeWhile (fun _ =&gt; true) = \"red green blue\"`\n</code>",
 "3652": "<code><span class=\"literal string\">\"r\"</span> : String</code>",
 "3651":
 "<code><span class=\"literal string\">\"green blue\"</span> : String</code>",
 "3650":
 "<code>String.extract : String → String.Pos → String.Pos → String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string that consists of the region of the input string delimited by the two positions.\n\nThe result is `\"\"` if the start position is greater than or equal to the end position or if the\nstart position is at the end of the string. If either position is invalid (that is, if either points\nat the middle of a multi-byte UTF-8 character) then the result is unspecified.\n\nExamples:\n* `\"red green blue\".extract ⟨0⟩ ⟨3⟩ = \"red\"`\n* `\"red green blue\".extract ⟨3⟩ ⟨0⟩ = \"\"`\n* `\"red green blue\".extract ⟨0⟩ ⟨100⟩ = \"red green blue\"`\n* `\"red green blue\".extract ⟨4⟩ ⟨100⟩ = \"green blue\"`\n* `\"L∃∀N\".extract ⟨2⟩ ⟨100⟩ = \"green blue\"`\n</code>",
 "365": "<code>motive x ⋯</code>",
 "3649":
 "<code><span class=\"literal string\">\"red green blue\"</span> : String</code>",
 "3648":
 "<code>String.get' (s : String) (p : String.Pos) (h : ¬s.atEnd p = true) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the character at position `p` of a string. Returns `(default : Char)`, which is `'A'`, if\n`p` is not a valid position.\n\nRequires evidence, `h`, that `p` is within bounds instead of performing a run-time bounds check as\nin `String.get`.\n\nA typical pattern combines `get'` with a dependent `if`-expression to avoid the overhead of an\nadditional bounds check. For example:\n```\ndef getInBounds? (s : String) (p : String.Pos) : Option Char :=\n  if h : s.atEnd p then none else some (s.get' p h)\n```\nEven with evidence of `¬ s.atEnd p`, `p` may be invalid if a byte index points into the middle of a\nmulti-byte UTF-8 character. For example, `\"L∃∀N\".get' ⟨2⟩ (by decide) = (default : Char)`.\n\nExamples:\n* `\"abc\".get' 0 (by decide) = 'a'`\n* `let lean := \"L∃∀N\"; lean.get' (0 |&gt; lean.next |&gt; lean.next) (by decide) = '∀'`\n</code>",
 "3647":
 "<code>getInBounds? (s : String) (p : String.Pos) : Option Char</code>",
 "3646":
 "<code>String.get! (s : String) (p : String.Pos) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the character at position `p` of a string. Panics if `p` is not a valid position.\n\nSee `String.get?` for a safer alternative.\n\nThis function is overridden with an efficient implementation in runtime code. See\n`String.utf8GetAux` for the reference implementation.\n\nExamples\n* `\"abc\".get! ⟨1⟩ = 'b'`\n</code>",
 "3645":
 "<code>String.get? : String → String.Pos → Option Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the character at position `p` of a string. If `p` is not a valid position, returns `none`.\n\nThis function is overridden with an efficient implementation in runtime code. See\n`String.utf8GetAux?` for the reference implementation.\n\nExamples:\n* `\"abc\".get? ⟨1⟩ = some 'b'`\n* `\"abc\".get? ⟨3⟩ = none`\n* `\"L∃∀N\".get? ⟨1⟩ = some '∃'`\n* `\"L∃∀N\".get? ⟨2⟩ = none`\n</code>",
 "3644":
 "<code>String.utf8GetAux? : List Char → String.Pos → String.Pos → Option Char</code>",
 "3643":
 "<code>String.utf8GetAux : List Char → String.Pos → String.Pos → Char</code>",
 "3642": "<code>?m.1929</code>",
 "3641": "<code>?m.1908</code>",
 "3640":
 "<code>String.nextUntil (s : String) (p : Char → Bool) (i : String.Pos) : String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Repeatedly increments a position in a string, as if by `String.next`, while the predicate `p`\nreturns `false` for the character at the position. Stops incrementing at the end of the string or\nwhen `p` returns `true` for the current character.\n\nExamples:\n* `let s := \"   a  \"; s.get (s.nextUntil Char.isWhitespace 0) = ' '`\n* `let s := \"   a  \"; s.get (s.nextUntil Char.isLetter 0) = 'a'`\n* `let s := \"a  \"; s.get (s.nextUntil Char.isWhitespace 0) = ' '`\n</code>",
 "364": "<code>(y : α) → x = y → Sort u</code>",
 "3639": "<code><span class=\"literal string\">\"ba  \"</span> : String</code>",
 "3638": "<code><span class=\"literal string\">\"a  \"</span> : String</code>",
 "3637":
 "<code>Char.isWhitespace (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the character is a space `(' ', U+0020)`, a tab `('\\t', U+0009)`, a carriage\nreturn `('\\r', U+000D)`, or a newline `('\\n', U+000A)`.\n</code>",
 "3636":
 "<code>String.nextWhile (s : String) (p : Char → Bool) (i : String.Pos) : String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Repeatedly increments a position in a string, as if by `String.next`, while the predicate `p`\nreturns `true` for the character at the position. Stops incrementing at the end of the string or\nwhen `p` returns `false` for the current character.\n\nExamples:\n* `let s := \"   a  \"; s.get (s.nextWhile Char.isWhitespace 0) = 'a'`\n* `let s := \"a  \"; s.get (s.nextWhile Char.isWhitespace 0) = 'a'`\n* `let s := \"ba  \"; s.get (s.nextWhile Char.isWhitespace 0) = 'b'`\n</code>",
 "3635":
 "<code><span class=\"literal string\">\"   a  \"</span> : String</code>",
 "3634": "<code>Char → Bool</code>",
 "3633": "<code>s.atEnd p = true</code>",
 "3632": "<code>next? (s : String) (p : String.Pos) : Option Char</code>",
 "3631": "<code>¬s.atEnd p = true</code>",
 "3630":
 "<code>String.get (s : String) (p : String.Pos) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the character at position `p` of a string. If `p` is not a valid position, returns the\nfallback value `(default : Char)`, which is `'A'`, but does not panic.\n\nThis function is overridden with an efficient implementation in runtime code. See\n`String.utf8GetAux` for the reference implementation.\n\nExamples:\n* `\"abc\".get ⟨1⟩ = 'b'`\n* `\"abc\".get ⟨3⟩ = (default : Char)` because byte `3` is at the end of the string.\n* `\"L∃∀N\".get ⟨2⟩ = (default : Char)` because byte `2` is in the middle of `'∃'`.\n</code>",
 "363":
 "<code>Eq.rec.{u, u_1} {α : Sort u_1} {a✝ : α} {motive : (a : α) → a✝ = a → Sort u} (refl : motive a✝ ⋯) {a✝¹ : α}\n  (t : a✝ = a✝¹) : motive a✝¹ t</code>",
 "3629":
 "<code>String.next' (s : String) (p : String.Pos) (h : ¬s.atEnd p = true) : String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Returns the next position in a string after position `p`. The result is unspecified if `p` is not a\nvalid position.\n\nRequires evidence, `h`, that `p` is within bounds. No run-time bounds check is performed, as in\n`String.next`.\n\nA typical pattern combines `String.next'` with a dependent `if`-expression to avoid the overhead of\nan additional bounds check. For example:\n```\ndef next? (s: String) (p : String.Pos) : Option Char :=\n  if h : s.atEnd p then none else s.get (s.next' p h)\n```\n\nExample:\n* `let abc := \"abc\"; abc.get (abc.next' 0 (by decide)) = 'b'`\n</code>",
 "3628":
 "<code>String.atEnd : String → String.Pos → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if a specified byte position is greater than or equal to the position which points to\nthe end of a string. Otherwise, returns `false`.\n\nExamples:\n* `(0 |&gt; \"abc\".next |&gt; \"abc\".next |&gt; \"abc\".atEnd) = false`\n* `(0 |&gt; \"abc\".next |&gt; \"abc\".next |&gt; \"abc\".next |&gt; \"abc\".next |&gt; \"abc\".atEnd) = true`\n* `(0 |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".atEnd) = false`\n* `(0 |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".atEnd) = true`\n* `\"abc\".atEnd ⟨4⟩ = true`\n* `\"L∃∀N\".atEnd ⟨7⟩ = false`\n* `\"L∃∀N\".atEnd ⟨8⟩ = true`\n</code>",
 "3627": "<code><span class=\"literal string\">\"𝒫(A)\"</span> : String</code>",
 "3626":
 "<code>String.Pos.isValid (s : String) (p : String.Pos) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `p` is a valid UTF-8 position in the string `s`.\n\nThis means that `p ≤ s.endPos` and `p` lies on a UTF-8 character boundary. At runtime, this\noperation takes constant time.\n\nExamples:\n * `String.Pos.isValid \"abc\" ⟨0⟩ = true`\n * `String.Pos.isValid \"abc\" ⟨1⟩ = true`\n * `String.Pos.isValid \"abc\" ⟨3⟩ = true`\n * `String.Pos.isValid \"abc\" ⟨4⟩ = false`\n * `String.Pos.isValid \"𝒫(A)\" ⟨0⟩ = true`\n * `String.Pos.isValid \"𝒫(A)\" ⟨1⟩ = false`\n * `String.Pos.isValid \"𝒫(A)\" ⟨2⟩ = false`\n * `String.Pos.isValid \"𝒫(A)\" ⟨3⟩ = false`\n * `String.Pos.isValid \"𝒫(A)\" ⟨4⟩ = true`\n</code>",
 "3625":
 "<code>String.endPos (s : String) : String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">A UTF-8 byte position that points at the end of a string, just after the last character.\n\n* `\"abc\".endPos = ⟨3⟩`\n* `\"L∃∀N\".endPos = ⟨8⟩`\n</code>",
 "3624": "<code>String.Pos</code>",
 "3623":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">Get the underlying byte index of a `String.Pos` </code>",
 "3622": "<code>String.Pos.mk (byteIdx : Nat) : String.Pos</code>",
 "3621": "<code><span class=\"literal string\">\"L∃∀N\"</span> : String</code>",
 "3620":
 "<code><span class=\"literal string\">\"empty\"</span> : String</code>",
 "362":
 "<code>Eq.refl.{u_1} {α : Sort u_1} (a : α) : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`Eq.refl a : a = a` is reflexivity, the unique constructor of the\nequality type. See also `rfl`, which is usually used instead. </code>",
 "3619":
 "<code>String.isEmpty (s : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether a string is empty.\n\nEmpty strings are equal to `\"\"` and have length and end position `0`.\n\nExamples:\n* `\"\".isEmpty = true`\n* `\"empty\".isEmpty = false`\n* `\" \".isEmpty = false`\n</code>",
 "3618":
 "<code>Std.Format.line : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">A position where a newline may be inserted\nif the current group does not fit within the allotted column width. </code>",
 "3617":
 "<code>Std.Format : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string with pretty-printing information for rendering in a column-width-aware way.\n\nThe pretty-printing algorithm is based on Wadler's paper\n[_A Prettier Printer_](https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf). </code>",
 "3616": "<code><span class=\"literal string\">\"-5\"</span> : String</code>",
 "3615": "<code><span class=\"literal string\">\"2-3\"</span> : String</code>",
 "3614": "<code><span class=\"literal string\">\"+587\"</span> : String</code>",
 "3613": "<code><span class=\"literal string\">\"-0\"</span> : String</code>",
 "3612":
 "<code>String.isInt (s : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the string can be interpreted as the decimal representation of an integer.\n\nA string can be interpreted as a decimal integer if it is not empty, its first character is\n`'-'` or a digit, and all subsequent characters are digits. Leading `+` characters are not allowed.\n\nUse `String.toInt?` or `String.toInt!` to convert such a string to an integer.\n\nExamples:\n * `\"\".isInt = false`\n * `\"0\".isInt = true`\n * `\"-0\".isInt = true`\n * `\"5\".isInt = true`\n * `\"587\".isInt = true`\n * `\"-587\".isInt = true`\n * `\"+587\".isInt = false`\n * `\" 5\".isInt = false`\n * `\"2-3\".isInt = false`\n * `\"0xff\".isInt = false`\n</code>",
 "3611":
 "<code>String.toInt! (s : String) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a string as the decimal representation of an integer, returning it. Panics if the string\ndoes not contain a decimal integer.\n\nA string can be interpreted as a decimal integer if it is not empty, its first character is `'-'` or\na digit, and all remaining characters are digits.\n\nUse `String.isInt` to check whether `String.toInt!` would return a value. `String.toInt?` is a safer\nalternative that returns `none` instead of panicking when the string is not an integer.\n\nExamples:\n * `\"0\".toInt! = 0`\n * `\"5\".toInt! = 5`\n * `\"587\".toInt! = 587`\n * `\"-587\".toInt! = -587`\n</code>",
 "3610":
 "<code>String.toInt? (s : String) : Option Int</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a string as the decimal representation of an integer, returning it. Returns `none` if the\nstring does not contain a decimal integer.\n\nA string can be interpreted as a decimal integer if it is not empty, its first character is either\n`'-'` or a digit, and all remaining characters are digits.\n\nUse `String.isInt` to check whether `String.toInt?` would return `some`. `String.toInt!` is an\nalternative that panics instead of returning `none` when the string is not an integer.\n\nExamples:\n * `\"\".toInt? = none`\n * `\"0\".toInt? = some 0`\n * `\"5\".toInt? = some 5`\n * `\"-5\".toInt? = some (-5)`\n * `\"587\".toInt? = some 587`\n * `\"-587\".toInt? = some (-587)`\n * `\" 5\".toInt? = none`\n * `\"2-3\".toInt? = none`\n * `\"0xff\".toInt? = none`\n</code>",
 "361": "<code>a ∨ b</code>",
 "3609": "<code><span class=\"literal string\">\"0xff\"</span> : String</code>",
 "3608": "<code><span class=\"literal string\">\"2+3\"</span> : String</code>",
 "3607": "<code><span class=\"literal string\">\" 5\"</span> : String</code>",
 "3606": "<code><span class=\"literal string\">\"-587\"</span> : String</code>",
 "3605": "<code><span class=\"literal string\">\"587\"</span> : String</code>",
 "3604": "<code><span class=\"literal string\">\"05\"</span> : String</code>",
 "3603": "<code><span class=\"literal string\">\"5\"</span> : String</code>",
 "3602":
 "<code>String.isNat (s : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the string can be interpreted as the decimal representation of a natural number.\n\nA string can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.\n\nUse `String.toNat?` or `String.toNat!` to convert such a string to a natural number.\n\nExamples:\n * `\"\".isNat = false`\n * `\"0\".isNat = true`\n * `\"5\".isNat = true`\n * `\"05\".isNat = true`\n * `\"587\".isNat = true`\n * `\"-587\".isNat = false`\n * `\" 5\".isNat = false`\n * `\"2+3\".isNat = false`\n * `\"0xff\".isNat = false`\n</code>",
 "3601":
 "<code>String.toNat! (s : String) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a string as the decimal representation of a natural number, returning it. Panics if the\nstring does not contain a decimal natural number.\n\nA string can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.\n\nUse `String.isNat` to check whether `String.toNat!` would return a value. `String.toNat?` is a safer\nalternative that returns `none` instead of panicking when the string is not a natural number.\n\nExamples:\n * `\"0\".toNat! = 0`\n * `\"5\".toNat! = 5`\n * `\"587\".toNat! = 587`\n</code>",
 "3600":
 "<code><span class=\"literal string\">\"M |  | N\"</span> : String</code>",
 "360":
 "<code>Or.inr {a b : Prop} (h : b) : a ∨ b</code><span class=\"sep\"></span><code class=\"docstring\">`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a ∨ b`. </code>",
 "36":
 "<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>",
 "3599": "<code><span class=\"literal string\">\"N\"</span> : String</code>",
 "3598": "<code><span class=\"literal string\">\"M\"</span> : String</code>",
 "3597": "<code><span class=\"literal string\">\" | \"</span> : String</code>",
 "3596":
 "<code><span class=\"literal string\">\"tea and coffee\"</span> : String</code>",
 "3595":
 "<code><span class=\"literal string\">\"coffee\"</span> : String</code>",
 "3594": "<code><span class=\"literal string\">\"tea\"</span> : String</code>",
 "3593":
 "<code><span class=\"literal string\">\" and \"</span> : String</code>",
 "3592":
 "<code><span class=\"literal string\">\"red, green, blue\"</span> : String</code>",
 "3591": "<code><span class=\"literal string\">\"blue\"</span> : String</code>",
 "3590": "<code><span class=\"literal string\">\", \"</span> : String</code>",
 "359": "<code>∀ (h : b), motive ⋯</code>",
 "3589": "<code><span class=\"literal string\">\"red\"</span> : String</code>",
 "3588": "<code><span class=\"literal string\">\"ue\"</span> : String</code>",
 "3587": "<code><span class=\"literal string\">\"l\"</span> : String</code>",
 "3586": "<code><span class=\"literal string\">\"ee\"</span> : String</code>",
 "3585": "<code><span class=\"literal string\">\"gr\"</span> : String</code>",
 "3584":
 "<code>String.join (l : List String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Appends all the strings in a list of strings, in order.\n\nUse `String.intercalate` to place a separator string between the strings in a list.\n\nExamples:\n* `String.join [\"gr\", \"ee\", \"n\"] = \"green\"`\n* `String.join [\"b\", \"\", \"l\", \"\", \"ue\"] = \"red\"`\n* `String.join [] = \"\"`\n</code>",
 "3583":
 "<code>String.intercalate (s : String) : List String → String</code><span class=\"sep\"></span><code class=\"docstring\">Appends the strings in a list of strings, placing the separator `s` between each pair.\n\nExamples:\n* `\", \".intercalate [\"red\", \"green\", \"blue\"] = \"red, green, blue\"`\n* `\" and \".intercalate [\"tea\", \"coffee\"] = \"tea and coffee\"`\n* `\" | \".intercalate [\"M\", \"\", \"N\"] = \"M |  | N\"`\n</code>",
 "3582":
 "<code><span class=\"literal string\">\"abcdef\"</span> : String</code>",
 "3581": "<code><span class=\"literal string\">\"def\"</span> : String</code>",
 "3580":
 "<code>String.append : String → String → String</code><span class=\"sep\"></span><code class=\"docstring\">Appends two strings. Usually accessed via the `++` operator.\n\nThe internal implementation will perform destructive updates if the string is not shared.\n\nExamples:\n* `\"abc\".append \"def\" = \"abcdef\"`\n* `\"abc\" ++ \"def\" = \"abcdef\"`\n* `\"\" ++ \"\" = \"\"`\n</code>",
 "358":
 "<code>Or.inl {a b : Prop} (h : a) : a ∨ b</code><span class=\"sep\"></span><code class=\"docstring\">`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a ∨ b`. </code>",
 "3579": "<code><span class=\"literal string\">\"𝒫\"</span> : String</code>",
 "3578":
 "<code>String.singleton (c : Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Returns a new string that contains only the character `c`.\n\nBecause strings are encoded in UTF-8, the resulting string may take multiple bytes.\n\nExamples:\n* `String.singleton 'L' = \"L\"`\n* `String.singleton ' ' = \" \"`\n* `String.singleton '\"' = \"\\\"\"`\n* `String.singleton '𝒫' = \"𝒫\"`\n</code>",
 "3577":
 "<code><span class=\"literal string\">\"This is r#\\\"literally\\\"# quoted\"</span> : String</code>",
 "3576":
 "<code><span class=\"literal string\">\"This is \\\"literally\\\" quoted\"</span> : String</code>",
 "3575":
 "<code><span class=\"literal string\">\"Write backslash in a string using '\\\\\\\\\\\\\\\\'\"</span> : String</code>",
 "3574":
 "<code><span class=\"literal string\">\"\\\\t\"</span> : String</code>",
 "3573":
 "<code>Lean.MessageData : Type</code><span class=\"sep\"></span><code class=\"docstring\">Structured message data. We use it for reporting errors, trace messages, etc. </code>",
 "3572":
 "<code><span class=\"literal string\">\"1 + 1 = \"</span> : String</code>",
 "3571": "<code>str2 : String</code>",
 "3570":
 "<code><span class=\"literal string\">\"String with a gap\"</span> : String</code>",
 "357": "<code>∀ (h : a), motive ⋯</code>",
 "3569": "<code>str1 : String</code>",
 "3568":
 "<code>List Char</code><span class=\"sep\"></span><code class=\"docstring\">Unpack `String` into a `List Char`. This function is overridden by the\ncompiler and is O(n) in the length of the list. </code>",
 "3567":
 "<code>String.mk (data : List Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Pack a `List Char` into a `String`. This function is overridden by the\ncompiler and is O(n) in the length of the list. </code>",
 "3566":
 "<code>String.utf8ByteSize : String → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number of bytes used by the string's UTF-8 encoding.\n\nAt runtime, this function takes constant time because the byte length of strings is cached.\n</code>",
 "3565":
 "<code>String.prev : String → String.Pos → String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Returns the position in a string before a specified position, `p`. If `p = ⟨0⟩`, returns `0`. If `p`\nis not a valid position, the result is unspecified.\n\nFor example, `\"L∃∀N\".prev ⟨3⟩` is unspecified, since byte 3 occurs in the middle of the multi-byte\ncharacter `'∃'`.\n\nExamples:\n* `\"abc\".get (\"abc\".endPos |&gt; \"abc\".prev) = 'c'`\n* `\"L∃∀N\".get (\"L∃∀N\".endPos |&gt; \"L∃∀N\".prev |&gt; \"L∃∀N\".prev |&gt; \"L∃∀N\".prev) = '∃'`\n</code>",
 "3564":
 "<code>String.next (s : String) (p : String.Pos) : String.Pos</code><span class=\"sep\"></span><code class=\"docstring\">Returns the next position in a string after position `p`. The result is unspecified if `p` is not a\nvalid position or if `p = s.endPos`.\n\nA run-time bounds check is performed to determine whether `p` is at the end of the string. If a\nbounds check has already been performed, use `String.next'` to avoid a repeated check.\n\nSome examples where the result is unspecified:\n* `\"abc\".next ⟨3⟩`, since `3 = \"abc\".endPos`\n* `\"L∃∀N\".next ⟨2⟩`, since `2` points into the middle of a multi-byte UTF-8 character\n\nExamples:\n* `\"abc\".get (\"abc\".next 0) = 'b'`\n* `\"L∃∀N\".get (0 |&gt; \"L∃∀N\".next |&gt; \"L∃∀N\".next) = '∀'`\n</code>",
 "3563":
 "<code>String.Pos : Type</code><span class=\"sep\"></span><code class=\"docstring\">A byte position in a `String`, according to its UTF-8 encoding.\n\nCharacter positions (counting the Unicode code points rather than bytes) are represented by plain\n`Nat`s. Indexing a `String` by a `String.Pos` takes constant time, while character positions need to\nbe translated internally to byte positions, which takes linear time.\n\nA byte position `p` is *valid* for a string `s` if `0 ≤ p ≤ s.endPos` and `p` lies on a UTF-8\ncharacter boundary.\n</code>",
 "3562":
 "<code>String.Iterator : Type</code><span class=\"sep\"></span><code class=\"docstring\">An iterator over the characters (Unicode code points) in a `String`. Typically created by\n`String.iter`.\n\nString iterators pair a string with a valid byte index. This allows efficient character-by-character\nprocessing of strings while avoiding the need to manually ensure that byte indices are used with the\ncorrect strings.\n\nAn iterator is *valid* if the position `i` is *valid* for the string `s`, meaning `0 ≤ i ≤ s.endPos`\nand `i` lies on a UTF8 byte boundary. If `i = s.endPos`, the iterator is at the end of the string.\n\nMost operations on iterators return unspecified values if the iterator is not valid. The functions\nin the `String.Iterator` API rule out the creation of invalid iterators, with two exceptions:\n- `Iterator.next iter` is invalid if `iter` is already at the end of the string (`iter.atEnd` is\n  `true`), and\n- `Iterator.forward iter n`/`Iterator.nextn iter n` is invalid if `n` is strictly greater than the\n  number of remaining characters.\n</code>",
 "3561":
 "<code><span class=\"literal string\">\"'\\\\\\\"'\"</span> : String</code>",
 "3560": "<code><span class=\"literal string\">\"'L'\"</span> : String</code>",
 "356": "<code>a ∨ b → Prop</code>",
 "3559": "<code><span class=\"literal string\">\"\\\"\"</span> : String</code>",
 "3558": "<code><span class=\"literal string\">\"L\"</span> : String</code>",
 "3557":
 "<code>Char.quote (c : Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Quotes the character to its representation as a character literal, surrounded by single quotes and\nescaped as necessary.\n\nExamples:\n * `'L'.quote = \"'L'\"`\n * `'\"'.quote = \"'\\\\\\\"'\"`\n</code>",
 "3556":
 "<code>Char.toString (c : Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a singleton string that contains only the provided character.\n\nExamples:\n* `'L'.toString = \"L\"`\n* `'\"'.toString = \"\\\"\"`\n</code>",
 "3555":
 "<code>self.val.isValidChar</code><span class=\"sep\"></span><code class=\"docstring\">The value must be a legal scalar value. </code>",
 "3554":
 "<code>UInt32</code><span class=\"sep\"></span><code class=\"docstring\">The underlying Unicode scalar value as a `UInt32`. </code>",
 "3553": "<code>Float32</code>",
 "3552": "<code>Float</code>",
 "3551": "<code>?m.3131</code>",
 "3550": "<code>?m.2349</code>",
 "355":
 "<code>Or.rec {a b : Prop} {motive : a ∨ b → Prop} (inl : ∀ (h : a), motive ⋯) (inr : ∀ (h : b), motive ⋯) (t : a ∨ b) :\n  motive t</code>",
 "3549": "<code>?m.2328</code>",
 "3548": "<code>?m.2601</code>",
 "3547": "<code>?m.2124</code>",
 "3546": "<code>?m.1324</code>",
 "3545": "<code>?m.1303</code>",
 "3544": "<code>?m.1585</code>",
 "3543":
 "<code>Float32.toUInt32 : Float32 → UInt32</code><span class=\"sep\"></span><code class=\"docstring\">If the given float is non-negative, truncates the value to the nearest non-negative integer.\nIf negative or NaN, returns `0`.\nIf larger than the maximum value for `UInt32` (including Inf), returns the maximum value of `UInt32`\n(i.e. `UInt32.size - 1`).\n</code>",
 "3542":
 "<code>Float.toUInt64 : Float → UInt64</code><span class=\"sep\"></span><code class=\"docstring\">If the given float is non-negative, truncates the value to the nearest non-negative integer.\nIf negative or NaN, returns `0`.\nIf larger than the maximum value for `UInt64` (including Inf), returns the maximum value of `UInt64`\n(i.e. `UInt64.size - 1`).\n</code>",
 "3541": "<code>pos0 : Float</code>",
 "3540": "<code>neg0 : Float</code>",
 "354": "<code>a ∧ b</code>",
 "3539":
 "<code>Float.zero_eq_zero_plus_zero : (0.0 == 0.0 + 0.0) = true</code>",
 "3538": "<code>float32Spec : FloatSpec</code>",
 "3537": "<code>float32Spec.float</code>",
 "3536": "<code>Float32.mk (val : float32Spec.float) : Float32</code>",
 "3535": "<code>FloatSpec.float (self : FloatSpec) : Type</code>",
 "3534": "<code>floatSpec : FloatSpec</code>",
 "3533": "<code>floatSpec.float</code>",
 "3532": "<code>Float.mk (val : floatSpec.float) : Float</code>",
 "3531": "<code>?m.11942</code>",
 "3530":
 "<code>BitVec.sshiftRight {n : Nat} (x : BitVec n) (s : Nat) : BitVec n</code><span class=\"sep\"></span><code class=\"docstring\">Arithmetic right shift for bit vectors. The high bits are filled with the\nmost-significant bit.\nAs a numeric operation, this is equivalent to `x.toInt &gt;&gt;&gt; s`.\n\nSMT-LIB name: `bvashr` except this operator uses a `Nat` shift value.\n</code>",
 "353":
 "<code>And.intro {a b : Prop} (left : a) (right : b) : a ∧ b</code><span class=\"sep\"></span><code class=\"docstring\">`And.intro : a → b → a ∧ b` is the constructor for the And operation. </code>",
 "3529": "<code>BitVec w₂</code>",
 "3528": "<code>BitVec w₁</code>",
 "3527":
 "<code>BitVec.DivModState (w : Nat) : Type</code><span class=\"sep\"></span><code class=\"docstring\">`DivModState` is a structure that maintains the state of recursive `divrem` calls. </code>",
 "3526": "<code>BitVec.DivModState w</code>",
 "3525":
 "<code>BitVec.DivModArgs (w : Nat) : Type</code><span class=\"sep\"></span><code class=\"docstring\">`DivModArgs` contains the arguments to a `divrem` call which remain constant throughout\nexecution. </code>",
 "3524": "<code>BitVec.DivModArgs w</code>",
 "3523": "<code>?m.10345</code>",
 "3522": "<code>?m.10248</code>",
 "3521": "<code>?m.10279</code>",
 "3520": "<code>Fin w → α → α × Bool</code>",
 "352": "<code>b</code>",
 "3519": "<code>?m.7118</code>",
 "3518":
 "<code>BitVec.toNat {n : Nat} (x : BitVec n) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Given a bitvector `x`, return the underlying `Nat`. This is O(1) because `BitVec` is a\n(zero-cost) wrapper around a `Nat`. </code>",
 "3517":
 "<code>BitVec.toInt {n : Nat} (x : BitVec n) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Interpret the bitvector as an integer stored in two's complement form. </code>",
 "3516": "<code>BitVec 4</code>",
 "3515": "<code>Fin w</code>",
 "3514":
 "<code>HMul.hMul.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMul α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.</code>",
 "3513": "<code>BitVec m</code>",
 "3512": "<code>n ≤ w</code>",
 "3511": "<code>BitVec w</code>",
 "3510":
 "<code>BitVec.shiftConcat {n : Nat} (x : BitVec n) (b : Bool) : BitVec n</code><span class=\"sep\"></span><code class=\"docstring\">`x.shiftConcat b` shifts all bits of `x` to the left by `1` and sets the least significant bit to `b`.\nIt is a non-dependent version of `concat` that does not change the total bitwidth.\n</code>",
 "351": "<code>a</code>",
 "3509":
 "<code>mixHash (u₁ u₂ : UInt64) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">An opaque hash mixing operation, used to implement hashing for products. </code>",
 "3508": "<code>i &lt; 2 ^ n</code>",
 "3507": "<code>List Bool</code>",
 "3506": "<code>BitVec n</code>",
 "3505":
 "<code>BitVec.ofNat (n i : Nat) : BitVec n</code><span class=\"sep\"></span><code class=\"docstring\">The `BitVec` with value `i mod 2^n`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `0#n` in identifiers is `zero` (not `ofNat_zero`).\n\n * The recommended spelling of `1#n` in identifiers is `one` (not `ofNat_one`).</code>",
 "3504":
 "<code>HShiftRight.hShiftRight.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HShiftRight α β γ] :\n  α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &gt;&gt;&gt; b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;&gt;` in identifiers is `shiftRight`.</code>",
 "3503": "<code>popcount_correct : popcount = popcount_spec</code>",
 "3502": "<code>popcount_spec (x : BitVec 32) : BitVec 32</code>",
 "3501": "<code>popcount (x : BitVec 32) : BitVec 32</code>",
 "3500":
 "<code>HPow.hPow.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HPow α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.</code>",
 "350": "<code>(left : a) → (right : b) → motive ⋯</code>",
 "35":
 "<code>Lean.SourceInfo.none : SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">A synthesized token without position information. </code>",
 "3499":
 "<code>Fin (2 ^ w)</code><span class=\"sep\"></span><code class=\"docstring\">Interpret a bitvector as a number less than `2^w`.\nO(1), because we use `Fin` as the internal representation of a bitvector. </code>",
 "3498":
 "<code>BitVec.ofFin {w : Nat} (toFin : Fin (2 ^ w)) : BitVec w</code><span class=\"sep\"></span><code class=\"docstring\">Construct a `BitVec w` from a number less than `2^w`.\nO(1), because we use `Fin` as the internal representation of a bitvector. </code>",
 "3497": "<code>Fin UInt64.size</code>",
 "3496": "<code>Fin UInt32.size</code>",
 "3495": "<code>Fin UInt16.size</code>",
 "3494": "<code>Fin UInt8.size</code>",
 "3493": "<code>Fin USize.size</code>",
 "3492": "<code>BitVec 16</code>",
 "3491": "<code>BitVec 8</code>",
 "3490": "<code>BitVec System.Platform.numBits</code>",
 "349": "<code>a ∧ b → Sort u</code>",
 "3489":
 "<code>UInt64.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The size of type `UInt64`, that is, `2^64 = 18446744073709551616`. </code>",
 "3488": "<code>n &lt; UInt64.size</code>",
 "3487":
 "<code>UInt32.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The size of type `UInt32`, that is, `2^32 = 4294967296`. </code>",
 "3486": "<code>n &lt; UInt32.size</code>",
 "3485":
 "<code>UInt16.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The size of type `UInt16`, that is, `2^16 = 65536`. </code>",
 "3484": "<code>n &lt; UInt16.size</code>",
 "3483":
 "<code>UInt8.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The size of type `UInt8`, that is, `2^8 = 256`. </code>",
 "3482": "<code>n &lt; UInt8.size</code>",
 "3481": "<code>n &lt; USize.size</code>",
 "3480":
 "<code>USize.size : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The size of type `USize`, that is, `2^System.Platform.numBits`. </code>",
 "348":
 "<code>And.rec.{u} {a b : Prop} {motive : a ∧ b → Sort u} (intro : (left : a) → (right : b) → motive ⋯) (t : a ∧ b) : motive t</code>",
 "3479": "<code>n &lt; 4294967296</code>",
 "3478":
 "<code>Int64.ofNat (n : Nat) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 64-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Int64.ofNat 127 = 127`\n * `Int64.ofNat 2_147_483_648 = 2_147_483_648`\n * `Int64.ofNat 9_223_372_036_854_775_807 = 9_223_372_036_854_775_807`\n * `Int64.ofNat 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n * `Int64.ofNat 18_446_744_073_709_551_618 = 0`\n</code>",
 "3477":
 "<code>UInt64.ofNat (n : Nat) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 64-bit unsigned integer, wrapping on overflow.\n\nExamples:\n* `UInt64.ofNat 5 = 5`\n* `UInt64.ofNat 65539 = 65539`\n* `UInt64.ofNat 4_294_967_299 = 4_294_967_299`\n* `UInt64.ofNat 18_446_744_073_709_551_620 = 4`\n</code>",
 "3476":
 "<code>Int32.ofNat (n : Nat) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 32-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Int32.ofNat 127 = 127`\n * `Int32.ofNat 32770 = 32770`\n * `Int32.ofNat 2_147_483_647 = 2_147_483_647`\n * `Int32.ofNat 2_147_483_648 = -2_147_483_648`\n</code>",
 "3475":
 "<code>UInt32.ofNat (n : Nat) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 32-bit unsigned integer, wrapping on overflow.\n\nExamples:\n* `UInt32.ofNat 5 = 5`\n* `UInt32.ofNat 65539 = 65539`\n* `UInt32.ofNat 4_294_967_299 = 3`\n</code>",
 "3474":
 "<code>Int16.ofNat (n : Nat) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 16-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Int16.ofNat 127 = 127`\n * `Int16.ofNat 32767 = 32767`\n * `Int16.ofNat 32768 = -32768`\n * `Int16.ofNat 32770 = -32766`\n</code>",
 "3473":
 "<code>UInt16.ofNat (n : Nat) : UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 16-bit unsigned integer, wrapping on overflow.\n\nExamples:\n* `UInt16.ofNat 5 = 5`\n* `UInt16.ofNat 255 = 255`\n* `UInt16.ofNat 32770 = 32770`\n* `UInt16.ofNat 65537 = 1`\n</code>",
 "3472":
 "<code>Int8.ofNat (n : Nat) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to an 8-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Int8.ofNat 53 = 53`\n * `Int8.ofNat 127 = 127`\n * `Int8.ofNat 128 = -128`\n * `Int8.ofNat 255 = -1`\n</code>",
 "3471":
 "<code>UInt8.ofNat (n : Nat) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to an 8-bit unsigned integer, wrapping on overflow.\n\nExamples:\n* `UInt8.ofNat 5 = 5`\n* `UInt8.ofNat 255 = 255`\n* `UInt8.ofNat 256 = 0`\n* `UInt8.ofNat 259 = 3`\n* `UInt8.ofNat 32770 = 2`\n</code>",
 "3470":
 "<code>Int64.maxValue : Int64</code><span class=\"sep\"></span><code class=\"docstring\">The maximum value an `Int64` may attain, that is, `2^63 - 1 = 9223372036854775807`. </code>",
 "347":
 "<code>And (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.\n\n * The recommended spelling of `/\\` in identifiers is `and` (prefer `∧` over `/\\`).</code>",
 "3469": "<code>i ≤ Int64.maxValue.toInt</code>",
 "3468": "<code>Int64.toInt (i : Int64) : Int</code>",
 "3467":
 "<code>Int64.minValue : Int64</code><span class=\"sep\"></span><code class=\"docstring\">The minimum value an `Int64` may attain, that is, `-2^63 = -9223372036854775808`. </code>",
 "3466": "<code>Int64.minValue.toInt ≤ i</code>",
 "3465":
 "<code>Int32.maxValue : Int32</code><span class=\"sep\"></span><code class=\"docstring\">The maximum value an `Int32` may attain, that is, `2^31 - 1 = 2147483647`. </code>",
 "3464": "<code>i ≤ Int32.maxValue.toInt</code>",
 "3463": "<code>Int32.toInt (i : Int32) : Int</code>",
 "3462":
 "<code>Int32.minValue : Int32</code><span class=\"sep\"></span><code class=\"docstring\">The minimum value an `Int32` may attain, that is, `-2^31 = -2147483648`. </code>",
 "3461": "<code>Int32.minValue.toInt ≤ i</code>",
 "3460":
 "<code>Int16.maxValue : Int16</code><span class=\"sep\"></span><code class=\"docstring\">The maximum value an `Int16` may attain, that is, `2^15 - 1 = 32767`. </code>",
 "346": "<code>False</code>",
 "3459": "<code>i ≤ Int16.maxValue.toInt</code>",
 "3458": "<code>Int16.toInt (i : Int16) : Int</code>",
 "3457":
 "<code>Int16.minValue : Int16</code><span class=\"sep\"></span><code class=\"docstring\">The minimum value an `Int16` may attain, that is, `-2^15 = -32768`. </code>",
 "3456": "<code>Int16.minValue.toInt ≤ i</code>",
 "3455":
 "<code>Int8.maxValue : Int8</code><span class=\"sep\"></span><code class=\"docstring\">The maximum value an `Int8` may attain, that is, `2^7 - 1 = 127`. </code>",
 "3454": "<code>i ≤ Int8.maxValue.toInt</code>",
 "3453": "<code>Int8.toInt (i : Int8) : Int</code>",
 "3452":
 "<code>Int8.minValue : Int8</code><span class=\"sep\"></span><code class=\"docstring\">The minimum value an `Int8` may attain, that is, `-2^7 = -128`. </code>",
 "3451": "<code>Int8.minValue.toInt ≤ i</code>",
 "3450":
 "<code>ISize.maxValue : ISize</code><span class=\"sep\"></span><code class=\"docstring\">The maximum value an `ISize` may attain, that is, `2^(System.Platform.numBits - 1) - 1`. </code>",
 "345": "<code>False → Sort u</code>",
 "3449": "<code>i ≤ ISize.maxValue.toInt</code>",
 "3448": "<code>ISize.toInt (i : ISize) : Int</code>",
 "3447":
 "<code>ISize.minValue : ISize</code><span class=\"sep\"></span><code class=\"docstring\">The minimum value an `ISize` may attain, that is, `-2^(System.Platform.numBits - 1)`. </code>",
 "3446": "<code>ISize.minValue.toInt ≤ i</code>",
 "3445":
 "<code>Int64.ofInt (i : Int) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 64-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int64.ofInt 48 = 48`\n* `Int64.ofInt (-40_000) = -40_000`\n* `Int64.ofInt 2_147_483_648 = 2_147_483_648`\n* `Int64.ofInt (-2_147_483_649) = -2_147_483_649`\n* `Int64.ofInt 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n* `Int64.ofInt (-9_223_372_036_854_775_809) = 9_223_372_036_854_775_807`\n</code>",
 "3444":
 "<code>Int32.ofInt (i : Int) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 32-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int32.ofInt 48 = 48`\n* `Int32.ofInt (-129) = -129`\n* `Int32.ofInt 70000 = 70000`\n* `Int32.ofInt (-40000) = -40000`\n* `Int32.ofInt 2147483648 = -2147483648`\n* `Int32.ofInt (-2147483649) = 2147483647`\n</code>",
 "3443":
 "<code>Int16.ofInt (i : Int) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 16-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int16.ofInt 48 = 48`\n* `Int16.ofInt (-129) = -129`\n* `Int16.ofInt (128) = 128`\n* `Int16.ofInt 70000 = 4464`\n* `Int16.ofInt (-40000) = 25536`\n</code>",
 "3442":
 "<code>Int8.ofInt (i : Int) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to an 8-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int8.ofInt 48 = 48`\n* `Int8.ofInt (-115) = -115`\n* `Int8.ofInt (-129) = 127`\n* `Int8.ofInt (128) = -128`\n</code>",
 "3441": "<code>ISize</code>",
 "3440":
 "<code>Permissions.mk (readable writable executable : Bool) : Permissions</code>",
 "344":
 "<code>False.rec.{u} (motive : False → Sort u) (t : False) : motive t</code>",
 "3439": "<code>Permissions.decode (i : UInt8) : Permissions</code>",
 "3438": "<code>Permissions</code>",
 "3437": "<code>Permissions.encode (p : Permissions) : UInt8</code>",
 "3436": "<code>Permissions.executable (self : Permissions) : Bool</code>",
 "3435": "<code>Permissions.writable (self : Permissions) : Bool</code>",
 "3434": "<code>Permissions.readable (self : Permissions) : Bool</code>",
 "3433": "<code>Permissions : Type</code>",
 "3432":
 "<code>UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `UInt64` that is 2's complement equivalent to the `Int64`.\n</code>",
 "3431":
 "<code>UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `UInt32` that is 2's complement equivalent to the `Int32`.\n</code>",
 "3430":
 "<code>UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `UInt16` that is 2's complement equivalent to the `Int16`.\n</code>",
 "343": "<code>True</code>",
 "3429":
 "<code>UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `UInt8` that is 2's complement equivalent to the `Int8`.\n</code>",
 "3428":
 "<code>USize</code><span class=\"sep\"></span><code class=\"docstring\">Obtain the `USize` that is 2's complement equivalent to the `ISize`.\n</code>",
 "3427":
 "<code>BitVec 64</code><span class=\"sep\"></span><code class=\"docstring\">Unpack a `UInt64` as a `BitVec 64`. This function is overridden with a native implementation.\n</code>",
 "3426":
 "<code>UInt64.ofBitVec (toBitVec : BitVec 64) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Create a `UInt64` from a `BitVec 64`. This function is overridden with a native implementation.\n</code>",
 "3425":
 "<code>BitVec 32</code><span class=\"sep\"></span><code class=\"docstring\">Unpack a `UInt32` as a `BitVec 32`. This function is overridden with a native implementation.\n</code>",
 "3424":
 "<code>UInt32.ofBitVec (toBitVec : BitVec 32) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Create a `UInt32` from a `BitVec 32`. This function is overridden with a native implementation.\n</code>",
 "3423":
 "<code>BitVec 16</code><span class=\"sep\"></span><code class=\"docstring\">Unpack a `UInt16` as a `BitVec 16`. This function is overridden with a native implementation.\n</code>",
 "3422":
 "<code>UInt16.ofBitVec (toBitVec : BitVec 16) : UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Create a `UInt16` from a `BitVec 16`. This function is overridden with a native implementation.\n</code>",
 "3421":
 "<code>BitVec 8</code><span class=\"sep\"></span><code class=\"docstring\">Unpack a `UInt8` as a `BitVec 8`. This function is overridden with a native implementation.\n</code>",
 "3420":
 "<code>UInt8.ofBitVec (toBitVec : BitVec 8) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Create a `UInt8` from a `BitVec 8`. This function is overridden with a native implementation.\n</code>",
 "342":
 "<code>True.intro : True</code><span class=\"sep\"></span><code class=\"docstring\">`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. </code>",
 "3419":
 "<code>BitVec System.Platform.numBits</code><span class=\"sep\"></span><code class=\"docstring\">Unpack a `USize` as a `BitVec System.Platform.numBits`. This function is overridden with a native\nimplementation.\n</code>",
 "3418":
 "<code>System.Platform.numBits : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The word size of the current platform, which may be 64 or 32 bits.\n</code>",
 "3417":
 "<code>USize.ofBitVec (toBitVec : BitVec System.Platform.numBits) : USize</code><span class=\"sep\"></span><code class=\"docstring\">Create a `USize` from a `BitVec System.Platform.numBits`. This function is overridden with a\nnative implementation.\n</code>",
 "3416":
 "<code>Fin.succRec.{u_1} {motive : (n : Nat) → Fin n → Sort u_1} (zero : (n : Nat) → motive n.succ 0)\n  (succ : (n : Nat) → (i : Fin n) → motive n i → motive n.succ i.succ) {n : Nat} (i : Fin n) : motive n i</code><span class=\"sep\"></span><code class=\"docstring\">An induction principle for `Fin` that considers a given `i : Fin n` as given by a sequence of `i`\napplications of `Fin.succ`.\n\nThe cases in the induction are:\n * `zero` demonstrates the motive for `(0 : Fin (n + 1))` for all bounds `n`\n * `succ` demonstrates the motive for `Fin.succ` applied to an arbitrary `Fin` for an arbitrary\n   bound `n`\n\nUnlike `Fin.induction`, the motive quantifies over the bound, and the bound varies at each inductive\nstep. `Fin.succRecOn` is a version of this induction principle that takes the `Fin` argument first.\n</code>",
 "3415": "<code>(n : Nat) → motive (n + 1) 0</code>",
 "3414":
 "<code>Fin.succRecOn.{u_1} {n : Nat} (i : Fin n) {motive : (n : Nat) → Fin n → Sort u_1} (zero : (n : Nat) → motive (n + 1) 0)\n  (succ : (n : Nat) → (i : Fin n) → motive n i → motive n.succ i.succ) : motive n i</code><span class=\"sep\"></span><code class=\"docstring\">An induction principle for `Fin` that considers a given `i : Fin n` as given by a sequence of `i`\napplications of `Fin.succ`.\n\nThe cases in the induction are:\n * `zero` demonstrates the motive for `(0 : Fin (n + 1))` for all bounds `n`\n * `succ` demonstrates the motive for `Fin.succ` applied to an arbitrary `Fin` for an arbitrary\n   bound `n`\n\nUnlike `Fin.induction`, the motive quantifies over the bound, and the bound varies at each inductive\nstep. `Fin.succRec` is a version of this induction principle that takes the `Fin` argument last.\n</code>",
 "3413":
 "<code>(n : Nat) → (i : Fin n) → motive n i → motive n.succ i.succ</code>",
 "3412": "<code>(n : Nat) → motive n.succ 0</code>",
 "3411": "<code>(n : Nat) → Fin n → Sort u_1</code>",
 "3410": "<code>Fin (m + n)</code>",
 "341": "<code>motive True.intro</code>",
 "3409": "<code>(i : Fin n) → motive (Fin.natAdd m i)</code>",
 "3408": "<code>(i : Fin m) → motive (Fin.castAdd n i)</code>",
 "3407": "<code>Fin (m + n) → Sort u</code>",
 "3406": "<code>(i : Fin n) → motive i.castSucc</code>",
 "3405": "<code>(i : Fin n) → motive i.succ</code>",
 "3404": "<code>(i : Fin n) → motive i.succ → motive i.castSucc</code>",
 "3403": "<code>motive (Fin.last n)</code>",
 "3402":
 "<code>Fin.induction.{u_1} {n : Nat} {motive : Fin (n + 1) → Sort u_1} (zero : motive 0)\n  (succ : (i : Fin n) → motive i.castSucc → motive i.succ) (i : Fin (n + 1)) : motive i</code><span class=\"sep\"></span><code class=\"docstring\">Proves a statement by induction on the underlying `Nat` value in a `Fin (n + 1)`.\n\nFor the induction:\n * `zero` is the base case, demonstrating `motive 0`.\n * `succ` is the inductive step, assuming the motive for `i : Fin n` (lifted to `Fin (n + 1)` with\n   `Fin.castSucc`) and demonstrating it for `i.succ`.\n\n`Fin.inductionOn` is a version of this induction principle that takes the `Fin` as its first\nparameter, `Fin.cases` is the corresponding case analysis operator, and `Fin.reverseInduction` is a\nversion that starts at the greatest value instead of `0`.\n</code>",
 "3401":
 "<code>Fin.reverseInduction.{u_1} {n : Nat} {motive : Fin (n + 1) → Sort u_1} (last : motive (Fin.last n))\n  (cast : (i : Fin n) → motive i.succ → motive i.castSucc) (i : Fin (n + 1)) : motive i</code><span class=\"sep\"></span><code class=\"docstring\">Proves a statement by reverse induction on the underlying `Nat` value in a `Fin (n + 1)`.\n\nFor the induction:\n* `last` is the base case, demonstrating `motive (Fin.last n)`.\n* `cast` is the inductive step, assuming the motive for `(j : Fin n).succ` and demonstrating it for\n   the predecessor `j.castSucc`.\n\n`Fin.induction` is the non-reverse induction principle.\n</code>",
 "3400":
 "<code>Fin.cases.{u_1} {n : Nat} {motive : Fin (n + 1) → Sort u_1} (zero : motive 0) (succ : (i : Fin n) → motive i.succ)\n  (i : Fin (n + 1)) : motive i</code><span class=\"sep\"></span><code class=\"docstring\">Proves a statement by cases on the underlying `Nat` value in a `Fin (n + 1)`.\n\nThe two cases are:\n* `zero`, used when the value is of the form `(0 : Fin (n + 1))`\n* `succ`, used when the value is of the form `(j : Fin n).succ`\n\nThe corresponding induction principle is `Fin.induction`.\n</code>",
 "340": "<code>True → Sort u</code>",
 "34":
 "<code>Lean.SourceInfo.synthetic (pos endPos : String.Pos) (canonical : Bool := false) : SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">Synthetic syntax is syntax that was produced by a metaprogram or by Lean itself (e.g. by a\nquotation). Synthetic syntax is annotated with a source span from the original syntax, which\nrelates it to the source file.\n\nThe delaborator uses this constructor to store an encoded indicator of which core language\nexpression gave rise to the syntax.\n\nThe `canonical` flag on synthetic syntax is enabled for syntax that is not literally part of the\noriginal input syntax but should be treated “as if” the user really wrote it for the purpose of\nhovers and error messages. This is usually used on identifiers in order to connect the binding\nsite to the user's original syntax even if the name of the identifier changes during expansion, as\nwell as on tokens that should receive targeted messages.\n\nGenerally speaking, a macro expansion should only use a given piece of input syntax in a single\ncanonical token. An exception to this rule is when the same identifier is used to declare two\nbinders, as in the macro expansion for dependent if:\n```\n`(if $h : $cond then $t else $e) ~&gt;\n`(dite $cond (fun $h =&gt; $t) (fun $h =&gt; $t))\n```\nIn these cases, if the user hovers over `h` they will see information about both binding sites.\n</code>",
 "3399":
 "<code>Fin.inductionOn.{u_1} {n : Nat} (i : Fin (n + 1)) {motive : Fin (n + 1) → Sort u_1} (zero : motive 0)\n  (succ : (i : Fin n) → motive i.castSucc → motive i.succ) : motive i</code><span class=\"sep\"></span><code class=\"docstring\">Proves a statement by induction on the underlying `Nat` value in a `Fin (n + 1)`.\n\nFor the induction:\n * `zero` is the base case, demonstrating `motive 0`.\n * `succ` is the inductive step, assuming the motive for `i : Fin n` (lifted to `Fin (n + 1)` with\n   `Fin.castSucc`) and demonstrating it for `i.succ`.\n\n`Fin.induction` is a version of this induction principle that takes the `Fin` as its last\nparameter.\n</code>",
 "3398":
 "<code>Fin.castSucc {n : Nat} : Fin n → Fin (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">Coarsens a bound by one.\n</code>",
 "3397": "<code>(i : Fin n) → motive i.castSucc → motive i.succ</code>",
 "3396": "<code>Fin (n + 1) → Sort u_1</code>",
 "3395": "<code>P i</code>",
 "3394": "<code>i ≤ n</code>",
 "3393":
 "<code>Fin.hIterateFrom.{u_1} (P : Nat → Sort u_1) {n : Nat} (f : (i : Fin n) → P ↑i → P (↑i + 1)) (i : Nat) (ubnd : i ≤ n)\n  (a : P i) : P n</code><span class=\"sep\"></span><code class=\"docstring\">Applies an index-dependent function `f` to all of the values in `[i:n]`, starting at `i` with an\ninitial accumulator `a`.\n\nConcretely, `Fin.hIterateFrom P f i a` is equal to\n```lean\n  a |&gt; f i |&gt; f (i + 1) |&gt; ... |&gt; f (n - 1)\n```\n\nTheorems about `Fin.hIterateFrom` can be proven using the general theorem `Fin.hIterateFrom_elim` or\nother more specialized theorems.\n\n`Fin.hIterate` is a variant that always starts at `0`.\n</code>",
 "3392":
 "<code>Fin.hIterate_elim.{u_1} {P : Nat → Sort u_1} (Q : (i : Nat) → P i → Prop) {n : Nat}\n  (f : (i : Fin n) → P ↑i → P (↑i + 1)) (s : P 0) (init : Q 0 s)\n  (step : ∀ (k : Fin n) (s : P ↑k), Q (↑k) s → Q (↑k + 1) (f k s)) : Q n (Fin.hIterate P s f)</code>",
 "3391":
 "<code>Fin.hIterate.{u_1} (P : Nat → Sort u_1) {n : Nat} (init : P 0) (f : (i : Fin n) → P ↑i → P (↑i + 1)) : P n</code><span class=\"sep\"></span><code class=\"docstring\">Applies an index-dependent function to all the values less than the given bound `n`, starting at\n`0` with an accumulator.\n\nConcretely, `Fin.hIterate P init f` is equal to\n```lean\n  init |&gt; f 0 |&gt; f 1 |&gt; ... |&gt; f (n-1)\n```\n\nTheorems about `Fin.hIterate` can be proven using the general theorem `Fin.hIterate_elim` or other more\nspecialized theorems.\n\n`Fin.hIterateFrom` is a variant that takes a custom starting value instead of `0`.\n </code>",
 "3390": "<code>(i : Fin n) → P ↑i → P (↑i + 1)</code>",
 "339":
 "<code>True.rec.{u} {motive : True → Sort u} (intro : motive True.intro) (t : True) : motive t</code>",
 "3389": "<code>P 0</code>",
 "3388": "<code>Nat → Sort u_1</code>",
 "3387": "<code>α → Fin n → m α</code>",
 "3386":
 "<code>Fin.foldl.{u_1} {α : Sort u_1} (n : Nat) (f : α → Fin n → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Combine all the values that can be represented by `Fin n` with an initial value, starting at `0` and\nnesting to the left.\n\nExample:\n * `Fin.foldl 3 (· + ·.val) (0 : Nat) = ((0 + (0 : Fin 3).val) + (1 : Fin 3).val) + (2 : Fin 3).val`\n</code>",
 "3385": "<code>α → Fin n → α</code>",
 "3384": "<code>Fin n → α → m α</code>",
 "3383":
 "<code>Fin.foldr.{u_1} {α : Sort u_1} (n : Nat) (f : Fin n → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Combine all the values that can be represented by `Fin n` with an initial value, starting at `n - 1`\nand nesting to the right.\n\nExample:\n * `Fin.foldr 3 (·.val + ·) (0 : Nat) = (0 : Fin 3).val + ((1 : Fin 3).val + ((2 : Fin 3).val + 0))`\n</code>",
 "3382": "<code>Fin n → α → α</code>",
 "3381":
 "<code>Empty.elim.{u} {C : Sort u} : Empty → C</code><span class=\"sep\"></span><code class=\"docstring\">`Empty.elim : Empty → C` says that a value of any type can be constructed from\n`Empty`. This can be thought of as a compiler-checked assertion that a code path is unreachable.\n</code>",
 "3380":
 "<code>Fin.rev {n : Nat} (i : Fin n) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">Replaces a value with its difference from the largest value in the type.\n\nConsidering the values of `Fin n` as a sequence `0`, `1`, …, `n-2`, `n-1`, `Fin.rev` finds the\ncorresponding element of the reversed sequence. In other words, it maps `0` to `n-1`, `1` to `n-2`,\n..., and `n-1` to `0`.\n\nExamples:\n * `(5 : Fin 6).rev = (0 : Fin 6)`\n * `(0 : Fin 6).rev = (5 : Fin 6)`\n * `(2 : Fin 5).rev = (2 : Fin 5)`\n</code>",
 "338": "<code>EvenOddList α isEven</code>",
 "3379":
 "<code>Fin.castLE {n m : Nat} (h : n ≤ m) (i : Fin n) : Fin m</code><span class=\"sep\"></span><code class=\"docstring\">Coarsens a bound to one at least as large.\n\nSee also `Fin.castAdd` for a version that represents the larger bound with addition rather than an\nexplicit inequality proof.\n</code>",
 "3378":
 "<code>Fin.castAdd {n : Nat} (m : Nat) : Fin n → Fin (n + m)</code><span class=\"sep\"></span><code class=\"docstring\">Coarsens a bound to one at least as large.\n\nSee also `Fin.natAdd` and `Fin.addNat` for addition functions that increase the bound, and\n`Fin.castLE` for a version that uses an explicit inequality proof.\n</code>",
 "3377": "<code>n ≤ m</code>",
 "3376": "<code>val✝ &lt; 10</code>",
 "3375":
 "<code>Fin.castLT {n m : Nat} (i : Fin m) (h : ↑i &lt; n) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the bound with another that is suitable for the value.\n\nThe proof embedded in `i` can be used to cast to a larger bound even if the concrete value is not\nknown.\n\nExamples:\n```lean example\nexample : Fin 12 := (7 : Fin 10).castLT (by decide : 7 &lt; 12)\n```\n```lean example\nexample (i : Fin 10) : Fin 12 :=\n  i.castLT &lt;| by\n    cases i; simp; omega\n```\n</code>",
 "3374": "<code>↑i &lt; n</code>",
 "3373":
 "<code>Fin.cast {n m : Nat} (eq : n = m) (i : Fin n) : Fin m</code><span class=\"sep\"></span><code class=\"docstring\">Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other.\n\nIn other words, when `eq : n = m`, `Fin.cast eq i` converts `i : Fin n` into a `Fin m`.\n</code>",
 "3372": "<code>n = m</code>",
 "3371": "<code>Fin 17</code>",
 "3370": "<code>Fin 16</code>",
 "337":
 "<code>{isEven : Bool} →\n  (head : α) → (tail : EvenOddList α isEven) → motive isEven tail → motive (!isEven) (EvenOddList.cons head tail)</code>",
 "3369":
 "<code>Xor.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HXor`: `a ^^^ b : α` where `a b : α`. </code>",
 "3368":
 "<code>OrOp.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HOr`: `a ||| b : α` where `a b : α`.\n(It is called `OrOp` because `Or` is taken for the propositional connective.)\n</code>",
 "3367":
 "<code>AndOp.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAnd`: `a &&& b : α` where `a b : α`.\n(It is called `AndOp` because `And` is taken for the propositional connective.)\n</code>",
 "3366":
 "<code>ShiftRight.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HShiftRight`: `a &gt;&gt;&gt; b : α` where `a b : α`. </code>",
 "3365":
 "<code>ShiftLeft.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HShiftLeft`: `a &lt;&lt;&lt; b : α` where `a b : α`. </code>",
 "3364":
 "<code>Fin.log2 {m : Nat} (n : Fin m) : Fin m</code><span class=\"sep\"></span><code class=\"docstring\">Logarithm base 2 for bounded numbers.\n\nThe resulting value is the same as that computed by `Nat.log2`. In particular, the result for `0` is\n`0`.\n\nExamples:\n * `(8 : Fin 10).log2 = (3 : Fin 10)`\n * `(7 : Fin 10).log2 = (2 : Fin 10)`\n * `(4 : Fin 10).log2 = (2 : Fin 10)`\n * `(3 : Fin 10).log2 = (1 : Fin 10)`\n * `(1 : Fin 10).log2 = (0 : Fin 10)`\n * `(0 : Fin 10).log2 = (0 : Fin 10)`\n</code>",
 "3363": "<code>Fin 6</code>",
 "3362":
 "<code>Fin.subNat {n : Nat} (m : Nat) (i : Fin (n + m)) (h : m ≤ ↑i) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">Subtraction of a natural number from a `Fin`, with the bound narrowed.\n\nThis is a generalization of `Fin.pred`. It is guaranteed to not underflow or wrap around.\n\nExamples:\n* `(5 : Fin 9).subNat 2 (by decide) = (3 : Fin 7)`\n* `(5 : Fin 9).subNat 0 (by decide) = (5 : Fin 9)`\n* `(3 : Fin 9).subNat 3 (by decide) = (0 : Fin 6)`\n</code>",
 "3361": "<code>m ≤ ↑i</code>",
 "3360": "<code>Fin (n + m)</code>",
 "336": "<code>motive true EvenOddList.nil</code>",
 "3359": "<code>Fin 9</code>",
 "3358": "<code>Fin 11</code>",
 "3357":
 "<code>Fin.addNat {n : Nat} (i : Fin n) (m : Nat) : Fin (n + m)</code><span class=\"sep\"></span><code class=\"docstring\">Adds a natural number to a `Fin`, increasing the bound.\n\nThis is a generalization of `Fin.succ`.\n\n`Fin.natAdd` is a version of this function that takes its `Nat` parameter first.\n\nExamples:\n* `Fin.addNat (5 : Fin 8) 3 = (8 : Fin 11)`\n* `Fin.addNat (0 : Fin 8) 1 = (1 : Fin 9)`\n* `Fin.addNat (1 : Fin 8) 2 = (3 : Fin 10)`\n\n</code>",
 "3356": "<code>Fin m</code>",
 "3355":
 "<code>Fin.natAdd {m : Nat} (n : Nat) (i : Fin m) : Fin (n + m)</code><span class=\"sep\"></span><code class=\"docstring\">Adds a natural number to a `Fin`, increasing the bound.\n\nThis is a generalization of `Fin.succ`.\n\n`Fin.addNat` is a version of this function that takes its `Nat` parameter second.\n\nExamples:\n* `Fin.natAdd 3 (5 : Fin 8) = (8 : Fin 11)`\n* `Fin.natAdd 1 (0 : Fin 8) = (1 : Fin 9)`\n* `Fin.natAdd 1 (2 : Fin 8) = (3 : Fin 9)`\n</code>",
 "3354": "<code>Fin 1</code>",
 "3353":
 "<code>Fin.pred {n : Nat} (i : Fin (n + 1)) (h : i ≠ 0) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">The predecessor of a non-zero element of `Fin (n+1)`, with the bound decreased.\n\nExamples:\n* `(4 : Fin 8).pred (by decide) = (3 : Fin 7)`\n* `(1 : Fin 2).pred (by decide) = (0 : Fin 1)`\n</code>",
 "3352": "<code>Fin 8</code>",
 "3351": "<code>i ≠ 0</code>",
 "3350": "<code>Fin 4</code>",
 "335": "<code>(isEven : Bool) → EvenOddList α isEven → Sort u</code>",
 "3349":
 "<code>Fin.succ {n : Nat} : Fin n → Fin (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">The successor, with an increased bound.\n\nThis differs from adding `1`, which instead wraps around.\n\nExamples:\n* `(2 : Fin 3).succ = (3 : Fin 4)`\n* `(2 : Fin 3) + 1 = (0 : Fin 3)`\n</code>",
 "3348":
 "<code>Fin.last (n : Nat) : Fin (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">The greatest value of `Fin (n+1)`, namely `n`.\n\nExamples:\n* `Fin.last 4 = (4 : Fin 5)`\n* `(Fin.last 0).val = (0 : Nat)`\n</code>",
 "3347": "<code>Fin 0</code>",
 "3346":
 "<code>NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A type-class version of `n ≠ 0`.  </code>",
 "3345": "<code>Fin 20</code>",
 "3344": "<code>Fin 3</code>",
 "3343":
 "<code>↑self &lt; n</code><span class=\"sep\"></span><code class=\"docstring\">The number `val` is strictly less than the bound `n`.\n</code>",
 "3342":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The number that is strictly less than `n`.\n\n`Fin.val` is a coercion, so any `Fin n` can be used in a position where a `Nat` is expected.\n</code>",
 "3341": "<code>?m.34</code>",
 "3340":
 "<code>Int.NonNeg : Int → Prop</code><span class=\"sep\"></span><code class=\"docstring\">An integer is non-negative if it is equal to a natural number.\n</code>",
 "334":
 "<code>EvenOddList.rec.{u_1, u} {α : Type u} {motive : (a : Bool) → EvenOddList α a → Sort u_1}\n  (nil : motive true EvenOddList.nil)\n  (cons :\n    {isEven : Bool} →\n      (a : α) → (a_1 : EvenOddList α isEven) → motive isEven a_1 → motive (!isEven) (EvenOddList.cons a a_1))\n  {a✝ : Bool} (t : EvenOddList α a✝) : motive a✝ t</code>",
 "3339":
 "<code>Int.fmod : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer modulus using the F-rounding convention.\n\nIn the F-rounding convention (flooring division), `Int.fdiv x y` satisfies `Int.fdiv x y = ⌊x / y⌋`\nand `Int.fmod` is the unique function satisfying `Int.fmod x y + (Int.fdiv x y) * y = x`.\n\nExamples:\n\n* `(7 : Int).fmod (0 : Int) = 7`\n* `(0 : Int).fmod (7 : Int) = 0`\n\n* `(12 : Int).fmod (6 : Int) = 0`\n* `(12 : Int).fmod (-6 : Int) = 0`\n* `(-12 : Int).fmod (6 : Int) = 0`\n* `(-12 : Int).fmod (-6 : Int) = 0`\n\n* `(12 : Int).fmod (7 : Int) = 5`\n* `(12 : Int).fmod (-7 : Int) = -2`\n* `(-12 : Int).fmod (7 : Int) = 2`\n* `(-12 : Int).fmod (-7 : Int) = -5`\n\n</code>",
 "3338":
 "<code>Int.bmod (x : Int) (m : Nat) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Balanced modulus.\n\nThis version of integer modulus uses the balanced rounding convention, which guarantees that\n`-m / 2 ≤ Int.bmod x m &lt; m/2` for `m ≠ 0` and `Int.bmod x m` is congruent to `x` modulo `m`.\n\nIf `m = 0`, then `Int.bmod x m = x`.\n\nExamples:\n* `(7 : Int).bmod 0 = 7`\n* `(0 : Int).bmod 7 = 0`\n* `(12 : Int).bmod 6 = 0`\n* `(12 : Int).bmod 7 = -2`\n* `(12 : Int).bmod 8 = -4`\n* `(12 : Int).bmod 9 = 3`\n* `(-12 : Int).bmod 6 = 0`\n* `(-12 : Int).bmod 7 = 2`\n* `(-12 : Int).bmod 8 = -4`\n* `(-12 : Int).bmod 9 = -3`\n</code>",
 "3337":
 "<code>Int.tmod : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer modulo using the T-rounding convention.\n\nIn [the T-rounding convention][t-rounding] (division with truncation), all rounding is towards zero.\nDivision by 0 is defined to be 0 and `Int.tmod a 0 = a`.\n\nIn this convention, `Int.tmod a b + b * (Int.tdiv a b) = a`. Additionally,\n`Int.natAbs (Int.tmod a b) = Int.natAbs a % Int.natAbs b`, and when `b` does not divide `a`,\n`Int.tmod a b` has the same sign as `a`.\n\n[t-rounding]: https://dl.acm.org/doi/pdf/10.1145/128861.128862\n\nThis function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.\n\nExamples:\n* `(7 : Int).tmod (0 : Int) = 7`\n* `(0 : Int).tmod (7 : Int) = 0`\n* `(12 : Int).tmod (6 : Int) = 0`\n* `(12 : Int).tmod (-6 : Int) = 0`\n* `(-12 : Int).tmod (6 : Int) = 0`\n* `(-12 : Int).tmod (-6 : Int) = 0`\n* `(12 : Int).tmod (7 : Int) = 5`\n* `(12 : Int).tmod (-7 : Int) = 5`\n* `(-12 : Int).tmod (7 : Int) = -5`\n* `(-12 : Int).tmod (-7 : Int) = -5`\n</code>",
 "3336":
 "<code>Int.emod : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer modulus that uses the E-rounding convention. Usually accessed via the `%` operator.\n\nIn the E-rounding convention (Euclidean division), `Int.emod x y` satisfies `0 ≤ Int.emod x y &lt; Int.natAbs y`\nfor `y ≠ 0` and `Int.ediv` is the unique function satisfying `Int.emod x y + (Int.edivx y) * y = x`\nfor `y ≠ 0`.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n* `(7 : Int) % (0 : Int) = 7`\n* `(0 : Int) % (7 : Int) = 0`\n* `(12 : Int) % (6 : Int) = 0`\n* `(12 : Int) % (-6 : Int) = 0`\n* `(-12 : Int) % (6 : Int) = 0`\n* `(-12 : Int) % (-6 : Int) = 0`\n* `(12 : Int) % (7 : Int) = 5`\n* `(12 : Int) % (-7 : Int) = 5`\n* `(-12 : Int) % (7 : Int) = 2`\n* `(-12 : Int) % (-7 : Int) = 2`\n</code>",
 "3335":
 "<code>Mod.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HMod`: `a % b : α` where `a b : α`. </code>",
 "3334":
 "<code>Int.lcm (m n : Int) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the least common multiple of two integers as a natural number. The LCM of two integers is\nthe smallest natural number that's evenly divisible by the absolute values of both.\n\nExamples:\n * `Int.lcm 9 6 = 18`\n * `Int.lcm 9 (-6) = 18`\n * `Int.lcm 9 3 = 9`\n * `Int.lcm 9 (-3) = 9`\n * `Int.lcm 0 3 = 0`\n * `Int.lcm (-3) 0 = 0`\n</code>",
 "3333":
 "<code>Int.gcd (m n : Int) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the greatest common divisor of two integers as a natural number. The GCD of two integers is\nthe largest natural number that evenly divides both. However, the GCD of a number and `0` is the\nnumber's absolute value.\n\nThis implementation uses `Nat.gcd`, which is overridden in both the kernel and the compiler to\nefficiently evaluate using arbitrary-precision arithmetic.\n\nExamples:\n* `Int.gcd 10 15 = 5`\n* `Int.gcd 10 (-15) = 5`\n* `Int.gcd (-6) (-9) = 3`\n* `Int.gcd 0 5 = 5`\n* `Int.gcd (-7) 0 = 7`\n</code>",
 "3332":
 "<code>Int.negOfNat : Nat → Int</code><span class=\"sep\"></span><code class=\"docstring\">Negation of natural numbers.\n\nExamples:\n* `Int.negOfNat 6 = -6`\n* `Int.negOfNat 0 = 0`\n</code>",
 "3331":
 "<code>Int.neg (n : Int) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Negation of integers, usually accessed via the `-` prefix operator.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `-(6 : Int) = -6`\n * `-(-6 : Int) = 6`\n * `(12 : Int).neg = -12`\n</code>",
 "3330":
 "<code>Int.toInt64 (i : Int) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 64-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt64 48 = 48`\n* `Int.toInt64 (-40_000) = -40_000`\n* `Int.toInt64 2_147_483_648 = 2_147_483_648`\n* `Int.toInt64 (-2_147_483_649) = -2_147_483_649`\n* `Int.toInt64 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n* `Int.toInt64 (-9_223_372_036_854_775_809) = 9_223_372_036_854_775_807`\n</code>",
 "333":
 "<code>(head : α) → (tail : List α) → motive tail → motive (head :: tail)</code>",
 "3329":
 "<code>Int.toInt32 (i : Int) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 32-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt32 48 = 48`\n* `Int.toInt32 (-129) = -129`\n* `Int.toInt32 70000 = 70000`\n* `Int.toInt32 (-40000) = -40000`\n* `Int.toInt32 2147483648 = -2147483648`\n* `Int.toInt32 (-2147483649) = 2147483647`\n</code>",
 "3328":
 "<code>Int.toInt16 (i : Int) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to a 16-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt16 48 = 48`\n* `Int.toInt16 (-129) = -129`\n* `Int.toInt16 (128) = 128`\n* `Int.toInt16 70000 = 4464`\n* `Int.toInt16 (-40000) = 25536`\n</code>",
 "3327":
 "<code>Int.toInt8 (i : Int) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Converts an arbitrary-precision integer to an 8-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt8 48 = 48`\n* `Int.toInt8 (-115) = -115`\n* `Int.toInt8 (-129) = 127`\n* `Int.toInt8 (128) = -128`\n</code>",
 "3326":
 "<code>Int.toNat? : Int → Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Converts an integer into a natural number. Returns `none` for negative numbers.\n\nExamples:\n* `(7 : Int).toNat? = some 7`\n* `(0 : Int).toNat? = some 0`\n* `(-7 : Int).toNat? = none`\n</code>",
 "3325":
 "<code>Int.toNat : Int → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Converts an integer into a natural number. Negative numbers are converted to `0`.\n\nExamples:\n* `(7 : Int).toNat = 7`\n* `(0 : Int).toNat = 0`\n* `(-7 : Int).toNat = 0`\n</code>",
 "3324": "<code>Int → Int</code>",
 "3323":
 "<code>Int.sign : Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Returns the “sign” of the integer as another integer:\n* `1` for positive numbers,\n* `-1` for negative numbers, and\n* `0` for `0`.\n\nExamples:\n* `Int.sign 34 = 1`\n* `Int.sign 2 = 1`\n* `Int.sign 0 = 0`\n* `Int.sign -1 = -1`\n* `Int.sign -362 = -1`\n</code>",
 "3322":
 "<code>Int.negSucc : Nat → Int</code><span class=\"sep\"></span><code class=\"docstring\">The negation of the successor of a natural number is an integer.\n\nThis constructor covers the negative integers (from `-1` to `-∞`).\n</code>",
 "3321": "<code>(n : Nat) → (n &gt; 0 → motive (n / 2)) → motive n</code>",
 "3320": "<code>(x y : Nat) → ¬(0 &lt; y ∧ y ≤ x) → motive x y</code>",
 "332": "<code>motive []</code>",
 "3319":
 "<code>(x y : Nat) → 0 &lt; y ∧ y ≤ x → motive (x - y) y → motive x y</code>",
 "3318": "<code>Nat → Nat → Sort u</code>",
 "3317":
 "<code>(n : Nat) → ((m : Nat) → m ≤ n → motive m) → motive n.succ</code>",
 "3316":
 "<code>(n : Nat) → ((m : Nat) → m &lt; n → motive m) → motive n</code>",
 "3315": "<code>a = b → α</code>",
 "3314": "<code>a + k = b + k</code>",
 "3313": "<code>(n : Nat) → motive (n + 1)</code>",
 "3312": "<code>(n : Nat) → motive n → motive (n + 1)</code>",
 "3311": "<code>motive 0</code>",
 "3310":
 "<code>Nat.superDigitChar (n : Nat) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number less than `10` to the corresponding Unicode superscript digit character.\nReturns `'*'` for other numbers.\n\nExamples:\n* `Nat.superDigitChar 3 = '³'`\n* `Nat.superDigitChar 7 = '⁷'`\n* `Nat.superDigitChar 10 = '*'`\n</code>",
 "331": "<code>List α → Sort u</code>",
 "3309":
 "<code>Nat.subDigitChar (n : Nat) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number less than `10` to the corresponding Unicode subscript digit character.\nReturns `'*'` for other numbers.\n\nExamples:\n* `Nat.subDigitChar 3 = '₃'`\n* `Nat.subDigitChar 7 = '₇'`\n* `Nat.subDigitChar 10 = '*'`\n</code>",
 "3308":
 "<code>Nat.toSubDigits (n : Nat) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to the list of Unicode subscript digit characters that corresponds to\nits decimal representation.\n\nExamples:\n * `Nat.toSubDigits 0 = ['₀']`\n * `Nat.toSubDigits 35 = ['₃', '₅']`\n</code>",
 "3307":
 "<code>Nat.toSuperDigits (n : Nat) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to the list of Unicode superscript digit characters that corresponds to\nits decimal representation.\n\nExamples:\n * `Nat.toSuperDigits 0 = ['⁰']`\n * `Nat.toSuperDigits 35 = ['³', '⁵']`\n</code>",
 "3306": "<code><span class=\"literal string\">\"³⁵\"</span> : String</code>",
 "3305": "<code><span class=\"literal string\">\"⁰\"</span> : String</code>",
 "3304":
 "<code>Nat.toSuperscriptString (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a string that contains the its decimal representation as Unicode\nsuperscript digit characters.\n\nExamples:\n * `Nat.toSuperscriptString 0 = \"⁰\"`\n * `Nat.toSuperscriptString 35 = \"³⁵\"`\n</code>",
 "3303": "<code><span class=\"literal string\">\"₃₅\"</span> : String</code>",
 "3302": "<code><span class=\"literal string\">\"₀\"</span> : String</code>",
 "3301":
 "<code>Nat.toSubscriptString (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a string that contains the its decimal representation as Unicode\nsubscript digit characters.\n\nExamples:\n * `Nat.toSubscriptString 0 = \"₀\"`\n * `Nat.toSubscriptString 35 = \"₃₅\"`\n</code>",
 "3300":
 "<code>Nat.digitChar (n : Nat) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns a single digit representation of `n`, which is assumed to be in a base less than or equal to\n`16`. Returns `'*'` if `n &gt; 15`.\n\nExamples:\n * `Nat.digitChar 5 = '5'`\n * `Nat.digitChar 12 = 'c'`\n * `Nat.digitChar 15 = 'f'`\n * `Nat.digitChar 16 = '*'`\n * `Nat.digitChar 85 = '*'`\n</code>",
 "330":
 "<code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">The list whose first element is `head`, where `tail` is the rest of the list.\nUsually written `head :: tail`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `::` in identifiers is `cons`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.</code>",
 "33":
 "<code>Lean.SourceInfo.original (leading : Substring) (pos : String.Pos) (trailing : Substring) (endPos : String.Pos) :\n  SourceInfo</code><span class=\"sep\"></span><code class=\"docstring\">A token produced by the parser from original input that includes both leading and trailing\nwhitespace as well as position information.\n\nThe `leading` whitespace is inferred after parsing by `Syntax.updateLeading`. This is because the\n“preceding token” is not well-defined during parsing, especially in the presence of backtracking.\n</code>",
 "3299":
 "<code>Nat.toDigits (base n : Nat) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Returns the decimal representation of a natural number as a list of digit characters in the given\nbase. If the base is greater than `16` then `'*'` is returned for digits greater than `0xf`.\n\nExamples:\n* `Nat.toDigits 10 0xff = ['2', '5', '5']`\n* `Nat.toDigits 8 0xc = ['1', '4']`\n* `Nat.toDigits 16 0xcafe = ['c', 'a', 'f', 'e']`\n* `Nat.toDigits 80 200 = ['2', '*']`\n</code>",
 "3298":
 "<code>ISize : Type</code><span class=\"sep\"></span><code class=\"docstring\">A `ISize` is a signed integer with the size of a word for the platform's architecture.\n\nFor example, if running on a 32-bit machine, ISize is equivalent to `Int32`.\nOr on a 64-bit machine, `Int64`.\n</code>",
 "3297": "<code>Int64</code>",
 "3296":
 "<code>Nat.toInt64 (n : Nat) : Int64</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 64-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt64 127 = 127`\n * `Nat.toInt64 2_147_483_648 = 2_147_483_648`\n * `Nat.toInt64 9_223_372_036_854_775_807 = 9_223_372_036_854_775_807`\n * `Nat.toInt64 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n * `Nat.toInt64 18_446_744_073_709_551_618 = 0`\n</code>",
 "3295": "<code>Int32</code>",
 "3294":
 "<code>Nat.toInt32 (n : Nat) : Int32</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 32-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt32 127 = 127`\n * `Nat.toInt32 32770 = 32770`\n * `Nat.toInt32 2_147_483_647 = 2_147_483_647`\n * `Nat.toInt32 2_147_483_648 = -2_147_483_648`\n</code>",
 "3293":
 "<code>Int32 : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of signed 32-bit integers. This type has special support in the\ncompiler to make it actually 32 bits rather than wrapping a `Nat`.\n</code>",
 "3292": "<code>Int16</code>",
 "3291":
 "<code>Nat.toInt16 (n : Nat) : Int16</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 16-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt16 127 = 127`\n * `Nat.toInt16 32767 = 32767`\n * `Nat.toInt16 32768 = -32768`\n * `Nat.toInt16 32770 = -32766`\n</code>",
 "3290":
 "<code>Int16 : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of signed 16-bit integers. This type has special support in the\ncompiler to make it actually 16 bits rather than wrapping a `Nat`.\n</code>",
 "329":
 "<code>List.nil.{u} {α : Type u} : List α</code><span class=\"sep\"></span><code class=\"docstring\">The empty list, usually written `[]`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.</code>",
 "3289": "<code>Int8</code>",
 "3288":
 "<code>Nat.toInt8 (n : Nat) : Int8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to an 8-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt8 53 = 53`\n * `Nat.toInt8 127 = 127`\n * `Nat.toInt8 128 = -128`\n * `Nat.toInt8 255 = -1`\n</code>",
 "3287":
 "<code>Nat.toUInt64 (n : Nat) : UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 64-bit unsigned integer, wrapping on overflow.\n\nExamples:\n* `Nat.toUInt64 5 = 5`\n* `Nat.toUInt64 65539 = 65539`\n* `Nat.toUInt64 4_294_967_299 = 4_294_967_299`\n* `Nat.toUInt64 18_446_744_073_709_551_620 = 4`\n</code>",
 "3286": "<code>UInt16</code>",
 "3285":
 "<code>Nat.toUInt16 (n : Nat) : UInt16</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 16-bit unsigned integer, wrapping on overflow.\n\nExamples:\n* `Nat.toUInt16 5 = 5`\n* `Nat.toUInt16 255 = 255`\n* `Nat.toUInt16 32770 = 32770`\n* `Nat.toUInt16 65537 = 1`\n</code>",
 "3284": "<code>(i : Nat) → i &lt; n → m Bool</code>",
 "3283":
 "<code>Nat.anyTR (n : Nat) (f : (i : Nat) → i &lt; n → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether there is some number less that the given bound for which `f` returns `true`.\n\nThis is a tail-recursive equivalent of `Nat.any` that's used at runtime.\n\nExamples:\n* `Nat.anyTR 4 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.anyTR 7 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.anyTR 7 (fun i _ =&gt; i % 2 = 0) = true`\n* `Nat.anyTR 1 (fun i _ =&gt; i % 2 = 1) = false`\n</code>",
 "3282":
 "<code>Nat.any (n : Nat) (f : (i : Nat) → i &lt; n → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether there is some number less that the given bound for which `f` returns `true`.\n\nExamples:\n* `Nat.any 4 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.any 7 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.any 7 (fun i _ =&gt; i % 2 = 0) = true`\n* `Nat.any 1 (fun i _ =&gt; i % 2 = 1) = false`\n</code>",
 "3281":
 "<code>Nat.allTR (n : Nat) (f : (i : Nat) → i &lt; n → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `f` returns `true` for every number strictly less than a bound.\n\nThis is a tail-recursive equivalent of `Nat.all` that's used at runtime.\n\nExamples:\n* `Nat.allTR 4 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.allTR 7 (fun i _ =&gt; i &lt; 5) = false`\n* `Nat.allTR 7 (fun i _ =&gt; i % 2 = 0) = false`\n* `Nat.allTR 1 (fun i _ =&gt; i % 2 = 0) = true`\n</code>",
 "3280":
 "<code>Nat.all (n : Nat) (f : (i : Nat) → i &lt; n → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `f` returns `true` for every number strictly less than a bound.\n\nExamples:\n* `Nat.all 4 (fun i _ =&gt; i &lt; 5) = true`\n* `Nat.all 7 (fun i _ =&gt; i &lt; 5) = false`\n* `Nat.all 7 (fun i _ =&gt; i % 2 = 0) = false`\n* `Nat.all 1 (fun i _ =&gt; i % 2 = 0) = true`\n</code>",
 "328":
 "<code>List.rec.{u_1, u} {α : Type u} {motive : List α → Sort u_1} (nil : motive [])\n  (cons : (head : α) → (tail : List α) → motive tail → motive (head :: tail)) (t : List α) : motive t</code>",
 "3279": "<code>(i : Nat) → i &lt; n → Bool</code>",
 "3278":
 "<code>Nat.forRevM.{u_1} {m : Type → Type u_1} [Monad m] (n : Nat) (f : (i : Nat) → i &lt; n → m Unit) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Executes a monadic action on all the numbers less than some bound, in decreasing order.\n\nExample:\n````lean example\n#eval Nat.forRevM 5 fun i _ =&gt; IO.println i\n````\n````output\n4\n3\n2\n1\n0\n````\n</code>",
 "3277":
 "<code>Nat.forM.{u_1} {m : Type → Type u_1} [Monad m] (n : Nat) (f : (i : Nat) → i &lt; n → m Unit) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Executes a monadic action on all the numbers less than some bound, in increasing order.\n\nExample:\n````lean example\n#eval Nat.forM 5 fun i _ =&gt; IO.println i\n````\n````output\n0\n1\n2\n3\n4\n````\n</code>",
 "3276": "<code>(i : Nat) → i &lt; n → m Unit</code>",
 "3275":
 "<code>Nat.foldRev.{u} {α : Type u} (n : Nat) (f : (i : Nat) → i &lt; n → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Iterates the application of a function `f` to a starting value `init`, `n` times. At each step, `f`\nis applied to the current value and to the next natural number less than `n`, in decreasing order.\n\nExamples:\n* `Nat.foldRev 3 f init = (f 0 (by simp) &lt;| f 1 (by simp) &lt;| f 2 (by simp) init)`\n* `Nat.foldRev 4 (fun i _ xs =&gt; xs.push i) #[] = #[3, 2, 1, 0]`\n* `Nat.foldRev 0 (fun i _ xs =&gt; xs.push i) #[] = #[]`\n</code>",
 "3274": "<code>(i : Nat) → i &lt; n → α → m α</code>",
 "3273":
 "<code>Nat.foldTR.{u} {α : Type u} (n : Nat) (f : (i : Nat) → i &lt; n → α → α) (init : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Iterates the application of a function `f` to a starting value `init`, `n` times. At each step, `f`\nis applied to the current value and to the next natural number less than `n`, in increasing order.\n\nThis is a tail-recursive version of `Nat.fold` that's used at runtime.\n\nExamples:\n* `Nat.foldTR 3 f init = (init |&gt; f 0 (by simp) |&gt; f 1 (by simp) |&gt; f 2 (by simp))`\n* `Nat.foldTR 4 (fun i _ xs =&gt; xs.push i) #[] = #[0, 1, 2, 3]`\n* `Nat.foldTR 0 (fun i _ xs =&gt; xs.push i) #[] = #[]`\n</code>",
 "3272": "<code>(i : Nat) → i &lt; n → α → α</code>",
 "3271":
 "<code>Nat.repeatTR.{u} {α : Type u} (f : α → α) (n : Nat) (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to a starting value the specified number of times.\n\nIn other words, `f` is iterated `n` times on `a`.\n\nThis is a tail-recursive version of `Nat.repeat` that's used at runtime.\n\nExamples:\n* `Nat.repeatTR f 3 a = f &lt;| f &lt;| f &lt;| a`\n* `Nat.repeatTR (· ++ \"!\") 4 \"Hello\" = \"Hello!!!!\"`\n</code>",
 "3270":
 "<code><span class=\"literal string\">\"Hello!!!!\"</span> : String</code>",
 "327": "<code>motive Bool.true</code>",
 "3269": "<code><span class=\"literal string\">\"!\"</span> : String</code>",
 "3268":
 "<code>Nat.repeat.{u} {α : Type u} (f : α → α) (n : Nat) (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to a starting value the specified number of times.\n\nIn other words, `f` is iterated `n` times on `a`.\n\nExamples:\n* `Nat.repeat f 3 a = f &lt;| f &lt;| f &lt;| a`\n* `Nat.repeat (· ++ \"!\") 4 \"Hello\" = \"Hello!!!!\"`\n</code>",
 "3267":
 "<code>DecidableLT.{u} (α : Type u) [LT α] : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Abbreviation for `DecidableRel (· &lt; · : α → α → Prop)`. </code>",
 "3266":
 "<code>DecidableLE.{u} (α : Type u) [LE α] : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Abbreviation for `DecidableRel (· ≤ · : α → α → Prop)`. </code>",
 "3265": "<code><span class=\"literal string\">\"no\"</span> : String</code>",
 "3264": "<code><span class=\"literal string\">\"yes\"</span> : String</code>",
 "3263":
 "<code>Nat.decEq (n m : Nat) : Decidable (n = m)</code><span class=\"sep\"></span><code class=\"docstring\">A decision procedure for equality of natural numbers, usually accessed via the `DecidableEq Nat`\ninstance.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nExamples:\n * `Nat.decEq 5 5 = isTrue rfl`\n * `(if 3 = 4 then \"yes\" else \"no\") = \"no\"`\n * `show 12 = 12 by decide`\n</code>",
 "3262":
 "<code>Nat.blt (a b : Nat) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean less-than comparison on natural numbers.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nExamples:\n * `Nat.blt 2 5 = true`\n * `Nat.blt 5 2 = false`\n * `Nat.blt 5 5 = false`\n</code>",
 "3261":
 "<code>Nat.ble : Nat → Nat → Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean less-than-or-equal-to comparison on natural numbers.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nExamples:\n * `Nat.ble 2 5 = true`\n * `Nat.ble 5 2 = false`\n * `Nat.ble 5 5 = true`\n</code>",
 "3260":
 "<code>Nat.nextPowerOfTwo (n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the least power of two that's greater than or equal to `n`.\n\nExamples:\n* `Nat.nextPowerOfTwo 0 = 1`\n* `Nat.nextPowerOfTwo 1 = 1`\n* `Nat.nextPowerOfTwo 2 = 2`\n* `Nat.nextPowerOfTwo 3 = 4`\n* `Nat.nextPowerOfTwo 5 = 8`\n</code>",
 "326": "<code>motive Bool.false</code>",
 "3259":
 "<code>Nat.lcm (m n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The least common multiple of `m` and `n` is the smallest natural number that's evenly divisible by\nboth `m` and `n`. Returns `0` if either `m` or `n` is `0`.\n\nExamples:\n * `Nat.lcm 9 6 = 18`\n * `Nat.lcm 9 3 = 9`\n * `Nat.lcm 0 3 = 0`\n * `Nat.lcm 3 0 = 0`\n</code>",
 "3258":
 "<code>Nat.gcd (m n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the greatest common divisor of two natural numbers. The GCD of two natural numbers is the\nlargest natural number that evenly divides both.\n\nIn particular, the GCD of a number and `0` is the number itself.\n\nThis reference implementation via the Euclidean algorithm is overridden in both the kernel and the\ncompiler to efficiently evaluate using arbitrary-precision arithmetic. The definition provided here\nis the logical model.\n\nExamples:\n* `Nat.gcd 10 15 = 5`\n* `Nat.gcd 0 5 = 5`\n* `Nat.gcd 7 0 = 7`\n</code>",
 "3257": "<code>Bool → Bool → Bool</code>",
 "3256":
 "<code>Nat.log2 (n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Base-two logarithm of natural numbers. Returns `⌊max 0 (log₂ n)⌋`.\n\nThis function is overridden at runtime with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `Nat.log2 0 = 0`\n * `Nat.log2 1 = 0`\n * `Nat.log2 2 = 1`\n * `Nat.log2 4 = 2`\n * `Nat.log2 7 = 2`\n * `Nat.log2 8 = 3`\n</code>",
 "3255": "<code>Fin (n + 1)</code>",
 "3254":
 "<code>Nat.modCore (x y : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator, which computes the remainder when dividing one natural number by another.\nUsually accessed via the `%` operator. When the divisor is `0`, the result is the dividend rather\nthan an error.\n\nThis is the core implementation of `Nat.mod`. It computes the correct result for any two closed\nnatural numbers, but it does not have some convenient [definitional\nreductions](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=type-system) when the `Nat`s contain free variables. The wrapper\n`Nat.mod` handles those cases specially and then calls `Nat.modCore`.\n\nThis function is overridden at runtime with an efficient implementation. This definition is the\nlogical model.\n</code>",
 "3253":
 "<code>Nat.mod : Nat → Nat → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The modulo operator, which computes the remainder when dividing one natural number by another.\nUsually accessed via the `%` operator. When the divisor is `0`, the result is the dividend rather\nthan an error.\n\n`Nat.mod` is a wrapper around `Nat.modCore` that special-cases two situations, giving better\ndefinitional reductions:\n * `Nat.mod 0 m` should reduce to `m`, for all terms `m : Nat`.\n * `Nat.mod n (m + n + 1)` should reduce to `n` for concrete `Nat` literals `n`.\n\nThese reductions help `Fin n` literals work well, because the `OfNat` instance for `Fin` uses\n`Nat.mod`. In particular, `(0 : Fin (n + 1)).val` should reduce definitionally to `0`. `Nat.modCore`\ncan handle all numbers, but its definitional reductions are not as convenient.\n\nThis function is overridden at runtime with an efficient implementation. This definition is the\nlogical model.\n\nExamples:\n * `7 % 2 = 1`\n * `9 % 3 = 0`\n * `5 % 7 = 5`\n * `5 % 0 = 5`\n * `show ∀ (n : Nat), 0 % n = 0 from fun _ =&gt; rfl`\n * `show ∀ (m : Nat), 5 % (m + 6) = 5 from fun _ =&gt; rfl`\n</code>",
 "3252": "<code>succ_not_zero {n : Nat} : ¬n + 1 = 0</code>",
 "3251": "<code>succ_injective {n k : Nat} : n + 1 = k + 1 → n = k</code>",
 "3250": "<code>noConfusion (n k : Nat) (eq : n = k) : NoConfusion n k</code>",
 "325": "<code>Bool → Sort u</code>",
 "3249": "<code>noConfusionDiagonal (n : Nat) : NoConfusion n n</code>",
 "3248": "<code>NoConfusion : Nat → Nat → Prop</code>",
 "3247": "<code>(n : Nat) → motive n → motive n.succ</code>",
 "3246": "<code>motive Nat.zero</code>",
 "3245":
 "<code>Nat.succ_lt_succ {n m : Nat} : n &lt; m → n.succ &lt; m.succ</code>",
 "3244": "<code>i &lt; i + 1</code>",
 "3243":
 "<code class=\"docstring\">After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n</code>",
 "3242": "<code>b = b'</code>",
 "3241":
 "<code>Eq.recOn.{u, u_1} {α : Sort u_1} {a✝ : α} {motive : (a : α) → a✝ = a → Sort u} {a✝¹ : α} (t : a✝ = a✝¹)\n  (refl : motive a✝ ⋯) : motive a✝¹ t</code>",
 "3240": "<code>φ a</code>",
 "324":
 "<code>Bool.rec.{u} {motive : Bool → Sort u} (false : motive false) (true : motive true) (t : Bool) : motive t</code>",
 "3239": "<code>h₁ ▸ a = b</code>",
 "3238": "<code>a = a'</code>",
 "3237": "<code>HEq a a'</code>",
 "3236": "<code>p α a</code>",
 "3235": "<code>(T : Sort u) → T → Prop</code>",
 "3234":
 "<code>HEq.{u} {α : Sort u} : α → {β✝ : Sort u} → β✝ → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Heterogeneous equality. `HEq a b` asserts that `a` and `b` have the same\ntype, and casting `a` across the equality yields `b`, and vice versa.\n\nYou should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as `Eq`, because the assumption that the types of\n`a` and `b` are equal is often too weak to prove theorems of interest. One\nimportant non-theorem is the analogue of `congr`: If `HEq f g` and `HEq x y`\nand `f x` and `g y` are well typed it does not follow that `HEq (f x) (g y)`.\n(This does follow if you have `f = g` instead.) However if `a` and `b` have\nthe same type then `a = b` and `HEq a b` are equivalent.\n</code>",
 "3233": "<code>{β : Sort u2} → β → Sort u1</code>",
 "3232": "<code>Sort u2</code>",
 "3231":
 "<code>HEq.ndrec.{u1, u2} {α : Sort u2} {a : α} {motive : {β : Sort u2} → β → Sort u1} (m : motive a) {β : Sort u2} {b : β}\n  (h : HEq a b) : motive b</code><span class=\"sep\"></span><code class=\"docstring\">Non-dependent recursor for `HEq` </code>",
 "3230": "<code>HEq a b</code>",
 "323":
 "<code>IO.print.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it to the current standard\noutput (as determined by `IO.getStdout`).\n</code>",
 "3229":
 "<code>(toArray✝² ++ (toArray✝¹ ++ toArray✝)).size = l₁ + l₂ + l₃</code>",
 "3228":
 "<code>(toArray✝² ++ (toArray✝¹ ++ toArray✝)).size = l₁ + (l₂ + l₃)</code>",
 "3227":
 "<code>heq_of_eqRec_eq.{u} {α β : Sort u} {a : α} {b : β} (h₁ : α = β) (h₂ : h₁ ▸ a = b) : HEq a b</code>",
 "3226":
 "<code>(toArray✝² ++ (toArray✝¹ ++ toArray✝)).size = l₁ + l₂ + l₃</code><span class=\"sep\"></span><code class=\"docstring\">Array size. </code>",
 "3225":
 "<code>(toArray✝² ++ (toArray✝¹ ++ toArray✝)).size = l₁ + (l₂ + l₃)</code><span class=\"sep\"></span><code class=\"docstring\">Array size. </code>",
 "3224":
 "<code>toArray✝.size = l₃</code><span class=\"sep\"></span><code class=\"docstring\">Array size. </code>",
 "3223":
 "<code>toArray✝¹.size = l₂</code><span class=\"sep\"></span><code class=\"docstring\">Array size. </code>",
 "3222":
 "<code>toArray✝².size = l₁</code><span class=\"sep\"></span><code class=\"docstring\">Array size. </code>",
 "3221": "<code>toArray✝.size = l₃</code>",
 "3220": "<code>toArray✝¹.size = l₂</code>",
 "322": "<code>EvenNumber</code>",
 "3219": "<code>toArray✝².size = l₁</code>",
 "3218":
 "<code>toArray✝.size = l₂</code><span class=\"sep\"></span><code class=\"docstring\">Array size. </code>",
 "3217":
 "<code>toArray✝¹.size = l₁</code><span class=\"sep\"></span><code class=\"docstring\">Array size. </code>",
 "3216": "<code>toArray✝.size = l₂</code>",
 "3215": "<code>toArray✝¹.size = l₁</code>",
 "3214":
 "<code>toArray✝.size = l₁</code><span class=\"sep\"></span><code class=\"docstring\">Array size. </code>",
 "3213": "<code>toArray✝.size = l₁</code>",
 "3212":
 "<code>Vector.append_assoc.{u} {α : Type u} {l₁ l₂ l₃ : Nat} {xs : Vector α l₁} {ys : Vector α l₂} {zs : Vector α l₃} :\n  HEq (xs ++ (ys ++ zs)) (xs ++ ys ++ zs)</code>",
 "3211":
 "<code>Vector.append_assoc'.{u} {α : Type u} {l₁ l₂ l₃ : Nat} {xs : Vector α l₁} {ys : Vector α l₂} {zs : Vector α l₃} :\n  xs ++ (ys ++ zs) = ⋯ ▸ (xs ++ ys ++ zs)</code>",
 "3210": "<code>sorry</code>",
 "321": "<code>printEven (num : EvenNumber) : IO Unit</code>",
 "3209": "<code>Vector α l₃</code>",
 "3208": "<code>Vector α l₂</code>",
 "3207": "<code>Vector α l₁</code>",
 "3206":
 "<code>Vector.{u} (α : Type u) (n : Nat) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Vector α n` is an `Array α` with size `n`. </code>",
 "3205":
 "<code>HEq.refl.{u} {α : Sort u} (a : α) : HEq a a</code><span class=\"sep\"></span><code class=\"docstring\">Reflexivity of heterogeneous equality. </code>",
 "3204": "<code>?m.2635</code>",
 "3203": "<code>?m.2060</code>",
 "3202": "<code>?m.2014</code>",
 "3201": "<code>?m.1968</code>",
 "3200": "<code>?m.1925</code>",
 "320":
 "<code class=\"docstring\">The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n</code>",
 "32":
 "<code>Lean.SourceInfo : Type</code><span class=\"sep\"></span><code class=\"docstring\">Source information that relates syntax to the context that it came from.\n\nThe primary purpose of `SourceInfo` is to relate the output of the parser and the macro expander to\nthe original source file. When produced by the parser, `Syntax.node` does not carry source info; the\nparser associates it only with atoms and identifiers. If a `Syntax.node` is introduced by a\nquotation, then it has synthetic source info that both associates it with an original reference\nposition and indicates that the original atoms in it may not originate from the Lean file under\nelaboration.\n\nSource info is also used to relate Lean's output to the internal data that it represents; this is\nthe basis for many interactive features. When used this way, it can occur on `Syntax.node` as well.\n</code>",
 "3199": "<code>?m.2466</code>",
 "3198": "<code>?m.2273</code>",
 "3197": "<code>?m.1875</code>",
 "3196": "<code>?m.1865</code>",
 "3195": "<code>motive ⋯</code>",
 "3194": "<code>{x : α} → x = x → Sort u</code>",
 "3193": "<code>x = x</code>",
 "3192": "<code>{x : α} → motive ⋯</code>",
 "3191": "<code>{x : α} → x = x → Sort v</code>",
 "3190":
 "<code>K.{u, v} {α : Sort u} {motive : {x : α} → x = x → Sort v} (d : {x : α} → motive ⋯) (x : α) (z : x = x) : motive z</code>",
 "319":
 "<code class=\"docstring\">`all_goals tac` runs `tac` on each goal, concatenating the resulting goals.\nIf the tactic fails on any goal, the entire `all_goals` tactic fails.\n\nSee also `any_goals tac`.\n</code>",
 "3189":
 "<code>Eq.unique.{u} {α : Sort u} (x y : α) (p1 p2 : x = y) : p1 = p2</code>",
 "3188":
 "<code>Eq.mpr.{u} {α β : Sort u} (h : α = β) (b : β) : α</code><span class=\"sep\"></span><code class=\"docstring\">If `h : α = β` is a proof of type equality, then `h.mpr : β → α` is the induced\n\"cast\" operation in the reverse direction, mapping elements of `β` to elements of `α`.\n\nYou can prove theorems about the resulting element by induction on `h`, since\n`rfl.mpr` is definitionally the identity function.\n</code>",
 "3187":
 "<code>Eq.mp.{u} {α β : Sort u} (h : α = β) (a : α) : β</code><span class=\"sep\"></span><code class=\"docstring\">If `h : α = β` is a proof of type equality, then `h.mp : α → β` is the induced\n\"cast\" operation, mapping elements of `α` to elements of `β`.\n\nYou can prove theorems about the resulting element by induction on `h`, since\n`rfl.mp` is definitionally the identity function.\n</code>",
 "3186": "<code>f = g</code>",
 "3185": "<code>a₁ = a₂</code>",
 "3184": "<code>f₁ = f₂</code>",
 "3183":
 "<code>cast.{u} {α β : Sort u} (h : α = β) (a : α) : β</code><span class=\"sep\"></span><code class=\"docstring\">Cast across a type equality. If `h : α = β` is an equality of types, and\n`a : α`, then `a : β` will usually not typecheck directly, but this function\nwill allow you to work around this and embed `a` in type `β` as `cast h a : β`.\n\nIt is best to avoid this function if you can, because it is more complicated\nto reason about terms containing casts, but if the types don't match up\ndefinitionally sometimes there isn't anything better you can do.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "3182": "<code>?m.1339</code>",
 "3181": "<code>motive a</code>",
 "3180": "<code>b = c</code>",
 "318": "<code>0 ∣ 2</code>",
 "3179": "<code>p a</code>",
 "3178":
 "<code>Eq.subst.{u} {α : Sort u} {motive : α → Prop} {a b : α} (h₁ : a = b) (h₂ : motive a) : motive b</code><span class=\"sep\"></span><code class=\"docstring\">The substitution principle for equality. If `a = b ` and `P a` holds,\nthen `P b` also holds. We conventionally use the name `motive` for `P` here,\nso that you can specify it explicitly using e.g.\n`Eq.subst (motive := fun x =&gt; x &lt; 5)` if it is not otherwise inferred correctly.\n\nThis theorem is the underlying mechanism behind the `rw` tactic, which is\nessentially a fancy algorithm for finding good `motive` arguments to usefully\napply this theorem to replace occurrences of `a` with `b` in the goal or\nhypotheses.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "3177": "<code>?m.897</code>",
 "3176":
 "<code>Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a</code><span class=\"sep\"></span><code class=\"docstring\">Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "3175":
 "<code>Eq.trans.{u} {α : Sort u} {a b c : α} (h₁ : a = b) (h₂ : b = c) : a = c</code><span class=\"sep\"></span><code class=\"docstring\">Equality is transitive: if `a = b` and `b = c` then `a = c`.\n\nBecause this is in the `Eq` namespace, if you have variables or expressions\n`h₁ : a = b` and `h₂ : b = c`, you can use `h₁.trans h₂ : a = c` as shorthand\nfor `Eq.trans h₁ h₂`.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "3174": "<code>c = d</code>",
 "3173": "<code>c = b</code>",
 "3172": "<code>?m.845</code>",
 "3171":
 "<code>Classical.choose.{u} {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : α</code><span class=\"sep\"></span><code class=\"docstring\">Given that there exists an element satisfying `p`, returns one such element.\n\nThis is a straightforward consequence of, and equivalent to, `Classical.choice`.\n\nSee also `choose_spec`, which asserts that the returned value has property `p`.\n</code>",
 "3170": "<code>∃ a, p a</code>",
 "317":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil =&gt; tac₁ | cons a as' =&gt; tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n</code>",
 "3169": "<code>p w</code>",
 "3168": "<code>∃ x, x = x</code>",
 "3167": "<code>?m.559</code>",
 "3166": "<code>ex_four_plus_five' : ∃ n, 4 + 5 = n</code>",
 "3165": "<code>ex_four_plus_five : ∃ n, 4 + 5 = n</code>",
 "3164":
 "<code>Sigma.{u, v} {α : Type u} (β : α → Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Dependent pairs, in which the second element's type depends on the value of the first element. The\ntype `Sigma β` is typically written `Σ a : α, β a` or `(a : α) × β a`.\n\nAlthough its values are pairs, `Sigma` is sometimes known as the *dependent sum type*, since it is\nthe type level version of an indexed summation.\n</code>",
 "3163": "<code>a ↔ b</code>",
 "3162": "<code>(a → b) → (b → a) → α</code>",
 "3161":
 "<code>b → a</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. </code>",
 "3160":
 "<code>a → b</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. </code>",
 "316":
 "<code class=\"docstring\">`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n</code>",
 "3159":
 "<code>Iff.intro {a b : Prop} (mp : a → b) (mpr : b → a) : a ↔ b</code><span class=\"sep\"></span><code class=\"docstring\">If `a → b` and `b → a` then `a` and `b` are equivalent. </code>",
 "3158": "<code>A → B</code>",
 "3157": "<code>A</code>",
 "3156": "<code>B</code>",
 "3155": "<code>¬A</code>",
 "3154": "<code>truth_functional_imp {A B : Prop} : (¬A ∨ B) = (A → B)</code>",
 "3153":
 "<code>absurd.{v} {a : Prop} {b : Sort v} (h₁ : a) (h₂ : ¬a) : b</code><span class=\"sep\"></span><code class=\"docstring\">Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : ¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "3152": "<code>¬a</code>",
 "3151": "<code>q → α</code>",
 "3150": "<code>p → α</code>",
 "315": "<code>n✝ ∣ 2</code>",
 "3149": "<code>p ∨ q</code>",
 "3148": "<code>a → b → α</code>",
 "3147":
 "<code>b</code><span class=\"sep\"></span><code class=\"docstring\">Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. </code>",
 "3146":
 "<code>a</code><span class=\"sep\"></span><code class=\"docstring\">Extract the left conjunct from a conjunction. `h : a ∧ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. </code>",
 "3145":
 "<code>And.right {a b : Prop} (self : a ∧ b) : b</code><span class=\"sep\"></span><code class=\"docstring\">Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. </code>",
 "3144":
 "<code>And.left {a b : Prop} (self : a ∧ b) : a</code><span class=\"sep\"></span><code class=\"docstring\">Extract the left conjunct from a conjunction. `h : a ∧ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. </code>",
 "3143":
 "<code>PProd.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">A product type in which the types may be propositions, usually written `α ×' β`.\n\nThis type is primarily used internally and as an implementation detail of proof automation. It is\nrarely useful in hand-written code.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×'` in identifiers is `PProd`.</code>",
 "3142":
 "<code>And.elim.{u_1} {a b : Prop} {α : Sort u_1} (f : a → b → α) (h : a ∧ b) : α</code><span class=\"sep\"></span><code class=\"docstring\">Non-dependent eliminator for `And`. </code>",
 "3141": "<code>g (n : Nat) : String</code>",
 "3140":
 "<code><span class=\"literal string\">\"Twelve\"</span> : String</code>",
 "314": "<code>n✝ ≤ 2</code>",
 "3139": "<code>¬n % 2 = 1</code>",
 "3138": "<code>¬n &gt; 13</code>",
 "3137": "<code>¬n &lt; 11</code>",
 "3136": "<code>n ≠ 12</code>",
 "3135": "<code><span class=\"literal string\">\"Odd\"</span> : String</code>",
 "3134": "<code>n % 2 = 1</code>",
 "3133":
 "<code><span class=\"literal string\">\"Large\"</span> : String</code>",
 "3132": "<code>n &gt; 13</code>",
 "3131":
 "<code><span class=\"literal string\">\"Small\"</span> : String</code>",
 "3130": "<code>n &lt; 11</code>",
 "313":
 "<code class=\"docstring\">Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* 'empty' is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`\n* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal\n* `at *`: target all hypotheses and the goal\n</code>",
 "3129": "<code>f (n : Nat) : String</code>",
 "3128":
 "<code>Lean.Meta.Rewrite.Config.occs (self : Lean.Meta.Rewrite.Config) : Lean.Meta.Occurrences</code>",
 "3127":
 "<code class=\"docstring\">Auxiliary attribute for simplification procedures.\n</code>",
 "3126": "<code>?m.17535</code>",
 "3125": "<code>?m.17522</code>",
 "3124": "<code>?m.17359</code>",
 "3123": "<code>?m.17243</code>",
 "3122": "<code>?m.17280</code>",
 "3121": "<code>?m.14464</code>",
 "3120": "<code>?m.15029</code>",
 "312":
 "<code class=\"docstring\">The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n</code>",
 "3119":
 "<code>Lean.Meta.DSimp.Config.mk (zeta beta eta : Bool) (etaStruct : Lean.Meta.EtaStructMode)\n  (iota proj decide autoUnfold failIfUnchanged unfoldPartialApp zetaDelta index zetaUnused : Bool) :\n  Lean.Meta.DSimp.Config</code>",
 "3118":
 "<code>Lean.Elab.Tactic.elabSimpConfig (optConfig : Lean.Syntax) (kind : Lean.Elab.Tactic.SimpKind) :\n  Lean.Elab.Tactic.TacticM Lean.Meta.Simp.Config</code>",
 "3117": "<code>?m.10515</code>",
 "3116": "<code>?m.10502</code>",
 "3115":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default : `true`), then simps will remove unused let-declarations:\n`let x := v; e` simplifies to `e` when `x` does not occur in `e`.\n</code>",
 "3114":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `implicitDefEqProofs := true`, `simp` does not create proof terms when the\ninput and output terms are definitionally equal.\n</code>",
 "3113":
 "<code>Verso.Genre.Manual.index (args : Array (Verso.Doc.Inline Manual)) (subterm index : Option String := none) :\n  Verso.Doc.Inline Manual</code>",
 "3112":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `index` (default : `true`) is `false`, `simp` will only use the root symbol\nto find candidate `simp` theorems. It approximates Lean 3 `simp` behavior.\n</code>",
 "3111":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), local definitions are unfolded.\nThat is, given a local context containing entry `x : t := e`, the free variable `x` reduces to `e`.\n</code>",
 "3110":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `unfoldPartialApp` is `true` (default: `false`), then calls to `simp`, `dsimp`, or `simp_all`\nwill unfold even partial applications of `f` when we request `f` to be unfolded.\n</code>",
 "311": "<code>n✝ ∣ { val := 2, isEven := ⋯ }.val</code>",
 "3109":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `ground` is `true` (default: `false`), then ground terms are reduced.\nA term is ground when it does not contain free or meta variables.\nReduction is interrupted at a function application `f ...` if `f` is marked to not be unfolded.\nGround term reduction applies `@[seval]` lemmas.\n</code>",
 "3108":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">If `failIfUnchanged` is `true` (default: `true`), then calls to `simp`, `dsimp`, or `simp_all`\nwill fail if they do not make progress.\n</code>",
 "3107":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`) then switches to `dsimp` on dependent arguments\nif there is no congruence theorem that would allow `simp` to visit them.\nWhen `dsimp` is `false`, then the argument is not visited.\n</code>",
 "3106":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), unfolds definitions.\nThis can be enabled using the `simp!` syntax.\n</code>",
 "3105": "<code>?m.10188</code>",
 "3104":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), rewrites a proposition `p` to `True` or `False` by inferring\na `Decidable p` instance and reducing it.\n</code>",
 "3103":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), reduces projections of structure constructors.\n</code>",
 "3102":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), reduces `match` expressions applied to constructors.\n</code>",
 "3101": "<code>Lean.Meta.EtaStructMode : Type</code>",
 "3100":
 "<code>Lean.Meta.EtaStructMode</code><span class=\"sep\"></span><code class=\"docstring\">Configures how to determine definitional equality between two structure instances.\nSee documentation for `Lean.Meta.EtaStructMode`.\n</code>",
 "310": "<code>n✝ ≤ { val := 2, isEven := ⋯ }.val</code>",
 "31":
 "<code>Lean.Syntax.missing : Syntax</code><span class=\"sep\"></span><code class=\"docstring\">A portion of the syntax tree that is missing because of a parse error.\n\nThe indexing operator on `Syntax` also returns `Syntax.missing` when the index is out of bounds.\n</code>",
 "3099": "<code>?m.10036</code>",
 "3098": "<code>?m.10073</code>",
 "3097":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">TODO (currently unimplemented). When `true` (default: `true`), performs eta reduction for `fun` expressions.\nThat is, `(fun x =&gt; f x)` reduces to `f`.\n</code>",
 "3096": "<code>?m.7248</code>",
 "3095": "<code>?m.7813</code>",
 "3094":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), performs beta reduction of applications of `fun` expressions.\nThat is, `(fun x =&gt; e[x]) v` reduces to `e[v]`.\n</code>",
 "3093":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `true`), performs zeta reduction of let expressions.\nThat is, `let x := v; e[x]` reduces to `e[v]`.\nSee also `zetaDelta`.\n</code>",
 "3092":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `singlePass` is `true` (default: `false`), the simplifier runs through a single round of simplification,\nwhich consists of running pre-methods, recursing using congruence lemmas, and then running post-methods.\nOtherwise, when it is `false`, it iteratively applies this simplification procedure.\n</code>",
 "3091":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When true (default: `true`) then the simplifier caches the result of simplifying each subexpression, if possible.\n</code>",
 "3090": "<code>Sort ?u.3277</code>",
 "309":
 "<code class=\"docstring\">Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k =&gt; f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k =&gt; g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k =&gt; f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n</code>",
 "3089": "<code>Sort ?u.3276</code>",
 "3088":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `contextual` is true (default: `false`) and simplification encounters an implication `p → q`\nit includes `p` as an additional simp lemma when simplifying `q`.\n</code>",
 "3087":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">When simp discharges side conditions for conditional lemmas, it can recursively apply simplification.\nThe `maxDischargeDepth` (default: 2) is the maximum recursion depth when recursively applying simplification to side conditions.\n</code>",
 "3086":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The maximum number of subexpressions to visit when performing simplification.\nThe default is 100000.\n</code>",
 "3085":
 "<code>Lean.Meta.Simp.Config.mk (maxSteps maxDischargeDepth : Nat) (contextual memoize singlePass zeta beta eta : Bool)\n  (etaStruct : Lean.Meta.EtaStructMode)\n  (iota proj decide arith autoUnfold dsimp failIfUnchanged ground unfoldPartialApp zetaDelta index implicitDefEqProofs\n    zetaUnused : Bool) :\n  Lean.Meta.Simp.Config</code>",
 "3084":
 "<code>Lean.Meta.Simp.neutralConfig : Lean.Meta.Simp.Config</code><span class=\"sep\"></span><code class=\"docstring\">A neutral configuration for `simp`, turning off all reductions and other built-in simplifications.\n</code>",
 "3083": "<code>Nat.reduceAdd : Lean.Meta.Simp.DSimproc</code>",
 "3082": "<code>Nat.zero_add (n : Nat) : 0 + n = n</code>",
 "3081": "<code>List.length_nil.{u} {α : Type u} : [].length = 0</code>",
 "3080":
 "<code>List.length_cons.{u_1} {α : Type u_1} (a : α) (as : List α) : (a :: as).length = as.length + 1</code>",
 "308":
 "<code>Or (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∨` in identifiers is `or`.\n\n * The recommended spelling of `\\/` in identifiers is `or` (prefer `∨` over `\\/`).</code>",
 "3079":
 "<code>List.size_toArray.{u} {α : Type u} (as : List α) : as.toArray.size = as.length</code>",
 "3078": "<code>xs.size = 2</code>",
 "3077":
 "<code>List.toArray.{u_1} {α : Type u_1} (xs : List α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `List α` into an `Array α`.\n\n `O(|xs|)`. At runtime, this operation is implemented by `List.toArrayImpl` and takes time linear in\nthe length of the list. `List.toArray` should be used instead of `Array.mk`.\n\nExamples:\n * `[1, 2, 3].toArray = #[1, 2, 3]`\n * `[\"monday\", \"wednesday\", friday\"].toArray = #[\"monday\", \"wednesday\", friday\"].`\n</code>",
 "3076": "<code>Array Unit</code>",
 "3075": "<code>autoParam Lean.Name _auto✝</code>",
 "3074": "<code>Lean.Meta.SimpExtension : Type</code>",
 "3073":
 "<code>Lean.Meta.registerSimpAttr (attrName : Lean.Name) (attrDescr : String) (ref : Lean.Name := by exact decl_name%) :\n  IO Lean.Meta.SimpExtension</code>",
 "3072": "<code class=\"docstring\">simplification theorem</code>",
 "3071": "<code>p (x + 12)</code>",
 "3070": "<code>p (x + 7)</code>",
 "307":
 "<code>Dvd.dvd.{u_1} {α : Type u_1} [self : Dvd α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Divisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.</code>",
 "3069": "<code>p (3 + x + 9)</code>",
 "3068": "<code>p (x + 5 + 2)</code>",
 "3067": "<code>iff_self (p : Prop) : (p ↔ p) = True</code>",
 "3066": "<code>eq_self.{u_1} {α : Sort u_1} (a : α) : (a = a) = True</code>",
 "3065":
 "<code>Lean.Meta.Simp.Config.autoUnfold (self : Lean.Meta.Simp.Config) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), unfolds definitions.\nThis can be enabled using the `simp!` syntax.\n</code>",
 "3064": "<code>Lean.KeyedDeclsAttribute (γ : Type) : Type</code>",
 "3063":
 "<code>Lean.Meta.DSimp.Config : Type</code><span class=\"sep\"></span><code class=\"docstring\">The configuration for `dsimp`.\nPassed to `dsimp` using, for example, the `dsimp (config := {zeta := false})` syntax.\n\nImplementation note: this structure is only used for processing the `(config := ...)` syntax, and it is not used internally.\nIt is immediately converted to `Lean.Meta.Simp.Config` by `Lean.Elab.Tactic.elabSimpConfig`.\n</code>",
 "3062": "<code>Lean.Meta.Simp.Stats : Type</code>",
 "3061": "<code>Lean.Meta.Simp.ConfigCtx : Type</code>",
 "3060":
 "<code>Lean.Meta.Simp.Config : Type</code><span class=\"sep\"></span><code class=\"docstring\">The configuration for `simp`.\nPassed to `simp` using, for example, the `simp (config := {contextual := true})` syntax.\n\nSee also `Lean.Meta.Simp.neutralConfig` and `Lean.Meta.DSimp.Config`.\n</code>",
 "306": "<code>2 ∣ 2</code>",
 "3059": "<code><span class=\"literal string\">\"]\"</span> : String</code>",
 "3058": "<code><span class=\"literal string\">\"[\"</span> : String</code>",
 "3057": "<code>Lean.Elab.Tactic.ElabSimpArgsResult : Type</code>",
 "3056": "<code>Lean.Elab.Tactic.SimpKind : Type</code>",
 "3055": "<code>SimpKind</code>",
 "3054": "<code>Lean.Meta.Simp.SimprocsArray : Type</code>",
 "3053": "<code>Lean.Meta.Simp.SimprocsArray</code>",
 "3052": "<code>Lean.Meta.Simp.Context : Type</code>",
 "3051": "<code>Lean.Meta.Simp.Context</code>",
 "3050": "<code>Lean.Elab.Tactic.Tactic : Type</code>",
 "305":
 "<code>LE.le.{u} {α : Type u} [self : LE α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≤` in identifiers is `le`.\n\n * The recommended spelling of `&lt;=` in identifiers is `le` (prefer `≤` over `&lt;=`).</code>",
 "3049": "<code>Lean.Syntax → TacticM Lean.Syntax</code>",
 "3048":
 "<code>Lean.MacroScope : Type</code><span class=\"sep\"></span><code class=\"docstring\">A macro scope identifier is just a `Nat` that gets bumped every time we\nenter a new macro scope. Within a macro scope, all occurrences of identifier `x`\nparse to the same thing, but `x` parsed from different macro scopes will\nproduce different identifiers.\n</code>",
 "3047": "<code>Unit → TacticM α</code>",
 "3046": "<code>Lean.MVarId → Lean.MetaM α</code>",
 "3045":
 "<code>Lean.Exception : Type</code><span class=\"sep\"></span><code class=\"docstring\">Exception type used in most Lean monads </code>",
 "3044": "<code>Lean.Exception → TacticM α</code>",
 "3043":
 "<code>Lean.Elab.Tactic.elabTermWithHoles (stx : Lean.Syntax) (expectedType? : Option Lean.Expr) (tagSuffix : Lean.Name)\n  (allowNaturalHoles : Bool := false) (parentTag? : Option Lean.Name := none) : TacticM (Lean.Expr × List Lean.MVarId)</code><span class=\"sep\"></span><code class=\"docstring\">Elaborates `stx` and collects the `MVarId`s of any holes that were created during elaboration.\n\nWith `allowNaturalHoles := false` (the default), any new natural holes (`_`) which cannot\nbe synthesized during elaboration cause `elabTermWithHoles` to fail. (Natural goals appearing in\n`stx` which were created prior to elaboration are permitted.)\n\nUnnamed `MVarId`s are renamed to share the tag `parentTag?` (or the main goal's tag if `parentTag?` is `none`).\nIf multiple unnamed goals are encountered, `tagSuffix` is appended to this tag along with a numerical index.\n\nNote:\n* Previously-created `MVarId`s which appear in `stx` are not returned.\n* All parts of `elabTermWithHoles` operate at the current `MCtxDepth`, and therefore may assign\nmetavariables.\n* When `allowNaturalHoles := true`, `stx` is elaborated under `withAssignableSyntheticOpaque`,\nmeaning that `.syntheticOpaque` metavariables might be assigned during elaboration. This is a\nconsequence of the implementation. </code>",
 "3042": "<code>optParam (Option Lean.Name) none</code>",
 "3041":
 "<code>Lean.Elab.Tactic.elabTermEnsuringType (stx : Lean.Syntax) (expectedType? : Option Lean.Expr)\n  (mayPostpone : Bool := false) : TacticM Lean.Expr</code><span class=\"sep\"></span><code class=\"docstring\">Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration and then a `TypeMismatchError` will be thrown if the elaborated type doesn't match.  </code>",
 "3040": "<code>Option Lean.Expr</code>",
 "304":
 "<code>∀ (n : Nat),\n  n ≤ { val := 2, isEven := ⋯ }.val → n ∣ { val := 2, isEven := ⋯ }.val → n = 1 ∨ n = { val := 2, isEven := ⋯ }.val</code>",
 "3039":
 "<code>Lean.Elab.Tactic.pushGoals (mvarIds : List Lean.MVarId) : TacticM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Add the given goals to the front of the current list of goals. </code>",
 "3038": "<code>Lean.Expr → Lean.Name → TacticM Lean.Expr</code>",
 "3037": "<code>Lean.Name</code>",
 "3036":
 "<code>Lean.Elab.Tactic.withLocation (loc : Location) (atLocal : Lean.FVarId → TacticM Unit) (atTarget : TacticM Unit)\n  (failed : Lean.MVarId → TacticM Unit) : TacticM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Runs the given `atLocal` and `atTarget` methods on each of the locations selected by the given `loc`.\n* If `loc` is a list of locations, runs at each specified hypothesis (and finally the goal if `⊢` is included),\n  and fails if any of the tactic applications fail.\n* If `loc` is `*`, runs at the target first and then the hypotheses in reverse order.\n  If `atTarget` closes the main goal, `withLocation` does not run `atLocal`.\n  If all tactic applications fail, `withLocation` with call `failed` with the main goal mvar.\n</code>",
 "3035": "<code>Lean.MVarId → TacticM Unit</code>",
 "3034": "<code>Lean.FVarId → TacticM Unit</code>",
 "3033":
 "<code>Lean.Elab.Tactic.Location : Type</code><span class=\"sep\"></span><code class=\"docstring\">Denotes a set of locations where a tactic should be applied for the main goal. See also `withLocation`. </code>",
 "3032": "<code>Location</code>",
 "3031": "<code>Array Lean.MVarId</code>",
 "3030": "<code>List Lean.MVarId</code>",
 "303": "<code>two : EvenPrime</code>",
 "3029":
 "<code>Lean.MonadMCtx (m : Type → Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad with a stateful metavariable context, defining `getMCtx` and `modifyMCtx`. </code>",
 "3028": "<code>Array Lean.Syntax</code>",
 "3027":
 "<code>Lean.FVarId : Type</code><span class=\"sep\"></span><code class=\"docstring\">The unique free variable identifier. It is just a hierarchical name,\nbut we wrap it in `FVarId` to make sure they don't get mixed up with `MVarId`.\n\nThis is not the user-facing name for a free variable. This information is stored\nin the local context (`LocalContext`). The unique identifiers are generated using\na `NameGenerator`.\n</code>",
 "3026":
 "<code>Lean.Expr : Type</code><span class=\"sep\"></span><code class=\"docstring\">Lean expressions. This data structure is used in the kernel and\nelaborator. However, expressions sent to the kernel should not\ncontain metavariables.\n\nRemark: we use the `E` suffix (short for `Expr`) to avoid collision with keywords.\nWe considered using «...», but it is too inconvenient to use.\n</code>",
 "3025": "<code>Lean.Expr</code>",
 "3024": "<code>TacticM α</code>",
 "3023": "<code>Lean.Elab.TermElabM α</code>",
 "3022": "<code>TacticM Unit</code>",
 "3021":
 "<code>Lean.MVarId : Type</code><span class=\"sep\"></span><code class=\"docstring\">Universe metavariable Id   </code>",
 "3020": "<code>Lean.MVarId</code>",
 "302":
 "<code>EvenPrime.isPrime (self : EvenPrime) (n : Nat) : n ≤ self.val → n ∣ self.val → n = 1 ∨ n = self.val</code>",
 "3019":
 "<code><span class=\"literal string\">\"&lt;|||&gt;\"</span> : String</code>",
 "3018": "<code>emptyIsEmpty.{u_1} {α : Type u_1} : IsEmpty []</code>",
 "3017": "<code>IsEmpty.{u_1} {α : Type u_1} (xs : List α) : Prop</code>",
 "3016":
 "<code>Nat.le.refl {n : Nat} : n.le n</code><span class=\"sep\"></span><code class=\"docstring\">Non-strict inequality is reflexive: `n ≤ n` </code>",
 "3015":
 "<code>Nat.le (n : Nat) : Nat → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Non-strict, or weak, inequality of natural numbers, usually accessed via the `≤` operator.\n</code>",
 "3014":
 "<code>Nat.le.step {n m : Nat} : n.le m → n.le m.succ</code><span class=\"sep\"></span><code class=\"docstring\">If `n ≤ m`, then `n ≤ m + 1`. </code>",
 "3013": "<code>TSyntax `tactic</code>",
 "3012":
 "<code>Lean.Parser.Category.tactic : Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`tactic` is the builtin syntax category for tactics. These appear after\n`by` in proofs, and they are programs that take in the proof context\n(the hypotheses in scope plus the type of the term to synthesize) and construct\na term of the expected type. For example, `simp` is a tactic, used in:\n```\nexample : 2 + 2 = 4 := by simp\n```\n</code>",
 "3011": "<code><span class=\"literal string\">\"rep\"</span> : String</code>",
 "3010": "<code>Lean.Elab.Tactic.TacticM (α : Type) : Type</code>",
 "301": "<code>EvenPrime.notOne (self : EvenPrime) : self.val ≠ 1</code>",
 "3009": "<code>Manual.name : Verso.Doc.Elab.RoleExpander</code>",
 "3008": "<code class=\"docstring\">`norm_cast` tactic in `conv` mode. </code>",
 "3007":
 "<code class=\"docstring\">`rfl` closes one conv goal \"trivially\", by using reflexivity\n(that is, no rewriting). </code>",
 "3006":
 "<code class=\"docstring\">`trace_state` prints the current goal state. </code>",
 "3005":
 "<code class=\"docstring\">Executes the given tactic block without converting `conv` goal into a regular goal. </code>",
 "3004":
 "<code class=\"docstring\">Focuses, converts the `conv` goal `⊢ lhs` into a regular goal `⊢ lhs = rhs`, and then executes the given tactic block. </code>",
 "3003":
 "<code class=\"docstring\">Executes the given conv block without converting regular goal into a `conv` goal. </code>",
 "3002":
 "<code class=\"docstring\">The `apply thm` conv tactic is the same as `apply thm` the tactic.\nThere are no restrictions on `thm`, but strange results may occur if `thm`\ncannot be reasonably interpreted as proving one equality from a list of others. </code>",
 "3001":
 "<code class=\"docstring\">`rw [thm]` rewrites the target using `thm`. See the `rw` tactic for more information. </code>",
 "3000":
 "<code class=\"docstring\">`change t'` replaces the target `t` with `t'`,\nassuming `t` and `t'` are definitionally equal. </code>",
 "300": "<code>EvenPrime : Type</code>",
 "30":
 "<code>Lean.Syntax : Type</code><span class=\"sep\"></span><code class=\"docstring\">Lean syntax trees.\n\nSyntax trees are used pervasively throughout Lean: they are produced by the parser, transformed by\nthe macro expander, and elaborated. They are also produced by the delaborator and presented to\nusers.\n</code>",
 "3":
 "<code>Unit : Type</code><span class=\"sep\"></span><code class=\"docstring\">The canonical type with one element. This element is written `()`.\n\n`Unit` has a number of uses:\n* It can be used to model control flow that returns from a function call without providing other\n  information.\n* Monadic actions that return `Unit` have side effects without computing values.\n* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\n  field.\n</code>",
 "2999":
 "<code class=\"docstring\">`simp_match` simplifies match expressions. For example,\n```\nmatch [a, b] with\n| [] =&gt; 0\n| hd :: tl =&gt; hd\n```\nsimplifies to `a`. </code>",
 "2998": "<code>Nat.sub_self (n : Nat) : n - n = 0</code>",
 "2997":
 "<code class=\"docstring\">`dsimp` is the definitional simplifier in `conv`-mode. It differs from `simp` in that it only\napplies theorems that hold by reflexivity.\n\nExamples:\n\n```lean\nexample (a : Nat): (0 + 0) = a - a := by\n  conv =&gt;\n    lhs\n    dsimp\n    rw [← Nat.sub_self a]\n```\n</code>",
 "2996":
 "<code class=\"docstring\">`simp [thm]` performs simplification using `thm` and marked `@[simp]` lemmas.\nSee the `simp` tactic for more information. </code>",
 "2995":
 "<code class=\"docstring\">* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n\nThis is the `conv` version of the `unfold` tactic.\n</code>",
 "2994":
 "<code class=\"docstring\">`delta id1 id2 ...` unfolds all occurrences of `id1`, `id2`, ... in the target.\nLike the `delta` tactic, this ignores any definitional equations and uses\nprimitive delta-reduction instead, which may result in leaking implementation details.\nUsers should prefer `unfold` for unfolding definitions. </code>",
 "2993":
 "<code class=\"docstring\">Expands let-declarations and let-variables. </code>",
 "2992":
 "<code class=\"docstring\">Puts term in normal form, this tactic is meant for debugging purposes only. </code>",
 "2991": "<code>?m.3617</code>",
 "2990": "<code>?m.3617 → ?m.3605</code>",
 "299": "<code>EvenNumber.isEven (self : EvenNumber) : 2 ∣ self.val</code>",
 "2989": "<code>?m.3596</code>",
 "2988": "<code>?m.3596 → ?m.3575</code>",
 "2987":
 "<code class=\"docstring\">Reduces the target to Weak Head Normal Form. This reduces definitions\nin \"head position\" until a constructor is exposed. For example, `List.map f [a, b, c]`\nweak head normalizes to `f a :: List.map f [b, c]`. </code>",
 "2986":
 "<code class=\"docstring\">`right` traverses into the right argument. Synonym for `rhs`. </code>",
 "2985":
 "<code class=\"docstring\">`left` traverses into the left argument. Synonym for `lhs`. </code>",
 "2984":
 "<code class=\"docstring\">`args` traverses into all arguments. Synonym for `congr`. </code>",
 "2983": "<code>Sort ?u.3350</code>",
 "2982": "<code>?m.3348</code>",
 "2981": "<code>?m.3342</code>",
 "2980": "<code>?m.3345</code>",
 "298": "<code>EvenNumber.val (self : EvenNumber) : Nat</code>",
 "2979":
 "<code class=\"docstring\">`ext x` traverses into a binder (a `fun x =&gt; e` or `∀ x, e` expression)\nto target `e`, introducing name `x` in the process. </code>",
 "2978":
 "<code class=\"docstring\">* `pattern pat` traverses to the first subterm of the target that matches `pat`.\n* `pattern (occs := *) pat` traverses to every subterm of the target that matches `pat`\n  which is not contained in another match of `pat`. It generates one subgoal for each matching\n  subterm.\n* `pattern (occs := 1 2 4) pat` matches occurrences `1, 2, 4` of `pat` and produces three subgoals.\n  Occurrences are numbered left to right from the outside in.\n\nNote that skipping an occurrence of `pat` will traverse inside that subexpression, which means\nit may find more matches and this can affect the numbering of subsequent pattern matches.\nFor example, if we are searching for `f _` in `f (f a) = f b`:\n* `occs := 1 2` (and `occs := *`) returns `| f (f a)` and `| f b`\n* `occs := 2` returns `| f a`\n* `occs := 2 3` returns `| f a` and `| f b`\n* `occs := 1 3` is an error, because after skipping `f b` there is no third match.\n</code>",
 "2977":
 "<code class=\"docstring\">`enter [arg, ...]` is a compact way to describe a path to a subterm.\nIt is a shorthand for other conv tactics as follows:\n* `enter [i]` is equivalent to `arg i`.\n* `enter [@i]` is equivalent to `arg @i`.\n* `enter [x]` (where `x` is an identifier) is equivalent to `ext x`.\nFor example, given the target `f (g a (fun x =&gt; x b))`, `enter [1, 2, x, 1]`\nwill traverse to the subterm `b`. </code>",
 "2976": "<code>?m.2104</code>",
 "2975":
 "<code class=\"docstring\">Performs one step of \"congruence\", which takes a term and produces\nsubgoals for all the function arguments. For example, if the target is `f x y` then\n`congr` produces two subgoals, one for `x` and one for `y`. </code>",
 "2974":
 "<code class=\"docstring\">Traverses into the function of a (unary) function application.\nFor example, `| f a b` turns into `| f a`. (Use `arg 0` to traverse into `f`.)  </code>",
 "2973":
 "<code class=\"docstring\">Traverses into the right subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the last argument.\nIt is a synonym for `arg -1`.\n</code>",
 "2972":
 "<code class=\"docstring\">`· conv` focuses on the main conv goal and tries to solve it using `s`. </code>",
 "2971":
 "<code class=\"docstring\">`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n</code>",
 "2970":
 "<code class=\"docstring\">`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. </code>",
 "297": "<code>EvenNumber : Type</code>",
 "2969":
 "<code class=\"docstring\">`done` succeeds iff there are no goals remaining. </code>",
 "2968": "<code>?m.1118</code>",
 "2967":
 "<code class=\"docstring\">`(convs)` runs the `convs` in sequence on the current list of targets.\nThis is pure grouping with no added effects. </code>",
 "2966": "<code>?m.228</code>",
 "2965":
 "<code class=\"docstring\">`{ convs }` runs the list of `convs` on the current target, and any subgoals that\nremain are trivially closed by `skip`. </code>",
 "2964":
 "<code class=\"docstring\">`repeat convs` runs the sequence `convs` repeatedly until it fails to apply. </code>",
 "2963":
 "<code class=\"docstring\">`first | conv | ...` runs each `conv` until one succeeds, or else fails. </code>",
 "2962":
 "<code class=\"docstring\">`conv =&gt; cs` runs `cs` in sequence on the target `t`,\nresulting in `t'`, which becomes the new target subgoal. </code>",
 "2961":
 "<code class=\"docstring\">`intro` traverses into binders. Synonym for `ext`. </code>",
 "2960": "<code>Nat.add_assoc (n m k : Nat) : n + m + k = n + (m + k)</code>",
 "296":
 "<code>Triple.toPair.{u} {α : Type u} (self : Triple α) : Pair α</code>",
 "2959": "<code>Nat.add_comm (n m : Nat) : n + m = m + n</code>",
 "2958":
 "<code class=\"docstring\">`rw [rules]` applies the given list of rewrite rules to the target.\nSee the `rw` tactic for more information. </code>",
 "2957":
 "<code class=\"docstring\">* `arg i` traverses into the `i`'th argument of the target. For example if the\n  target is `f a b c d` then `arg 1` traverses to `a` and `arg 3` traverses to `c`.\n  The index may be negative; `arg -1` traverses into the last argument,\n  `arg -2` into the second-to-last argument, and so on.\n* `arg @i` is the same as `arg i` but it counts all arguments instead of just the\n  explicit arguments.\n* `arg 0` traverses into the function. If the target is `f a b c d`, `arg 0` traverses into `f`. </code>",
 "2956":
 "<code class=\"docstring\">Traverses into the left subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the second to last argument.\nIt is a synonym for `arg -2`.\n</code>",
 "2955":
 "<code class=\"docstring\">The `run_tac doSeq` tactic executes code in `TacticM Unit`. </code>",
 "2954": "<code>?m.20204</code>",
 "2953":
 "<code class=\"docstring\">`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n</code>",
 "2952":
 "<code class=\"docstring\">`expose_names` renames all inaccessible variables with accessible names, making them available\nfor reference in generated tactics. However, this renaming introduces machine-generated names\nthat are not fully under user control. `expose_names` is primarily intended as a preamble for\nauto-generated end-game tactic scripts. It is also useful as an alternative to\n`set_option tactic.hygienic false`. If explicit control over renaming is needed in the\nmiddle of a tactic script, consider using structured tactic scripts with\n`match .. with`, `induction .. with`, or `intro` with explicit user-defined names,\nas well as tactics such as `next`, `case`, and `rename_i`.\n</code>",
 "2951":
 "<code class=\"docstring\">`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n</code>",
 "2950":
 "<code class=\"docstring\">`and_intros` applies `And.intro` until it does not make progress. </code>",
 "295": "<code>Nat</code>",
 "2949":
 "<code class=\"docstring\">Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n</code>",
 "2948":
 "<code class=\"docstring\">`trace msg` displays `msg` in the info view. </code>",
 "2947":
 "<code class=\"docstring\">`trace_state` displays the current state in the info view. </code>",
 "2946":
 "<code><span class=\"literal string\">\"right\"</span> : String</code>",
 "2945": "<code><span class=\"literal string\">\"left\"</span> : String</code>",
 "2944": "<code><span class=\"literal string\">\"foo\"</span> : String</code>",
 "2943":
 "<code class=\"docstring\">`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n</code>",
 "2942": "<code class=\"docstring\">`admit` is a synonym for `sorry`. </code>",
 "2941":
 "<code>sorryAx.{u} (α : Sort u) (synthetic : Bool) : α</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary axiom used to implement the `sorry` term and tactic.\n\nThe `sorry` term/tactic expands to `sorryAx _ (synthetic := false)`.\nIt is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can check if a declaration depends on `sorry` either directly or indirectly by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command.\n\nThe `synthetic` flag is false when a `sorry` is written explicitly by the user, but it is\nset to `true` when a tactic fails to prove a goal, or if there is a type error\nin the expression. A synthetic `sorry` acts like a regular one, except that it\nsuppresses follow-up errors in order to prevent an error from causing a cascade\nof other errors because the desired term was not constructed.\n</code>",
 "2940": "<code>?m.20034</code>",
 "294": "<code>coords : Triple Nat</code>",
 "2939":
 "<code class=\"docstring\">Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. </code>",
 "2938":
 "<code class=\"docstring\">`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n</code>",
 "2937":
 "<code class=\"docstring\">The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n</code>",
 "2936":
 "<code class=\"docstring\">Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n</code>",
 "2935":
 "<code class=\"docstring\">Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n</code>",
 "2934":
 "<code><span class=\"literal string\">\"proof.lrat\"</span> : String</code>",
 "2933":
 "<code class=\"docstring\">This tactic works just like `bv_decide` but skips calling a SAT solver by using a proof that is\nalready stored on disk. It is called with the name of an LRAT file in the same directory as the\ncurrent Lean file:\n```\nbv_check \"proof.lrat\"\n```\n</code>",
 "2932":
 "<code class=\"docstring\">Run the normalization procedure of `bv_decide` only. Sometimes this is enough to solve basic\n`BitVec` goals already.\n\nNote: include `import Std.Tactic.BVDecide`\n</code>",
 "2931":
 "<code class=\"docstring\">Suggest a proof script for a `bv_decide` tactic call. Useful for caching LRAT proofs.\n\nNote: include `import Std.Tactic.BVDecide`\n</code>",
 "2930":
 "<code>HOr.hOr.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HOr α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `|||` in identifiers is `or`.</code>",
 "293": "<code>Triple.thd.{u} {α : Type u} (self : Triple α) : α</code>",
 "2929":
 "<code>HAnd.hAnd.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAnd α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&&&` in identifiers is `and`.</code>",
 "2928": "<code>BitVec 64</code>",
 "2927":
 "<code class=\"docstring\">`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bitvec_to_nat] at *`.\n`bitvec_to_nat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n</code>",
 "2926":
 "<code>Min.min.{u} {α : Type u} [self : Min α] : α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the lesser of its two arguments. </code>",
 "2925":
 "<code>Int.natAbs (m : Int) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The absolute value of an integer is its distance from `0`.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `(7 : Int).natAbs = 7`\n * `(0 : Int).natAbs = 0`\n * `((-11 : Int).natAbs = 11`\n</code>",
 "2924": "<code>?m.14037</code>",
 "2923": "<code>?m.12668</code>",
 "2922": "<code>?m.12672</code>",
 "2921":
 "<code>List.range (n : Nat) : List Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns a list of the numbers from `0` to `n` exclusive, in increasing order.\n\n`O(n)`.\n\nExamples:\n* `range 5 = [0, 1, 2, 3, 4]`\n* `range 0 = []`\n* `range 2 = [0, 1]`\n</code>",
 "2920": "<code>?m.11679</code>",
 "292": "<code>Triple.{u} (α : Type u) : Type u</code>",
 "2919":
 "<code class=\"docstring\">`native_decide` is a synonym for `decide +native`.\nIt will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `Lean.ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```lean\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n</code>",
 "2918":
 "<code>decidable_of_iff {b : Prop} (a : Prop) (h : a ↔ b) [Decidable a] : Decidable b</code><span class=\"sep\"></span><code class=\"docstring\">Transfer decidability of `a` to decidability of `b`, if the propositions are equivalent.\n**Important**: this function should be used instead of `rw` on `Decidable b`, because the\nkernel will get stuck reducing the usage of `propext` otherwise,\nand `decide` will not work. </code>",
 "2917":
 "<code>Lean.ofReduceBool (a b : Bool) (h : Lean.reduceBool a = b) : a = b</code><span class=\"sep\"></span><code class=\"docstring\">The axiom `ofReduceBool` is used to perform proofs by reflection. See `reduceBool`.\n\nThis axiom is usually not used directly, because it has some syntactic restrictions.\nInstead, the `native_decide` tactic can be used to prove any proposition whose\ndecidability instance can be evaluated to `true` using the lean compiler / interpreter.\n\nWarning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\nThis is extra 30k lines of code. More importantly, you will probably not be able to check your development using\nexternal type checkers that do not implement this feature.\nKeep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\nSo, you are mainly losing the capability of type checking your development using external checkers.\n</code>",
 "2916": "<code>?m.11617</code>",
 "2915": "<code>?m.11609</code>",
 "2914": "<code>Sort ?u.11464</code>",
 "2913":
 "<code class=\"docstring\">`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n</code>",
 "2912": "<code>?m.11396</code>",
 "2911":
 "<code class=\"docstring\">`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n</code>",
 "2910":
 "<code class=\"docstring\">Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n</code>",
 "291": "<code>Pair.snd.{u} {α : Type u} (self : Pair α) : α</code>",
 "2909":
 "<code class=\"docstring\">Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n</code>",
 "2908":
 "<code class=\"docstring\">The tactic `nomatch h` is shorthand for `exact nomatch h`.\n</code>",
 "2907":
 "<code class=\"docstring\">The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n</code>",
 "2906":
 "<code class=\"docstring\">The `fun_induction` tactic is a convenience wrapper of the `induction` tactic when using a functional\ninduction principle.\n\nThe tactic invocation\n```\nfun_induction f x₁ ... xₙ y₁ ... yₘ\n```\nwhere `f` is a function defined by non-mutual structural or well-founded recursion, is equivalent to\n```\ninduction y₁, ... yₘ using f.induct x₁ ... xₙ\n```\nwhere the arguments of `f` are used as arguments to `f.induct` or targets of the induction, as\nappropriate.\n\nThe form\n```\nfun_induction f\n```\n(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses\nthese arguments. An application of `f` is eligible if it is saturated and the arguments that will\nbecome targets are free variables.\n\nThe forms `fun_induction f x y generalizing z₁ ... zₙ` and\n`fun_induction f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂` work like with `induction.`\n</code>",
 "2905": "<code>?m.5715</code>",
 "2904": "<code>sorry → sorry</code>",
 "2903":
 "<code>Verso.Genre.Manual.fun_cases (motive : Prop) (case1 : motive) : motive</code>",
 "2902":
 "<code class=\"docstring\">The `fun_cass` tactic is a convenience wrapper of the `cases` tactic when using a functional\ncases principle.\n\nThe tactic invocation\n```\nfun_cases f x ... y ...`\n```\nis equivalent to\n```\ncases y, ... using f.fun_cases x ...\n```\nwhere the arguments of `f` are used as arguments to `f.fun_cases` or targets of the case analysis, as\nappropriate.\n\nThe form\n```\nfun_cases f\n```\n(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses\nthese arguments. An application of `f` is eligible if it is saturated and the arguments that will\nbecome targets are free variables.\n\nThe form `fun_cases f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂` works like with `cases`.\n</code>",
 "2901": "<code>?m.5008</code>",
 "2900": "<code>e = PAT</code>",
 "290": "<code>Pair.fst.{u} {α : Type u} (self : Pair α) : α</code>",
 "29":
 "<code>Even.plusTwo {n : Nat} : Even n → Even (n + 2)</code><span class=\"sep\"></span><code class=\"docstring\">If `n` is even, then so is `n + 2`. </code>",
 "2899": "<code>?m.4953 x</code>",
 "2898": "<code>?m.4941</code>",
 "2897": "<code>Sort ?u.4799</code>",
 "2896": "<code>ty</code>",
 "2895": "<code>?m.4789</code>",
 "2894": "<code>a = b</code>",
 "2893": "<code>a ∧ b ∧ c ∨ d</code>",
 "2892": "<code>Type ?u.4228</code>",
 "2891":
 "<code class=\"docstring\">Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n</code>",
 "2890":
 "<code class=\"docstring\">Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n</code>",
 "289": "<code>Pair.{u} (α : Type u) : Type u</code>",
 "2889": "<code>List ?m.3799</code>",
 "2888": "<code>?m.3799</code>",
 "2887":
 "<code class=\"docstring\">`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. </code>",
 "2886": "<code>List ?m.3323</code>",
 "2885": "<code>?m.3323</code>",
 "2884": "<code>a :: b = c :: d</code>",
 "2883": "<code>List ?m.3308</code>",
 "2882": "<code>?m.3308</code>",
 "2881": "<code>List ?m.3304</code>",
 "2880": "<code>?m.3304</code>",
 "288":
 "<code>AcademicWork.mk (author discipline : String) : AcademicWork</code>",
 "2879": "<code>?m.3269</code>",
 "2878": "<code>?m.2632</code>",
 "2877": "<code>?m.2526</code>",
 "2876": "<code>?m.2409</code>",
 "2875":
 "<code class=\"docstring\">The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n</code>",
 "2874":
 "<code class=\"docstring\">If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n</code>",
 "2873":
 "<code class=\"docstring\">Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n</code>",
 "2872":
 "<code>Lean.Elab.Tactic.evalUnfold : Lean.Elab.Tactic.Tactic</code><span class=\"sep\"></span><code class=\"docstring\">\"unfold \" ident+ (location)? </code>",
 "2871": "<code>id.eq_def.{u} {α : Sort u} (a : α) : id a = a</code>",
 "2870":
 "<code class=\"docstring\">`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n</code>",
 "287": "<code>Book.mk (title author : String) : Book</code>",
 "2869": "<code>Lean.Meta.Rewrite.NewGoals : Type</code>",
 "2868": "<code>Lean.Meta.Rewrite.NewGoals</code>",
 "2867":
 "<code>Lean.Meta.Occurrences : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for which occurrences that match an expression should be rewritten. </code>",
 "2866": "<code>Lean.Meta.Occurrences</code>",
 "2865": "<code>Lean.Meta.TransparencyMode : Type</code>",
 "2864": "<code>Lean.Meta.TransparencyMode</code>",
 "2863":
 "<code>Lean.Meta.Rewrite.Config.mk (transparency : Lean.Meta.TransparencyMode) (offsetCnstrs : Bool)\n  (occs : Lean.Meta.Occurrences) (newGoals : Lean.Meta.Rewrite.NewGoals) : Lean.Meta.Rewrite.Config</code>",
 "2862":
 "<code class=\"docstring\">`rwa` is short-hand for `rw; assumption`. </code>",
 "2861":
 "<code class=\"docstring\">`erw [rules]` is a shorthand for `rw (transparency := .default) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). </code>",
 "2860":
 "<code class=\"docstring\">Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n</code>",
 "286":
 "<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n</code>",
 "2859":
 "<code class=\"docstring\">`simp_all_arith!` has been deprecated. It was a shorthand for `simp_all! +arith +decide`.\nNote that `+decide` is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n</code>",
 "2858":
 "<code class=\"docstring\">`simp_all_arith` has been deprecated. It was a shorthand for `simp_all +arith +decide`.\nNote that `+decide` is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n</code>",
 "2857":
 "<code class=\"docstring\">`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. </code>",
 "2856":
 "<code class=\"docstring\">`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. </code>",
 "2855":
 "<code class=\"docstring\">`simp_arith!` has been deprecated. It was a shorthand for `simp! +arith +decide`.\nNote that `+decide` is not needed for reducing arithmetic terms since simprocs have been added to Lean.\n</code>",
 "2854":
 "<code class=\"docstring\">`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n</code>",
 "2853":
 "<code class=\"docstring\">`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. </code>",
 "2852": "<code>Sort ?u.413</code>",
 "2851": "<code>Tₙ</code>",
 "2850": "<code>Sort ?u.412</code>",
 "285": "<code>toAcademicWork (self : Textbook) : AcademicWork</code>",
 "2849": "<code>T₁</code>",
 "2848":
 "<code class=\"docstring\">Apply a single extensionality theorem to the current goal. </code>",
 "2847":
 "<code class=\"docstring\">`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n</code>",
 "2846":
 "<code class=\"docstring\">Registers an extensionality theorem.\n\n* When `@[ext]` is applied to a theorem, the theorem is registered for the `ext` tactic, and it generates an \"`ext_iff`\" theorem.\nThe name of the theorem is from adding the suffix `_iff` to the theorem name.\n\n* When `@[ext]` is applied to a structure, it generates an `.ext` theorem and applies the `@[ext]` attribute to it.\nThe result is an `.ext` and an `.ext_iff` theorem with the `.ext` theorem registered for the `ext` tactic.\n\n* An optional natural number argument, e.g. `@[ext 9000]`, specifies a priority for the `ext` lemma.\nHigher-priority lemmas are chosen first, and the default is `1000`.\n\n* The flag `@[ext (iff := false)]` disables generating an `ext_iff` theorem.\n\n* The flag `@[ext (flat := false)]` causes generated structure extensionality theorems to show inherited fields based on their representation,\nrather than flattening the parents' fields into the lemma's equality hypotheses.\n</code>",
 "2845": "<code>Int.add_zero (a : Int) : a + 0 = a</code>",
 "2844": "<code>↑a + ↑b = 10</code>",
 "2843": "<code>↑(a + b + 0) = 10</code>",
 "2842": "<code>↑(a + b) = 10</code>",
 "2841":
 "<code class=\"docstring\">`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n</code>",
 "2840":
 "<code class=\"docstring\">`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. </code>",
 "284": "<code>Textbook.toAcademicWork (self : Textbook) : AcademicWork</code>",
 "2839":
 "<code class=\"docstring\">Rewrites with the given rules, normalizing casts prior to each step.\n</code>",
 "2838":
 "<code class=\"docstring\">Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n</code>",
 "2837":
 "<code class=\"docstring\">Normalize casts in the goal and the given expression, then close the goal with `exact`.\n</code>",
 "2836": "<code>?m.1567</code>",
 "2835":
 "<code class=\"docstring\">`show_term e` elaborates `e`, then prints the generated term.\n</code>",
 "2834":
 "<code class=\"docstring\">`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n</code>",
 "2833": "<code>?m.1463</code>",
 "2832": "<code>e = x</code>",
 "2831": "<code>?m.1458</code>",
 "2830": "<code>?m.1442</code>",
 "283": "<code>Textbook</code>",
 "2829": "<code>?m.1419</code>",
 "2828":
 "<code class=\"docstring\">* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n</code>",
 "2827":
 "<code class=\"docstring\">* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n</code>",
 "2826": "<code>Sort ?u.1307</code>",
 "2825":
 "<code class=\"docstring\">* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n</code>",
 "2824": "<code>?m.1207</code>",
 "2823": "<code>?m.1214</code>",
 "2822": "<code>?m.1211</code>",
 "2821":
 "<code class=\"docstring\">Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n</code>",
 "2820": "<code>x ≠ x</code>",
 "282": "<code>Book</code>",
 "2819": "<code>Sort ?u.17</code>",
 "2818": "<code>Sort ?u.159</code>",
 "2817": "<code>2 + 2 = 3</code>",
 "2816": "<code>Sort ?u.75</code>",
 "2815": "<code>none = some true</code>",
 "2814": "<code>Sort ?u.9</code>",
 "2813":
 "<code>False.elim.{u} {C : Sort u} (h : False) : C</code><span class=\"sep\"></span><code class=\"docstring\">`False.elim : False → C` says that from `False`, any desired proposition\n`C` holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.\n\nThe target type is actually `C : Sort u` which means it works for both\npropositions and types. When executed, this acts like an \"unreachable\"\ninstruction: it is **undefined behavior** to run, but it will probably print\n\"unreachable code\". (You would need to construct a proof of false to run it\nanyway, which you can only do using `sorry` or unsound axioms.)\n</code>",
 "2812":
 "<code class=\"docstring\">`as_aux_lemma =&gt; tac` does the same as `tac`, except that it wraps the resulting expression\ninto an auxiliary lemma. In some cases, this significantly reduces the size of expressions\nbecause the proof term is not duplicated.\n</code>",
 "2811":
 "<code class=\"docstring\">`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n</code>",
 "2810":
 "<code>Lean.Meta.Tactic.Backtrack.BacktrackConfig : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration structure to control the behaviour of `backtrack`:\n* control the maximum depth and behaviour (fail or return subgoals) at the maximum depth,\n* and hooks allowing\n  * modifying intermediate goals before running the external tactic,\n  * 'suspending' goals, returning them in the result, and\n  * discharging subgoals if the external tactic fails.\n</code>",
 "281":
 "<code>Textbook.mk (toBook : Book) (discipline : String) : Textbook</code>",
 "2809":
 "<code class=\"docstring\">Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). </code>",
 "2808":
 "<code class=\"docstring\">`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n</code>",
 "2807":
 "<code class=\"docstring\">`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n</code>",
 "2806":
 "<code>congr.{u, v} {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α} (h₁ : f₁ = f₂) (h₂ : a₁ = a₂) : f₁ a₁ = f₂ a₂</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in both function and argument. If `f₁ = f₂` and `a₁ = a₂` then\n`f₁ a₁ = f₂ a₂`. This only works for nondependent functions; the theorem\nstatement is more complex in the dependent case.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "2805":
 "<code class=\"docstring\">Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n</code>",
 "2804": "<code>?m.680</code>",
 "2803": "<code>x = t</code>",
 "2802":
 "<code class=\"docstring\">Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n</code>",
 "2801": "<code>?m.626</code>",
 "2800": "<code>?m.623</code>",
 "280": "<code>Textbook.toBook (self : Textbook) : Book</code>",
 "28":
 "<code>Even.zero : Even 0</code><span class=\"sep\"></span><code class=\"docstring\">0 is considered even here </code>",
 "2799": "<code>?m.619</code>",
 "2798": "<code>?m.616</code>",
 "2797": "<code>?m.576</code>",
 "2796":
 "<code class=\"docstring\">`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n</code>",
 "2795":
 "<code>Verso.Genre.Manual.conv : Verso.Doc.Elab.DirectiveExpander</code>",
 "2794":
 "<code>Trans.{u, v, w, u_1, u_2, u_3} {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (r : α → β → Sort u) (s : β → γ → Sort v)\n  (t : outParam (α → γ → Sort w)) : Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a ≤ b` and `b &lt; c`\nit knows that this should be a proof of `a &lt; c` because there is an instance\n`Trans (·≤·) (·&lt;·) (·&lt;·)`.\n</code>",
 "2793": "<code>?m.527</code>",
 "2792":
 "<code class=\"docstring\">Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `&lt;lhs&gt;\\n  _ = &lt;rhs&gt; :=\n&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n</code>",
 "2791":
 "<code class=\"docstring\">For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. </code>",
 "2790":
 "<code class=\"docstring\">`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. </code>",
 "279": "<code>AcademicWork.discipline (self : AcademicWork) : String</code>",
 "2789":
 "<code class=\"docstring\">The same as `rfl`, but without trying `eq_refl` at the end.\n</code>",
 "2788":
 "<code class=\"docstring\">`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n</code>",
 "2787":
 "<code class=\"docstring\">`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n</code>",
 "2786":
 "<code class=\"docstring\">The tactic\n```\nintro\n| pat1 =&gt; tac1\n| pat2 =&gt; tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 =&gt; tac1\n| pat2 =&gt; tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n</code>",
 "2785": "<code>AllEven f</code>",
 "2784": "<code>AllEven g</code>",
 "2783": "<code>AllEven f✝</code>",
 "2782": "<code>AllEven (f : Nat → Nat) : Prop</code>",
 "2781": "<code>?m.200</code>",
 "2780":
 "<code class=\"docstring\">`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n</code>",
 "278": "<code>AcademicWork.author (self : AcademicWork) : String</code>",
 "2779":
 "<code class=\"docstring\">`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n</code>",
 "2778": "<code>Sort ?u.176</code>",
 "2777":
 "<code class=\"docstring\">`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. </code>",
 "2776":
 "<code class=\"docstring\">* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n</code>",
 "2775":
 "<code>congrFun.{u, v} {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x} (h : f = g) (a : α) : f a = g a</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in the function part of an application: If `f = g` then `f a = g a`. </code>",
 "2774":
 "<code>trivial : True</code><span class=\"sep\"></span><code class=\"docstring\">`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. </code>",
 "2773":
 "<code class=\"docstring\">`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n</code>",
 "2772":
 "<code>Classical.propDecidable (a : Prop) : Decidable a</code><span class=\"sep\"></span><code class=\"docstring\">All propositions are `Decidable`. </code>",
 "2771":
 "<code class=\"docstring\">`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority\nlocal instance.\n\nNote that `classical` is a scoping tactic: it adds the instance only within the\nscope of the tactic.\n</code>",
 "2770":
 "<code class=\"docstring\">`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n</code>",
 "277": "<code>Book.author (self : Book) : String</code>",
 "2769":
 "<code class=\"docstring\">`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n</code>",
 "2768":
 "<code class=\"docstring\">`open Foo in e` is like `open Foo` but scoped to a single term.\nIt makes the given namespaces available in the term `e`.\n</code>",
 "2767":
 "<code class=\"docstring\">`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. </code>",
 "2766":
 "<code class=\"docstring\">`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. </code>",
 "2765":
 "<code class=\"docstring\">Similar to `let`, but using `refine'` </code>",
 "2764":
 "<code class=\"docstring\">`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. </code>",
 "2763": "<code>Type ?u.5730</code>",
 "2762": "<code>Type ?u.5731</code>",
 "2761": "<code>Type ?u.5729</code>",
 "2760": "<code>α × β × γ</code>",
 "276": "<code>Book.title (self : Book) : String</code>",
 "2759":
 "<code class=\"docstring\">The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n</code>",
 "2758":
 "<code class=\"docstring\">`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n</code>",
 "2757":
 "<code class=\"docstring\">Similar to `have`, but using `refine'` </code>",
 "2756":
 "<code class=\"docstring\">`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. </code>",
 "2755": "<code>r</code>",
 "2754": "<code>q</code>",
 "2753": "<code>Sort ?u.5033</code>",
 "2752":
 "<code class=\"docstring\">`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. </code>",
 "2751":
 "<code class=\"docstring\">`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n</code>",
 "2750":
 "<code class=\"docstring\">`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n</code>",
 "275": "<code>AcademicWork : Type</code>",
 "2749":
 "<code class=\"docstring\">The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n</code>",
 "2748":
 "<code>tactic.hygienic</code><span class=\"sep\"></span><code class=\"docstring\">make sure tactics are hygienic</code>",
 "2747":
 "<code class=\"docstring\">`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n</code>",
 "2746":
 "<code class=\"docstring\">`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n</code>",
 "2745": "<code>TacticM ?m.3285</code>",
 "2744":
 "<code>Lean.Elab.Tactic.focus {α : Type} (x : TacticM α) : TacticM α</code><span class=\"sep\"></span><code class=\"docstring\">Runs `x` with only the first unsolved goal as the goal.\nFails if there are no goal to be solved.\n</code>",
 "2743":
 "<code class=\"docstring\">`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n</code>",
 "2742":
 "<code class=\"docstring\">`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. </code>",
 "2741": "<code>?m.3093</code>",
 "2740": "<code>?m.3000</code>",
 "274": "<code>Book : Type</code>",
 "2739":
 "<code class=\"docstring\">`any_goals tac` applies the tactic `tac` to every goal,\nconcating the resulting goals for successful tactic applications.\nIf the tactic fails on all of the goals, the entire `any_goals` tactic fails.\n\nThis tactic is like `all_goals try tac` except that it fails if none of the applications of `tac` succeeds.\n</code>",
 "2738": "<code>x = 2</code>",
 "2737": "<code>x = 1</code>",
 "2736": "<code>x = 1 ∨ x = 2</code>",
 "2735":
 "<code class=\"docstring\">Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n</code>",
 "2734":
 "<code class=\"docstring\">`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n</code>",
 "2733":
 "<code class=\"docstring\">`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 =&gt; rfl\n  | i+1 =&gt; simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n</code>",
 "2732": "<code>reduceIte : Lean.Meta.Simp.Simproc</code>",
 "2731": "<code>¬n = 0</code>",
 "2730": "<code>n = 0</code>",
 "273": "<code>Textbook : Type</code>",
 "2729": "<code>Sort ?u.1660</code>",
 "2728": "<code>?m.1614</code>",
 "2727": "<code>t</code>",
 "2726":
 "<code class=\"docstring\">`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n</code>",
 "2725": "<code>?m.1400</code>",
 "2724":
 "<code class=\"docstring\">`try tac` runs `tac` and succeeds even if `tac` failed. </code>",
 "2723":
 "<code class=\"docstring\">`fail_if_success t` fails if the tactic `t` succeeds. </code>",
 "2722":
 "<code class=\"docstring\">`fail msg` is a tactic that always fails, and produces an error using the given message. </code>",
 "2721":
 "<code class=\"docstring\">`first | tac | ...` runs each `tac` until one succeeds, or else fails. </code>",
 "2720":
 "<code>pp.mvars</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display names of metavariables when true, and otherwise display them as '?_' (for expression metavariables) and as '_' (for universe level metavariables)</code>",
 "272":
 "<code>Float</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "2719":
 "<code>Nat.lt_trans {n m k : Nat} (h₁ : n &lt; m) : m &lt; k → n &lt; k</code>",
 "2718": "<code>j &lt; k</code>",
 "2717": "<code>List ?m.1052</code>",
 "2716": "<code>?m.1052</code>",
 "2715": "<code>Type ?u.896</code>",
 "2714":
 "<code>pp.maxSteps</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) maximum number of expressions to visit, after which terms will pretty print as `⋯`</code>",
 "2713":
 "<code>pp.deepTerms.threshold</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) when `pp.deepTerms` is false, the depth at which terms start being replaced with `⋯`</code>",
 "2712":
 "<code>pp.deepTerms</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display deeply nested terms, replacing them with `⋯` if set to false</code>",
 "2711": "<code>↑i &gt; 5</code>",
 "2710": "<code>Fin n</code>",
 "271":
 "<code>Float</code><span class=\"sep\"></span><code class=\"docstring\">The first element of a pair. </code>",
 "2709":
 "<code>pp.proofs.threshold</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) when `pp.proofs` is false, controls the complexity of proofs at which they begin being replaced with `⋯`</code>",
 "2708":
 "<code>pp.proofs</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display proofs when true, and replace proofs appearing within expressions by `⋯` when false</code>",
 "2707": "<code>n✝ + 1 + 1 + 1 &lt; 3</code>",
 "2706": "<code>0 + 1 + 1 &lt; 3</code>",
 "2705":
 "<code class=\"docstring\">`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n</code>",
 "2704": "<code>x &lt; 3</code>",
 "2703":
 "<code>[Error pretty printing expression: unknown metavariable '?_uniq.113'. Falling back to raw printer.]\nfun (f : _uniq.102 -&gt; (Option.{?_uniq.25} _uniq.105)) =&gt; ?_uniq.113 f</code>",
 "2702":
 "<code class=\"docstring\">`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. </code>",
 "2701": "<code>α → β✝</code>",
 "2700": "<code>Type ?u.561</code>",
 "270":
 "<code>Float : Type</code><span class=\"sep\"></span><code class=\"docstring\">Native floating point type, corresponding to the IEEE 754 *binary64* format\n(`double` in C or `f64` in Rust). </code>",
 "27":
 "<code>Even : Nat → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Evenness: a number is even if it can be evenly divided by two.\n</code>",
 "2699": "<code>Type ?u.453</code>",
 "2698": "<code>ih : xs ++ [] = xs</code>",
 "2697": "<code>xs : List α</code>",
 "2696": "<code>x : α</code>",
 "2695": "<code>xs ++ [] = xs</code>",
 "2694": "<code>Type ?u.314</code>",
 "2693": "<code>0 + n✝ = n✝ + 0</code>",
 "2692": "<code>n✝ + k = k + n✝</code>",
 "2691":
 "<code class=\"docstring\">`case'` is similar to the `case tag =&gt; tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n</code>",
 "2690": "<code>β → Option γ</code>",
 "269": "<code>location : Float × Float</code>",
 "2689": "<code>α → Option β</code>",
 "2688": "<code>Option (α → β)</code>",
 "2687": "<code>Option α</code>",
 "2686": "<code>Type ?u.25</code>",
 "2685":
 "<code class=\"docstring\">* `case tag =&gt; tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ =&gt; tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ =&gt; tac` is equivalent to `(case tag₁ =&gt; tac); (case tag₂ =&gt; tac)`.\n</code>",
 "2684":
 "<code class=\"docstring\">`tac &lt;;&gt; tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n</code>",
 "2683":
 "<code>IO.cancel.{u_1} {α : Type u_1} : Task α → BaseIO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Requests cooperative cancellation of the task. The task must explicitly call `IO.checkCanceled` to\nreact to the cancellation.\n</code>",
 "2682":
 "<code>IO.TaskState : Type</code><span class=\"sep\"></span><code class=\"docstring\">The current state of a `Task` in the Lean runtime's task manager. </code>",
 "2681": "<code>α → IO (Task (Except IO.Error β))</code>",
 "2680": "<code>α → EIO ε (Task (Except ε β))</code>",
 "268": "<code>two'' : AugmentedIntArray</code>",
 "2679": "<code>α → BaseIO (Task β)</code>",
 "2678":
 "<code>EIO.mapTasks.{u_1} {α : Type u_1} {ε β : Type} (f : List α → EIO ε β) (tasks : List (Task α))\n  (prio : Task.Priority := Task.Priority.default) (sync : Bool := false) : BaseIO (Task (Except ε β))</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new task that waits for all the tasks in the list `tasks` to complete, and then runs the\n`EIO ε` action `f` on their results. This new task has priority `prio`.\n\nRunning the resulting `BaseIO` action causes the task to be started eagerly. Unlike pure tasks\ncreated by `Task.spawn`, tasks created by this function will run even if the last reference to the\ntask is dropped. The `act` should explicitly check for cancellation via `IO.checkCanceled` if it\nshould be terminated or otherwise react to the last reference being dropped.\n</code>",
 "2677": "<code>List α → IO β</code>",
 "2676": "<code>List α → EIO ε β</code>",
 "2675": "<code>List α → BaseIO β</code>",
 "2674": "<code>α → IO β</code>",
 "2673": "<code>α → EIO ε β</code>",
 "2672":
 "<code>IO.checkCanceled : BaseIO Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the current task's cancellation flag has been set by calling `IO.cancel` or by\ndropping the last reference to the task.\n</code>",
 "2671":
 "<code>Task.spawn.{u} {α : Type u} (fn : Unit → α) (prio : Task.Priority := Task.Priority.default) : Task α</code><span class=\"sep\"></span><code class=\"docstring\">`spawn fn : Task α` constructs and immediately launches a new task for\nevaluating the function `fn () : α` asynchronously.\n\n`prio`, if provided, is the priority of the task.\n</code>",
 "2670": "<code>α → BaseIO β</code>",
 "267": "<code>two' : AugmentedIntArray</code>",
 "2669": "<code>autoParam (tasks.length &gt; 0) _auto✝</code>",
 "2668": "<code>List (Task α)</code>",
 "2667": "<code>α → Task β</code>",
 "2666": "<code>optParam Bool false</code>",
 "2665": "<code>Task α</code>",
 "2664":
 "<code>Task.Priority.max : Task.Priority</code><span class=\"sep\"></span><code class=\"docstring\">The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but will spawn a\ndedicated worker for the task. This is indicated using `Task.Priority.dedicated`. Regular priority\ntasks are placed in a thread pool and worked on according to their priority order.\n</code>",
 "2663":
 "<code>Task.Priority.default : Task.Priority</code><span class=\"sep\"></span><code class=\"docstring\">The default priority for spawned tasks, also the lowest priority: `0`. </code>",
 "2662":
 "<code>Task.Priority : Type</code><span class=\"sep\"></span><code class=\"docstring\">Task priority.\n\nTasks with higher priority will always be scheduled before tasks with lower priority. Tasks with a\npriority greater than `Task.Priority.max` are scheduled on dedicated threads.\n</code>",
 "2661": "<code>optParam Task.Priority Task.Priority.default</code>",
 "2660":
 "<code>Task.bind.{u_1, u_2} {α : Type u_1} {β : Type u_2} (x : Task α) (f : α → Task β)\n  (prio : Task.Priority := Task.Priority.default) (sync : Bool := false) : Task β</code><span class=\"sep\"></span><code class=\"docstring\">`bind x f` does a monad \"bind\" operation on the task `x` with function `f`:\nthat is, it constructs (and immediately launches) a new task which will wait\nfor the value of `x` to be available and then calls `f` on the result,\nresulting in a new task which is then run for a result.\n\n`prio`, if provided, is the priority of the task.\nIf `sync` is set to true, `f` is executed on the current thread if `x` has already finished and\notherwise on the thread that `x` finished on. `prio` is ignored in this case. This should only be\ndone when executing `f` is cheap and non-blocking.\n</code>",
 "266": "<code>two : AugmentedIntArray</code>",
 "2659":
 "<code>Task.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (x : Task α)\n  (prio : Task.Priority := Task.Priority.default) (sync : Bool := false) : Task β</code><span class=\"sep\"></span><code class=\"docstring\">`map f x` maps function `f` over the task `x`: that is, it constructs\n(and immediately launches) a new task which will wait for the value of `x` to\nbe available and then calls `f` on the result.\n\n`prio`, if provided, is the priority of the task.\nIf `sync` is set to true, `f` is executed on the current thread if `x` has already finished and\notherwise on the thread that `x` finished on. `prio` is ignored in this case. This should only be\ndone when executing `f` is cheap and non-blocking.\n</code>",
 "2658":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">Blocks the current thread until the given task has finished execution, and then returns the result\nof the task. If the current thread is itself executing a (non-dedicated) task, the maximum\nthreadpool size is temporarily increased by one while waiting so as to ensure the process cannot\nbe deadlocked by threadpool starvation. Note that when the current thread is unblocked, more tasks\nthan the configured threadpool size may temporarily be running at the same time until sufficiently\nmany tasks have finished.\n\n`Task.map` and `Task.bind` should be preferred over `Task.get` for setting up task dependencies\nwhere possible as they do not require temporarily growing the threadpool in this way.\n</code>",
 "2657":
 "<code>Task.pure.{u} {α : Type u} (get : α) : Task α</code><span class=\"sep\"></span><code class=\"docstring\">`Task.pure (a : α)` constructs a task that is already resolved with value `a`. </code>",
 "2656":
 "<code>IO.Promise (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">`Promise α` allows you to create a `Task α` whose value is provided later by calling `resolve`.\n\nTypical usage is as follows:\n1. `let promise ← Promise.new` creates a promise\n2. `promise.result? : Task (Option α)` can now be passed around\n3. `promise.result?.get` blocks until the promise is resolved\n4. `promise.resolve a` resolves the promise\n5. `promise.result?.get` now returns `some a`\n\nIf the promise is dropped without ever being resolved, `promise.result?.get` will return `none`.\nSee `Promise.result!/resultD` for other ways to handle this case.\n</code>",
 "2655":
 "<code>IO.Condvar : Type</code><span class=\"sep\"></span><code class=\"docstring\">Condition variable. </code>",
 "2654":
 "<code>IO.Channel (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">FIFO channel with unbounded buffer, where `recv?` returns a `Task`.\n\nA channel can be closed.  Once it is closed, all `send`s are ignored, and\n`recv?` returns `none` once the queue is empty.\n</code>",
 "2653":
 "<code>IO.Mutex (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Mutual exclusion primitive (lock) guarding shared state of type `α`.\n\nThe type `Mutex α` is similar to `IO.Ref α`,\nexcept that concurrent accesses are guarded by a mutex\ninstead of atomic pointer operations and busy-waiting.\n</code>",
 "2652":
 "<code>Task.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Task α` is a primitive for asynchronous computation.\nIt represents a computation that will resolve to a value of type `α`,\npossibly being computed on another thread. This is similar to `Future` in Scala,\n`Promise` in Javascript, and `JoinHandle` in Rust.\n\nThe tasks have an overridden representation in the runtime.\n</code>",
 "2651":
 "<code>StdGen : Type</code><span class=\"sep\"></span><code class=\"docstring\">\"Standard\" random number generator. </code>",
 "2650": "<code>StdGen.mk (s1 s2 : Nat) : StdGen</code>",
 "265": "<code>Int</code>",
 "2649":
 "<code>g → g × g</code><span class=\"sep\"></span><code class=\"docstring\">The 'split' operation allows one to obtain two distinct random number\ngenerators. This is very useful in functional programs (for example, when\npassing a random number generator down to recursive calls). </code>",
 "2648": "<code>g → Nat × g</code>",
 "2647":
 "<code>g → Nat × g</code><span class=\"sep\"></span><code class=\"docstring\">`next` operation returns a natural number that is uniformly distributed\n the range returned by `range` (including both end points),\nand a new generator. </code>",
 "2646": "<code>g → Nat × Nat</code>",
 "2645":
 "<code>g → Nat × Nat</code><span class=\"sep\"></span><code class=\"docstring\">`range` returns the range of values returned by\nthe generator. </code>",
 "2644":
 "<code>RandomGen.mk.{u} {g : Type u} (range : g → Nat × Nat) (next : g → Nat × g) (split : g → g × g) : RandomGen g</code>",
 "2643": "<code>gen</code>",
 "2642":
 "<code>RandomGen.{u} (g : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Interface for random number generators. </code>",
 "2641":
 "<code>IO.setRandSeed (n : Nat) : BaseIO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Seeds the random number generator state used by `IO.rand`.\n</code>",
 "2640":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">Everything that was written to the process's standard error. </code>",
 "264": "<code>Array Int</code>",
 "2639":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">Everything that was written to the process's standard output. </code>",
 "2638":
 "<code>UInt32</code><span class=\"sep\"></span><code class=\"docstring\">The process's exit code. </code>",
 "2637":
 "<code>IO.Process.Output.mk (exitCode : UInt32) (stdout stderr : String) : IO.Process.Output</code>",
 "2636":
 "<code>IO.Process.Child.wait {cfg : IO.Process.StdioConfig} : IO.Process.Child cfg → IO UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Blocks until the child process has exited and return its exit code.\n</code>",
 "2635":
 "<code>{ stdin := IO.Process.Stdio.piped, stdout := IO.Process.Stdio.piped, stderr := IO.Process.Stdio.null, cmd := \"grep\",\n      args := #[\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"] }.stdin.toHandleType</code>",
 "2634":
 "<code>IO.Process.Child\n  { stdin := IO.Process.Stdio.null,\n    stdout :=\n      { stdin := IO.Process.Stdio.piped, stdout := IO.Process.Stdio.piped, stderr := IO.Process.Stdio.null,\n          cmd := \"grep\", args := #[\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"] }.stdout,\n    stderr :=\n      { stdin := IO.Process.Stdio.piped, stdout := IO.Process.Stdio.piped, stderr := IO.Process.Stdio.null,\n          cmd := \"grep\", args := #[\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"] }.stderr }</code>",
 "2633":
 "<code>IO.Process.StdioConfig.stderr (self : IO.Process.StdioConfig) : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stderr handle. </code>",
 "2632":
 "<code>cfg.stderr.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard error handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "2631":
 "<code>IO.Process.StdioConfig.stdout (self : IO.Process.StdioConfig) : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stdout handle. </code>",
 "2630":
 "<code>cfg.stdout.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard output handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "263": "<code>one : AugmentedIntArray</code>",
 "2629":
 "<code>IO.Process.Stdio.toHandleType : IO.Process.Stdio → Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of handles that can be used to communicate with a child process on its standard input,\noutput, or error streams.\n\nFor `IO.Process.Stdio.piped`, this type is `IO.FS.Handle`. Otherwise, it is `Unit`, because no\ncommunication is possible.\n</code>",
 "2628":
 "<code>IO.Process.StdioConfig.stdin (self : IO.Process.StdioConfig) : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stdin handle. </code>",
 "2627":
 "<code>cfg.stdin.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard input handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "2626":
 "<code>IO.Process.Child.mk {cfg : IO.Process.StdioConfig} (stdin : cfg.stdin.toHandleType) (stdout : cfg.stdout.toHandleType)\n  (stderr : cfg.stderr.toHandleType) : IO.Process.Child cfg</code>",
 "2625": "<code>IO.Process.StdioConfig</code>",
 "2624":
 "<code>IO.Process.StdioConfig.mk (stdin stdout stderr : IO.Process.Stdio) : IO.Process.StdioConfig</code>",
 "2623":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">Starts the child process in a new session and process group using `setsid`. Currently a no-op on\nnon-POSIX platforms.\n</code>",
 "2622": "<code>Array (String × Option String)</code>",
 "2621":
 "<code>Array (String × Option String)</code><span class=\"sep\"></span><code class=\"docstring\">Add or remove environment variables for the child process.\n\nThe child process inherits the parent's environment, as modified by `env`. Keys in the array are\nthe names of environment variables. A `none`, causes the entry to be removed from the environment,\nand `some` sets the variable to the new value, adding it if necessary. Variables are processed from left to right.\n</code>",
 "2620":
 "<code>Option System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">The child process's working directory. Inherited from the parent current process if `none`. </code>",
 "262":
 "<code>Repr.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A typeclass that specifies the standard way of turning values of some type into `Format`.\n\nWhen rendered this `Format` should be as close as possible to something that can be parsed as the\ninput value.\n</code>",
 "2619":
 "<code>IO.Process.Stdio : Type</code><span class=\"sep\"></span><code class=\"docstring\">Whether the standard input, output, and error handles of a child process should be attached to\npipes, inherited from the parent, or null.\n\nIf the stream is a pipe, then the parent process can use it to communicate with the child.\n</code>",
 "2618":
 "<code>IO.Process.StdioConfig : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the standard input, output, and error handles of a child process.\n</code>",
 "2617":
 "<code>IO.Process.SpawnArgs.mk (toStdioConfig : IO.Process.StdioConfig) (cmd : String) (args : Array String)\n  (cwd : Option System.FilePath) (env : Array (String × Option String)) (setsid : Bool) : IO.Process.SpawnArgs</code>",
 "2616":
 "<code>IO.FS.Handle.readToEnd (h : IO.FS.Handle) : IO String</code><span class=\"sep\"></span><code class=\"docstring\">Reads the entire remaining contents of the file handle as a UTF-8-encoded string. An exception is\nthrown if the contents are not valid UTF-8.\n\nThe underlying file is not automatically closed, and subsequent reads from the handle may block\nand/or return data.\n</code>",
 "2615":
 "<code>IO.Process.Child.stdout {cfg : IO.Process.StdioConfig} (self : IO.Process.Child cfg) : cfg.stdout.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard output handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "2614":
 "<code>IO.Process.Child.stdin {cfg : IO.Process.StdioConfig} (self : IO.Process.Child cfg) : cfg.stdin.toHandleType</code><span class=\"sep\"></span><code class=\"docstring\">The child process's standard input handle, if it was configured as `IO.Process.Stdio.piped`, or\n`()` otherwise.\n</code>",
 "2613":
 "<code>IO.Process.Stdio.null : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">The stream should be empty. </code>",
 "2612":
 "<code>IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stderr handle. </code>",
 "2611":
 "<code>IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stdout handle. </code>",
 "2610":
 "<code>IO.Process.Stdio.piped : IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">The stream should be attached to a pipe. </code>",
 "261":
 "<code>AugmentedIntArray.augmentation (self : AugmentedIntArray) : String</code>",
 "2609":
 "<code>IO.Process.Stdio</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for the process' stdin handle. </code>",
 "2608":
 "<code>IO.Process.Child\n  { stdin := IO.Process.Stdio.piped, stdout := IO.Process.Stdio.piped, stderr := IO.Process.Stdio.null, cmd := \"grep\",\n      args := #[\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"] }.toStdioConfig</code>",
 "2607":
 "<code>IO.Process.Child.takeStdin {cfg : IO.Process.StdioConfig} :\n  IO.Process.Child cfg →\n    IO\n      (cfg.stdin.toHandleType ×\n        IO.Process.Child { stdin := IO.Process.Stdio.null, stdout := cfg.stdout, stderr := cfg.stderr })</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the `stdin` field from a `Child` object, allowing the handle to be closed while maintaining\na reference to the child process.\n\nFile handles are closed when the last reference to them is dropped. Closing the child's standard\ninput causes an end-of-file marker. Because the `Child` object has a reference to the standard\ninput, this operation is necessary in order to close the stream while the process is running (e.g.\nto extract its exit code after calling `Child.wait`). Many processes do not terminate until their\nstandard input is exhausted.\n</code>",
 "2606":
 "<code>IO.Process.SpawnArgs.toStdioConfig (self : IO.Process.SpawnArgs) : IO.Process.StdioConfig</code>",
 "2605":
 "<code>IO.Process.Child (cfg : IO.Process.StdioConfig) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A child process that was spawned with configuration `cfg`.\n\nThe configuration determines whether the child process's standard input, standard output, and\nstandard error are `IO.FS.Handle`s or `Unit`.\n</code>",
 "2604":
 "<code><span class=\"literal string\">\"Concatenation failed\"</span> : String</code>",
 "2603":
 "<code>IO.Process.Output.stdout (self : IO.Process.Output) : String</code><span class=\"sep\"></span><code class=\"docstring\">Everything that was written to the process's standard output. </code>",
 "2602":
 "<code>IO.Process.Output.exitCode (self : IO.Process.Output) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">The process's exit code. </code>",
 "2601":
 "<code><span class=\"literal string\">\"Nonexistent.lean\"</span> : String</code>",
 "2600": "<code>IO.Process.Output</code>",
 "260":
 "<code>AugmentedIntArray.array (self : AugmentedIntArray) : Array Int</code>",
 "26": "<code>Even.plusTwo {n : Nat} : Even n → Even (n + 2)</code>",
 "2599": "<code>main : IO UInt32</code>",
 "2598":
 "<code>IO.Process.Output : Type</code><span class=\"sep\"></span><code class=\"docstring\">The result of running a process to completion.\n</code>",
 "2597": "<code><span class=\"literal string\">\"\\n\"</span> : String</code>",
 "2596":
 "<code>String.splitOn (s : String) (sep : String := \" \") : List String</code><span class=\"sep\"></span><code class=\"docstring\">Splits a string `s` on occurrences of the separator string `sep`. The default separator is `\" \"`.\n\nWhen `sep` is empty, the result is `[s]`. When `sep` occurs in overlapping patterns, the first match\nis taken. There will always be exactly `n+1` elements in the returned list if there were `n`\nnon-overlapping matches of `sep` in the string. The separators are not included in the returned\nsubstrings.\n\nExamples:\n* `\"here is some text \".splitOn = [\"here\", \"is\", \"some\", \"text\", \"\"]`\n* `\"here is some text \".splitOn \"some\" = [\"here is \", \" text \"]`\n* `\"here is some text \".splitOn \"\" = [\"here is some text \"]`\n* `\"ababacabac\".splitOn \"aba\" = [\"\", \"bac\", \"c\"]`\n</code>",
 "2595":
 "<code><span class=\"literal string\">\"^\\\\([0-9]\\\\)\\\\([0-9]\\\\)\\\\2\\\\1$\"</span> : String</code>",
 "2594": "<code><span class=\"literal string\">\"grep\"</span> : String</code>",
 "2593":
 "<code>IO.FS.Handle.putStrLn (h : IO.FS.Handle) (s : String) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the contents of the string to the handle, followed by a newline. Uses UTF-8.\n</code>",
 "2592":
 "<code><span class=\"literal string\">\"numbers.txt\"</span> : String</code>",
 "2591":
 "<code><span class=\"literal string\">\"Main.lean\"</span> : String</code>",
 "2590":
 "<code>Array String</code><span class=\"sep\"></span><code class=\"docstring\">Arguments for the command. </code>",
 "259": "<code>AugmentedIntArray : Type</code>",
 "2589": "<code><span class=\"literal string\">\"cat\"</span> : String</code>",
 "2588":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">Command name. </code>",
 "2587":
 "<code>IO.Process.SpawnArgs : Type</code><span class=\"sep\"></span><code class=\"docstring\">Configuration for a child process to be spawned.\n\nUse `IO.Process.spawn` to start the child process. `IO.Process.output` and `IO.Process.run` can be\nused when the child process should be run to completion, with its output and/or error code captured.\n</code>",
 "2586": "<code>IO.Process.SpawnArgs</code>",
 "2585":
 "<code>IO.Process.spawn (args : IO.Process.SpawnArgs) : IO (IO.Process.Child args.toStdioConfig)</code><span class=\"sep\"></span><code class=\"docstring\">Starts a child process with the provided configuration. The child process is spawned using operating\nsystem primitives, and it can be written in any language.\n\nThe child process runs in parallel with the parent.\n\nIf the child process's standard input is a pipe, use `IO.Process.Child.takeStdin` to make it\npossible to close the child's standard input before the process terminates, which provides the child with an end-of-file marker.\n</code>",
 "2584":
 "<code>IO.Process.output (args : IO.Process.SpawnArgs) : IO IO.Process.Output</code><span class=\"sep\"></span><code class=\"docstring\">Runs a process to completion and captures its output and exit code. The child process is run with a\nnull standard input, and the current process blocks until it has run to completion.\n\nThe specifications of standard input, output, and error handles in `args` are ignored.\n</code>",
 "2583":
 "<code>IO.Process.run (args : IO.Process.SpawnArgs) : IO String</code><span class=\"sep\"></span><code class=\"docstring\">Runs a process to completion, blocking until it terminates. If the child process terminates\nsuccessfully with exit code 0, its standard output is returned. An exception is thrown if it\nterminates with any other exit code.\n</code>",
 "2582":
 "<code>IO.FS.withIsolatedStreams.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] [MonadFinally m] [MonadLiftT BaseIO m]\n  (x : m α) (isolateStderr : Bool := true) : m (String × α)</code><span class=\"sep\"></span><code class=\"docstring\">Runs an action with `stdin` emptied and `stdout` and `stderr` captured into a `String`. If\n`isolateStderr` is `false`, only `stdout` is captured.\n</code>",
 "2581": "<code>runCountdown : IO String</code>",
 "2580":
 "<code><span class=\"literal string\">\"Blastoff!\"</span> : String</code>",
 "258": "<code><span class=\"literal string\">\"extra\"</span> : String</code>",
 "2579": "<code>countdown : Nat → IO Unit</code>",
 "2578": "<code>Manual.stderr : Verso.Doc.Elab.CodeBlockExpander</code>",
 "2577": "<code>Manual.stdout : Verso.Doc.Elab.CodeBlockExpander</code>",
 "2576": "<code>Manual.stdin : Verso.Doc.Elab.CodeBlockExpander</code>",
 "2575":
 "<code>IO.setStderr : IO.FS.Stream → BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the standard error stream of the current thread and returns its previous value.\n\nUse `IO.getStderr` to get the current standard error stream.\n</code>",
 "2574":
 "<code>IO.setStdout : IO.FS.Stream → BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the standard output stream of the current thread and returns its previous value.\n\nUse `IO.getStdout` to get the current standard output stream.\n</code>",
 "2573":
 "<code><span class=\"literal string\">\"Hello, \"</span> : String</code>",
 "2572":
 "<code>IO.FS.Stream.putStr (self : IO.FS.Stream) : String → IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the provided string to the stream.\n</code>",
 "2571":
 "<code><span class=\"literal string\">\"Who is it?\"</span> : String</code>",
 "2570":
 "<code>IO.FS.Stream.putStrLn (strm : IO.FS.Stream) (s : String) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the contents of the string to the stream, followed by a newline.\n</code>",
 "257": "<code>String</code>",
 "2569":
 "<code>IO.FS.withFile {α : Type} (fn : System.FilePath) (mode : IO.FS.Mode) (f : IO.FS.Handle → IO α) : IO α</code><span class=\"sep\"></span><code class=\"docstring\">Opens the file `fn` with the specified `mode` and passes the resulting file handle to `f`.\n\nThe file handle is closed when the last reference to it is dropped. If references escape `f`, then\nthe file remains open even after `IO.FS.withFile` has finished.\n</code>",
 "2568": "<code>IO.FS.Handle → IO α</code>",
 "2567":
 "<code>IO.FS.createTempDir : IO System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">Creates a temporary directory in the most secure manner possible, returning the new directory's\npath. There are no race conditions in the directory’s creation. The directory is readable and\nwritable only by the creating user ID.\n\nIt is the caller's job to remove the directory after use. Use `withTempDir` to ensure that the\ntemporary directory is removed.\n</code>",
 "2566": "<code>System.FilePath → m α</code>",
 "2565":
 "<code>IO.FS.createTempFile : IO (IO.FS.Handle × System.FilePath)</code><span class=\"sep\"></span><code class=\"docstring\">Creates a temporary file in the most secure manner possible, returning both a `Handle` to the\nalready-opened file and its path.\n\nThere are no race conditions in the file’s creation. The file is readable and writable only by the\ncreating user ID. Additionally on UNIX style platforms the file is executable by nobody.\n\nIt is the caller's job to remove the file after use. Use `withTempFile` to ensure that the temporary\nfile is removed.\n</code>",
 "2564": "<code>IO.FS.Handle → System.FilePath → m α</code>",
 "2563":
 "<code class=\"docstring\">`rename t =&gt; x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n</code>",
 "2562":
 "<code>IO.FS.removeDirAll (p : System.FilePath) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Fully remove given directory by deleting all contained files and directories in an unspecified order.\nFails if any contained entry cannot be deleted or was newly created during execution. </code>",
 "2561":
 "<code>IO.FS.removeDir : System.FilePath → IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Removes (deletes) a directory.\n\nRemoving a directory fails if the directory is not empty. Use `IO.FS.removeDirAll` to remove\ndirectories along with their contents.\n</code>",
 "2560":
 "<code>IO.FileRight : Type</code><span class=\"sep\"></span><code class=\"docstring\">POSIX-style file permissions that describe access rights for a file's owner, members of its\nassigned group, and all others.\n</code>",
 "256": "<code>List Int</code>",
 "2559": "<code>IO.FileRight</code>",
 "2558":
 "<code>IO.AccessRight</code><span class=\"sep\"></span><code class=\"docstring\">The permissions that all others have to access the file. </code>",
 "2557":
 "<code>IO.AccessRight</code><span class=\"sep\"></span><code class=\"docstring\">The assigned group's permissions to access the file. </code>",
 "2556":
 "<code>IO.AccessRight</code><span class=\"sep\"></span><code class=\"docstring\">The owner's permissions to access the file. </code>",
 "2555":
 "<code>IO.FileRight.mk (user group other : IO.AccessRight) : IO.FileRight</code>",
 "2554": "<code>Sort ?u.1316</code>",
 "2553":
 "<code>IO.AccessRight : Type</code><span class=\"sep\"></span><code class=\"docstring\">POSIX-style file permissions.\n\nThe `FileRight` structure describes these permissions for a file's owner, members of it's designated\ngroup, and all others.\n</code>",
 "2552": "<code>IO.AccessRight</code>",
 "2551":
 "<code>IO.AccessRight.mk (read write execution : Bool) : IO.AccessRight</code>",
 "2550":
 "<code>optParam (System.FilePath → IO Bool) fun x =&gt; pure true</code>",
 "255": "<code>AugmentedIntList.isEmpty : AugmentedIntList → Bool</code>",
 "2549":
 "<code>IO.FS.DirEntry : Type</code><span class=\"sep\"></span><code class=\"docstring\">An entry in a directory on a filesystem. </code>",
 "2548": "<code>IO.FS.DirEntry</code>",
 "2547":
 "<code>String</code><span class=\"sep\"></span><code class=\"docstring\">The name of the entry. </code>",
 "2546":
 "<code>System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">The directory in which the entry is found. </code>",
 "2545":
 "<code>IO.FS.DirEntry.mk (root : System.FilePath) (fileName : String) : IO.FS.DirEntry</code>",
 "2544":
 "<code>IO.FS.Metadata : Type</code><span class=\"sep\"></span><code class=\"docstring\">File metadata.\n\nThe metadata for a file can be accessed with `System.FilePath.metadata`.\n</code>",
 "2543":
 "<code>IO.FS.FileType : Type</code><span class=\"sep\"></span><code class=\"docstring\">Types of files that may be found on a filesystem. </code>",
 "2542":
 "<code>IO.FS.FileType</code><span class=\"sep\"></span><code class=\"docstring\">Whether the file is an ordinary file, a directory, a symbolic link, or some other kind of file.\n</code>",
 "2541":
 "<code>UInt64</code><span class=\"sep\"></span><code class=\"docstring\">The size of the file in bytes. </code>",
 "2540":
 "<code>IO.FS.SystemTime</code><span class=\"sep\"></span><code class=\"docstring\">File modification time. </code>",
 "254": "<code><span class=\"literal string\">\"\"</span> : String</code>",
 "2539":
 "<code>IO.FS.SystemTime : Type</code><span class=\"sep\"></span><code class=\"docstring\">Low-level system time, tracked in whole seconds and additional nanoseconds.\n</code>",
 "2538":
 "<code>IO.FS.SystemTime</code><span class=\"sep\"></span><code class=\"docstring\">File access time. </code>",
 "2537":
 "<code>IO.FS.Metadata.mk (accessed modified : IO.FS.SystemTime) (byteSize : UInt64) (type : IO.FS.FileType) : IO.FS.Metadata</code>",
 "2536":
 "<code>System.FilePath.metadata : System.FilePath → IO IO.FS.Metadata</code><span class=\"sep\"></span><code class=\"docstring\">Returns metadata for the indicated file. Throws an exception if the file does not exist or the\nmetadata cannot be accessed.\n</code>",
 "2535":
 "<code><span class=\"literal string\">\"files.tar.xz\"</span> : String</code>",
 "2534": "<code><span class=\"literal string\">\"xz\"</span> : String</code>",
 "2533":
 "<code><span class=\"literal string\">\"files/archive.tar.gz\"</span> : String</code>",
 "2532":
 "<code><span class=\"literal string\">\"files.zip\"</span> : String</code>",
 "2531":
 "<code><span class=\"literal string\">\"files\"</span> : String</code>",
 "2530": "<code><span class=\"literal string\">\"zip\"</span> : String</code>",
 "253":
 "<code>AugmentedIntList.augmentation (self : AugmentedIntList) : String</code>",
 "2529":
 "<code><span class=\"literal string\">\"files/picture.jpeg\"</span> : String</code>",
 "2528":
 "<code>System.FilePath.withExtension (p : System.FilePath) (ext : String) : System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current extension in a path `p` with `ext`, adding it if there is no extension. If the\npath has multiple file extensions, only the last one is replaced. If the path has no filename, or if\n`ext` is the empty string, then the filename is returned unmodified.\n\n`ext` should not have a leading `.`, as this function adds one.\n\nExamples:\n* `(\"files/picture.jpeg\" : System.FilePath).withExtension \"jpg\" = ⟨\"files/picture.jpg\"⟩`\n* `(\"files/\" : System.FilePath).withExtension \"zip\" = ⟨\"files/\"⟩`\n* `(\"files\" : System.FilePath).withExtension \"zip\" = ⟨\"files.zip\"⟩`\n* `(\"files/archive.tar.gz\" : System.FilePath).withExtension \"xz\" = ⟨\"files.tar.xz\"⟩`\n</code>",
 "2527": "<code><span class=\"literal string\">\"jpg\"</span> : String</code>",
 "2526": "<code><span class=\"literal string\">\"gz\"</span> : String</code>",
 "2525": "<code><span class=\"literal string\">\"exe\"</span> : String</code>",
 "2524":
 "<code>System.FilePath.extension (p : System.FilePath) : Option String</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the extension part of `p.fileName`.\n\nIf the filename contains multiple extensions, then only the last one is extracted. Returns `none` if\nthere is no file name at the end of the path.\n\nExamples:\n * `(\"app.exe\" : System.FilePath).extension = some \"exe\"`\n * `(\"file.tar.gz\" : System.FilePath).extension = some \"gz\"`\n * `(\"files/\" : System.FilePath).extension = none`\n * `(\"files/picture.jpg\" : System.FilePath).extension = some \"jpg\"`\n</code>",
 "2523":
 "<code><span class=\"literal string\">\"picture\"</span> : String</code>",
 "2522":
 "<code><span class=\"literal string\">\"files/picture.jpg\"</span> : String</code>",
 "2521":
 "<code><span class=\"literal string\">\"files/\"</span> : String</code>",
 "2520":
 "<code><span class=\"literal string\">\"file.tar\"</span> : String</code>",
 "252":
 "<code>AugmentedIntList.list (self : AugmentedIntList) : List Int</code>",
 "2519":
 "<code><span class=\"literal string\">\"file.tar.gz\"</span> : String</code>",
 "2518": "<code><span class=\"literal string\">\"app\"</span> : String</code>",
 "2517":
 "<code>System.FilePath.fileStem (p : System.FilePath) : Option String</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the stem (non-extension) part of `p.fileName`.\n\nIf the filename contains multiple extensions, then only the last one is removed. Returns `none` if\nthere is no file name at the end of the path.\n\nExamples:\n * `(\"app.exe\" : System.FilePath).fileStem = some \"app\"`\n * `(\"file.tar.gz\" : System.FilePath).fileStem = some \"file.tar\"`\n * `(\"files/\" : System.FilePath).fileStem = none`\n * `(\"files/picture.jpg\" : System.FilePath).fileStem = some \"picture\"`\n</code>",
 "2516":
 "<code><span class=\"literal string\">\"app.exe\"</span> : String</code>",
 "2515":
 "<code>System.FilePath.fileName (p : System.FilePath) : Option String</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the last element of a path if it is a file or directory name.\n\nReturns `none ` if the last entry is a special name (such as `.` or `..`) or if the path is the root\ndirectory.\n</code>",
 "2514": "<code>List String</code>",
 "2513":
 "<code>System.FilePath.mk (toString : String) : System.FilePath</code>",
 "2512":
 "<code>Div.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HDiv`: `a / b : α` where `a b : α`. </code>",
 "2511":
 "<code>System.FilePath.pathSeparator : Char</code><span class=\"sep\"></span><code class=\"docstring\">The character that separates directories.\n\nOn platforms that support multiple separators, `System.FilePath.pathSeparator` is the “ideal” one expected by users\non the platform. `System.FilePath.pathSeparators` lists all supported separators.\n</code>",
 "2510":
 "<code>System.FilePath.join (p sub : System.FilePath) : System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">Appends two paths, taking absolute paths into account. This operation is also accessible via the `/`\noperator.\n\nIf `sub` is an absolute path, then `p` is discarded and `sub` is returned. If `sub` is a relative\npath, then it is attached to `p` with the platform-specific path separator.\n</code>",
 "251": "<code>AugmentedIntList : Type</code>",
 "2509":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The read/write cursor's position in the buffer. </code>",
 "2508":
 "<code>ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">The contents of the buffer. </code>",
 "2507":
 "<code>IO.FS.Stream.Buffer.mk (data : ByteArray) (pos : Nat) : IO.FS.Stream.Buffer</code>",
 "2506":
 "<code>IO.FS.Stream.ofBuffer (r : IO.Ref IO.FS.Stream.Buffer) : IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Creates a stream from a mutable reference to a buffer.\n\nThe resulting stream simulates a file, mutating the contents of the reference in response to writes\nand reading from it in response to reads. These streams can be used with `IO.withStdin`,\n`IO.setStdin`, and the corresponding operators for standard output and standard error to redirect\ninput and output.\n</code>",
 "2505": "<code>IO.FS.Stream</code>",
 "2504":
 "<code>IO.setStdin : IO.FS.Stream → BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the standard input stream of the current thread and returns its previous value.\n\nUse `IO.getStdin` to get the current standard input stream.\n</code>",
 "2503":
 "<code>IO.FS.Stream.Buffer : Type</code><span class=\"sep\"></span><code class=\"docstring\">A byte buffer that can simulate a file in memory.\n\nUse `IO.FS.Stream.ofBuffer` to create a stream from a buffer.\n</code>",
 "2502": "<code>IO.Ref IO.FS.Stream.Buffer</code>",
 "2501":
 "<code>BaseIO Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if a stream refers to a Windows console or Unix terminal. </code>",
 "2500":
 "<code>String → IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the provided string to the stream.\n</code>",
 "250":
 "<code>Std.HashMap.insert.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashMap α β) (a : α)\n  (b : β) : Std.HashMap α β</code><span class=\"sep\"></span><code class=\"docstring\">Inserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.\n\nNote: this replacement behavior is true for `HashMap`, `DHashMap`, `HashMap.Raw` and `DHashMap.Raw`.\nThe `insert` function on `HashSet` and `HashSet.Raw` behaves differently: it will return the set\nunchanged if a matching key is already present.\n</code>",
 "25": "<code>instOfNatNat 2</code>",
 "2499":
 "<code>IO String</code><span class=\"sep\"></span><code class=\"docstring\">Reads text up to and including the next newline from the stream.\n\nIf the returned string is empty, an end-of-file marker (EOF) has been reached.\nAn EOF does not actually close a stream, so further reads may block and return more data.\n</code>",
 "2498":
 "<code>ByteArray → IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the provided bytes to the stream.\n\nIf the stream represents a physical output device such as a file on disk, then the results may be\nbuffered. Call `FS.Stream.flush` to synchronize their contents.\n</code>",
 "2497":
 "<code>USize → IO ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Reads up to the given number of bytes from the stream.\n\nIf the returned array is empty, an end-of-file marker (EOF) has been reached. An EOF does not\nactually close a stream, so further reads may block and return more data.\n</code>",
 "2496":
 "<code>IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Flushes the stream's output buffers.\n</code>",
 "2495":
 "<code>IO.FS.Stream.mk (flush : IO Unit) (read : USize → IO ByteArray) (write : ByteArray → IO Unit) (getLine : IO String)\n  (putStr : String → IO Unit) (isTty : BaseIO Bool) : IO.FS.Stream</code>",
 "2494":
 "<code>IO.FS.Handle.flush (h : Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Flushes the output buffer associated with the handle, writing any unwritten data to the associated\noutput device.\n</code>",
 "2493":
 "<code>Char.toUInt8 (c : Char) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a character into a `UInt8` that contains its code point.\n\nIf the code point is larger than 255, it is truncated (reduced modulo 256).\n</code>",
 "2492": "<code>ByteArray.push : ByteArray → UInt8 → ByteArray</code>",
 "2491": "<code>ByteArray.empty : ByteArray</code>",
 "2490":
 "<code>IO.FS.Handle.write (h : Handle) (buffer : ByteArray) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Writes the provided bytes to the the handle.\n\nWriting to a handle is typically buffered, and may not immediately modify the file on disk. Use\n`IO.FS.Handle.flush` to write changes to buffers to the associated device.\n</code>",
 "249":
 "<code>Std.HashMap.contains.{u, v} {α : Type u} {β : Type v} {x✝ : BEq α} {x✝¹ : Hashable α} (m : Std.HashMap α β) (a : α) :\n  Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if there is a mapping for the given key. There is also a `Prop`-valued version\nof this: `a ∈ m` is equivalent to `m.contains a = true`.\n\nObserve that this is different behavior than for lists: for lists, `∈` uses `=` and `contains` uses\n`==` for comparisons, while for hash maps, both use `==`.\n</code>",
 "2489":
 "<code>Char.ofUInt8 (n : UInt8) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts an 8-bit unsigned integer into a character.\n\nThe integer's value is interpreted as a Unicode code point.\n</code>",
 "2488": "<code>ByteArray.size : ByteArray → Nat</code>",
 "2487": "<code>buf.size = 1</code>",
 "2486":
 "<code>IO.FS.Handle.read (h : Handle) (bytes : USize) : IO ByteArray</code><span class=\"sep\"></span><code class=\"docstring\">Reads up to the given number of bytes from the handle. If the returned array is empty, an\nend-of-file marker (EOF) has been reached.\n\nEncountering an EOF does not close a handle. Subsequent reads may block and return more data.\n</code>",
 "2485":
 "<code>IO.FS.Handle.rewind (h : Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Rewinds the read/write cursor to the beginning of the handle's file.\n</code>",
 "2484":
 "<code>IO.FS.Mode.read : IO.FS.Mode</code><span class=\"sep\"></span><code class=\"docstring\">The file should be opened for reading.\n\nThe read/write cursor is positioned at the beginning of the file. It is an error if the file does\nnot exist.\n\n* `open` flags: `O_RDONLY`\n* `fdopen` mode: `r`\n</code>",
 "2483":
 "<code>IO.FS.Handle.mk (fn : System.FilePath) (mode : IO.FS.Mode) : IO Handle</code><span class=\"sep\"></span><code class=\"docstring\">Opens the file at `fn` with the given `mode`.\n\nAn exception is thrown if the file cannot be opened.\n</code>",
 "2482": "<code>Handle</code>",
 "2481": "<code><span class=\"literal string\">\"data\"</span> : String</code>",
 "2480":
 "<code>IO.FS.readFile (fname : System.FilePath) : IO String</code><span class=\"sep\"></span><code class=\"docstring\">Reads the entire contents of the UTF-8-encoded file at the given path as a `String`.\n\nAn exception is thrown if the contents of the file are not valid UTF-8. This is in addition to\nexceptions that may always be thrown as a result of failing to read files.\n</code>",
 "248": "<code>NatStringBimap</code>",
 "2479":
 "<code>IO.FS.Mode.write : IO.FS.Mode</code><span class=\"sep\"></span><code class=\"docstring\">The file should be opened for writing.\n\nIf the file already exists, it is truncated to zero length. Otherwise, a new file is created. The\nread/write cursor is positioned at the beginning of the file.\n\n* `open` flags: `O_WRONLY | O_CREAT | O_TRUNC`\n* `fdopen` mode: `w`\n</code>",
 "2478":
 "<code>IO.FS.Mode.readWrite : IO.FS.Mode</code><span class=\"sep\"></span><code class=\"docstring\">The file should be opened for both reading and writing.\n\nIt is an error if the file does not already exist. The read/write cursor is positioned at the\nstart of the file.\n\n* `open` flags: `O_RDWR`\n* `fdopen` mode: `r+`\n</code>",
 "2477":
 "<code>IO.FS.Handle.truncate (h : IO.FS.Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Truncates the handle to its read/write cursor.\n\nThis operation does not automatically flush output buffers, so the contents of the output device may\nnot reflect the change immediately. This does not usually lead to problems because the read/write\ncursor includes buffered writes. However, buffered writes followed by `IO.FS.Handle.rewind`, then\n`IO.FS.Handle.truncate`, and then closing the file may lead to a non-empty file. If unsure, call\n`IO.FS.Handle.flush` before truncating.\n</code>",
 "2476":
 "<code>IO.FS.Handle.rewind (h : IO.FS.Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Rewinds the read/write cursor to the beginning of the handle's file.\n</code>",
 "2475":
 "<code>IO.FS.Handle.flush (h : IO.FS.Handle) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Flushes the output buffer associated with the handle, writing any unwritten data to the associated\noutput device.\n</code>",
 "2474": "<code>ByteArray</code>",
 "2473": "<code>ByteArray : Type</code>",
 "2472": "<code>USize</code>",
 "2471": "<code>IO.FS.Handle</code>",
 "2470":
 "<code>IO.FS.Mode : Type</code><span class=\"sep\"></span><code class=\"docstring\">Whether a file should be opened for reading, writing, creation and writing, or appending.\n\nA the operating system level, this translates to the mode of a file handle (i.e., a set of `open`\nflags and an `fdopen` mode).\n\nNone of the modes represented by this datatype translate line endings (i.e. `O_BINARY` on Windows).\nFurthermore, they are not inherited across process creation (i.e. `O_NOINHERIT` on Windows and\n`O_CLOEXEC` elsewhere).\n\n**Operating System Specifics:**\n* Windows:\n  [`_open`](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/open-wopen?view=msvc-170),\n  [`_fdopen`](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/fdopen-wfdopen?view=msvc-170)\n* Linux: [`open`](https://linux.die.net/man/2/open), [`fdopen`](https://linux.die.net/man/3/fdopen)\n</code>",
 "247":
 "<code>NatStringBimap.insert (nat : Nat) (string : String) (map : NatStringBimap) : Option NatStringBimap</code>",
 "2469": "<code>IO.FS.Mode</code>",
 "2468": "<code>System.FilePath</code>",
 "2467":
 "<code>IO.FS.Handle.mk (fn : System.FilePath) (mode : IO.FS.Mode) : IO IO.FS.Handle</code><span class=\"sep\"></span><code class=\"docstring\">Opens the file at `fn` with the given `mode`.\n\nAn exception is thrown if the file cannot be opened.\n</code>",
 "2466":
 "<code>System.FilePath.exeExtension : String</code><span class=\"sep\"></span><code class=\"docstring\">The file extension expected for executable binaries on the current platform, or `\"\"` if there is no\nsuch extension.\n</code>",
 "2465":
 "<code>System.FilePath.extSeparator : Char</code><span class=\"sep\"></span><code class=\"docstring\">The character that separates file extensions from file names.\n</code>",
 "2464":
 "<code>System.FilePath.pathSeparators : List Char</code><span class=\"sep\"></span><code class=\"docstring\">The list of all path separator characters supported on the current platform.\n\nOn platforms that support multiple separators, `System.FilePath.pathSeparator` is the “ideal” one\nexpected by users on the platform.\n</code>",
 "2463":
 "<code>System.FilePath : Type</code><span class=\"sep\"></span><code class=\"docstring\">A path on the file system.\n\nPaths consist of a sequence of directories followed by the name of a file or directory. They are\ndelimited by a platform-dependent separator character (see `System.FilePath.pathSeparator`).\n</code>",
 "2462":
 "<code>IO.FS.Handle : Type</code><span class=\"sep\"></span><code class=\"docstring\">A reference to an opened file.\n\nFile handles wrap the underlying operating system's file descriptors. There is no explicit operation\nto close a file: when the last reference to a file handle is dropped, the file is closed\nautomatically.\n\nHandles have an associated read/write cursor that determines the where reads and writes occur in the\nfile.\n</code>",
 "2461":
 "<code><span class=\"literal string\">\"Validation prevented a negative balance.\"</span> : String</code>",
 "2460": "<code>IO.Ref Bool</code>",
 "246": "<code>NatStringBimap.empty : NatStringBimap</code>",
 "2459":
 "<code>ST.Ref.take {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (r : ST.Ref σ α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Reads the value of a mutable reference cell, removing it.\n\nThis causes subsequent attempts to read from or take the reference cell to block until a new value\nis written using `ST.Ref.set`.\n</code>",
 "2458":
 "<code>ST.mkRef {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (a : α) : m (ST.Ref σ α)</code>",
 "2457": "<code>α → β × α</code>",
 "2456":
 "<code><span class=\"literal string\">\"Final balance negative!\"</span> : String</code>",
 "2455":
 "<code>ST.Ref.modify {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (r : ST.Ref σ α) (f : α → α) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Atomically modifies a mutable reference cell by replacing its contents with the result of a function\ncall.\n</code>",
 "2454":
 "<code><span class=\"literal string\">\"Final balance is zero or positive.\"</span> : String</code>",
 "2453":
 "<code><span class=\"literal string\">\"Final balance is negative!\"</span> : String</code>",
 "2452":
 "<code>Task.get.{u} {α : Type u} (self : Task α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Blocks the current thread until the given task has finished execution, and then returns the result\nof the task. If the current thread is itself executing a (non-dedicated) task, the maximum\nthreadpool size is temporarily increased by one while waiting so as to ensure the process cannot\nbe deadlocked by threadpool starvation. Note that when the current thread is unblocked, more tasks\nthan the configured threadpool size may temporarily be running at the same time until sufficiently\nmany tasks have finished.\n\n`Task.map` and `Task.bind` should be preferred over `Task.get` for setting up task dependencies\nwhere possible as they do not require temporarily growing the threadpool in this way.\n</code>",
 "2451":
 "<code>Nat.toUInt32 (n : Nat) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to a 32-bit unsigned integer, wrapping on overflow.\n\nExamples:\n* `Nat.toUInt32 5 = 5`\n* `Nat.toUInt32 65_539 = 65_539`\n* `Nat.toUInt32 4_294_967_299 = 3`\n</code>",
 "2450":
 "<code>IO.sleep (ms : UInt32) : BaseIO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Pauses execution for the specified number of milliseconds.\n</code>",
 "245":
 "<code>NatStringBimap.stringToNat (self : NatStringBimap) : Std.HashMap String Nat</code>",
 "2449":
 "<code>IO.rand (lo hi : Nat) : BaseIO Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns a pseudorandom number between `lo` and `hi`, using and updating a saved random generator\nstate.\n\nThis state can be seeded using `IO.setRandSeed`.\n</code>",
 "2448":
 "<code>Task.Priority.dedicated : Task.Priority</code><span class=\"sep\"></span><code class=\"docstring\">Indicates that a task should be scheduled on a dedicated thread.\n\nAny priority higher than `Task.Priority.max` will result in the task being scheduled\nimmediately on a dedicated thread. This is particularly useful for long-running and/or\nI/O-bound tasks since Lean will, by default, allocate no more non-dedicated workers\nthan the number of cores to reduce context switches.\n</code>",
 "2447":
 "<code>IO.asTask {α : Type} (act : IO α) (prio : Task.Priority := Task.Priority.default) : BaseIO (Task (Except IO.Error α))</code><span class=\"sep\"></span><code class=\"docstring\">Runs `act` in a separate `Task`, with priority `prio`. Because `IO` actions may throw an exception\nof type `IO.Error`, the result of the task is an `Except IO.Error α`.\n\nRunning the resulting `BaseIO` action causes the task to be started eagerly. Pure accesses to the\n`Task` do not influence the impure `act`. Because `IO` actions may throw an exception of type\n`IO.Error`, the result of the task is an `Except IO.Error α`.\n\nUnlike pure tasks created by `Task.spawn`, tasks created by this function will run even if the last\nreference to the task is dropped. The `act` should explicitly check for cancellation via\n`IO.checkCanceled` if it should be terminated or otherwise react to the last reference being\ndropped.\n</code>",
 "2446": "<code>Task (Except IO.Error Unit)</code>",
 "2445":
 "<code><span class=\"literal string\">\"Sending out orders...\"</span> : String</code>",
 "2444": "<code>Array (Task (Except IO.Error Unit))</code>",
 "2443":
 "<code>IO.mkRef {α : Type} (a : α) : BaseIO (IO.Ref α)</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new mutable reference cell that contains `a`.\n</code>",
 "2442": "<code>IO.Ref Int</code>",
 "2441":
 "<code>ST.Ref.set {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (r : ST.Ref σ α) (a : α) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the value of a mutable reference.\n</code>",
 "2440":
 "<code>ST.Ref.get {σ : Type} {m : Type → Type} [MonadLiftT (ST σ) m] {α : Type} (r : ST.Ref σ α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Reads the value of a mutable reference.\n</code>",
 "244":
 "<code>Std.HashMap.{u, v} (α : Type u) (β : Type v) [BEq α] [Hashable α] : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Hash maps.\n\nThis is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.\n\nThe hash table is backed by an `Array`. Users should make sure that the hash map is used linearly to\navoid expensive copies.\n\nThe hash map uses `==` (provided by the `BEq` typeclass) to compare keys and `hash` (provided by\nthe `Hashable` typeclass) to hash them. To ensure that the operations behave as expected, `==`\nshould be an equivalence relation and `a == b` should imply `hash a = hash b` (see also the\n`EquivBEq` and `LawfulHashable` typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if `a == b` implies `a = b`.\n\nThese hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, `Std.Data.HashMap.Raw` and\n`Std.Data.HashMap.Raw.WF` unbundle the invariant from the hash map. When in doubt, prefer\n`HashMap` over `HashMap.Raw`.\n\nDependent hash maps, in which keys may occur in their values' types, are available as\n`Std.Data.DHashMap`.\n</code>",
 "2439": "<code>ST.Ref σ α</code>",
 "2438":
 "<code>ST.Ref.mk {σ α : Type} (ref : ST.RefPointed.type) (h : Nonempty α) : ST.Ref σ α</code>",
 "2437": "<code>(σ : Type) → EST ε σ α</code>",
 "2436":
 "<code>runEST {ε α : Type} (x : (σ : Type) → EST ε σ α) : Except ε α</code><span class=\"sep\"></span><code class=\"docstring\">Runs an `EST` computation, in which mutable state and exceptions are the only side effects.\n</code>",
 "2435": "<code>(σ : Type) → ST σ α</code>",
 "2434":
 "<code>IO.Ref (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Mutable reference cells that contain values of type `α`. These cells can read from and mutated in\nthe `IO` monad.\n</code>",
 "2433":
 "<code><span class=\"literal string\">\" so they can be corrected.\"</span> : String</code>",
 "2432":
 "<code>IO.eprintln.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it with a trailing newline to\nthe current standard error (as determined by `IO.getStderr`).\n</code>",
 "2431":
 "<code><span class=\"literal string\">\"errors\"</span> : String</code>",
 "2430":
 "<code><span class=\"literal string\">\"Please report any \"</span> : String</code>",
 "243":
 "<code>NatStringBimap.natToString (self : NatStringBimap) : Std.HashMap Nat String</code>",
 "2429":
 "<code>IO.eprint.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it to the current standard\nerror (as determined by `IO.getStderr`).\n</code>",
 "2428":
 "<code><span class=\"literal string\">\"Thank you for reading it!\"</span> : String</code>",
 "2427":
 "<code><span class=\"literal string\">\" language reference.\"</span> : String</code>",
 "2426": "<code><span class=\"literal string\">\"Lean\"</span> : String</code>",
 "2425":
 "<code><span class=\"literal string\">\"This is the \"</span> : String</code>",
 "2424":
 "<code>IO.getStderr : BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Returns the current thread's standard error stream.\n\nUse `IO.setStderr` to replace the current thread's standard error stream.\n</code>",
 "2423":
 "<code>IO.getStdout : BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Returns the current thread's standard output stream.\n\nUse `IO.setStdout` to replace the current thread's standard output stream.\n</code>",
 "2422":
 "<code>Sum.inr.{u, v} {α : Type u} {β : Type v} (val : β) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Right injection into the sum type `α ⊕ β`. </code>",
 "2421": "<code>α → IO (α ⊕ β)</code>",
 "2420":
 "<code><span class=\"literal string\">\"Access granted!\"</span> : String</code>",
 "242":
 "<code>NatStringBimap.mk (natToString : Std.HashMap Nat String) (stringToNat : Std.HashMap String Nat) : NatStringBimap</code><span class=\"sep\"></span><code class=\"docstring\">Build a finite bijection between some\nnatural numbers and strings\n</code>",
 "2419": "<code>IO.Error</code>",
 "2418":
 "<code class=\"docstring\">`continue` skips to the next iteration of the surrounding `for` loop. </code>",
 "2417":
 "<code class=\"docstring\">`break` exits the surrounding `for` loop. </code>",
 "2416": "<code>repeatAccessControl : IO Unit</code>",
 "2415":
 "<code><span class=\"literal string\">\"Incorrect password\"</span> : String</code>",
 "2414":
 "<code><span class=\"literal string\">\"secret\"</span> : String</code>",
 "2413":
 "<code><span class=\"literal string\">\"What is the password?\"</span> : String</code>",
 "2412": "<code>accessControl : IO Unit</code>",
 "2411": "<code>ε → BaseIO α</code>",
 "2410": "<code>Option String</code>",
 "241": "<code>NatStringBimap : Type</code>",
 "2409":
 "<code>IO.Error.userError (msg : String) : IO.Error</code><span class=\"sep\"></span><code class=\"docstring\">Some other error occurred. </code>",
 "2408": "<code>IO α</code>",
 "2407": "<code>IO.Error → ε</code>",
 "2406": "<code>ε → IO.Error</code>",
 "2405": "<code>EIO ε α</code>",
 "2404": "<code>Unit → α</code>",
 "2403":
 "<code>EIO (ε : Type) : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad that can have side effects on the external world or throw exceptions of type `ε`.\n\n`BaseIO` is a version of this monad that cannot throw exceptions. `IO` sets the exception type to\n`IO.Error`.\n</code>",
 "2402":
 "<code>IO.Error : Type</code><span class=\"sep\"></span><code class=\"docstring\">Exceptions that may be thrown in the `IO` monad.\n\nMany of the constructors of `IO.Error` correspond to POSIX error numbers. In these cases, the\ndocumentation string lists POSIX standard error macros that correspond to the error. This list is\nnot necessarily exhaustive, and these constructor includes a field for the underlying error number.\n</code>",
 "2401":
 "<code>α : Type</code><span class=\"sep\"></span><code class=\"docstring\">A type </code>",
 "2400": "<code>?m.716</code>",
 "240":
 "<code>String.data (self : String) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Unpack `String` into a `List Char`. This function is overridden by the\ncompiler and is O(n) in the length of the list. </code>",
 "24": "<code>Even.zero : Even 0</code>",
 "2399": "<code>ε → EStateM ε σ α</code>",
 "2398": "<code>Unit → EStateM ε σ β</code>",
 "2397": "<code>?m.595</code>",
 "2396": "<code>Unit → EStateM ε σ α</code>",
 "2395": "<code>α → EStateM ε σ β</code>",
 "2394":
 "<code>σ → δ → σ</code><span class=\"sep\"></span><code class=\"docstring\">Updates the current state with the saved information that should be rolled back. This updated\nstate becomes the current state when an exception is handled.\n</code>",
 "2393":
 "<code>σ → δ</code><span class=\"sep\"></span><code class=\"docstring\">Extracts the information in the state that should be rolled back if an exception is handled.\n</code>",
 "2392":
 "<code>EStateM.Backtrackable.mk.{u} {δ : outParam (Type u)} {σ : Type u} (save : σ → δ) (restore : σ → δ → σ) :\n  EStateM.Backtrackable δ σ</code>",
 "2391": "<code>StateM σ α</code>",
 "2390": "<code>EStateM ε σ α</code>",
 "239": "<code>String</code>",
 "2389":
 "<code>EStateM.Backtrackable.{u} (δ : outParam (Type u)) (σ : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Exception handlers in `EStateM` save some part of the state, determined by `δ`, and restore it if an\nexception is caught. By default, `δ` is `Unit`, and no information is saved.\n</code>",
 "2388":
 "<code>EStateM.Result.{u} (ε σ α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The value returned from a combined state and exception monad in which exceptions do not\nautomatically roll back the state.\n\n`Result ε σ α` is equivalent to `Except ε α × σ`, but using a single combined inductive type yields\na more efficient data representation.\n</code>",
 "2387": "<code>ε → m β</code>",
 "2386": "<code>ExceptCpsT ε m α</code>",
 "2385": "<code>ExceptCpsT α m α</code>",
 "2384": "<code>m (Except ε α)</code>",
 "2383": "<code>ε → ExceptT ε m α</code>",
 "2382": "<code>α → ExceptT ε m β</code>",
 "2381":
 "<code>ExceptT.mk.{u, v} {ε : Type u} {m : Type u → Type v} {α : Type u} (x : m (Except ε α)) : ExceptT ε m α</code><span class=\"sep\"></span><code class=\"docstring\">Use a monadic action that may return an exception's value as an action in the transformed monad that\nmay throw the corresponding exception.\n\nThis is the inverse of `ExceptT.run`.\n</code>",
 "2380": "<code>ExceptT ε m α</code>",
 "238":
 "<code>Palindrome.is_palindrome (self : Palindrome) : self.text.data.reverse = self.text.data</code>",
 "2379":
 "<code>MonadFinally.tryFinally'.{u, v} {m : Type u → Type v} [self : MonadFinally m] {α β : Type u} :\n  m α → (Option α → m β) → m (α × β)</code><span class=\"sep\"></span><code class=\"docstring\">`tryFinally' x f` runs `x` and then the \"finally\" computation `f`.\nWhen `x` succeeds with `a : α`, `f (some a)` is returned. If `x` fails\nfor `m`'s definition of failure, `f none` is returned. Hence `tryFinally'`\ncan be thought of as performing the same role as a `finally` block in\nan imperative programming language. </code>",
 "2378": "<code>Option ?m.2032 → m ?m.1889</code>",
 "2377": "<code>m ?m.1987</code>",
 "2376": "<code>Sort ?u.1893</code>",
 "2375": "<code>Option ?m.1888 → m ?m.1889</code>",
 "2374": "<code>m ?m.1888</code>",
 "2373": "<code>{α β : Type u} → m α → (Option α → m β) → m (α × β)</code>",
 "2372":
 "<code>{α β : Type u} → m α → (Option α → m β) → m (α × β)</code><span class=\"sep\"></span><code class=\"docstring\">`tryFinally' x f` runs `x` and then the \"finally\" computation `f`.\nWhen `x` succeeds with `a : α`, `f (some a)` is returned. If `x` fails\nfor `m`'s definition of failure, `f none` is returned. Hence `tryFinally'`\ncan be thought of as performing the same role as a `finally` block in\nan imperative programming language. </code>",
 "2371":
 "<code>MonadFinally.mk.{u, v} {m : Type u → Type v} (tryFinally' : {α β : Type u} → m α → (Option α → m β) → m (α × β)) :\n  MonadFinally m</code>",
 "2370": "<code>ε → m α</code>",
 "237": "<code>Palindrome.text (self : Palindrome) : String</code>",
 "2369": "<code>ε</code>",
 "2368":
 "<code>{α : Type v} → ε → m α</code><span class=\"sep\"></span><code class=\"docstring\">Throws an exception of type `ε` to the nearest enclosing `catch`.\n</code>",
 "2367":
 "<code>MonadExceptOf.mk.{u, v, w} {ε : semiOutParam (Type u)} {m : Type v → Type w} (throw : {α : Type v} → ε → m α)\n  (tryCatch : {α : Type v} → m α → (ε → m α) → m α) : MonadExceptOf ε m</code>",
 "2366": "<code>optParam Bool true</code>",
 "2365": "<code>Unit → m α</code>",
 "2364":
 "<code>{α : Type v} → m α → (ε → m α) → m α</code><span class=\"sep\"></span><code class=\"docstring\">Catches errors thrown in `body`, passing them to `handler`. Errors in `handler` are not caught.\n</code>",
 "2363":
 "<code>{α : Type v} → ε → m α</code><span class=\"sep\"></span><code class=\"docstring\">Throws an exception of type `ε` to the nearest enclosing handler.\n</code>",
 "2362":
 "<code>MonadExcept.mk.{u, v, w} {ε : outParam (Type u)} {m : Type v → Type w} (throw : {α : Type v} → ε → m α)\n  (tryCatch : {α : Type v} → m α → (ε → m α) → m α) : MonadExcept ε m</code>",
 "2361": "<code>Type v → Type w</code>",
 "2360":
 "<code><span class=\"literal string\">\"Failure\"</span> : String</code>",
 "236":
 "<code>Palindrome.ofString (text : String) (is_palindrome : text.data.reverse = text.data) : Palindrome</code>",
 "2359":
 "<code>Except.toOption.{u, u_1} {ε : Type u} {α : Type u_1} : Except ε α → Option α</code><span class=\"sep\"></span><code class=\"docstring\">Returns `none` if an exception was thrown, or `some` around the value on success.\n\nExamples:\n* `(pure 10 : Except String Nat).toOption = some 10`\n* `(throw \"Failure\" : Except String Nat).toOption = none`\n</code>",
 "2358": "<code>Unit → Except ε α</code>",
 "2357":
 "<code><span class=\"literal string\">\"E: Error\"</span> : String</code>",
 "2356": "<code><span class=\"literal string\">\"E: \"</span> : String</code>",
 "2355":
 "<code>Except.mapError.{u, u_1, u_2} {ε : Type u} {ε' : Type u_1} {α : Type u_2} (f : ε → ε') : Except ε α → Except ε' α</code><span class=\"sep\"></span><code class=\"docstring\">Transforms exceptions with a function, doing nothing on successful results.\n\nExamples:\n* `(pure 2 : Except String Nat).mapError (·.length) = pure 2`\n* `(throw \"Error\" : Except String Nat).mapError (·.length) = throw 5`\n</code>",
 "2354": "<code>ε → ε'</code>",
 "2353":
 "<code><span class=\"literal string\">\"Error\"</span> : String</code>",
 "2352": "<code>α → Except ε β</code>",
 "2351": "<code>Unit → OptionT m α</code>",
 "2350": "<code>α → OptionT m β</code>",
 "235": "<code>Palindrome : Type</code>",
 "2349": "<code>m (Option α)</code>",
 "2348": "<code>OptionT m α</code>",
 "2347": "<code>Unit → ReaderT ρ m α</code>",
 "2346": "<code>α → ReaderT ρ m β</code>",
 "2345": "<code>ρ' → ρ</code>",
 "2344": "<code>ReaderT ρ m α</code>",
 "2343": "<code>ρ → ρ</code>",
 "2342":
 "<code>MonadWithReaderOf.mk.{u, v} {ρ : semiOutParam (Type u)} {m : Type u → Type v}\n  (withReader : {α : Type u} → (ρ → ρ) → m α → m α) : MonadWithReaderOf ρ m</code>",
 "2341":
 "<code>{α : Type u} → (ρ → ρ) → m α → m α</code><span class=\"sep\"></span><code class=\"docstring\">Locally modifies the reader monad's value while running an action.\n\nDuring the inner action `x`, reading the value returns `f` applied to the original value. After\ncontrol returns from `x`, the reader monad's value is restored.\n</code>",
 "2340":
 "<code>MonadWithReader.mk.{u, v} {ρ : outParam (Type u)} {m : Type u → Type v}\n  (withReader : {α : Type u} → (ρ → ρ) → m α → m α) : MonadWithReader ρ m</code>",
 "234": "<code>Graph : Type</code>",
 "2339":
 "<code>m ρ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the local value. </code>",
 "2338":
 "<code>MonadReaderOf.mk.{u, v} {ρ : semiOutParam (Type u)} {m : Type u → Type v} (read : m ρ) : MonadReaderOf ρ m</code>",
 "2337":
 "<code>m ρ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the local value.\n\nUse `readThe` to explicitly specify a type when more than one value is available.\n</code>",
 "2336":
 "<code>MonadReader.mk.{u, v} {ρ : outParam (Type u)} {m : Type u → Type v} (read : m ρ) : MonadReader ρ m</code>",
 "2335": "<code>StateRefT' ω σ m α</code>",
 "2334":
 "<code>STWorld.mk {σ : outParam Type} {m : Type → Type} : STWorld σ m</code>",
 "2333":
 "<code>STWorld (σ : outParam Type) (m : Type → Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">An auxiliary class used to infer the “state” of `EST` and `ST` monads.\n</code>",
 "2332":
 "<code>runST {α : Type} (x : (σ : Type) → ST σ α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Runs an `ST` computation, in which mutable state via `ST.Ref` is the only side effect.\n</code>",
 "2331":
 "<code>EST (ε σ : Type) : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A restricted version of `IO` in which mutable state and exceptions are the only side effects.\n\nIt is possible to run `EST` computations in a non-monadic context using `runEST`.\n</code>",
 "2330":
 "<code>ST (σ : Type) : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A restricted version of `IO` in which mutable state is the only side effect.\n\nIt is possible to run `ST` computations in a non-monadic context using `runST`.\n</code>",
 "233": "<code>Graph.empty : Graph</code>",
 "2329":
 "<code class=\"docstring\">A state monad that uses an actual mutable reference cell (i.e. an `ST.Ref`).\n\nThis is syntax, rather than a function, to make it easier to use. Its elaborator synthesizes an\nappropriate parameter for the underlying monad's `ST` effects, then passes it to `StateRefT'`.\n</code>",
 "2328": "<code>α → σ → m β</code>",
 "2327": "<code>StateCpsT σ m α</code>",
 "2326":
 "<code>StateT.modifyGet.{u, v} {σ : Type u} {m : Type u → Type v} [Monad m] {α : Type u} (f : σ → α × σ) : StateT σ m α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.\n\nIt is equivalent to `do let (a, s) := f (← StateT.get); StateT.set s; pure a`. However, using\n`StateT.modifyGet` may lead to better performance because it doesn't add a new reference to the\nstate value, and additional references can inhibit in-place updates of data.\n</code>",
 "2325": "<code>α → StateT σ m β</code>",
 "2324": "<code>Unit → StateT σ m α</code>",
 "2323": "<code>σ</code>",
 "2322": "<code>StateT σ m α</code>",
 "2321":
 "<code>modifyGetThe.{u, v} {α : Type u} (σ : Type u) {m : Type u → Type v} [MonadStateOf σ m] (f : σ → α × σ) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the current state that has the explicitly-provided type `σ`. The function both\ncomputes a new state and a value. The new state replaces the current state, and the value is\nreturned.\n\nIt is equivalent to `do let (a, s) := f (← getThe σ); set s; pure a`. However, using `modifyGetThe`\nmay lead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n</code>",
 "2320": "<code>σ → α × σ</code>",
 "232": "<code>Graph.adjacency (self : Graph) : Array (List Nat)</code>",
 "2319":
 "<code>MonadStateOf.mk.{u, v} {σ : semiOutParam (Type u)} {m : Type u → Type v} (get : m σ) (set : σ → m PUnit)\n  (modifyGet : {α : Type u} → (σ → α × σ) → m α) : MonadStateOf σ m</code>",
 "2318": "<code>semiOutParam (Type u)</code>",
 "2317": "<code>σ → σ</code>",
 "2316": "<code>MonadState σ m</code>",
 "2315":
 "<code>{α : Type u} → (σ → α × σ) → m α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.\n\nIt is equivalent to `do let (a, s) := f (← get); set s; pure a`. However, using `modifyGet` may\nlead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n</code>",
 "2314":
 "<code>σ → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current value of the mutable state with a new one.\n</code>",
 "2313":
 "<code>m σ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the current value of the monad's mutable state.\n</code>",
 "2312":
 "<code>MonadState.mk.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} (get : m σ) (set : σ → m PUnit)\n  (modifyGet : {α : Type u} → (σ → α × σ) → m α) : MonadState σ m</code>",
 "2311": "<code>outParam (Type u)</code>",
 "2310":
 "<code>ST.Ref (σ α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Mutable reference cells that contain values of type `α`. These cells can read from and mutated in\nthe `ST σ` monad.\n</code>",
 "231": "<code>ArraySized α length</code>",
 "2309": "<code>Id α</code>",
 "2308": "<code>containsFive (xs : List Nat) : Bool</code>",
 "2307":
 "<code>EStateM.{u} (ε σ α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A combined state and exception monad in which exceptions do not automatically roll back the state.\n\nInstances of `EStateM.Backtrackable` provide a way to roll back some part of the state if needed.\n\n`EStateM ε σ` is equivalent to `ExceptT ε (StateM σ)`, but it is more efficient.\n</code>",
 "2306":
 "<code>ExceptCpsT.{u, v} (ε : Type u) (m : Type u → Type v) (α : Type u) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds exceptions of type `ε` to a monad `m`.\n\nInstead of using `Except ε` to model exceptions, this implementation uses continuation passing\nstyle. This has different performance characteristics from `ExceptT ε`.\n</code>",
 "2305":
 "<code>StateRefT' (ω σ : Type) (m : Type → Type) (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">A state monad that uses an actual mutable reference cell (i.e. an `ST.Ref ω σ`).\n\nThe macro `StateRefT σ m α` infers `ω` from `m`. It should normally be used instead.\n</code>",
 "2304":
 "<code>StateCpsT.{u, v} (σ : Type u) (m : Type u → Type v) (α : Type u) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">An alternative implementation of a state monad transformer that internally uses continuation passing\nstyle instead of tuples.\n</code>",
 "2303": "<code>m ((fun α =&gt; α) α✝)</code>",
 "2302":
 "<code>{α : Type u} → m ((fun α =&gt; α) α) → m ((fun α =&gt; α) α)</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a monadic action that returns a state and a value in the inner monad to an action in the\nouter monad. The extra state information is used to restore the results of effects from the\nreverse lift passed to `liftWith`'s parameter.\n</code>",
 "2301": "<code>IdT m β✝</code>",
 "2300": "<code>({β : Type u} → IdT m β → m ((fun α =&gt; α) β)) → m α✝</code>",
 "230": "<code>Array α</code>",
 "23":
 "<code class=\"docstring\">The universe of propositions. `Prop ≡ Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. </code>",
 "2299":
 "<code>{α : Type u} → (({β : Type u} → IdT m β → m ((fun α =&gt; α) β)) → m α) → m α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an action from the inner monad `m` to the outer monad `n`. The inner monad has access to a\nreverse lifting operator that can run an `n` action, returning a value and state together.\n</code>",
 "2298": "<code>instOfNatNat 5</code>",
 "2297":
 "<code>{α : Type u} → m α → m α</code><span class=\"sep\"></span><code class=\"docstring\">Translates an action from monad `m` into monad `n`. </code>",
 "2296": "<code>α✝ → IdT m β✝</code>",
 "2295": "<code>IdT m α✝</code>",
 "2294":
 "<code>{α β : Type u} → IdT m α → (α → IdT m β) → m β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "2293":
 "<code>{α : Type u} → α → m α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "2292": "<code>IdT m α</code>",
 "2291":
 "<code>IdT.run.{u, v} {m : Type u → Type v} {α : Type u} (act : IdT m α) : m α</code>",
 "2290": "<code>IdT.{u, v} (m : Type u → Type v) : Type u → Type v</code>",
 "229":
 "<code>ArraySized.size_eq_length.{u} {α : Type u} {length : Nat} (self : ArraySized α length) : self.array.size = length</code>",
 "2289": "<code>(Type u → Type v) → Type u → Type w</code>",
 "2288": "<code><span class=\"literal string\">\"Four\"</span> : String</code>",
 "2287": "<code>M (α : Type) : Type</code>",
 "2286":
 "<code>throwThe.{u, v, w} (ε : Type u) {m : Type v → Type w} [MonadExceptOf ε m] {α : Type v} (e : ε) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Throws an exception, with the exception type specified explicitly. This is useful when a monad\nsupports throwing more than one type of exception.\n\nUse `throw` for a version that expects the exception type to be inferred from `m`.\n</code>",
 "2285":
 "<code>MonadWithReaderOf.{u, v} (ρ : semiOutParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A reader monad that additionally allows the value to be locally overridden.\n\nIn this class, `ρ` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadWithReader ρ` provides the same operations, but requires that `ρ` be inferrable from `m`.\n</code>",
 "2284":
 "<code>withTheReader.{u, v} (ρ : Type u) {m : Type u → Type v} [MonadWithReaderOf ρ m] {α : Type u} (f : ρ → ρ) (x : m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Locally modifies the reader monad's value while running an action, with the reader monad's local\nvalue type specified explicitly. This is useful when a monad supports reading more than one type of\nvalue.\n\nDuring the inner action `x`, reading the value returns `f` applied to the original value. After\ncontrol returns from `x`, the reader monad's value is restored.\n\nUse `withReader` for a version that expects the local value's type to be inferred from `m`.\n</code>",
 "2283":
 "<code>MonadWithReader.withReader.{u, v} {ρ : outParam (Type u)} {m : Type u → Type v} [self : MonadWithReader ρ m]\n  {α : Type u} : (ρ → ρ) → m α → m α</code><span class=\"sep\"></span><code class=\"docstring\">Locally modifies the reader monad's value while running an action.\n\nDuring the inner action `x`, reading the value returns `f` applied to the original value. After\ncontrol returns from `x`, the reader monad's value is restored.\n</code>",
 "2282":
 "<code>MonadState.modifyGet.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} [self : MonadState σ m] {α : Type u} :\n  (σ → α × σ) → m α</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.\n\nIt is equivalent to `do let (a, s) := f (← get); set s; pure a`. However, using `modifyGet` may\nlead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n</code>",
 "2281":
 "<code>tryCatchThe.{u, v, w} (ε : Type u) {m : Type v → Type w} [MonadExceptOf ε m] {α : Type v} (x : m α) (handle : ε → m α) :\n  m α</code><span class=\"sep\"></span><code class=\"docstring\">Catches errors, recovering using `handle`. The exception type is specified explicitly. This is useful when a monad\nsupports throwing or handling more than one type of exception.\n\nUse `tryCatch`, for a version that expects the exception type to be inferred from `m`.\n</code>",
 "2280":
 "<code>readThe.{u, v} (ρ : Type u) {m : Type u → Type v} [MonadReaderOf ρ m] : m ρ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the local value whose type is `ρ`.  This is useful when a monad supports reading more that\none type of value.\n\nUse `read` for a version that expects the type `ρ` to be inferred from `m`.\n</code>",
 "228":
 "<code>ArraySized.array.{u} {α : Type u} {length : Nat} (self : ArraySized α length) : Array α</code>",
 "2279":
 "<code>getThe.{u, v} (σ : Type u) {m : Type u → Type v} [MonadStateOf σ m] : m σ</code><span class=\"sep\"></span><code class=\"docstring\">Gets the current state that has the explicitly-provided type `σ`. When the current monad has\nmultiple state types available, this function selects one of them.\n</code>",
 "2278":
 "<code>MonadExceptOf.{u, v, w} (ε : semiOutParam (Type u)) (m : Type v → Type w) : Type (max (max u (v + 1)) w)</code><span class=\"sep\"></span><code class=\"docstring\">Exception monads provide the ability to throw errors and handle errors.\n\nIn this class, `ε` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadExcept ε` provides the same operations, but requires that `ε` be inferrable from `m`.\n\n`tryCatchThe`, which takes an explicit exception type, is used to desugar `try ... catch ...` steps\ninside `do`-blocks when the handlers have type annotations.\n</code>",
 "2277":
 "<code>MonadReaderOf.{u, v} (ρ : semiOutParam (Type u)) (m : Type u → Type v) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Reader monads provide the ability to implicitly thread a value through a computation. The value can\nbe read, but not written. A `MonadWithReader ρ` instance additionally allows the value to be locally\noverridden for a sub-computation.\n\nIn this class, `ρ` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadReader ρ` provides the same operations, but requires that `ρ` be inferrable from `m`.\n</code>",
 "2276":
 "<code>MonadStateOf.{u, v} (σ : semiOutParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">State monads provide a value of a given type (the _state_) that can be retrieved or replaced.\nInstances may implement these operations by passing state values around, by using a mutable\nreference cell (e.g. `ST.Ref σ`), or in other ways.\n\nIn this class, `σ` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadState σ` provides the same operations, but requires that `σ` be inferrable from `m`.\n\nThe mutable state of a state monad is visible between multiple `do`-blocks or functions, unlike\n[local mutable state](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=do-notation-let-mut) in `do`-notation.\n</code>",
 "2275":
 "<code>StateT.run'.{u, v} {σ : Type u} {m : Type u → Type v} [Functor m] {α : Type u} (x : StateT σ m α) (s : σ) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action from a monad with added state in the underlying monad `m`. Given an initial\nstate, it returns a value, discarding the final state.\n</code>",
 "2274":
 "<code>MonadState.get.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} [self : MonadState σ m] : m σ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the current value of the monad's mutable state.\n</code>",
 "2273":
 "<code>MonadState.set.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} [self : MonadState σ m] : σ → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current value of the mutable state with a new one.\n</code>",
 "2272":
 "<code>sumUntilFive.{u_1} {m : Type → Type u_1} [Monad m] [MonadState Nat m] [MonadExcept String m] (xs : List Nat) : m Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the sum of the non-5 prefix of a list. </code>",
 "2271":
 "<code>ExceptT.run.{u, v} {ε : Type u} {m : Type u → Type v} {α : Type u} (x : ExceptT ε m α) : m (Except ε α)</code><span class=\"sep\"></span><code class=\"docstring\">Use a monadic action that may throw an exception as an action that may return an exception's value.\n\nThis is the inverse of `ExceptT.mk`.\n</code>",
 "2270":
 "<code><span class=\"literal string\">\"Five was encountered\"</span> : String</code>",
 "227": "<code>ArraySized.{u} (α : Type u) (length : Nat) : Type u</code>",
 "2269":
 "<code>sumNonFives.{u_1} {m : Type → Type u_1} [Monad m] [MonadState Nat m] [MonadExcept String m] (xs : List Nat) : m Unit</code>",
 "2268":
 "<code>MonadExcept.{u, v, w} (ε : outParam (Type u)) (m : Type v → Type w) : Type (max (max u (v + 1)) w)</code><span class=\"sep\"></span><code class=\"docstring\">Exception monads provide the ability to throw errors and handle errors.\n\nIn this class, `ε` is an `outParam`, which means that it is inferred from `m`. `MonadExceptOf ε`\nprovides the same operations, but allows `ε` to influence instance synthesis.\n\n`MonadExcept.tryCatch` is used to desugar `try ... catch ...` steps inside `do`-blocks when the\nhandlers do not have exception type annotations.\n</code>",
 "2267":
 "<code>MonadWithReader.{u, v} (ρ : outParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A reader monad that additionally allows the value to be locally overridden.\n\nIn this class, `ρ` is an `outParam`, which means that it is inferred from `m`. `MonadWithReaderOf ρ`\nprovides the same operations, but allows `ρ` to influence instance synthesis.\n</code>",
 "2266":
 "<code>MonadReader.{u, v} (ρ : outParam (Type u)) (m : Type u → Type v) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Reader monads provide the ability to implicitly thread a value through a computation. The value can\nbe read, but not written. A `MonadWithReader ρ` instance additionally allows the value to be locally\noverridden for a sub-computation.\n\nIn this class, `ρ` is an `outParam`, which means that it is inferred from `m`. `MonadReaderOf ρ`\nprovides the same operations, but allows `ρ` to influence instance synthesis.\n</code>",
 "2265":
 "<code>MonadState.{u, v} (σ : outParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">State monads provide a value of a given type (the _state_) that can be retrieved or replaced.\nInstances may implement these operations by passing state values around, by using a mutable\nreference cell (e.g. `ST.Ref σ`), or in other ways.\n\nIn this class, `σ` is an `outParam`, which means that it is inferred from `m`. `MonadStateOf σ`\nprovides the same operations, but allows `σ` to influence instance synthesis.\n\nThe mutable state of a state monad is visible between multiple `do`-blocks or functions, unlike\n[local mutable state](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=do-notation-let-mut) in `do`-notation.\n</code>",
 "2264": "<code>m Bool</code>",
 "2263": "<code>ToBool.{u} (α : Type u) : Type u</code>",
 "2262": "<code>Type → Type v</code>",
 "2261":
 "<code>Functor.discard.{u, v} {f : Type u → Type v} {α : Type u} [Functor f] (x : f α) : f PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Discards the value in a functor, retaining the functor's structure.\n\nDiscarding values is especially useful when using `Applicative` functors or `Monad`s to implement\neffects, and some operation should be carried out only for its effects. In `do`-notation, statements\nwhose values are discarded must return `Unit`, and `discard` can be used to explicitly discard their\nvalues.\n</code>",
 "2260":
 "<code><span class=\"literal string\">\"These values were kept:\"</span> : String</code>",
 "226": "<code>{α : Sort v} → α</code>",
 "2259": "<code><span class=\"literal string\">\"n\"</span> : String</code>",
 "2258": "<code>values : Array Nat</code>",
 "2257":
 "<code>Array.filterM.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] (p : α → m Bool) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : m (Array α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic predicate `p` to every element in the array, in order from left to right, and\nreturns the array of elements for which `p` returns `true`.\n\nOnly elements from `start` (inclusive) to `stop` (exclusive) are considered. Elements outside that\nrange are discarded. By default, the entire array is checked.\n\nExample:\n```lean example\n#eval #[1, 2, 5, 2, 7, 7].filterM fun x =&gt; do\n  IO.println s!\"Checking {x}\"\n  return x &lt; 3\n```\n```output\nChecking 1\nChecking 2\nChecking 5\nChecking 2\nChecking 7\nChecking 7\n```\n```output\n#[1, 2, 2]\n```\n</code>",
 "2256":
 "<code>ForM.{u, v, w₁, w₂} (m : Type u → Type v) (γ : Type w₁) (α : outParam (Type w₂)) :\n  Type (max (max (max (u + 1) v) w₁) w₂)</code><span class=\"sep\"></span><code class=\"docstring\">Typeclass for the polymorphic `forM` operation described in the \"do unchained\" paper.\nRemark:\n- `γ` is a \"container\" type of elements of type `α`.\n- `α` is treated as an output parameter by the typeclass resolution procedure.\n  That is, it tries to find an instance using only `m` and `γ`.\n</code>",
 "2255": "<code>Type u_4</code>",
 "2254": "<code>Type u_3</code>",
 "2253": "<code>Type u_1 → Type u_2</code>",
 "2252": "<code>[inst : Monad m] → γ → (α → m PUnit) → m PUnit</code>",
 "2251":
 "<code>ForM.mk.{u, v, w₁, w₂} {m : Type u → Type v} {γ : Type w₁} {α : outParam (Type w₂)}\n  (forM : [inst : Monad m] → γ → (α → m PUnit) → m PUnit) : ForM m γ α</code>",
 "2250":
 "<code>ForM.forM.{u, v, w₁, w₂} {m : Type u → Type v} {γ : Type w₁} {α : outParam (Type w₂)} [self : ForM m γ α] [Monad m] :\n  γ → (α → m PUnit) → m PUnit</code>",
 "225": "<code>{α : Sort u} → α</code>",
 "2249": "<code>outParam (Type w₂)</code>",
 "2248": "<code>Type w₁</code>",
 "2247": "<code>(a : α) → a ∈ x → β → m (ForInStep β)</code>",
 "2246":
 "<code>{β : Type u₁} → [inst : Monad m] → (x : ρ) → β → ((a : α) → a ∈ x → β → m (ForInStep β)) → m β</code><span class=\"sep\"></span><code class=\"docstring\">`forIn' x b f : m β` runs a for-loop in the monad `m` with additional state `β`.\nThis traverses over the \"contents\" of `x`, and passes the elements `a : α` along\nwith a proof that `a ∈ x` to `f : (a : α) → a ∈ x → β → m (ForInStep β)`.\n`b : β` is the initial state, and the return value\nof `f` is the new state as well as a directive `.done` or `.yield`\nwhich indicates whether to abort early or continue iteration. </code>",
 "2245":
 "<code>ForIn'.mk.{u, v, u₁, u₂} {m : Type u₁ → Type u₂} {ρ : Type u} {α : outParam (Type v)} {d : outParam (Membership α ρ)}\n  (forIn' : {β : Type u₁} → [inst : Monad m] → (x : ρ) → β → ((a : α) → a ∈ x → β → m (ForInStep β)) → m β) :\n  ForIn' m ρ α d</code>",
 "2244": "<code>outParam (Membership α ρ)</code>",
 "2243": "<code>α → β → m (ForInStep β)</code>",
 "2242":
 "<code>ForInStep.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary type used to compile `for x in xs` notation.\n\nThis is the return value of the body of a `ForIn` call,\nrepresenting the body of a for loop. It can be:\n\n* `.yield (a : α)`, meaning that we should continue the loop and `a` is the new state.\n  `.yield` is produced by `continue` and reaching the bottom of the loop body.\n* `.done (a : α)`, meaning that we should early-exit the loop with state `a`.\n  `.done` is produced by calls to `break` or `return` in the loop,\n</code>",
 "2241": "<code>Monad m</code>",
 "2240": "<code>Type u₁</code>",
 "224":
 "<code>MyStructure.mk.{u_1, u_2} (field1 : {α : Sort u_1} → α) (field2 : {α : Sort u_2} → α) : MyStructure</code>",
 "2239":
 "<code>{β : Type u₁} → [inst : Monad m] → ρ → β → (α → β → m (ForInStep β)) → m β</code><span class=\"sep\"></span><code class=\"docstring\">`forIn x b f : m β` runs a for-loop in the monad `m` with additional state `β`.\nThis traverses over the \"contents\" of `x`, and passes the elements `a : α` to\n`f : α → β → m (ForInStep β)`. `b : β` is the initial state, and the return value\nof `f` is the new state as well as a directive `.done` or `.yield`\nwhich indicates whether to abort early or continue iteration.\n\nThe expression\n```\nlet mut b := ...\nfor x in xs do\n  b ← foo x b\n```\nin a `do` block is syntactic sugar for:\n```\nlet b := ...\nlet b ← forIn xs b (fun x b =&gt; do\n  let b ← foo x b\n  return .yield b)\n```\n(Here `b` corresponds to the variables mutated in the loop.) </code>",
 "2238":
 "<code>ForIn.mk.{u, v, u₁, u₂} {m : Type u₁ → Type u₂} {ρ : Type u} {α : outParam (Type v)}\n  (forIn : {β : Type u₁} → [inst : Monad m] → ρ → β → (α → β → m (ForInStep β)) → m β) : ForIn m ρ α</code>",
 "2237": "<code>ρ</code>",
 "2236": "<code>outParam (Type v)</code>",
 "2235": "<code>Type u₁ → Type u₂</code>",
 "2234":
 "<code>ForIn'.{u, v, u₁, u₂} (m : Type u₁ → Type u₂) (ρ : Type u) (α : outParam (Type v)) (d : outParam (Membership α ρ)) :\n  Type (max (max (max u (u₁ + 1)) u₂) v)</code><span class=\"sep\"></span><code class=\"docstring\">`ForIn' m ρ α d` is a variation on the `ForIn m ρ α` typeclass which supports the\n`for h : x in xs` notation. It is the same as `for x in xs` except that `h : x ∈ xs`\nis provided as an additional argument to the body of the for-loop.\n</code>",
 "2233":
 "<code>MonadStateOf.set.{u, v} {σ : semiOutParam (Type u)} {m : Type u → Type v} [self : MonadStateOf σ m] : σ → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current value of the mutable state with a new one.\n</code>",
 "2232": "<code>test : StateM Nat Unit</code>",
 "2231":
 "<code>DecidablePred.{u} {α : Sort u} (r : α → Prop) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A decidable predicate.\n\nA predicate is decidable if the corresponding proposition is `Decidable` for each possible argument.\n</code>",
 "2230":
 "<code>satisfyingIndices {α : Type} (p : α → Prop) [DecidablePred p] (xs : Array α) : Array Nat</code>",
 "223": "<code>Sort u_2</code>",
 "2229": "<code>Array (Nat × Char)</code>",
 "2228": "<code>m (Option β)</code>",
 "2227": "<code>m Unit</code>",
 "2226":
 "<code>ForIn.{u, v, u₁, u₂} (m : Type u₁ → Type u₂) (ρ : Type u) (α : outParam (Type v)) :\n  Type (max (max (max u (u₁ + 1)) u₂) v)</code><span class=\"sep\"></span><code class=\"docstring\">`ForIn m ρ α` is the typeclass which supports `for x in xs` notation.\nHere `xs : ρ` is the type of the collection to iterate over, `x : α`\nis the element type which is made available inside the loop, and `m` is the monad\nfor the encompassing `do` block.\n</code>",
 "2225":
 "<code>Bind.kleisliLeft.{u, u_1, u_2} {α : Type u} {m : Type u_1 → Type u_2} {β γ : Type u_1} [Bind m] (f₂ : β → m γ)\n  (f₁ : α → m β) (a : α) : m γ</code><span class=\"sep\"></span><code class=\"docstring\">Right-to-left composition of Kleisli arrows. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;=&lt;` in identifiers is `kleisliLeft`.</code>",
 "2224":
 "<code>Bind.kleisliRight.{u, u_1, u_2} {α : Type u} {m : Type u_1 → Type u_2} {β γ : Type u_1} [Bind m] (f₁ : α → m β)\n  (f₂ : β → m γ) (a : α) : m γ</code><span class=\"sep\"></span><code class=\"docstring\">Left-to-right composition of Kleisli arrows. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;=&gt;` in identifiers is `kleisliRight`.</code>",
 "2223":
 "<code>repr.{u_1} {α : Type u_1} [Repr α] (a : α) : Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Turn `a` into `Format` using its `Repr` instance. The precedence level is initially set to 0.\n</code>",
 "2222": "<code>User</code>",
 "2221":
 "<code><span class=\"literal string\">\"Let's try again.\"</span> : String</code>",
 "2220":
 "<code>String.toNat? (s : String) : Option Nat</code><span class=\"sep\"></span><code class=\"docstring\">Interprets a string as the decimal representation of a natural number, returning it. Returns `none`\nif the string does not contain a decimal natural number.\n\nA string can be interpreted as a decimal natural number if it is not empty and all the characters in\nit are digits.\n\nUse `String.isNat` to check whether `String.toNat?` would return `some`. `String.toNat!` is an\nalternative that panics instead of returning `none` when the string is not a natural number.\n\nExamples:\n * `\"\".toNat? = none`\n * `\"0\".toNat? = some 0`\n * `\"5\".toNat? = some 5`\n * `\"587\".toNat? = some 587`\n * `\"-587\".toNat? = none`\n * `\" 5\".toNat? = none`\n * `\"2+3\".toNat? = none`\n * `\"0xff\".toNat? = none`\n</code>",
 "222":
 "<code>MyStructure.field2.{u_1, u_2} (self : MyStructure) {α : Sort u_2} : α</code>",
 "2219":
 "<code>String.trim (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes leading and trailing whitespace from a string.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`.\n\nExamples:\n* `\"abc\".trim = \"abc\"`\n* `\"   abc\".trim = \"abc\"`\n* `\"abc \\t  \".trim = \"abc\"`\n* `\"  abc   \".trim = \"abc\"`\n* `\"abc\\ndef\\n\".trim = \"abc\\ndef\"`\n</code>",
 "2218":
 "<code><span class=\"literal string\">\"What is your favorite natural number?\"</span> : String</code>",
 "2217": "<code>getFavoriteNat : IO Nat</code>",
 "2216":
 "<code>String.trimRight (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Removes trailing whitespace from a string.\n\n“Whitespace” is defined as characters for which `Char.isWhitespace` returns `true`.\n\nExamples:\n* `\"abc\".trimRight = \"abc\"`\n* `\"   abc\".trimRight = \"   abc\"`\n* `\"abc \\t  \".trimRight = \"abc\"`\n* `\"  abc   \".trimRight = \"  abc\"`\n* `\"abc\\ndef\\n\".trimRight = \"abc\\ndef\"`\n</code>",
 "2215":
 "<code>IO.FS.Stream.getLine (self : IO.FS.Stream) : IO String</code><span class=\"sep\"></span><code class=\"docstring\">Reads text up to and including the next newline from the stream.\n\nIf the returned string is empty, an end-of-file marker (EOF) has been reached.\nAn EOF does not actually close a stream, so further reads may block and return more data.\n</code>",
 "2214":
 "<code>IO.getStdin : BaseIO IO.FS.Stream</code><span class=\"sep\"></span><code class=\"docstring\">Returns the current thread's standard input stream.\n\nUse `IO.setStdin` to replace the current thread's standard input stream.\n</code>",
 "2213":
 "<code><span class=\"literal string\">\"What is your name?\"</span> : String</code>",
 "2212": "<code>getName : IO String</code>",
 "2211": "<code>User.mk (name : String) (favoriteNat : Nat) : User</code>",
 "2210": "<code>main : IO Unit</code>",
 "221":
 "<code>MyStructure.field1.{u_1, u_2} (self : MyStructure) {α : Sort u_1} : α</code>",
 "2209": "<code>User.favoriteNat (self : User) : Nat</code>",
 "2208": "<code>User.name (self : User) : String</code>",
 "2207": "<code>User : Type</code>",
 "2206":
 "<code>OrElse.orElse.{u} {α : Type u} [self : OrElse α] : α → (Unit → α) → α</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of `a &lt;|&gt; b : α`. See `HOrElse`. </code>",
 "2205": "<code>Array UInt8</code>",
 "2204": "<code>Array String</code>",
 "2203":
 "<code>{β : Type} →\n  StateT (Array String) (StateT (Array UInt8) (Except String)) β →\n    Except String (stM (Except String) (StateT (Array String) (StateT (Array UInt8) (Except String))) β)</code>",
 "2202":
 "<code>modifyThe.{u, v} (σ : Type u) {m : Type u → Type v} [MonadStateOf σ m] (f : σ → σ) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Mutates the current state that has the explicitly-provided type `σ`, replacing its value with the\nresult of applying `f` to it. When the current monad has multiple state types available, this\nfunction selects one of them.\n\nIt is equivalent to `do set (f (← get))`. However, using `modify` may lead to higher performance\nbecause it doesn't add a new reference to the state value. Additional references can inhibit\nin-place updates of data.\n</code>",
 "2201":
 "<code>getBytes' (input : Array Nat) : StateT (Array String) (StateT (Array UInt8) (Except String)) Unit</code>",
 "2200":
 "<code>MonadExcept.tryCatch.{u, v, w} {ε : outParam (Type u)} {m : Type v → Type w} [self : MonadExcept ε m] {α : Type v}\n  (body : m α) (handler : ε → m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Catches errors thrown in `body`, passing them to `handler`. Errors in `handler` are not caught.\n</code>",
 "220": "<code>MyStructure.{u_1, u_2} : Type (max u_1 u_2)</code>",
 "22":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "2199":
 "<code>Except.map.{u, u_1, u_2} {ε : Type u} {α : Type u_1} {β : Type u_2} (f : α → β) : Except ε α → Except ε β</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a successful result with a function, doing nothing when an exception is thrown.\n\nExamples:\n* `(pure 2 : Except String Nat).map toString = pure 2`\n* `(throw \"Error\" : Except String Nat).map toString = throw \"Error\"`\n</code>",
 "2198":
 "<code>StateT.run.{u, v} {σ : Type u} {m : Type u → Type v} {α : Type u} (x : StateT σ m α) (s : σ) : m (α × σ)</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action from a monad with added state in the underlying monad `m`. Given an initial\nstate, it returns a value paired with the final state.\n</code>",
 "2197": "<code>UInt8</code>",
 "2196":
 "<code>Nat.toUInt8 (n : Nat) : UInt8</code><span class=\"sep\"></span><code class=\"docstring\">Converts a natural number to an 8-bit unsigned integer, wrapping on overflow.\n\nExamples:\n* `Nat.toUInt8 5 = 5`\n* `Nat.toUInt8 255 = 255`\n* `Nat.toUInt8 256 = 0`\n* `Nat.toUInt8 259 = 3`\n* `Nat.toUInt8 32770 = 2`\n</code>",
 "2195": "<code>getByte (n : Nat) : Except String UInt8</code>",
 "2194":
 "<code>getBytes (input : Array Nat) : StateT (Array UInt8) (Except String) Unit</code>",
 "2193": "<code>ε → Except ε α</code>",
 "2192": "<code>Except ε α</code>",
 "2191":
 "<code>Except.tryCatch.{u, u_1} {ε : Type u} {α : Type u_1} (ma : Except ε α) (handle : ε → Except ε α) : Except ε α</code><span class=\"sep\"></span><code class=\"docstring\">Handles exceptions thrown in the `Except ε` monad.\n\nIf `ma` is successful, its result is returned. If it throws an exception, then `handle` is invoked\non the exception's value.\n\nExamples:\n * `(pure 2 : Except String Nat).tryCatch (pure ·.length) = pure 2`\n * `(throw \"Error\" : Except String Nat).tryCatch (pure ·.length) = pure 5`\n * `(throw \"Error\" : Except String Nat).tryCatch (fun x =&gt; throw (\"E: \" ++ x)) = throw \"E: Error\"`\n</code>",
 "2190": "<code>({β : Type u} → n β → m (stM m n β)) → m (stM m n α)</code>",
 "219": "<code>AtLeastOne.head'.{u_1} {α : Type u_1} : AtLeastOne α → α</code>",
 "2189":
 "<code>{α : Type u} → stM m n α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a monadic action that returns a state and a value in the inner monad to an action in the\nouter monad. The extra state information is used to restore the results of effects from the\nreverse lift passed to `liftWith`'s parameter.\n</code>",
 "2188":
 "<code>MonadControlT.stM.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) [self : MonadControlT m n] : Type u → Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type that can be used to reconstruct both a returned value and any state used by the outer\nmonad.\n</code>",
 "2187":
 "<code>{α : Type u} → (({β : Type u} → n β → m (stM m n β)) → m α) → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an action from the inner monad `m` to the outer monad `n`. The inner monad has access to a\nreverse lifting operator that can run an `n` action, returning a value and state together.\n</code>",
 "2186":
 "<code>MonadControlT.mk.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} (stM : Type u → Type u)\n  (liftWith : {α : Type u} → (({β : Type u} → n β → m (stM β)) → m α) → n α) (restoreM : {α : Type u} → stM α → n α) :\n  MonadControlT m n</code>",
 "2185":
 "<code>MonadControlT.liftWith.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} [self : MonadControlT m n] {α : Type u} :\n  (({β : Type u} → n β → m (MonadControlT.stM m n β)) → m α) → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an action from the inner monad `m` to the outer monad `n`. The inner monad has access to a\nreverse lifting operator that can run an `n` action, returning a value and state together.\n</code>",
 "2184":
 "<code>{α : Type u} → m (MonadControl.stM m n α) → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a monadic action that returns a state and a value in the inner monad to an action in the\nouter monad. The extra state information is used to restore the results of effects from the\nreverse lift passed to `liftWith`'s parameter.\n</code>",
 "2183":
 "<code>MonadControl.stM.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) [self : MonadControl m n] :\n  Type u → Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type that can be used to reconstruct both a returned value and any state used by the outer\nmonad.\n</code>",
 "2182":
 "<code>{α : Type u} → (({β : Type u} → n β → m (MonadControl.stM m n β)) → m α) → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an action from the inner monad `m` to the outer monad `n`. The inner monad has access to a\nreverse lifting operator that can run an `n` action, returning a value and state together.\n</code>",
 "2181":
 "<code>Type u → Type u</code><span class=\"sep\"></span><code class=\"docstring\">A type that can be used to reconstruct both a returned value and any state used by the outer\nmonad.\n</code>",
 "2180":
 "<code>MonadControl.mk.{u, v, w} {m : semiOutParam (Type u → Type v)} {n : Type u → Type w} (stM : Type u → Type u)\n  (liftWith : {α : Type u} → (({β : Type u} → n β → m (stM β)) → m α) → n α)\n  (restoreM : {α : Type u} → m (stM α) → n α) : MonadControl m n</code>",
 "218": "<code>oneTwoThree' : AtLeastOne Nat</code>",
 "2179":
 "<code>MonadControlT.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">A way to lift a computation from one monad to another while providing the lifted computation with a\nmeans of interpreting computations from the outer monad. This provides a means of lifting\nhigher-order operations automatically.\n\nClients should typically use `control` or `controlAt`, which request an instance of `MonadControlT`:\nthe reflexive, transitive closure of `MonadControl`. New instances should be defined for\n`MonadControl` itself.\n</code>",
 "2178":
 "<code>controlAt.{u, v, w} (m : Type u → Type v) {n : Type u → Type w} [MonadControlT m n] [Bind n] {α : Type u}\n  (f : ({β : Type u} → n β → m (stM m n β)) → m (stM m n α)) : n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an operation from an inner monad to an outer monad, providing it with a reverse lifting\noperator that allows outer monad computations to be run in the inner monad. The lifted operation is\nrequired to return extra information that is required in order to reconstruct the reverse lift's\neffects in the outer monad; this extra information is determined by `stM`.\n\nThis function takes the inner monad as an explicit parameter. Use `control` to infer the monad.\n</code>",
 "2177":
 "<code>control.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} [MonadControlT m n] [Bind n] {α : Type u}\n  (f : ({β : Type u} → n β → m (stM m n β)) → m (stM m n α)) : n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts an operation from an inner monad to an outer monad, providing it with a reverse lifting\noperator that allows outer monad computations to be run in the inner monad. The lifted operation is\nrequired to return extra information that is required in order to reconstruct the reverse lift's\neffects in the outer monad; this extra information is determined by `stM`.\n\nThis function takes the inner monad as an implicit parameter. Use `controlAt` to specify it\nexplicitly.\n</code>",
 "2176":
 "<code>MonadFunctorT.mk.{u, v, w} {m : Type u → Type v} {n : Type u → Type w}\n  (monadMap : {α : Type u} → ({β : Type u} → m β → m β) → n α → n α) : MonadFunctorT m n</code>",
 "2175":
 "<code>{α : Type u} → ({β : Type u} → m β → m β) → n α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a fully-polymorphic transformation of `m` into `n`.\n</code>",
 "2174":
 "<code>MonadFunctor.mk.{u, v, w} {m : semiOutParam (Type u → Type v)} {n : Type u → Type w}\n  (monadMap : {α : Type u} → ({β : Type u} → m β → m β) → n α → n α) : MonadFunctor m n</code>",
 "2173":
 "<code>MonadFunctorT.{u, v, w} (m : Type u → Type v) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">A way to interpret a fully-polymorphic function in `m` into `n`. Such a function can be thought of\nas one that may change the effects in `m`, but can't do so based on specific values that are\nprovided.\n\nThis is the reflexive, transitive closure of `MonadFunctor`. It automatically chains together\n`MonadFunctor` instances as needed. Clients of `MonadFunctor` should typically use `MonadFunctorT`,\nbut new instances should be defined for `MonadFunctor`.\n</code>",
 "2172":
 "<code>MonadControl.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">A way to lift a computation from one monad to another while providing the lifted computation with a\nmeans of interpreting computations from the outer monad. This provides a means of lifting\nhigher-order operations automatically.\n\nClients should typically use `control` or `controlAt`, which request an instance of `MonadControlT`:\nthe reflexive, transitive closure of `MonadControl`. New instances should be defined for\n`MonadControl` itself.\n</code>",
 "2171":
 "<code>MonadFunctor.{u, v, w} (m : semiOutParam (Type u → Type v)) (n : Type u → Type w) : Type (max (max (u + 1) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">A way to interpret a fully-polymorphic function in `m` into `n`. Such a function can be thought of\nas one that may change the effects in `m`, but can't do so based on specific values that are\nprovided.\n\nClients of `MonadFunctor` should typically use `MonadFunctorT`, which is the reflexive, transitive\nclosure of `MonadFunctor`. New instances should be defined for `MonadFunctor.`\n</code>",
 "2170":
 "<code>autoLift</code><span class=\"sep\"></span><code class=\"docstring\">Insert monadic lifts (i.e., `liftM` and coercions) when needed.</code>",
 "217": "<code>AtLeastOne.head.{u_1} {α : Type u_1} : AtLeastOne α → α</code>",
 "2169":
 "<code><span class=\"literal string\">\"Too much!\"</span> : String</code>",
 "2168":
 "<code>MonadReader.read.{u, v} {ρ : outParam (Type u)} {m : Type u → Type v} [self : MonadReader ρ m] : m ρ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the local value.\n\nUse `readThe` to explicitly specify a type when more than one value is available.\n</code>",
 "2167":
 "<code>ExceptT.{u, v} (ε : Type u) (m : Type u → Type v) (α : Type u) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Adds exceptions of type `ε` to a monad `m`.\n</code>",
 "2166":
 "<code>ReaderT.{u, v} (ρ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds the ability to access a read-only value of type `ρ` to a monad. The value can be locally\noverridden by `withReader`, but it cannot be mutated.\n\nActions in the resulting monad are functions that take the local value as a parameter, returning\nordinary actions in `m`.\n</code>",
 "2165":
 "<code>incrOrFail : ReaderT Nat (ExceptT String (StateM Nat)) Unit</code>",
 "2164":
 "<code>modify.{u, v} {σ : Type u} {m : Type u → Type v} [MonadState σ m] (f : σ → σ) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Mutates the current state, replacing its value with the result of applying `f` to it.\n\nUse `modifyThe` to explicitly select a state type to modify.\n\nIt is equivalent to `do set (f (← get))`. However, using `modify` may lead to higher performance\nbecause it doesn't add a new reference to the state value. Additional references can inhibit\nin-place updates of data.\n</code>",
 "2163": "<code>incrBy (n : Nat) : StateM Nat Unit</code>",
 "2162": "<code>BaseIO α</code>",
 "2161": "<code>fromBaseIO {α : Type} (act : BaseIO α) : IO α</code>",
 "2160":
 "<code>Lean.Internal.liftCoeM.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} {α β : Type u} [MonadLiftT m n]\n  [(a : α) → CoeT α a β] [Monad n] (x : m α) : n β</code><span class=\"sep\"></span><code class=\"docstring\">Helper definition used by the elaborator. It is not meant to be used directly by users.\n\nThis is used for coercions between monads, in the case where we want to apply\na monad lift and a coercion on the result type at the same time.\n</code>",
 "216": "<code>oneTwoThree : AtLeastOne Nat</code>",
 "2159": "<code>MonadLiftT m n</code>",
 "2158":
 "<code>liftM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {n : Type u_1 → Type u_3} [self : MonadLiftT m n] {α : Type u_1} :\n  m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Translates an action from monad `m` into monad `n`. </code>",
 "2157":
 "<code>Lean.Internal.coeM.{u, v} {m : Type u → Type v} {α β : Type u} [(a : α) → CoeT α a β] [Monad m] (x : m α) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Helper definition used by the elaborator. It is not meant to be used directly by users.\n\nThis is used for coercing the result type under a monad.\n</code>",
 "2156":
 "<code>IO.FS.Stream : Type</code><span class=\"sep\"></span><code class=\"docstring\">A pure-Lean abstraction of POSIX streams. These streams may represent an underlying POSIX stream or\nbe implemented by Lean code.\n\nBecause standard input, standard output, and standard error are all `IO.FS.Stream`s that can be\noverridden, Lean code may capture and redirect input and output.\n</code>",
 "2155": "<code>FS.Stream</code>",
 "2154":
 "<code>BaseIO : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">An `IO` monad that cannot throw exceptions.\n</code>",
 "2153":
 "<code>MonadFinally.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code>",
 "2152": "<code>Type → Type u</code>",
 "2151":
 "<code>IO.withStdin.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] [MonadFinally m] [MonadLiftT BaseIO m] (h : IO.FS.Stream)\n  (x : m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Runs an action with the specified stream `h` as standard input, restoring the original standard\ninput stream afterwards.\n</code>",
 "2150":
 "<code>MonadLiftT.mk.{u, v, w} {m : Type u → Type v} {n : Type u → Type w} (monadLift : {α : Type u} → m α → n α) :\n  MonadLiftT m n</code>",
 "215":
 "<code>AtLeastOne.mk.{u} {α : Type u} : α → Option (AtLeastOne α) → AtLeastOne α</code>",
 "2149":
 "<code>{α : Type u} → m α → n α</code><span class=\"sep\"></span><code class=\"docstring\">Translates an action from monad `m` into monad `n`. </code>",
 "2148":
 "<code>MonadLift.mk.{u, v, w} {m : semiOutParam (Type u → Type v)} {n : Type u → Type w}\n  (monadLift : {α : Type u} → m α → n α) : MonadLift m n</code>",
 "2147":
 "<code>autoParam\n  (∀ {α β : Type u} (f : m (α → β)) (x : m α),\n    (do\n        let x_1 ← f\n        x_1 &lt;$&gt; x) =\n      f &lt;*&gt; x)\n  _auto✝</code>",
 "2146":
 "<code>autoParam\n  (∀ {α β : Type u} (f : α → β) (x : m α),\n    (do\n        let y ← x\n        pure (f y)) =\n      f &lt;$&gt; x)\n  _auto✝</code>",
 "2145":
 "<code>autoParam\n  (∀ {α β : Type u} (x : m α) (y : m β),\n    x *&gt; y = do\n      let _ ← x\n      y)\n  _auto✝</code>",
 "2144":
 "<code>autoParam\n  (∀ {α β : Type u} (x : m α) (y : m β),\n    x &lt;* y = do\n      let a ← x\n      let _ ← y\n      pure a)\n  _auto✝</code>",
 "2143":
 "<code>autoParam (∀ {α β : Type u} (x : α) (y : m β), Functor.mapConst x y = Function.const β x &lt;$&gt; y) _auto✝</code>",
 "2142":
 "<code>∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= fun x =&gt; f x &gt;&gt;= g</code>",
 "2141":
 "<code>∀ {α β : Type u} (x : α) (f : α → m β), pure x &gt;&gt;= f = f x</code>",
 "2140": "<code>∀ {α : Type u} (x : m α), id &lt;$&gt; x = x</code>",
 "214": "<code>AtLeastOne.{u} (α : Type u) : Type u</code>",
 "2139": "<code>β → m γ</code>",
 "2138":
 "<code>∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= fun x =&gt; f x &gt;&gt;= g</code><span class=\"sep\"></span><code class=\"docstring\">`bind` is associative.\n\nChanging the nesting of `bind` calls while maintaining the order of computations results in an\nequivalent computation. This means that `bind` is not doing more than data-dependent sequencing.\n</code>",
 "2137":
 "<code>∀ {α β : Type u} (x : α) (f : α → m β), pure x &gt;&gt;= f = f x</code><span class=\"sep\"></span><code class=\"docstring\">`pure` followed by `bind` is equivalent to function application.\n\nThis means that `pure` really is pure before a `bind` and has no effects.\n</code>",
 "2136":
 "<code>∀ {α β : Type u} (f : m (α → β)) (x : m α),\n  (do\n      let x_1 ← f\n      x_1 &lt;$&gt; x) =\n    f &lt;*&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">A `bind` followed by a functorial map is equivalent to `Applicative` sequencing.\n\nThis means that the effect sequencing from `Monad` and `Applicative` are the same.\n</code>",
 "2135":
 "<code>∀ {α β : Type u} (f : α → β) (x : m α),\n  (do\n      let a ← x\n      pure (f a)) =\n    f &lt;$&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">A `bind` followed by `pure` composed with a function is equivalent to a functorial map.\n\nThis means that `pure` really is pure after a `bind` and has no effects.\n</code>",
 "2134": "<code>m (β → γ)</code>",
 "2133": "<code>m (α → β)</code>",
 "2132": "<code>m β</code>",
 "2131":
 "<code>LawfulMonad.mk.{u, v} {m : Type u → Type v} [Monad m] [toLawfulApplicative : LawfulApplicative m]\n  (bind_pure_comp :\n    ∀ {α β : Type u} (f : α → β) (x : m α),\n      (do\n          let a ← x\n          pure (f a)) =\n        f &lt;$&gt; x)\n  (bind_map :\n    ∀ {α β : Type u} (f : m (α → β)) (x : m α),\n      (do\n          let x_1 ← f\n          x_1 &lt;$&gt; x) =\n        f &lt;*&gt; x)\n  (pure_bind : ∀ {α β : Type u} (x : α) (f : α → m β), pure x &gt;&gt;= f = f x)\n  (bind_assoc : ∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= fun x =&gt; f x &gt;&gt;= g) :\n  LawfulMonad m</code>",
 "2130":
 "<code>LawfulMonad.mk'.{u, v} (m : Type u → Type v) [Monad m] (id_map : ∀ {α : Type u} (x : m α), id &lt;$&gt; x = x)\n  (pure_bind : ∀ {α β : Type u} (x : α) (f : α → m β), pure x &gt;&gt;= f = f x)\n  (bind_assoc : ∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= fun x =&gt; f x &gt;&gt;= g)\n  (map_const : ∀ {α β : Type u} (x : α) (y : m β), Functor.mapConst x y = Function.const β x &lt;$&gt; y := by intros; rfl)\n  (seqLeft_eq :\n    ∀ {α β : Type u} (x : m α) (y : m β),\n      x &lt;* y = do\n        let a ← x\n        let _ ← y\n        pure a := by\n    intros; rfl)\n  (seqRight_eq :\n    ∀ {α β : Type u} (x : m α) (y : m β),\n      x *&gt; y = do\n        let _ ← x\n        y := by\n    intros; rfl)\n  (bind_pure_comp :\n    ∀ {α β : Type u} (f : α → β) (x : m α),\n      (do\n          let y ← x\n          pure (f y)) =\n        f &lt;$&gt; x := by\n    intros; rfl)\n  (bind_map :\n    ∀ {α β : Type u} (f : m (α → β)) (x : m α),\n      (do\n          let x_1 ← f\n          x_1 &lt;$&gt; x) =\n        f &lt;*&gt; x := by\n    intros; rfl) :\n  LawfulMonad m</code><span class=\"sep\"></span><code class=\"docstring\">An alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n</code>",
 "213":
 "<code>Either''.right.{u, v} {α : Type u} {β : Type v} : α → Either'' α β</code>",
 "2129": "<code>f (β → γ)</code>",
 "2128":
 "<code>∀ {α β γ : Type u} (x : f α) (g : f (α → β)) (h : f (β → γ)), h &lt;*&gt; (g &lt;*&gt; x) = Function.comp &lt;$&gt; h &lt;*&gt; g &lt;*&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">`seq` is associative.\n\nChanging the nesting of `seq` calls while maintaining the order of computations results in an\nequivalent computation. This means that `seq` is not doing any more than sequencing.\n</code>",
 "2127": "<code>f (α → β)</code>",
 "2126":
 "<code>∀ {α β : Type u} (g : f (α → β)) (x : α), g &lt;*&gt; pure x = (fun h =&gt; h x) &lt;$&gt; g</code><span class=\"sep\"></span><code class=\"docstring\">`pure` after `seq` is equivalent to `Functor.map`.\n\nThis means that `pure` really is pure when occurring just after `seq`.\n</code>",
 "2125":
 "<code>∀ {α β : Type u} (g : α → β) (x : α), g &lt;$&gt; pure x = pure (g x)</code><span class=\"sep\"></span><code class=\"docstring\">Mapping a function over the result of `pure` is equivalent to applying the function under `pure`.\n\nThis means that `pure` really is pure with respect to `Functor.map`.\n</code>",
 "2124":
 "<code>∀ {α β : Type u} (g : α → β) (x : f α), pure g &lt;*&gt; x = g &lt;$&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">`pure` before `seq` is equivalent to `Functor.map`.\n\nThis means that `pure` really is pure when occurring immediately prior to `seq`.\n</code>",
 "2123":
 "<code>∀ {α β : Type u} (x : f α) (y : f β), x *&gt; y = Function.const α id &lt;$&gt; x &lt;*&gt; y</code><span class=\"sep\"></span><code class=\"docstring\">`seqRight` is equivalent to the default implementation. </code>",
 "2122":
 "<code>∀ {α β : Type u} (x : f α) (y : f β), x &lt;* y = Function.const β &lt;$&gt; x &lt;*&gt; y</code><span class=\"sep\"></span><code class=\"docstring\">`seqLeft` is equivalent to the default implementation. </code>",
 "2121":
 "<code>LawfulApplicative.mk.{u, v} {f : Type u → Type v} [Applicative f] [toLawfulFunctor : LawfulFunctor f]\n  (seqLeft_eq : ∀ {α β : Type u} (x : f α) (y : f β), x &lt;* y = Function.const β &lt;$&gt; x &lt;*&gt; y)\n  (seqRight_eq : ∀ {α β : Type u} (x : f α) (y : f β), x *&gt; y = Function.const α id &lt;$&gt; x &lt;*&gt; y)\n  (pure_seq : ∀ {α β : Type u} (g : α → β) (x : f α), pure g &lt;*&gt; x = g &lt;$&gt; x)\n  (map_pure : ∀ {α β : Type u} (g : α → β) (x : α), g &lt;$&gt; pure x = pure (g x))\n  (seq_pure : ∀ {α β : Type u} (g : f (α → β)) (x : α), g &lt;*&gt; pure x = (fun h =&gt; h x) &lt;$&gt; g)\n  (seq_assoc :\n    ∀ {α β γ : Type u} (x : f α) (g : f (α → β)) (h : f (β → γ)), h &lt;*&gt; (g &lt;*&gt; x) = Function.comp &lt;$&gt; h &lt;*&gt; g &lt;*&gt; x) :\n  LawfulApplicative f</code>",
 "2120": "<code>f.{u, v} : Type u → Type v</code>",
 "212":
 "<code>Either''.left.{u, v} {α : Type u} {β : Type v} : α → Either'' α β</code>",
 "2119":
 "<code>SeqRight.seqRight.{u, v} {f : Type u → Type v} [self : SeqRight f] {α β : Type u} : f α → (Unit → f β) → f β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences the effects of two terms, discarding the value of the first. This function is usually\ninvoked via the `*&gt;` operator.\n\nGiven `x : f α` and `y : f β`, `x *&gt; y` runs `x`, then runs `y`, and finally returns the result of\n`y`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*&gt;` in identifiers is `seqRight`.</code>",
 "2118":
 "<code>SeqLeft.seqLeft.{u, v} {f : Type u → Type v} [self : SeqLeft f] {α β : Type u} : f α → (Unit → f β) → f α</code><span class=\"sep\"></span><code class=\"docstring\">Sequences the effects of two terms, discarding the value of the second. This function is usually\ninvoked via the `&lt;*` operator.\n\nGiven `x : f α` and `y : f β`, `x &lt;* y` runs `x`, then runs `y`, and finally returns the result of\n`x`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*` in identifiers is `seqLeft`.</code>",
 "2117":
 "<code>∀ {α β γ : Type u} (g : α → β) (h : β → γ) (x : f α), (h ∘ g) &lt;$&gt; x = h &lt;$&gt; g &lt;$&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">The `map` implementation preserves function composition.\n</code>",
 "2116":
 "<code>∀ {α : Type u} (x : f α), id &lt;$&gt; x = x</code><span class=\"sep\"></span><code class=\"docstring\">The `map` implementation preserves identity.\n</code>",
 "2115":
 "<code>∀ {α β : Type u}, Functor.mapConst = Functor.map ∘ Function.const β</code><span class=\"sep\"></span><code class=\"docstring\">The `mapConst` implementation is equivalent to the default implementation.\n</code>",
 "2114":
 "<code>LawfulFunctor.mk.{u, v} {f : Type u → Type v} [Functor f]\n  (map_const : ∀ {α β : Type u}, Functor.mapConst = Functor.map ∘ Function.const β)\n  (id_map : ∀ {α : Type u} (x : f α), id &lt;$&gt; x = x)\n  (comp_map : ∀ {α β γ : Type u} (g : α → β) (h : β → γ) (x : f α), (h ∘ g) &lt;$&gt; x = h &lt;$&gt; g &lt;$&gt; x) : LawfulFunctor f</code>",
 "2113":
 "<code>Monad.mk.{u, v} {m : Type u → Type v} [toApplicative : Applicative m] [toBind : Bind m] : Monad m</code>",
 "2112":
 "<code>LawfulMonad.{u, v} (m : Type u → Type v) [Monad m] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Lawful monads are those that satisfy a certain behavioral specification. While all instances of\n`Monad` should satisfy these laws, not all implementations are required to prove this.\n\n`LawfulMonad.mk'` is an alternative constructor that contains useful defaults for many fields.\n</code>",
 "2111": "<code>α → m β</code>",
 "2110":
 "<code>{α β : Type u} → m α → (α → m β) → m β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "211": "<code>Either''.{u, v} : Type u → Type v → Type (max u v)</code>",
 "2109":
 "<code>Bind.mk.{u, v} {m : Type u → Type v} (bind : {α β : Type u} → m α → (α → m β) → m β) : Bind m</code>",
 "2108":
 "<code>{α : Type u} → f α → (Unit → f α) → f α</code><span class=\"sep\"></span><code class=\"docstring\">Depending on the `Alternative` instance, collects values or recovers from `failure`s by\nreturning the leftmost success. Can be written using the `&lt;|&gt;` operator syntax.\n</code>",
 "2107":
 "<code>{α : Type u} → f α</code><span class=\"sep\"></span><code class=\"docstring\">Produces an empty collection or recoverable failure.  The `&lt;|&gt;` operator collects values or recovers\nfrom failures. See `Alternative` for more details.\n</code>",
 "2106":
 "<code>Alternative.mk.{u, v} {f : Type u → Type v} [toApplicative : Applicative f] (failure : {α : Type u} → f α)\n  (orElse : {α : Type u} → f α → (Unit → f α) → f α) : Alternative f</code>",
 "2105":
 "<code>Id.{u} (type : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The identity function on types, used primarily for its `Monad` instance.\n\nThe identity monad is useful together with monad transformers to construct monads for particular\npurposes. Additionally, it can be used with `do`-notation in order to use control structures such as\nlocal mutability, `for`-loops, and early returns in code that does not otherwise use monads.\n\nExamples:\n```lean example\ndef containsFive (xs : List Nat) : Bool := Id.run do\n  for x in xs do\n    if x == 5 then return true\n  return false\n```\n\n```lean example\n#eval containsFive [1, 3, 5, 7]\n```\n```output\ntrue\n```\n</code>",
 "2104":
 "<code>StateT.{u, v} (σ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds a mutable state of type `σ` to a monad.\n\nActions in the resulting monad are functions that take an initial state and return, in `m`, a tuple\nof a value and a state.\n</code>",
 "2103":
 "<code>OptionT.{u, v} (m : Type u → Type v) (α : Type u) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Adds the ability to fail to a monad. Unlike ordinary exceptions, there is no way to signal why a\nfailure occurred.\n</code>",
 "2102": "<code>LenList (n' + 1) α</code>",
 "2101":
 "<code>(square.head.head :: (diagonal (map (fun x =&gt; x.tail) square.tail)).list).length = n' + 1</code>",
 "2100": "<code>LenList (n' + 1) (LenList (n' + 1) α)</code>",
 "210": "<code>Type u → Type v → Type (max u v)</code>",
 "21": "<code>Even : Nat → Prop</code>",
 "2099": "<code>LenList n (LenList n α)</code>",
 "2098":
 "<code>LenList.diagonal.{u} {α : Type u} {n : Nat} (square : LenList n (LenList n α)) : LenList n α</code>",
 "2097":
 "<code>LenList.list_length_eq.{u} {α : Type u} {n : Nat} (xs : LenList n α) : xs.list.length = n</code>",
 "2096": "<code>Unit → LenList n α</code>",
 "2095": "<code>LenList n (α → β)</code>",
 "2094":
 "<code>{α β : Type u_1} → LenList n (α → β) → (Unit → LenList n α) → LenList n β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "2093":
 "<code>List.length_replicate.{u} {α : Type u} (n : Nat) (a : α) : (List.replicate n a).length = n</code>",
 "2092": "<code>(List.replicate n x).length = n</code>",
 "2091": "<code>List α✝</code>",
 "2090":
 "<code>{α : Type u_1} → α → LenList n α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "209":
 "<code>Either.right.{u, v} {α : Type u} {β : Type v} : α → Either α β</code>",
 "2089":
 "<code>{α β : Type u_1} → (α → β) → LenList n α → LenList n β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "2088":
 "<code>List.length_zipWith.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (l₁ : List α)\n  (l₂ : List β) : (List.zipWith f l₁ l₂).length = min l₁.length l₂.length</code>",
 "2087": "<code>list✝¹.length = n</code>",
 "2086": "<code>List β</code>",
 "2085": "<code>list✝¹.length = n</code>",
 "2084": "<code>Type ?u.2437</code>",
 "2083": "<code>(List.zipWith f xs.list ys.list).length = n</code>",
 "2082":
 "<code>List.zipWith.{u, v, w} {α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) (xs : List α) (ys : List β) : List γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of two lists, stopping at the end of the shorter\nlist.\n\n`O(min |xs| |ys|)`.\n\nExamples:\n* `[1, 2].zipWith (· + ·) [5, 6] = [6, 8]`\n* `[1, 2, 3].zipWith (· + ·) [5, 6, 10] = [6, 8, 13]`\n* `[].zipWith (· + ·) [5, 6] = []`\n* `[x₁, x₂, x₃].zipWith f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]`\n</code>",
 "2081": "<code>List γ</code>",
 "2080": "<code>LenList n β</code>",
 "208":
 "<code>Either.left.{u, v} {α : Type u} {β : Type v} : α → Either α β</code>",
 "2079": "<code>α → β → γ</code>",
 "2078":
 "<code>LenList.zipWith.{u, u_1} {α β : Type u} {γ : Type u_1} {n : Nat} (f : α → β → γ) (xs : LenList n α) (ys : LenList n β) :\n  LenList n γ</code>",
 "2077":
 "<code>List.length_map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (as : List α) (f : α → β) : (List.map f as).length = as.length</code>",
 "2076": "<code>list✝.length = n</code>",
 "2075": "<code>list✝.length = n</code>",
 "2074": "<code>(List.map f xs.list).length = n</code>",
 "2073": "<code>List β</code>",
 "2072": "<code>LenList n α</code>",
 "2071":
 "<code>LenList.map.{u} {α β : Type u} {n : Nat} (f : α → β) (xs : LenList n α) : LenList n β</code>",
 "2070": "<code>(head✝ :: xs').length = n + 1</code>",
 "207": "<code>Either.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code>",
 "2069":
 "<code>LenList.mk.{u} {length : Nat} {α : Type u} (list : List α) (lengthOk : list.length = length) : LenList length α</code>",
 "2068":
 "<code>LenList.tail.{u} {α : Type u} {n : Nat} (xs : LenList (n + 1) α) : LenList n α</code>",
 "2067":
 "<code class=\"docstring\">`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n</code>",
 "2066": "<code>list✝ = []</code>",
 "2065": "<code>list✝.length = n + 1</code>",
 "2064": "<code>List α</code>",
 "2063": "<code>{ list := list✝, lengthOk := lengthOk✝ }.list = []</code>",
 "2062": "<code>list✝.length = n + 1</code>",
 "2061": "<code>xs.list = []</code>",
 "2060":
 "<code>List.head.{u} {α : Type u} (as : List α) : as ≠ [] → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of a non-empty list.\n</code>",
 "206":
 "<code>Bool.not : Bool → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean negation, also known as Boolean complement. `not x` can be written `!x`.\n\nThis is a function that maps the value `true` to `false` and the value `false` to `true`. The\npropositional connective is `Not : Prop → Prop`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `!` in identifiers is `not`.</code>",
 "2059": "<code>LenList (n + 1) α</code>",
 "2058":
 "<code>LenList.head.{u} {α : Type u} {n : Nat} (xs : LenList (n + 1) α) : α</code>",
 "2057":
 "<code>LenList.lengthOk.{u} {length : Nat} {α : Type u} (self : LenList length α) : self.list.length = length</code>",
 "2056":
 "<code>LenList.list.{u} {length : Nat} {α : Type u} (self : LenList length α) : List α</code>",
 "2055": "<code>LenList.{u} (length : Nat) (α : Type u) : Type u</code>",
 "2054":
 "<code>Applicative.mk.{u, v} {f : Type u → Type v} [toFunctor : Functor f] [toPure : Pure f] [toSeq : Seq f]\n  [toSeqLeft : SeqLeft f] [toSeqRight : SeqRight f] : Applicative f</code>",
 "2053":
 "<code>LawfulApplicative.{u, v} (f : Type u → Type v) [Applicative f] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An applicative functor satisfies the laws of an applicative functor.\n\nThe `Applicative` class contains the operations of an applicative functor, but does not require that\ninstances prove they satisfy the laws of an applicative functor. A `LawfulApplicative` instance\nincludes proofs that the laws are satisfied.\n\nBecause `Applicative` instances may provide optimized implementations of `seqLeft` and `seqRight`,\n`LawfulApplicative` instances must also prove that the optimized implementation is equivalent to the\nstandard implementation.\n</code>",
 "2052": "<code>{α β : Type u} → f α → (Unit → f β) → f β</code>",
 "2051":
 "<code>{α β : Type u} → f α → (Unit → f β) → f β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences the effects of two terms, discarding the value of the first. This function is usually\ninvoked via the `*&gt;` operator.\n\nGiven `x : f α` and `y : f β`, `x *&gt; y` runs `x`, then runs `y`, and finally returns the result of\n`y`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*&gt;` in identifiers is `seqRight`.</code>",
 "2050":
 "<code>SeqRight.mk.{u, v} {f : Type u → Type v} (seqRight : {α β : Type u} → f α → (Unit → f β) → f β) : SeqRight f</code>",
 "205":
 "<code>EvenOddList.cons.{u} {α : Type u} {isEven : Bool} : α → EvenOddList α isEven → EvenOddList α !isEven</code>",
 "2049": "<code>{α β : Type u} → f α → (Unit → f β) → f α</code>",
 "2048": "<code>f β</code>",
 "2047":
 "<code>{α β : Type u} → f α → (Unit → f β) → f α</code><span class=\"sep\"></span><code class=\"docstring\">Sequences the effects of two terms, discarding the value of the second. This function is usually\ninvoked via the `&lt;*` operator.\n\nGiven `x : f α` and `y : f β`, `x &lt;* y` runs `x`, then runs `y`, and finally returns the result of\n`x`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*` in identifiers is `seqLeft`.</code>",
 "2046":
 "<code>SeqLeft.mk.{u, v} {f : Type u → Type v} (seqLeft : {α β : Type u} → f α → (Unit → f β) → f α) : SeqLeft f</code>",
 "2045": "<code>{α β : Type u} → f (α → β) → (Unit → f α) → f β</code>",
 "2044":
 "<code>{α β : Type u} → f (α → β) → (Unit → f α) → f β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "2043":
 "<code>Seq.mk.{u, v} {f : Type u → Type v} (seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β) : Seq f</code>",
 "2042":
 "<code>Seq.seq.{u, v} {f : Type u → Type v} [self : Seq f] {α β : Type u} : f (α → β) → (Unit → f α) → f β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "2041": "<code>{α : Type u} → α → f α</code>",
 "2040": "<code>Sort ?u.7458</code>",
 "204": "<code>EvenOddList.nil.{u} {α : Type u} : EvenOddList α true</code>",
 "2039":
 "<code>{α : Type u} → α → f α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "2038":
 "<code>Pure.mk.{u, v} {f : Type u → Type v} (pure : {α : Type u} → α → f α) : Pure f</code>",
 "2037": "<code>{α β : Type u} → α → f β → f α</code>",
 "2036": "<code>Sort ?u.7322</code>",
 "2035":
 "<code>{α β : Type u} → α → f β → f α</code><span class=\"sep\"></span><code class=\"docstring\">Mapping a constant function.\n\nGiven `a : α` and `v : f α`, `mapConst a v` is equivalent to `Function.const _ a &lt;$&gt; v`. For some\nfunctors, this can be implemented more efficiently; for all other functors, the default\nimplementation may be used.\n</code>",
 "2034": "<code>{α β : Type u} → (α → β) → f α → f β</code>",
 "2033":
 "<code>Functor.mapConst.{u, v} {f : Type u → Type v} [self : Functor f] {α β : Type u} : α → f β → f α</code><span class=\"sep\"></span><code class=\"docstring\">Mapping a constant function.\n\nGiven `a : α` and `v : f α`, `mapConst a v` is equivalent to `Function.const _ a &lt;$&gt; v`. For some\nfunctors, this can be implemented more efficiently; for all other functors, the default\nimplementation may be used.\n</code>",
 "2032":
 "<code>{α β : Type u} → (α → β) → f α → f β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "2031":
 "<code>Functor.mk.{u, v} {f : Type u → Type v} (map : {α β : Type u} → (α → β) → f α → f β)\n  (mapConst : {α β : Type u} → α → f β → f α) : Functor f</code>",
 "2030":
 "<code>LawfulFunctor.{u, v} (f : Type u → Type v) [Functor f] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A functor satisfies the functor laws.\n\nThe `Functor` class contains the operations of a functor, but does not require that instances\nprove they satisfy the laws of a functor. A `LawfulFunctor` instance includes proofs that the laws\nare satisfied. Because `Functor` instances may provide optimized implementations of `mapConst`,\n`LawfulFunctor` instances must also prove that the optimized implementation is equivalent to the\nstandard implementation.\n</code>",
 "203": "<code>b : Bool</code>",
 "2029": "<code>Sort ?u.3627</code>",
 "2028": "<code>Sort ?u.3624</code>",
 "2027": "<code>Sort ?u.3623</code>",
 "2026": "<code>β → γ</code>",
 "2025": "<code>f α</code>",
 "2024":
 "<code>Alternative.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">An `Alternative` functor is an `Applicative` functor that can \"fail\" or be \"empty\"\nand a binary operation `&lt;|&gt;` that “collects values” or finds the “left-most success”.\n\nImportant instances include\n* `Option`, where `failure := none` and `&lt;|&gt;` returns the left-most `some`.\n* Parser combinators typically provide an `Applicative` instance for error-handling and\n  backtracking.\n\nError recovery and state can interact subtly. For example, the implementation of `Alternative` for `OptionT (StateT σ Id)` keeps modifications made to the state while recovering from failure, while `StateT σ (OptionT Id)` discards them.\n</code>",
 "2023":
 "<code>Seq.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `&lt;*&gt;` operator is overloaded using the function `Seq.seq`.\n\nWhile `&lt;$&gt;` from the class `Functor` allows an ordinary function to be mapped over its contents,\n`&lt;*&gt;` allows a function that's “inside” the functor to be applied. When thinking about `f` as\npossible side effects, this captures evaluation order: `seq` arranges for the effects that produce\nthe function to occur prior to those that produce the argument value.\n\nFor most applications, `Applicative` or `Monad` should be used rather than `Seq` itself.\n</code>",
 "2022":
 "<code>SeqRight.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `*&gt;` operator is overloaded using `seqRight`.\n\nWhen thinking about `f` as potential side effects, `*&gt;` evaluates first the left and then the right\nargument for their side effects, discarding the value of the left argument and returning the value\nof the right argument.\n\nFor most applications, `Applicative` or `Monad` should be used rather than `SeqLeft` itself.\n</code>",
 "2021":
 "<code>SeqLeft.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `&lt;*` operator is overloaded using `seqLeft`.\n\nWhen thinking about `f` as potential side effects, `&lt;*` evaluates first the left and then the right\nargument for their side effects, discarding the value of the right argument and returning the value\nof the left argument.\n\nFor most applications, `Applicative` or `Monad` should be used rather than `SeqLeft` itself.\n</code>",
 "2020":
 "<code>Bind.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `&gt;&gt;=` operator is overloaded via instances of `bind`.\n\n`Bind` is typically used via `Monad`, which extends it.\n</code>",
 "202": "<code>α.{u} : Type u</code>",
 "2019":
 "<code>Applicative.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">An [applicative functor](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=monads-and-do) is more powerful than a `Functor`, but\nless powerful than a `Monad`.\n\nApplicative functors capture sequencing of effects with the `&lt;*&gt;` operator, overloaded as `seq`, but\nnot data-dependent effects. The results of earlier computations cannot be used to control later\neffects.\n\nApplicative functors should satisfy four laws. Instances of `Applicative` are not required to prove\nthat they satisfy these laws, which are part of the `LawfulApplicative` class.\n</code>",
 "2018":
 "<code>Functor.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A functor in the sense used in functional programming, which means a function `f : Type u → Type v`\nhas a way of mapping a function over its contents. This `map` operator is written `&lt;$&gt;`, and\noverloaded via `Functor` instances.\n\nThis `map` function should respect identity and function composition. In other words, for all terms\n`v : f α`, it should be the case that:\n\n * `id &lt;$&gt; v = v`\n\n * For all functions `h : β → γ` and `g : α → β`, `(h ∘ g) &lt;$&gt; v = h &lt;$&gt; g &lt;$&gt; v`\n\nWhile all `Functor` instances should live up to these requirements, they are not required to _prove_\nthat they do. Proofs may be required or provided via the `LawfulFunctor` class.\n\nAssuming that instances are lawful, this definition corresponds to the category-theoretic notion of\n[functor](https://en.wikipedia.org/wiki/Functor) in the special case where the category is the\ncategory of types and functions between them.\n</code>",
 "2017": "<code>elem</code>",
 "2016":
 "<code>∀ [inst : Inhabited elem] (c : cont) (i : idx),\n  c[i]! =\n    match c[i]? with\n    | some e =&gt; e\n    | none =&gt; default</code>",
 "2015": "<code>Decidable (dom c i)</code>",
 "2014": "<code>cont</code>",
 "2013":
 "<code>∀ (c : cont) (i : idx) [inst : Decidable (dom c i)], c[i]? = if h : dom c i then some c[i] else none</code>",
 "2012":
 "<code>LawfulGetElem.mk.{u, v, w} {cont : Type u} {idx : Type v} {elem : outParam (Type w)}\n  {dom : outParam (cont → idx → Prop)} [ge : GetElem? cont idx elem dom]\n  (getElem?_def :\n    ∀ (c : cont) (i : idx) [inst : Decidable (dom c i)],\n      c[i]? = if h : dom c i then some c[i] else none := by\n    intros\n    try simp only [getElem?] &lt;;&gt; congr)\n  (getElem!_def :\n    ∀ [inst : Inhabited elem] (c : cont) (i : idx),\n      c[i]! =\n        match c[i]? with\n        | some e =&gt; e\n        | none =&gt; default := by\n    intros\n    simp only [getElem!, getElem?, outOfBounds_eq_default]) :\n  LawfulGetElem cont idx elem dom</code>",
 "2011": "<code>GetElem? cont idx elem dom</code>",
 "2010": "<code>outParam (cont → idx → Prop)</code>",
 "201": "<code>EvenOddList.{u} (α : Type u) : Bool → Type u</code>",
 "2009":
 "<code>GetElem?.getElem!.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)}\n  {valid : outParam (coll → idx → Prop)} [self : GetElem? coll idx elem valid] [Inhabited elem] (xs : coll) (i : idx) :\n  elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]!` gets the `i`'th element of the collection `arr`,\nif it is present, and otherwise panics at runtime and returns the `default` term\nfrom `Inhabited elem`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]!` in identifiers is `getElem!`.</code>",
 "2008": "<code>?m.75245</code>",
 "2007": "<code>?m.76220</code>",
 "2006": "<code>Inhabited elem</code>",
 "2005":
 "<code>[inst : Inhabited elem] → coll → idx → elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]!` gets the `i`'th element of the collection `arr`,\nif it is present, and otherwise panics at runtime and returns the `default` term\nfrom `Inhabited elem`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]!` in identifiers is `getElem!`.</code>",
 "2004": "<code>?m.72945</code>",
 "2003": "<code>?m.73093</code>",
 "2002":
 "<code>coll → idx → Option elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]?` gets the `i`'th element of the collection `arr`,\nif it is present (and wraps it in `some`), and otherwise returns `none`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]?` in identifiers is `getElem?`.</code>",
 "2001":
 "<code>GetElem?.mk.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)} {valid : outParam (coll → idx → Prop)}\n  [toGetElem : GetElem coll idx elem valid] (getElem? : coll → idx → Option elem)\n  (getElem! : [inst : Inhabited elem] → coll → idx → elem) : GetElem? coll idx elem valid</code>",
 "2000": "<code>Type ?u.72002</code>",
 "200": "<code>Yes.intro : Yes</code>",
 "20":
 "<code class=\"docstring\">In Lean, every concrete type other than the universes\nand every type constructor other than dependent arrows\nis an instance of a general family of type constructions known as inductive types.\nIt is remarkable that it is possible to construct a substantial edifice of mathematics\nbased on nothing more than the type universes, dependent arrow types, and inductive types;\neverything else follows from those.\nIntuitively, an inductive type is built up from a specified list of constructors.\nFor example, `List α` is the list of elements of type `α`, and is defined as follows:\n```\ninductive List (α : Type u) where\n| nil\n| cons (head : α) (tail : List α)\n```\nA list of elements of type `α` is either the empty list, `nil`,\nor an element `head : α` followed by a list `tail : List α`.\nSee [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)\nfor more information.\n</code>",
 "2": "<code>hello : IO Unit</code>",
 "1999": "<code>?m.66818 xs i</code>",
 "1998": "<code>?m.63469</code>",
 "1997": "<code>?m.62451</code>",
 "1996":
 "<code>GetElem.getElem.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)}\n  {valid : outParam (coll → idx → Prop)} [self : GetElem coll idx elem valid] (xs : coll) (i : idx) (h : valid xs i) :\n  elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.\n\n * The recommended spelling of `xs[i]'h` in identifiers is `getElem`.</code>",
 "1995": "<code>?m.47273</code>",
 "1994": "<code>?m.48432</code>",
 "1993":
 "<code>(xs : coll) → (i : idx) → valid xs i → elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.\n\n * The recommended spelling of `xs[i]'h` in identifiers is `getElem`.</code>",
 "1992":
 "<code>GetElem.mk.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)} {valid : outParam (coll → idx → Prop)}\n  (getElem : (xs : coll) → (i : idx) → valid xs i → elem) : GetElem coll idx elem valid</code>",
 "1991": "<code>i &lt; arr.size</code>",
 "1990": "<code>Type ?u.46271</code>",
 "199": "<code>Yes : Prop</code>",
 "1989":
 "<code class=\"docstring\">`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i &lt; arr.size` is in the context) and `simp +arith` and `omega`\n(for doing linear arithmetic in the index).\n</code>",
 "1988": "<code>?m.41087 xs i</code>",
 "1987":
 "<code class=\"docstring\">`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n</code>",
 "1986": "<code>idx</code>",
 "1985": "<code>coll</code>",
 "1984": "<code>?m.37738</code>",
 "1983": "<code>?m.36720</code>",
 "1982":
 "<code>GetElem?.{u, v, w} (coll : Type u) (idx : Type v) (elem : outParam (Type w)) (valid : outParam (coll → idx → Prop)) :\n  Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The classes `GetElem` and `GetElem?` implement lookup notation,\nspecifically `xs[i]`, `xs[i]?`, `xs[i]!`, and `xs[i]'p`.\n\nBoth classes are indexed by types `coll`, `idx`, and `elem` which are\nthe collection, the index, and the element types.\nA single collection may support lookups with multiple index\ntypes. The relation `valid` determines when the index is guaranteed to be\nvalid; lookups of valid indices are guaranteed not to fail.\n\nFor example, an instance for arrays looks like\n`GetElem (Array α) Nat α (fun xs i =&gt; i &lt; xs.size)`. In other words, given an\narray `xs` and a natural number `i`, `xs[i]` will return an `α` when `valid xs i`\nholds, which is true when `i` is less than the size of the array. `Array`\nadditionally supports indexing with `USize` instead of `Nat`.\nIn either case, because the bounds are checked at compile time,\nno runtime check is required.\n\nGiven `xs[i]` with `xs : coll` and `i : idx`, Lean looks for an instance of\n`GetElem coll idx elem valid` and uses this to infer the type of the return\nvalue `elem` and side condition `valid` required to ensure `xs[i]` yields\na valid value of type `elem`. The tactic `get_elem_tactic` is\ninvoked to prove validity automatically. The `xs[i]'p` notation uses the\nproof `p` to satisfy the validity condition.\nIf the proof `p` is long, it is often easier to place the\nproof in the context using `have`, because `get_elem_tactic` tries\n`assumption`.\n\n\nThe proof side-condition `valid xs i` is automatically dispatched by the\n`get_elem_tactic` tactic; this tactic can be extended by adding more clauses to\n`get_elem_tactic_trivial` using `macro_rules`.\n\n`xs[i]?` and `xs[i]!` do not impose a proof obligation; the former returns\nan `Option elem`, with `none` signalling that the value isn't present, and\nthe latter returns `elem` but panics if the value isn't there, returning\n`default : elem` based on the `Inhabited elem` instance.\nThese are provided by the `GetElem?` class, for which there is a default instance\ngenerated from a `GetElem` class as long as `valid xs i` is always decidable.\n\nImportant instances include:\n  * `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`: does array\n    indexing with no runtime bounds check and a proof side goal `i &lt; arr.size`.\n  * `l[i] : α` where `l : List α` and `i : Nat`: index into a list, with proof\n    side goal `i &lt; l.length`.\n\n</code>",
 "1981":
 "<code>GetElem.{u, v, w} (coll : Type u) (idx : Type v) (elem : outParam (Type w)) (valid : outParam (coll → idx → Prop)) :\n  Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The classes `GetElem` and `GetElem?` implement lookup notation,\nspecifically `xs[i]`, `xs[i]?`, `xs[i]!`, and `xs[i]'p`.\n\nBoth classes are indexed by types `coll`, `idx`, and `elem` which are\nthe collection, the index, and the element types.\nA single collection may support lookups with multiple index\ntypes. The relation `valid` determines when the index is guaranteed to be\nvalid; lookups of valid indices are guaranteed not to fail.\n\nFor example, an instance for arrays looks like\n`GetElem (Array α) Nat α (fun xs i =&gt; i &lt; xs.size)`. In other words, given an\narray `xs` and a natural number `i`, `xs[i]` will return an `α` when `valid xs i`\nholds, which is true when `i` is less than the size of the array. `Array`\nadditionally supports indexing with `USize` instead of `Nat`.\nIn either case, because the bounds are checked at compile time,\nno runtime check is required.\n\nGiven `xs[i]` with `xs : coll` and `i : idx`, Lean looks for an instance of\n`GetElem coll idx elem valid` and uses this to infer the type of the return\nvalue `elem` and side condition `valid` required to ensure `xs[i]` yields\na valid value of type `elem`. The tactic `get_elem_tactic` is\ninvoked to prove validity automatically. The `xs[i]'p` notation uses the\nproof `p` to satisfy the validity condition.\nIf the proof `p` is long, it is often easier to place the\nproof in the context using `have`, because `get_elem_tactic` tries\n`assumption`.\n\n\nThe proof side-condition `valid xs i` is automatically dispatched by the\n`get_elem_tactic` tactic; this tactic can be extended by adding more clauses to\n`get_elem_tactic_trivial` using `macro_rules`.\n\n`xs[i]?` and `xs[i]!` do not impose a proof obligation; the former returns\nan `Option elem`, with `none` signalling that the value isn't present, and\nthe latter returns `elem` but panics if the value isn't there, returning\n`default : elem` based on the `Inhabited elem` instance.\nThese are provided by the `GetElem?` class, for which there is a default instance\ngenerated from a `GetElem` class as long as `valid xs i` is always decidable.\n\nImportant instances include:\n  * `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`: does array\n    indexing with no runtime bounds check and a proof side goal `i &lt; arr.size`.\n  * `l[i] : α` where `l : List α` and `i : Nat`: index into a list, with proof\n    side goal `i &lt; l.length`.\n\n</code>",
 "1980": "<code>outParam (coll → idx → Prop)</code>",
 "198": "<code>One.one : One</code>",
 "1979": "<code>?m.26500</code>",
 "1978": "<code>?m.26499</code>",
 "1977":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a ++ b` is the result of concatenation of `a` and `b`. See `HAppend`. </code>",
 "1976":
 "<code>Append.mk.{u} {α : Type u} (append : α → α → α) : Append α</code>",
 "1975":
 "<code>HAppend.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous append.\nThis enables the notation `a ++ b : γ` where `a : α`, `b : β`.\n</code>",
 "1974": "<code>?m.25991</code>",
 "1973": "<code>?m.25990</code>",
 "1972":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `++` in identifiers is `append`.</code>",
 "1971":
 "<code>HAppend.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hAppend : α → β → γ) : HAppend α β γ</code>",
 "1970":
 "<code>Bool.xor : Bool → Bool → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean “exclusive or”. `xor x y` can be written `x ^^ y`.\n\n`x ^^ y` is `true` when precisely one of `x` or `y` is `true`. Unlike `and` and `or`, it does not\nhave short-circuiting behavior, because one argument's value never determines the final value. Also\nunlike `and` and `or`, there is no commonly-used corresponding propositional connective.\n\nExamples:\n * `false ^^ false = false`\n * `true ^^ false = true`\n * `false ^^ true = true`\n * `true ^^ true = false`\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^^` in identifiers is `xor`.</code>",
 "197": "<code>One : Type</code>",
 "1969": "<code>?m.25506</code>",
 "1968": "<code>?m.25505</code>",
 "1967":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^^^` in identifiers is `xor`.</code>",
 "1966":
 "<code>HXor.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hXor : α → β → γ) : HXor α β γ</code>",
 "1965":
 "<code>Bool.or (x y : Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean “or”, also known as disjunction. `or x y` can be written `x || y`.\n\nThe corresponding propositional connective is `Or : Prop → Prop → Prop`, written with the `∨`\noperator.\n\nThe Boolean `or` is a `@[macro_inline]` function in order to give it short-circuiting evaluation:\nif `x` is `true` then `y` is not evaluated at runtime.\n</code>",
 "1964": "<code>?m.25127</code>",
 "1963": "<code>?m.25126</code>",
 "1962":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `|||` in identifiers is `or`.</code>",
 "1961":
 "<code>HOr.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hOr : α → β → γ) : HOr α β γ</code>",
 "1960":
 "<code>Bool.and (x y : Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean “and”, also known as conjunction. `and x y` can be written `x && y`.\n\nThe corresponding propositional connective is `And : Prop → Prop → Prop`, written with the `∧`\noperator.\n\nThe Boolean `and` is a `@[macro_inline]` function in order to give it short-circuiting evaluation:\nif `x` is `false` then `y` is not evaluated at runtime.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&&` in identifiers is `and`.\n\n * The recommended spelling of `||` in identifiers is `or`.</code>",
 "196": "<code>No : Prop</code>",
 "1959": "<code>?m.24748</code>",
 "1958": "<code>?m.24747</code>",
 "1957":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&&&` in identifiers is `and`.</code>",
 "1956":
 "<code>HAnd.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hAnd : α → β → γ) : HAnd α β γ</code>",
 "1955":
 "<code>α → α</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "1954": "<code>Neg.mk.{u} {α : Type u} (neg : α → α) : Neg α</code>",
 "1953":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of `a &gt;&gt;&gt; b : α`. See `HShiftRight`. </code>",
 "1952":
 "<code>ShiftRight.mk.{u} {α : Type u} (shiftRight : α → α → α) : ShiftRight α</code>",
 "1951":
 "<code>HShiftRight.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a &gt;&gt;&gt; b : γ` where `a : α`, `b : β`. </code>",
 "1950": "<code>?m.23349</code>",
 "195": "<code>Vacant : Type</code>",
 "1949": "<code>?m.23293</code>",
 "1948":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &gt;&gt;&gt; b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;&gt;` in identifiers is `shiftRight`.</code>",
 "1947":
 "<code>HShiftRight.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hShiftRight : α → β → γ) : HShiftRight α β γ</code>",
 "1946":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of `a &lt;&lt;&lt; b : α`. See `HShiftLeft`. </code>",
 "1945":
 "<code>ShiftLeft.mk.{u} {α : Type u} (shiftLeft : α → α → α) : ShiftLeft α</code>",
 "1944":
 "<code>HShiftLeft.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a &lt;&lt;&lt; b : γ` where `a : α`, `b : β`. </code>",
 "1943": "<code>?m.22079</code>",
 "1942": "<code>?m.22017</code>",
 "1941":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a &lt;&lt;&lt; b` computes `a` shifted to the left by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat`, this is equivalent to `a * 2 ^ b`.\n* On `UInt8` and other fixed width unsigned types, this is the same but\n  truncated to the bit width. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;&lt;&lt;` in identifiers is `shiftLeft`.</code>",
 "1940":
 "<code>HShiftLeft.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hShiftLeft : α → β → γ) : HShiftLeft α β γ</code>",
 "194":
 "<code>inductive.autoPromoteIndices</code><span class=\"sep\"></span><code class=\"docstring\">Promote indices to parameters in inductive types whenever possible.</code>",
 "1939": "<code>?m.21744</code>",
 "1938": "<code>?m.21743</code>",
 "1937":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b` where `a` and `b` both have the same type. </code>",
 "1936":
 "<code>HomogeneousPow.mk.{u} {α : Type u} (pow : α → α → α) : HomogeneousPow α</code>",
 "1935": "<code>?m.21094</code>",
 "1934": "<code>?m.21093</code>",
 "1933": "<code>?m.20550</code>",
 "1932": "<code>?m.20549</code>",
 "1931":
 "<code>α → Nat → α</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ n` computes `a` to the power of `n` where `n : Nat`. See `Pow`. </code>",
 "1930":
 "<code>NatPow.mk.{u} {α : Type u} (pow : α → Nat → α) : NatPow α</code>",
 "193":
 "<code>Empty : Type</code><span class=\"sep\"></span><code class=\"docstring\">The empty type. It has no constructors.\n\nUse `Empty.elim` in contexts where a value of type `Empty` is in scope.\n</code>",
 "1929": "<code>?m.19924</code>",
 "1928":
 "<code>Pow.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HPow`: `a ^ b : α` where `a : α`, `b : β`.\n(The right argument is not the same as the left since we often want this even\nin the homogeneous case.)\n\nTypes can choose to subscribe to particular defaulting behavior by providing\nan instance to either `NatPow` or `HomogeneousPow`:\n- `NatPow` is for types whose exponents is preferentially a `Nat`.\n- `HomogeneousPow` is for types whose base and exponent are preferentially the same.\n</code>",
 "1927": "<code>?m.19240</code>",
 "1926": "<code>?m.19239</code>",
 "1925":
 "<code>α → β → α</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b`. See `HPow`. </code>",
 "1924":
 "<code>Pow.mk.{u, v} {α : Type u} {β : Type v} (pow : α → β → α) : Pow α β</code>",
 "1923":
 "<code>HomogeneousPow.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The completely homogeneous version of `Pow` where the exponent has the same type as the base.\nThe purpose of this class is that it provides a default `Pow` instance,\nwhich can be used to specialize the exponent to have the same type as the base's type during elaboration.\nThis is to say, a type should provide an instance for this class in case `x ^ y` should be elaborated\nwith both `x` and `y` having the same type.\n\nFor example, the `Float` type provides an instance of this class, which causes expressions\nsuch as `(2.2 ^ 2.2 : Float)` to elaborate. </code>",
 "1922":
 "<code>NatPow.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `Pow` where the exponent is a `Nat`.\nThe purpose of this class is that it provides a default `Pow` instance,\nwhich can be used to specialize the exponent to `Nat` during elaboration.\n\nFor example, if `x ^ 2` should preferentially elaborate with `2 : Nat` then `x`'s type should\nprovide an instance for this class. </code>",
 "1921":
 "<code>HPow.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous exponentiation.\nThis enables the notation `a ^ b : γ` where `a : α`, `b : β`.\n</code>",
 "1920": "<code>?m.18531</code>",
 "192":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">Extracts a wrapped value from a universe-lifted type. </code>",
 "1919": "<code>?m.18530</code>",
 "1918":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.</code>",
 "1917":
 "<code>HPow.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hPow : α → β → γ) : HPow α β γ</code>",
 "1916": "<code>?m.17789</code>",
 "1915": "<code>?m.17788</code>",
 "1914":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a % b` computes the remainder upon dividing `a` by `b`. See `HMod`. </code>",
 "1913": "<code>Mod.mk.{u} {α : Type u} (mod : α → α → α) : Mod α</code>",
 "1912":
 "<code>HMod.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous modulo / remainder.\nThis enables the notation `a % b : γ` where `a : α`, `b : β`.\n</code>",
 "1911": "<code>?m.16522</code>",
 "1910": "<code>?m.16521</code>",
 "191":
 "<code>ULift.up.{r, s} {α : Type s} (down : α) : ULift α</code><span class=\"sep\"></span><code class=\"docstring\">Wraps a value to increase its type's universe level. </code>",
 "1909":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int` it satisfies `a % b + b * (a / b) = a`,\n  and `a % 0` is defined to be `a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `%` in identifiers is `mod`.</code>",
 "1908":
 "<code>HMod.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hMod : α → β → γ) : HMod α β γ</code>",
 "1907": "<code>?m.16076</code>",
 "1906":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Divisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.</code>",
 "1905":
 "<code>Dvd.mk.{u_1} {α : Type u_1} (dvd : α → α → Prop) : Dvd α</code>",
 "1904": "<code>?m.15908</code>",
 "1903": "<code>?m.15907</code>",
 "1902":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a / b` computes the result of dividing `a` by `b`. See `HDiv`. </code>",
 "1901": "<code>Div.mk.{u} {α : Type u} (div : α → α → α) : Div α</code>",
 "1900":
 "<code>HDiv.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous division.\nThis enables the notation `a / b : γ` where `a : α`, `b : β`.\n</code>",
 "190": "<code>Type s</code>",
 "19":
 "<code>[Error pretty printing expression: unknown metavariable '?_uniq.57'. Falling back to raw printer.]\n?_uniq.57</code>",
 "1899":
 "<code>Int.tdiv : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer division using the T-rounding convention.\n\nIn [the T-rounding convention][t-rounding] (division with truncation), all rounding is towards zero.\nDivision by 0 is defined to be 0. In this convention, `Int.tmod a b + b * (Int.tdiv a b) = a`.\n\n[t-rounding]: https://dl.acm.org/doi/pdf/10.1145/128861.128862\n\nThis function is overridden by the compiler with an efficient implementation. This definition is the\nlogical model.\n\nExamples:\n* `(7 : Int).tdiv (0 : Int) = 0`\n* `(0 : Int).tdiv (7 : Int) = 0`\n* `(12 : Int).tdiv (6 : Int) = 2`\n* `(12 : Int).tdiv (-6 : Int) = -2`\n* `(-12 : Int).tdiv (6 : Int) = -2`\n* `(-12 : Int).tdiv (-6 : Int) = 2`\n* `(12 : Int).tdiv (7 : Int) = 1`\n* `(12 : Int).tdiv (-7 : Int) = -1`\n* `(-12 : Int).tdiv (7 : Int) = -1`\n* `(-12 : Int).tdiv (-7 : Int) = 1`\n</code>",
 "1898":
 "<code>Int.fdiv : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer division using the F-rounding convention.\n\nIn the F-rounding convention (flooring division), `Int.fdiv x y` satisfies `Int.fdiv x y = ⌊x / y⌋`\nand `Int.fmod` is the unique function satisfying `Int.fmod x y + (Int.fdiv x y) * y = x`.\n\nExamples:\n* `(7 : Int).fdiv (0 : Int) = 0`\n* `(0 : Int).fdiv (7 : Int) = 0`\n* `(12 : Int).fdiv (6 : Int) = 2`\n* `(12 : Int).fdiv (-6 : Int) = -2`\n* `(-12 : Int).fdiv (6 : Int) = -2`\n* `(-12 : Int).fdiv (-6 : Int) = 2`\n* `(12 : Int).fdiv (7 : Int) = 1`\n* `(12 : Int).fdiv (-7 : Int) = -2`\n* `(-12 : Int).fdiv (7 : Int) = -2`\n* `(-12 : Int).fdiv (-7 : Int) = 1`\n</code>",
 "1897":
 "<code>Int.ediv : Int → Int → Int</code><span class=\"sep\"></span><code class=\"docstring\">Integer division that uses the E-rounding convention. Usually accessed via the `/` operator.\nDivision by zero is defined to be zero, rather than an error.\n\nIn the E-rounding convention (Euclidean division), `Int.emod x y` satisfies `0 ≤ Int.emod x y &lt; Int.natAbs y`\nfor `y ≠ 0` and `Int.ediv` is the unique function satisfying `Int.emod x y + (Int.edivx y) * y = x`\nfor `y ≠ 0`.\n\nThis means that `Int.ediv x y` is `⌊x / y⌋` when `y &gt; 0` and `⌈x / y⌉` when `y &lt; 0`.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n* `(7 : Int) / (0 : Int) = 0`\n* `(0 : Int) / (7 : Int) = 0`\n* `(12 : Int) / (6 : Int) = 2`\n* `(12 : Int) / (-6 : Int) = -2`\n* `(-12 : Int) / (6 : Int) = -2`\n* `(-12 : Int) / (-6 : Int) = 2`\n* `(12 : Int) / (7 : Int) = 1`\n* `(12 : Int) / (-7 : Int) = -1`\n* `(-12 : Int) / (7 : Int) = -2`\n* `(-12 : Int) / (-7 : Int) = 2`\n</code>",
 "1896": "<code>?m.14943</code>",
 "1895": "<code>?m.14942</code>",
 "1894":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 ≤ a % b &lt; natAbs b` for `b ≠ 0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.tdiv` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/` in identifiers is `div`.</code>",
 "1893":
 "<code>HDiv.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hDiv : α → β → γ) : HDiv α β γ</code>",
 "1892": "<code>?m.14637</code>",
 "1891": "<code>?m.14636</code>",
 "1890":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`. See `HMul`. </code>",
 "189":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">Extracts a wrapped proof or value from a universe-lifted proposition or type. </code>",
 "1889": "<code>Mul.mk.{u} {α : Type u} (mul : α → α → α) : Mul α</code>",
 "1888":
 "<code>HMul.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous multiplication.\nThis enables the notation `a * b : γ` where `a : α`, `b : β`.\n</code>",
 "1887": "<code>?m.14313</code>",
 "1886": "<code>?m.14312</code>",
 "1885":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.</code>",
 "1884":
 "<code>HMul.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hMul : α → β → γ) : HMul α β γ</code>",
 "1883": "<code>?m.14007</code>",
 "1882": "<code>?m.14006</code>",
 "1881":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`. See `HSub`. </code>",
 "1880": "<code>Sub.mk.{u} {α : Type u} (sub : α → α → α) : Sub α</code>",
 "188":
 "<code>True : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "1879":
 "<code>HSub.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous subtraction.\nThis enables the notation `a - b : γ` where `a : α`, `b : β`.\n</code>",
 "1878": "<code>?m.13405</code>",
 "1877": "<code>?m.13404</code>",
 "1876":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).</code>",
 "1875":
 "<code>HSub.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hSub : α → β → γ) : HSub α β γ</code>",
 "1874": "<code>?m.13099</code>",
 "1873": "<code>?m.13098</code>",
 "1872":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "1871": "<code>?m.12775</code>",
 "1870": "<code>?m.12774</code>",
 "187":
 "<code class=\"docstring\">`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nThe target is not allowed to contain local variables or metavariables.\nIf there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,\nor you can use the `+revert` option, described below.\n\nOptions:\n- `decide +revert` begins by reverting local variables that the target depends on,\n  after cleaning up the local context of irrelevant variables.\n  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,\n  or if it is a proposition that refers to a relevant variable.\n- `decide +kernel` uses kernel for reduction instead of the elaborator.\n  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,\n  and (2) it reduces the `Decidable` instance only once instead of twice.\n- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,\n  admitting the result via the `Lean.ofReduceBool` axiom.\n  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size\n  of the trusted code base.\n  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.\n  Like with `+kernel`, the `Decidable` instance is evaluated only once.\n\nLimitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,\n`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.\nReduction can also get stuck on `Decidable` instances with `Eq.rec` terms.\nThese can appear in instances defined using tactics (such as `rw` and `simp`).\nTo avoid this, create such instances using definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n</code>",
 "1869":
 "<code>α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.</code>",
 "1868":
 "<code>HAdd.mk.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} (hAdd : α → β → γ) : HAdd α β γ</code>",
 "1867": "<code>outParam (Type w)</code>",
 "1866":
 "<code>n ≠ 0</code><span class=\"sep\"></span><code class=\"docstring\">The proposition that `n` is not zero. </code>",
 "1865":
 "<code>NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n ≠ 0) : NeZero n</code>",
 "1864": "<code>R</code>",
 "1863":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The zero element of the type. </code>",
 "1862": "<code>Zero.mk.{u} {α : Type u} (zero : α) : Zero α</code>",
 "1861": "<code>α = β</code>",
 "1860": "<code>Subsingleton α</code>",
 "186":
 "<code class=\"docstring\">`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) =&gt; `(tactic| simp)\n```\n</code>",
 "1859":
 "<code>∀ (a b : α), a = b</code><span class=\"sep\"></span><code class=\"docstring\">Any two elements of a subsingleton are equal. </code>",
 "1858":
 "<code>Subsingleton.intro.{u} {α : Sort u} (allEq : ∀ (a b : α), a = b) : Subsingleton α</code><span class=\"sep\"></span><code class=\"docstring\">Prove that `α` is a subsingleton by showing that any two elements are equal. </code>",
 "1857":
 "<code>Classical.choice.{u} {α : Sort u} : Nonempty α → α</code><span class=\"sep\"></span><code class=\"docstring\">**The axiom of choice**. `Nonempty α` is a proof that `α` has an element,\nbut the element itself is erased. The axiom `choice` supplies a particular\nelement of `α` given only this proof.\n\nThe textbook axiom of choice normally makes a family of choices all at once,\nbut that is implied from this formulation, because if `α : ι → Type` is a\nfamily of types and `h : ∀ i, Nonempty (α i)` is a proof that they are all\nnonempty, then `fun i =&gt; Classical.choice (h i) : ∀ i, α i` is a family of\nchosen elements. This is actually a bit stronger than the ZFC choice axiom;\nthis is sometimes called \"[global choice](https://en.wikipedia.org/wiki/Axiom_of_global_choice)\".\n\nIn Lean, we use the axiom of choice to derive the law of excluded middle\n(see `Classical.em`), so it will often show up in axiom listings where you\nmay not expect. You can use `#print axioms my_thm` to find out if a given\ntheorem depends on this or other axioms.\n\nThis axiom can be used to construct \"data\", but obviously there is no algorithm\nto compute it, so Lean will require you to mark any definition that would\ninvolve executing `Classical.choice` or other axioms as `noncomputable`, and\nwill not produce any executable code for such definitions.\n</code>",
 "1856":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. </code>",
 "1855":
 "<code>Inhabited.mk.{u} {α : Sort u} (default : α) : Inhabited α</code>",
 "1854": "<code>¬p → q</code>",
 "1853": "<code>p → q</code>",
 "1852":
 "<code>Decidable.decide (p : Prop) [h : Decidable p] : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Converts a decidable proposition into a `Bool`.\n\nIf `p : Prop` is decidable, then `decide p : Bool` is the Boolean value\nthat is `true` if `p` is true and `false` if `p` is false.\n</code>",
 "1851": "<code>Decidable p</code>",
 "1850": "<code>?m.10102</code>",
 "185":
 "<code>PLift.up.{u} {α : Sort u} (down : α) : PLift α</code><span class=\"sep\"></span><code class=\"docstring\">Wraps a proof or value to increase its type's universe level by 1. </code>",
 "1849": "<code>α → β → Prop</code>",
 "1848": "<code>p</code>",
 "1847": "<code>¬p</code>",
 "1846":
 "<code class=\"docstring\">Theorems tagged with the `simp` attribute are used by the simplifier\n(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.\nWe call theorems tagged with the `simp` attribute \"simp theorems\" or \"simp lemmas\".\nLean maintains a database/index containing all active simp theorems.\nHere is an example of a simp theorem.\n```lean\n@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl\n```\nThis simp theorem instructs the simplifier to replace instances of the term\n`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).\nThe simplifier applies simp theorems in one direction only:\nif `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,\nbut it doesn't replace `B`s with `A`s. Hence a simp theorem should have the\nproperty that its right-hand side is \"simpler\" than its left-hand side.\nIn particular, `=` and `↔` should not be viewed as symmetric operators in this situation.\nThe following would be a terrible simp theorem (if it were even allowed):\n```lean\n@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...\n```\nReplacing 1 with a * a⁻¹ is not a sensible default direction to travel.\nEven worse would be a theorem that causes expressions to grow without bound,\ncausing simp to loop forever.\n\nBy default the simplifier applies `simp` theorems to an expression `e`\nafter its sub-expressions have been simplified.\nWe say it performs a bottom-up simplification.\nYou can instruct the simplifier to apply a theorem before its sub-expressions\nhave been simplified by using the modifier `↓`. Here is an example\n```lean\n@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=\n```\n\nYou can instruct the simplifier to rewrite the lemma from right-to-left:\n```lean\nattribute @[simp ←] and_assoc\n```\n\nWhen multiple simp theorems are applicable, the simplifier uses the one with highest priority.\nThe equational theorems of function are applied at very low priority (100 and below).\nIf there are several with the same priority, it is uses the \"most recent one\". Example:\n```lean\n@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl\n@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=\n  propext &lt;| Iff.intro (fun _ =&gt; trivial) (fun _ =&gt; Or.inr trivial)\n@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by\n  cases d &lt;;&gt; rfl\n```\n</code>",
 "1845": "<code>?m.10026</code>",
 "1844":
 "<code>DecidableRel.{u, v} {α : Sort u} {β : Sort v} (r : α → β → Prop) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">A decidable relation.\n\nA relation is decidable if the corresponding proposition is `Decidable` for all possible arguments.\n</code>",
 "1843":
 "<code>Max.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">An overloaded operation to find the greater of two values of type `α`.\n</code>",
 "1842":
 "<code>Min.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">An overloaded operation to find the lesser of two values of type `α`.\n</code>",
 "1841":
 "<code>maxOfLe.{u_1} {α : Type u_1} [LE α] [DecidableRel LE.le] : Max α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a `Max` instance from a decidable `≤` operation.\n</code>",
 "1840":
 "<code>minOfLe.{u_1} {α : Type u_1} [LE α] [DecidableRel LE.le] : Min α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a `Min` instance from a decidable `≤` operation.\n</code>",
 "184":
 "<code>ULift.{r, s} (α : Type s) : Type (max s r)</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a type to a higher universe level.\n\n`ULift α` wraps a value of type `α`. Instead of occupying the same universe as `α`, which would be\nthe minimal level, it takes a further level parameter and occupies their minimum. The resulting type\nmay occupy any universe that's at least as large as that of `α`.\n\nThe resulting universe of the lifting operator is the first parameter, and may be written explicitly\nwhile allowing `α`'s level to be inferred.\n\nThe related type `PLift` can be used to lift a proposition or type by one level.\n\nExamples:\n * `(Nat : Type 0)`\n * `(ULift Nat : Type 0)`\n * `(ULift Nat : Type 1)`\n * `(ULift Nat : Type 5)`\n * `(ULift.{7} (PUnit : Type 3) : Type 7)`\n</code>",
 "1839":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the greater of its two arguments. </code>",
 "1838": "<code>Max.mk.{u} {α : Type u} (max : α → α → α) : Max α</code>",
 "1837":
 "<code>α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the lesser of its two arguments. </code>",
 "1836": "<code>Min.mk.{u} {α : Type u} (min : α → α → α) : Min α</code>",
 "1835": "<code>?m.9851</code>",
 "1834": "<code>?m.9830</code>",
 "1833":
 "<code>leOfOrd.{u_1} {α : Type u_1} [Ord α] : LE α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs an `LT` instance from an `Ord` instance that asserts that the result of `compare`\nsatisfies `Ordering.isLE`.\n</code>",
 "1832":
 "<code>ltOfOrd.{u_1} {α : Type u_1} [Ord α] : LT α</code><span class=\"sep\"></span><code class=\"docstring\">Constructs an `LT` instance from an `Ord` instance that asserts that the result of `compare` is\n`Ordering.lt`.\n</code>",
 "1831": "<code>sweetPotato : Vegetable</code>",
 "1830": "<code>Fin 5</code>",
 "183":
 "<code>PLift.{u} (α : Sort u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a proposition or type to a higher universe level.\n\n`PLift α` wraps a proof or value of type `α`. The resulting type is in the next largest universe\nafter that of `α`. In particular, propositions become data.\n\nThe related type `ULift` can be used to lift a non-proposition type by any number of levels.\n\nExamples:\n * `(False : Prop)`\n * `(PLift False : Type)`\n * `([.up (by trivial), .up (by simp), .up (by decide)] : List (PLift True))`\n * `(Nat : Type 0)`\n * `(PLift Nat : Type 1)`\n</code>",
 "1829": "<code>Fin 5</code>",
 "1828":
 "<code><span class=\"literal string\">\"green\"</span> : String</code>",
 "1827": "<code>broccoli : Vegetable</code>",
 "1826": "<code>Vegetable.size (self : Vegetable) : Fin 5</code>",
 "1825": "<code>Vegetable.color (self : Vegetable) : String</code>",
 "1824": "<code>Vegetable : Type</code>",
 "1823":
 "<code>Ordering.isLE : Ordering → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the ordering is `lt` or `eq`.\n</code>",
 "1822":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≤` in identifiers is `le`.\n\n * The recommended spelling of `&lt;=` in identifiers is `le` (prefer `≤` over `&lt;=`).</code>",
 "1821": "<code>LE.mk.{u} {α : Type u} (le : α → α → Prop) : LE α</code>",
 "1820":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-than relation: `x &lt; y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;` in identifiers is `lt`.</code>",
 "182": "<code>L : Type 1</code>",
 "1819": "<code>LT.mk.{u} {α : Type u} (lt : α → α → Prop) : LT α</code>",
 "1818": "<code>α → β → Ordering</code>",
 "1817":
 "<code>compareOfLessAndEq.{u_1} {α : Type u_1} (x y : α) [LT α] [Decidable (x &lt; y)] [DecidableEq α] : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Uses decidable less-than and equality relations to find an `Ordering`.\n\nIn particular, if `x &lt; y` then the result is `Ordering.lt`. If `x = y` then the result is\n`Ordering.eq`. Otherwise, it is `Ordering.gt`.\n\n`compareOfLessAndBEq` uses `BEq` instead of `DecidableEq`.\n</code>",
 "1816":
 "<code>compareOfLessAndBEq.{u_1} {α : Type u_1} (x y : α) [LT α] [Decidable (x &lt; y)] [BEq α] : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Uses a decidable less-than relation and Boolean equality to find an `Ordering`.\n\nIn particular, if `x &lt; y` then the result is `Ordering.lt`. If `x == y` then the result is\n`Ordering.eq`. Otherwise, it is `Ordering.gt`.\n\n`compareOfLessAndEq` uses `DecidableEq` instead of `BEq`.\n</code>",
 "1815": "<code>Person</code>",
 "1814":
 "<code>Person → Person → Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compare two elements in `α` using the comparator contained in an `[Ord α]` instance. </code>",
 "1813": "<code>Person.age (self : Person) : Nat</code>",
 "1812": "<code>Person.name (self : Person) : String</code>",
 "1811": "<code>Person : Type</code>",
 "1810":
 "<code>compareLex.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} (cmp₁ cmp₂ : α → β → Ordering) (a : α) (b : β) : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compares `a` and `b` lexicographically by `cmp₁` and `cmp₂`.\n\n`a` and `b` are first compared by `cmp₁`. If this returns `Ordering.eq`, `a` and `b` are compared\nby `cmp₂` to break the tie.\n\nTo lexicographically combine two `Ordering`s, use `Ordering.then`.\n</code>",
 "181": "<code>L.{u_1} : Type u_1</code>",
 "1809":
 "<code>Ordering.then (a b : Ordering) : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">If `a` and `b` are `Ordering`, then `a.then b` returns `a` unless it is `.eq`, in which case it\nreturns `b`. Additionally, it has “short-circuiting” behavior similar to boolean `&&`: if `a` is not\n`.eq` then the expression for `b` is not evaluated.\n\nThis is a useful primitive for constructing lexicographic comparator functions. The `deriving Ord`\nsyntax on a structure uses the `Ord` instance to compare each field in order, combining the results\nequivalently to `Ordering.then`.\n\nUse `compareLex` to lexicographically combine two comparison functions.\n\nExamples:\n```lean example\nstructure Person where\n  name : String\n  age : Nat\n\n-- Sort people first by name (in ascending order), and people with the same name by age (in\n-- descending order)\ninstance : Ord Person where\n  compare a b := (compare a.name b.name).then (compare b.age a.age)\n```\n\n```lean example\n#eval Ord.compare (⟨\"Gert\", 33⟩ : Person) ⟨\"Dana\", 50⟩\n```\n```output\nOrdering.gt\n```\n\n```lean example\n#eval Ord.compare (⟨\"Gert\", 33⟩ : Person) ⟨\"Gert\", 50⟩\n```\n```output\nOrdering.gt\n```\n\n```lean example\n#eval Ord.compare (⟨\"Gert\", 33⟩ : Person) ⟨\"Gert\", 20⟩\n```\n```output\nOrdering.lt\n```\n</code>",
 "1808": "<code>Ordering</code>",
 "1807":
 "<code>Ordering.swap : Ordering → Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Swaps less-than and greater-than ordering results.\n\nExamples:\n* `Ordering.lt.swap = Ordering.gt`\n* `Ordering.eq.swap = Ordering.eq`\n* `Ordering.gt.swap = Ordering.lt`\n</code>",
 "1806":
 "<code>Ordering.eq : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Equal. </code>",
 "1805":
 "<code>Max.max.{u} {α : Type u} [self : Max α] : α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the greater of its two arguments. </code>",
 "1804":
 "<code>List.foldl.{u, v} {α : Type u} {β : Type v} (f : α → β → α) (init : α) : List β → α</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a list from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in order, using `f`.\n\nExamples:\n * `[a, b, c].foldl f z  = f (f (f z a) b) c`\n * `[1, 2, 3].foldl (· ++ toString ·) \"\" = \"123\"`\n * `[1, 2, 3].foldl (s!\"({·} {·})\") \"\" = \"((( 1) 2) 3)\"`\n</code>",
 "1803":
 "<code>Ordering.gt : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Greater than. </code>",
 "1802":
 "<code><span class=\"literal string\">\"banana\"</span> : String</code>",
 "1801":
 "<code><span class=\"literal string\">\"apple\"</span> : String</code>",
 "1800":
 "<code>String.length : String → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the length of a string in Unicode code points.\n\nExamples:\n* `\"\".length = 0`\n* `\"abc\".length = 3`\n* `\"L∃∀N\".length = 4`\n</code>",
 "180": "<code>L.{u} : Type (u + 1)</code>",
 "18":
 "<code>[Error pretty printing expression: unknown metavariable '?_uniq.48'. Falling back to raw printer.]\n?_uniq.48</code>",
 "1799":
 "<code>compareOn.{u_1, u_2} {β : Type u_1} {α : Sort u_2} [ord : Ord β] (f : α → β) (x y : α) : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compares two values by comparing the results of applying a function.\n\nIn particular, `x` is compared to `y` by comparing `f x` and `f y`.\n\nExamples:\n* `compareOn (·.length) \"apple\" \"banana\" = .lt`\n* `compareOn (· % 3) 5 6 = .gt`\n* `compareOn (·.foldl max 0) [1, 2, 3] [3, 2, 1] = .eq`\n</code>",
 "1798": "<code>Ord β</code>",
 "1797":
 "<code>α → α → Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compare two elements in `α` using the comparator contained in an `[Ord α]` instance. </code>",
 "1796":
 "<code>Ord.mk.{u} {α : Type u} (compare : α → α → Ordering) : Ord α</code>",
 "1795":
 "<code>LE.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`LE α` is the typeclass which supports the notation `x ≤ y` where `x y : α`.</code>",
 "1794":
 "<code>LT.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`LT α` is the typeclass which supports the notation `x &lt; y` where `x y : α`.</code>",
 "1793":
 "<code>Ordering : Type</code><span class=\"sep\"></span><code class=\"docstring\">The result of a comparison according to a total order.\n\nThe relationship between the compared items may be:\n* `Ordering.lt`: less than\n* `Ordering.eq`: equal\n* `Ordering.gt`: greater than\n</code>",
 "1792":
 "<code>LawfulHashable.{u} (α : Type u) [BEq α] [Hashable α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">The `BEq α` and `Hashable α` instances on `α` are compatible. This means that that `a == b` implies\n`hash a = hash b`.\n\nThis is automatic if the `BEq` instance is lawful.\n</code>",
 "1791":
 "<code>Hashable.hash.{u} {α : Sort u} [self : Hashable α] : α → UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Hashes a value into a `UInt64`. </code>",
 "1790":
 "<code>∀ (a b : α), (a == b) = true → hash a = hash b</code><span class=\"sep\"></span><code class=\"docstring\">If `a == b`, then `hash a = hash b`. </code>",
 "179": "<code>id₃.{u} (α : Type u) (a : α) : α</code>",
 "1789":
 "<code>LawfulHashable.mk.{u} {α : Type u} [BEq α] [Hashable α] (hash_eq : ∀ (a b : α), (a == b) = true → hash a = hash b) :\n  LawfulHashable α</code>",
 "1788":
 "<code>∀ {a : α}, (a == a) = true</code><span class=\"sep\"></span><code class=\"docstring\">`==` is reflexive, that is, `(a == a) = true`. </code>",
 "1787": "<code>?m.3847</code>",
 "1786":
 "<code>BEq.beq.{u} {α : Type u} [self : BEq α] : α → α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`.</code>",
 "1785":
 "<code>∀ {a b : α}, (a == b) = true → a = b</code><span class=\"sep\"></span><code class=\"docstring\">If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. </code>",
 "1784":
 "<code>LawfulBEq.mk.{u} {α : Type u} [BEq α] (eq_of_beq : ∀ {a b : α}, (a == b) = true → a = b)\n  (rfl : ∀ {a : α}, (a == a) = true) : LawfulBEq α</code>",
 "1783": "<code>?m.2614</code>",
 "1782":
 "<code>α → UInt64</code><span class=\"sep\"></span><code class=\"docstring\">Hashes a value into a `UInt64`. </code>",
 "1781":
 "<code>Hashable.mk.{u} {α : Sort u} (hash : α → UInt64) : Hashable α</code>",
 "1780": "<code>α → α → Bool</code>",
 "178":
 "<code class=\"docstring\">Declares one or more universe variables.\n\n`universe u v`\n\n`Prop`, `Type`, `Type u` and `Sort u` are types that classify other types, also known as\n*universes*. In `Type u` and `Sort u`, the variable `u` stands for the universe's *level*, and a\nuniverse at level `u` can only classify universes that are at levels lower than `u`. For more\ndetails on type universes, please refer to [the relevant chapter of Theorem Proving in Lean][tpil\nuniverses].\n\nJust as type arguments allow polymorphic definitions to be used at many different types, universe\nparameters, represented by universe variables, allow a definition to be used at any required level.\nWhile Lean mostly handles universe levels automatically, declaring them explicitly can provide more\ncontrol when writing signatures. The `universe` keyword allows the declared universe variables to be\nused in a collection of definitions, and Lean will ensure that these definitions use them\nconsistently.\n\n[tpil universes]: https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects\n(Type universes on Theorem Proving in Lean)\n\n```lean\n/- Explicit type-universe parameter. -/\ndef id₁.{u} (α : Type u) (a : α) := a\n\n/- Implicit type-universe parameter, equivalent to `id₁`.\n  Requires option `autoImplicit true`, which is the default. -/\ndef id₂ (α : Type u) (a : α) := a\n\n/- Explicit standalone universe variable declaration, equivalent to `id₁` and `id₂`. -/\nuniverse u\ndef id₃ (α : Type u) (a : α) := a\n```\n\nOn a more technical note, using a universe variable only in the right-hand side of a definition\ncauses an error if the universe has not been declared previously.\n\n```lean\ndef L₁.{u} := List (Type u)\n\n-- def L₂ := List (Type u) -- error: `unknown universe level 'u'`\n\nuniverse u\ndef L₃ := List (Type u)\n```\n\n## Examples\n\n```lean\nuniverse u v w\n\nstructure Pair (α : Type u) (β : Type v) : Type (max u v) where\n  a : α\n  b : β\n\n#check Pair.{v, w}\n-- Pair : Type v → Type w → Type (max v w)\n```\n</code>",
 "1779":
 "<code>α → α → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`.</code>",
 "1778":
 "<code>LawfulBEq.{u} (α : Type u) [BEq α] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A Boolean equality test coincides with propositional equality.\n\nIn other words:\n* `a == b` implies `a = b`.\n* `a == a` is true.\n</code>",
 "1777": "<code>?m.859</code>",
 "1776":
 "<code>Lean.Elab.Command.elabCommand (stx : Syntax) : CommandElabM Unit</code>",
 "1775":
 "<code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code>",
 "1774": "<code>TSyntax `command</code>",
 "1773":
 "<code>Lean.Parser.Term.matchAltExpr : Parser</code><span class=\"sep\"></span><code class=\"docstring\">Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... =&gt; $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). </code>",
 "1772":
 "<code>Lean.Syntax.mkNumLit (val : String) (info : SourceInfo := SourceInfo.none) : NumLit</code>",
 "1771": "<code>NumLit</code>",
 "1770": "<code>Lean.mkIdent (val : Name) : Ident</code>",
 "177": "<code>List sorry</code>",
 "1769":
 "<code>Lean.InductiveVal.ctors (self : InductiveVal) : List Name</code><span class=\"sep\"></span><code class=\"docstring\">List of the names of the constructors for this inductive datatype. </code>",
 "1768": "<code>Array (TSyntax `Lean.Parser.Term.matchAltExpr)</code>",
 "1767":
 "<code>Lean.Parser.Term.matchAlt (rhsParser : Parser := termParser) : Parser</code>",
 "1766":
 "<code>Lean.TSyntax (ks : SyntaxNodeKinds) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Typed syntax, which tracks the potential kinds of the `Syntax` it contains.\n\nWhile syntax quotations produce or expect `TSyntax` values of the correct kinds, this is not\notherwise enforced; it can easily be circumvented by direct use of the constructor.\n</code>",
 "1765": "<code>Array (TSyntax `Lean.Parser.Term.matchAlt)</code>",
 "1764":
 "<code>Lean.Environment.find? (env : Environment) (n : Name) (skipRealize : Bool := false) : Option ConstantInfo</code><span class=\"sep\"></span><code class=\"docstring\">Like `findAsync?`, but blocks until the constant's info is fully available.  </code>",
 "1763": "<code>InductiveVal</code>",
 "1762":
 "<code>Lean.ConstantInfo.inductInfo (val : InductiveVal) : ConstantInfo</code>",
 "1761":
 "<code>Lean.MonadEnv.getEnv {m : Type → Type} [self : MonadEnv m] : m Environment</code>",
 "1760": "<code>Environment</code>",
 "176": "<code>sorry</code>",
 "1759": "<code>declNames.size = 1</code>",
 "1758": "<code>Array Name</code>",
 "1757":
 "<code>deriveIsEnum (declNames : Array Name) : CommandElabM Bool</code>",
 "1756":
 "<code>∀ (x : Bool),\n  (fun x =&gt;\n        match x with\n        | 0 =&gt; false\n        | 1 =&gt; true)\n      ((fun x =&gt;\n          match x with\n          | false =&gt; 0\n          | true =&gt; 1)\n        x) =\n    x</code>",
 "1755":
 "<code>∀ (x : Fin 2),\n  (fun x =&gt;\n        match x with\n        | false =&gt; 0\n        | true =&gt; 1)\n      ((fun x =&gt;\n          match x with\n          | 0 =&gt; false\n          | 1 =&gt; true)\n        x) =\n    x</code>",
 "1754": "<code>Fin 2 → Bool</code>",
 "1753": "<code>Fin 2</code>",
 "1752": "<code>Bool → Fin 2</code>",
 "1751":
 "<code>IsEnum.from_to_id {α : Type} [self : IsEnum α] (x : α) : IsEnum.fromIdx (IsEnum.toIdx x) = x</code>",
 "1750": "<code>Fin size → α</code>",
 "175":
 "<code>map.{u_1, u_2, u_3, u_4, u_5} {α : sorry} {β : sorry} (f : sorry) : List sorry → List sorry</code>",
 "1749": "<code>α → Fin size</code>",
 "1748": "<code>Fin size</code>",
 "1747":
 "<code>IsEnum.to_from_id {α : Type} [self : IsEnum α] (i : Fin (IsEnum.size α)) : IsEnum.toIdx (IsEnum.fromIdx i) = i</code>",
 "1746":
 "<code>IsEnum.fromIdx {α : Type} [self : IsEnum α] : Fin (IsEnum.size α) → α</code>",
 "1745":
 "<code>IsEnum.toIdx {α : Type} [self : IsEnum α] : α → Fin (IsEnum.size α)</code>",
 "1744": "<code>IsEnum.size (α : Type) [self : IsEnum α] : Nat</code>",
 "1743": "<code>IsEnum (α : Type) : Type</code>",
 "1742": "<code>Lean.Elab.DerivingHandler : Type</code>",
 "1741": "<code>DerivingHandler</code>",
 "1740":
 "<code>Hashable.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">Types that can be hashed into a `UInt64`. </code>",
 "174":
 "<code>autoImplicit</code><span class=\"sep\"></span><code class=\"docstring\">Unbound local variables in declaration headers become implicit arguments. In \"relaxed\" mode (default), any atomic identifier is eligible, otherwise only single character followed by numeric digits are eligible. For example, `def f (x : Vector α n) : Vector α n :=` automatically introduces the implicit variables {α n}.</code>",
 "1739":
 "<code>Lean.Elab.registerDerivingHandler (className : Name) (handler : DerivingHandler) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">A `DerivingHandler` is called on the fully qualified names of all types it is running for\nas well as the syntax of a `with` argument, if present.\n\nFor example, `deriving instance Foo with fooArgs for Bar, Baz` invokes\n``fooHandler #[`Bar, `Baz] `(fooArgs)``. </code>",
 "1738":
 "<code>backward.synthInstance.canonInstances</code><span class=\"sep\"></span><code class=\"docstring\">use optimization that relies on 'morally canonical' instances during type class resolution</code>",
 "1737":
 "<code>OneSmaller.shrink {α : Type} {β : semiOutParam Type} [self : OneSmaller α β] (x : α) : x ≠ OneSmaller.biggest β → β</code>",
 "1736":
 "<code>OneSmaller.biggest {α : Type} (β : semiOutParam Type) [self : OneSmaller α β] : α</code>",
 "1735": "<code>semiOutParam Type</code>",
 "1734": "<code>OneSmaller (α : Type) (β : semiOutParam Type) : Type</code>",
 "1733": "<code>Type ?u.2251</code>",
 "1732": "<code>(x : Bool) → x ≠ true → Unit</code>",
 "1731": "<code>(x : Option Bool) → x ≠ some true → Option Unit</code>",
 "1730": "<code>Option Bool</code>",
 "173": "<code>{α : Type u} → {β : Type v} → (α → β) → List α → List β</code>",
 "1729": "<code>(x : Option α) → x ≠ none → α</code>",
 "1728": "<code>Option α</code>",
 "1727":
 "<code>OneSmaller.shrink {α : Type} {β : outParam Type} [self : OneSmaller α β] (x : α) : x ≠ OneSmaller.biggest → β</code>",
 "1726":
 "<code>OneSmaller.biggest {α : Type} {β : outParam Type} [self : OneSmaller α β] : α</code>",
 "1725": "<code>OneSmaller (α : Type) (β : outParam Type) : Type</code>",
 "1724":
 "<code>Serialize.ser {input : Type} {output : outParam Type} [self : Serialize input output] : input → output</code>",
 "1723": "<code>outParam Type</code>",
 "1722":
 "<code>Serialize (input : Type) (output : outParam Type) : Type</code>",
 "1721": "<code>α × β → γ</code>",
 "1720":
 "<code>Append.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAppend`: `a ++ b : α` where `a b : α`. </code>",
 "172": "<code>Type v</code>",
 "1719": "<code>Nat → String</code>",
 "1718":
 "<code class=\"docstring\">Adds names from other namespaces to the current namespace.\n\nThe command `export Some.Namespace (name₁ name₂)` makes `name₁` and `name₂`:\n\n- visible in the current namespace without prefix `Some.Namespace`, like `open`, and\n- visible from outside the current namespace `N` as `N.name₁` and `N.name₂`.\n\n## Examples\n\n```lean\nnamespace Morning.Sky\n  def star := \"venus\"\nend Morning.Sky\n\nnamespace Evening.Sky\n  export Morning.Sky (star)\n  -- `star` is now in scope\n  #check star\nend Evening.Sky\n\n-- `star` is visible in `Evening.Sky`\n#check Evening.Sky.star\n```\n</code>",
 "1717":
 "<code>Serialize.ser {input output : Type} [self : Serialize input output] : input → output</code>",
 "1716": "<code>Serialize (input output : Type) : Type</code>",
 "1715": "<code>?m.492</code>",
 "1714":
 "<code>pp.explicit</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display implicit arguments</code>",
 "1713":
 "<code>Sum.inl.{u, v} {α : Type u} {β : Type v} (val : α) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Left injection into the sum type `α ⊕ β`. </code>",
 "1712":
 "<code>Nonempty.intro.{u} {α : Sort u} (val : α) : Nonempty α</code><span class=\"sep\"></span><code class=\"docstring\">If `val : α`, then `α` is nonempty. </code>",
 "1711": "<code>Nonempty α</code>",
 "1710":
 "<code>aNonemptySumInstance (α : Type) {β : Type} [inst : Nonempty α] : Nonempty (α ⊕ β)</code>",
 "171":
 "<code>map.{u, v} {α : Type u} {β : Type v} (f : α → β) : List α → List β</code>",
 "1709":
 "<code>NatPair → NatPair → NatPair</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "1708": "<code>NatPair.mk (x y : Nat) : NatPair</code>",
 "1707": "<code>Add.mk.{u} {α : Type u} (add : α → α → α) : Add α</code>",
 "1706": "<code>NatPair</code>",
 "1705": "<code>NatPair.y (self : NatPair) : Nat</code>",
 "1704": "<code>NatPair.x (self : NatPair) : Nat</code>",
 "1703": "<code>NatPair : Type</code>",
 "1702": "<code>addPairs (p1 p2 : NatPair) : NatPair</code>",
 "1701":
 "<code>synthInstance.maxSize</code><span class=\"sep\"></span><code class=\"docstring\">maximum number of instances used to construct a solution in the type class instance synthesis procedure</code>",
 "1700": "<code>foo : Inhabited (Nat × Nat)</code>",
 "170": "<code>m α</code>",
 "17":
 "<code>[Error pretty printing expression: unknown metavariable '?_uniq.47'. Falling back to raw printer.]\n?_uniq.47</code>",
 "1699": "<code>Even</code>",
 "1698":
 "<code>ofNatEvenPlusTwo {n : Nat} [OfNat Even n] : OfNat Even (n + 2)</code>",
 "1697": "<code>Even.mk (half : Nat) : Even</code>",
 "1696":
 "<code>Even</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1695": "<code>ofNatEven0 : OfNat Even 0</code>",
 "1694": "<code>Even.half (self : Even) : Nat</code>",
 "1693": "<code class=\"docstring\">type class default instance</code>",
 "1692": "<code>Decidable (t1 = t1)</code>",
 "1691": "<code>Decidable (t1 = t2)</code>",
 "1690": "<code>instDecidableEqStringList : DecidableEq StringList</code>",
 "169": "<code>α → Bool</code>",
 "1689": "<code>¬h1 = h1</code>",
 "1688": "<code>¬h1 = h2</code>",
 "1687": "<code>¬t1 = t1</code>",
 "1686": "<code>h1 = h1</code>",
 "1685": "<code>StringList.cons h1 t1 = StringList.cons h2 t2</code>",
 "1684": "<code>¬t1 = t2</code>",
 "1683": "<code>t1 = t2</code>",
 "1682": "<code>h1 = h2</code>",
 "1681": "<code>StringList</code>",
 "1680":
 "<code>StringList.cons (hd : String) (tl : StringList) : StringList</code>",
 "168": "<code>Type → Type u_1</code>",
 "1679": "<code>StringList.nil : StringList</code>",
 "1678": "<code>StringList : Type</code>",
 "1677":
 "<code>Decidable.isFalse {p : Prop} (h : ¬p) : Decidable p</code><span class=\"sep\"></span><code class=\"docstring\">Proves that `p` is decidable by supplying a proof of `¬p` </code>",
 "1676":
 "<code>Decidable.isTrue {p : Prop} (h : p) : Decidable p</code><span class=\"sep\"></span><code class=\"docstring\">Proves that `p` is decidable by supplying a proof of `p` </code>",
 "1675": "<code>ThreeChoices.maybe : ThreeChoices</code>",
 "1674": "<code>ThreeChoices.no : ThreeChoices</code>",
 "1673": "<code>ThreeChoices.yes : ThreeChoices</code>",
 "1672": "<code>ThreeChoices : Type</code>",
 "1671":
 "<code>DecidableEq.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">Propositional equality is `Decidable` for all elements of a type.\n\nIn other words, an instance of `DecidableEq α` is a means of deciding the proposition `a = b` is\nfor all `a b : α`.\n</code>",
 "1670": "<code>NatRoseTree</code>",
 "167":
 "<code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">[Monads](https://en.wikipedia.org/wiki/Monad_(functional_programming)) are an abstraction of\nsequential control flow and side effects used in functional programming. Monads allow both\nsequencing of effects and data-dependent effects: the values that result from an early step may\ninfluence the effects carried out in a later step.\n\nThe `Monad` API may be used directly. However, it is most commonly accessed through\n[`do`-notation](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=do-notation).\n\nMost `Monad` instances provide implementations of `pure` and `bind`, and use default implementations\nfor the other methods inherited from `Applicative`. Monads should satisfy certain laws, but\ninstances are not required to prove this. An instance of `LawfulMonad` expresses that a given\nmonad's operations are lawful.\n</code>",
 "1669": "<code>NatRoseTree.beq (tree1 tree2 : NatRoseTree) : Bool</code>",
 "1668": "<code>Array NatRoseTree</code>",
 "1667":
 "<code>NatRoseTree.node (val : Nat) (children : Array NatRoseTree) : NatRoseTree</code>",
 "1666": "<code>NatRoseTree : Type</code>",
 "1665": "<code>NatTree.beq : NatTree → NatTree → Bool</code>",
 "1664":
 "<code>NatTree → NatTree → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`.</code>",
 "1663": "<code>NatTree</code>",
 "1662":
 "<code>NatTree.branch (left : NatTree) (val : Nat) (right : NatTree) : NatTree</code>",
 "1661": "<code>NatTree.leaf : NatTree</code>",
 "1660": "<code>NatTree : Type</code>",
 "166":
 "<code>count.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] (p : α → Bool) (act : m α) : m Nat</code>",
 "1659": "<code>instBeqNatWrapper : BEq NatWrapper</code>",
 "1658": "<code>NatWrapper</code>",
 "1657": "<code>BEq.mk.{u} {α : Type u} (beq : α → α → Bool) : BEq α</code>",
 "1656": "<code>instBEqNatWrapper : BEq NatWrapper</code>",
 "1655":
 "<code>NatWrapper → NatWrapper → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`.</code>",
 "1654":
 "<code>BEq.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`BEq α` is a typeclass for supplying a boolean-valued equality relation on\n`α`, notated as `a == b`. Unlike `DecidableEq α` (which uses `a = b`), this\nis `Bool` valued instead of `Prop` valued, and it also does not have any\naxioms like being reflexive or agreeing with `=`. It is mainly intended for\nprogramming applications. See `LawfulBEq` for a version that requires that\n`==` and `=` coincide.\n\nTypically we prefer to put the \"more variable\" term on the left,\nand the \"more constant\" term on the right.\n</code>",
 "1653": "<code>NatWrapper.val (self : NatWrapper) : Nat</code>",
 "1652": "<code>NatWrapper : Type</code>",
 "1651": "<code class=\"docstring\">type class instance</code>",
 "1650": "<code>AddMul'.{u} (α : Type u) : Type u</code>",
 "165": "<code>Sort u_1</code>",
 "1649": "<code>AddMul.{u} (α : Type u) : Type u</code>",
 "1648":
 "<code class=\"docstring\">Expands\n```\nclass abbrev C &lt;params&gt; := D_1, ..., D_n\n```\ninto\n```\nclass C &lt;params&gt; extends D_1, ..., D_n\nattribute [instance] C.mk\n```\n</code>",
 "1647":
 "<code>Mul.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HMul`: `a * b : α` where `a b : α`. </code>",
 "1646":
 "<code>plusTimes2.{u_1} {α : Type u_1} [AddMul' α] (x y z : α) : α</code>",
 "1645":
 "<code>plusTimes1.{u_1} {α : Type u_1} [AddMul α] (x y z : α) : α</code>",
 "1644":
 "<code>Heap'.insert.{u_1} {α : Type u_1} [Ord α] (x : α) (xs : Heap' α) : Heap' α</code>",
 "1643": "<code>Heap' α</code>",
 "1642": "<code>Ord α</code>",
 "1641":
 "<code>Heap'.bubbleUp.{u_1} {α : Type u_1} [inst : Ord α] (i : Nat) (xs : Heap' α) : Heap' α</code>",
 "1640":
 "<code>Heap'.contents.{u} {α : Type u} [Ord α] (self : Heap' α) : Array α</code>",
 "164": "<code>id'.{u_1} {α : Sort u_1} (x : α) : α</code>",
 "1639": "<code>Heap'.{u} (α : Type u) [Ord α] : Type u</code>",
 "1638":
 "<code>Heap.insert.{u_1} {α : Type u_1} [Ord α] (x : α) (xs : Heap α) : Heap α</code>",
 "1637":
 "<code>Array.swap.{u} {α : Type u} (xs : Array α) (i j : Nat) (hi : i &lt; xs.size := by get_elem_tactic)\n  (hj : j &lt; xs.size := by get_elem_tactic) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps two elements of an array. The modification is performed in-place when the reference to the\narray is unique.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swap 0 3 = #[\"brown\", \"green\", \"blue\", \"red\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swap 0 2 = #[\"blue\", \"green\", \"red\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swap 1 2 = #[\"red\", \"blue\", \"green\", \"brown\"]`\n* `#[\"red\", \"green\", \"blue\", \"brown\"].swap 3 0 = #[\"brown\", \"green\", \"blue\", \"red\"]`\n</code>",
 "1636": "<code>Array α</code>",
 "1635":
 "<code>Ordering.lt : Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Less than. </code>",
 "1634":
 "<code>Ord.compare.{u} {α : Type u} [self : Ord α] : α → α → Ordering</code><span class=\"sep\"></span><code class=\"docstring\">Compare two elements in `α` using the comparator contained in an `[Ord α]` instance. </code>",
 "1633": "<code>i ≥ xs.contents.size</code>",
 "1632": "<code>i = 0</code>",
 "1631": "<code>Heap α</code>",
 "1630":
 "<code>Ord.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Ord α` provides a computable total order on `α`, in terms of the\n`compare : α → α → Ordering` function.\n\nTypically instances will be transitive, reflexive, and antisymmetric,\nbut this is not enforced by the typeclass.\n\nThere is a derive handler, so appending `deriving Ord` to an inductive type or structure\nwill attempt to create an `Ord` instance.\n</code>",
 "163":
 "<code>rfl.{u} {α : Sort u} {a : α} : Eq.{u} a a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>",
 "1629":
 "<code>Heap.bubbleUp.{u_1} {α : Type u_1} [Ord α] (i : Nat) (xs : Heap α) : Heap α</code>",
 "1628":
 "<code>Heap.contents.{u} {α : Type u} (self : Heap α) : Array α</code>",
 "1627": "<code>Heap.{u} (α : Type u) : Type u</code>",
 "1626": "<code>∀ (x : α), Magma.op x ident = x</code>",
 "1625": "<code>∀ (x : α), Magma.op ident x = x</code>",
 "1624":
 "<code>C2.Magma.op.{u} {α : Type u} [self : C2.Magma α] : α → α → α</code>",
 "1623":
 "<code>C2.Monoid.mk.{u} {α : Type u} [toSemigroup : C2.Semigroup α] (ident : α)\n  (ident_left : ∀ (x : α), C2.Magma.op ident x = x) (ident_right : ∀ (x : α), C2.Magma.op x ident = x) : C2.Monoid α</code>",
 "1622":
 "<code>∀ (x y z : α), Magma.op (Magma.op x y) z = Magma.op x (Magma.op y z)</code>",
 "1621":
 "<code>∀ (x y z : α), toMagma.op (toMagma.op x y) z = toMagma.op x (toMagma.op y z)</code>",
 "1620": "<code>Magma α</code>",
 "162": "<code>test.{u, v} : Eq.{1} (T.{u} 0) (T.{v} 0)</code>",
 "1619":
 "<code>C2.Semigroup.mk.{u} {α : Type u} [toMagma : C2.Magma α]\n  (op_assoc : ∀ (x y z : α), C2.Magma.op (C2.Magma.op x y) z = C2.Magma.op x (C2.Magma.op y z)) : C2.Semigroup α</code>",
 "1618":
 "<code>S.Semigroup.mk.{u} {α : Type u} (toMagma : S.Magma α)\n  (op_assoc : ∀ (x y z : α), toMagma.op (toMagma.op x y) z = toMagma.op x (toMagma.op y z)) : S.Semigroup α</code>",
 "1617":
 "<code>C2.Magma.mk.{u} {α : Type u} (op : α → α → α) : C2.Magma α</code>",
 "1616":
 "<code>S.Magma.mk.{u} {α : Type u} (op : α → α → α) : S.Magma α</code>",
 "1615":
 "<code>S.Magma.op.{u} {α : Type u} (self : S.Magma α) : α → α → α</code>",
 "1614": "<code>S.Semigroup α</code>",
 "1613": "<code>∀ (x : α), toSemigroup.op x ident = x</code>",
 "1612": "<code>∀ (x : α), toSemigroup.op ident x = x</code>",
 "1611": "<code>Semigroup α</code>",
 "1610":
 "<code>C1.Monoid.mk.{u} {α : Type u} (toSemigroup : S.Semigroup α) (ident : α)\n  (ident_left : ∀ (x : α), toSemigroup.op ident x = x) (ident_right : ∀ (x : α), toSemigroup.op x ident = x) :\n  C1.Monoid α</code>",
 "161":
 "<code>pp.universes</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display universe</code>",
 "1609":
 "<code>S.Monoid.mk.{u} {α : Type u} (toSemigroup : S.Semigroup α) (ident : α)\n  (ident_left : ∀ (x : α), toSemigroup.op ident x = x) (ident_right : ∀ (x : α), toSemigroup.op x ident = x) :\n  S.Monoid α</code>",
 "1608":
 "<code>C2.Monoid.ident_right.{u} {α : Type u} [self : Monoid α] (x : α) : Magma.op x Monoid.ident = x</code>",
 "1607":
 "<code>C2.Monoid.ident_left.{u} {α : Type u} [self : Monoid α] (x : α) : Magma.op Monoid.ident x = x</code>",
 "1606": "<code>C2.Monoid.ident.{u} {α : Type u} [self : Monoid α] : α</code>",
 "1605":
 "<code>C2.Semigroup.op_assoc.{u} {α : Type u} [self : Semigroup α] (x y z : α) :\n  Magma.op (Magma.op x y) z = Magma.op x (Magma.op y z)</code>",
 "1604":
 "<code>C2.Magma.op.{u} {α : Type u} [self : Magma α] : α → α → α</code>",
 "1603":
 "<code>C1.Monoid.ident_right.{u} {α : Type u} [self : Monoid α] (x : α) : Monoid.toSemigroup.op x Monoid.ident = x</code>",
 "1602":
 "<code>C1.Monoid.ident_left.{u} {α : Type u} [self : Monoid α] (x : α) : Monoid.toSemigroup.op Monoid.ident x = x</code>",
 "1601": "<code>C1.Monoid.ident.{u} {α : Type u} [self : Monoid α] : α</code>",
 "1600":
 "<code>S.Monoid.ident_right.{u} {α : Type u} (self : Monoid α) (x : α) : self.op x self.ident = x</code>",
 "160":
 "<code class=\"docstring\">`set_option &lt;id&gt; &lt;value&gt;` sets the option `&lt;id&gt;` to `&lt;value&gt;`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `&lt;id&gt;` to list available options.\n\n`set_option &lt;id&gt; &lt;value&gt; in &lt;command&gt;` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option &lt;id&gt; &lt;value&gt; in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n</code>",
 "16":
 "<code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>",
 "1599":
 "<code>S.Monoid.ident_left.{u} {α : Type u} (self : Monoid α) (x : α) : self.op self.ident x = x</code>",
 "1598": "<code>S.Monoid.ident.{u} {α : Type u} (self : Monoid α) : α</code>",
 "1597": "<code>α → α → α</code>",
 "1596":
 "<code>S.Semigroup.op_assoc.{u} {α : Type u} (self : Semigroup α) (x y z : α) :\n  self.op (self.op x y) z = self.op x (self.op y z)</code>",
 "1595":
 "<code>S.Magma.op.{u} {α : Type u} (self : Magma α) : α → α → α</code>",
 "1594": "<code>C2.Monoid.{u} (α : Type u) : Type u</code>",
 "1593": "<code>C2.Semigroup.{u} (α : Type u) : Type u</code>",
 "1592": "<code>C2.Magma.{u} (α : Type u) : Type u</code>",
 "1591": "<code>C1.Monoid.{u} (α : Type u) : Type u</code>",
 "1590": "<code>S.Monoid.{u} (α : Type u) : Type u</code>",
 "159": "<code>T.{u} : Nat → Bool</code>",
 "1589": "<code>S.Semigroup.{u} (α : Type u) : Type u</code>",
 "1588": "<code>S.Magma.{u} (α : Type u) : Type u</code>",
 "1587":
 "<code>Sum.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The disjoint union of types `α` and `β`, ordinarily written `α ⊕ β`.\n\nAn element of `α ⊕ β` is either an `a : α` wrapped in `Sum.inl` or a `b : β` wrapped in `Sum.inr`.\n`α ⊕ β` is not equivalent to the set-theoretic union of `α` and `β` because its values include an\nindication of which of the two types was chosen. The union of a singleton set with itself contains\none element, while `Unit ⊕ Unit` contains distinct values `inl ()` and `inr ()`.\n</code>",
 "1586":
 "<code>StateM.{u} (σ α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A tuple-based state monad.\n\nActions in `StateM σ` are functions that take an initial state and return a value paired with a\nfinal state.\n</code>",
 "1585":
 "<code>Pure.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">The `pure` function is overloaded via `Pure` instances.\n\n`Pure` is typically accessed via `Monad` or `Applicative` instances.\n</code>",
 "1584": "<code>Nat.add 0 n' = n'</code>",
 "1583": "<code>0 + n' = n'</code>",
 "1582": "<code>0 + n✝ = n✝</code>",
 "1581":
 "<code class=\"docstring\">`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `&lt;-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (occs := .pos L) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`(occs := .neg L)` allows skipping specified occurrences.\n</code>",
 "1580": "<code>HEq 0 n'</code>",
 "158":
 "<code>Alternative.failure.{u, v} {f : Type u → Type v} [self : Alternative f] {α : Type u} : f α</code><span class=\"sep\"></span><code class=\"docstring\">Produces an empty collection or recoverable failure.  The `&lt;|&gt;` operator collects values or recovers\nfrom failures. See `Alternative` for more details.\n</code>",
 "1579": "<code>HEq 0 n✝</code>",
 "1578": "<code>the.{u} (α : Sort u) (x : α) : α</code>",
 "1577":
 "<code class=\"docstring\">Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n</code>",
 "1576":
 "<code><span class=\"literal string\">\"world\"</span> : String</code>",
 "1575": "<code>x = \"world\"</code>",
 "1574": "<code>x = \"Hello\"</code>",
 "1573": "<code>isZero' : Nat → Bool</code>",
 "1572": "<code>isZero : Nat → Bool</code>",
 "1571": "<code>add : Nat → Nat → Nat</code>",
 "1570": "<code>nonzero (n : Nat) : Bool</code>",
 "157":
 "<code class=\"docstring\">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,\nskipping any further statements.\nNote that uses of the `do` keyword in other syntax like in `for _ in _ do`\ndo not constitute a surrounding block in this sense;\nin supported editors, the corresponding `do` keyword of the surrounding block\nis highlighted when hovering over `return`.\n\n`return` not followed by a term starting on the same line is equivalent to `return ()`.\n</code>",
 "1569":
 "<code>Unit.unit : Unit</code><span class=\"sep\"></span><code class=\"docstring\">The only element of the unit type.\n\nIt can be written as an empty tuple: `()`.\n</code>",
 "1568":
 "<code>Add.add.{u} {α : Type u} [self : Add α] : α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "1567": "<code>b = false</code>",
 "1566": "<code>false = false → α</code>",
 "1565": "<code>true = true → α</code>",
 "1564": "<code>b = true</code>",
 "1563": "<code>b = false → α</code>",
 "1562": "<code>b = true → α</code>",
 "1561":
 "<code>boolCases.{u} {α : Type u} (b : Bool) (ifTrue : b = true → α) (ifFalse : b = false → α) : α</code>",
 "1560": "<code>n = 3</code>",
 "156": "<code>Char.mk (val : UInt32) (valid : val.isValidChar) : Char</code>",
 "1559": "<code>f (n : Nat) (p : n = 3) : String</code>",
 "1558": "<code><span class=\"literal string\">\"ok\"</span> : String</code>",
 "1557":
 "<code>last?'.{u_1} {α : Type u_1} (xs : List α) : Except String α</code>",
 "1556": "<code>xs = head✝ :: tail✝</code>",
 "1555": "<code>Type ?u.7</code>",
 "1554":
 "<code>Except.ok.{u, v} {ε : Type u} {α : Type v} : α → Except ε α</code><span class=\"sep\"></span><code class=\"docstring\">A success value of type `α` </code>",
 "1553":
 "<code><span class=\"literal string\">\"Can't take first element of empty list\"</span> : String</code>",
 "1552":
 "<code>Except.error.{u, v} {ε : Type u} {α : Type v} : ε → Except ε α</code><span class=\"sep\"></span><code class=\"docstring\">A failure value of type `ε` </code>",
 "1551": "<code>xs = []</code>",
 "1550":
 "<code>List.getLast.{u} {α : Type u} (as : List α) : as ≠ [] → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of a non-empty list.\n\nExamples:\n* `[\"circle\", \"rectangle\"].getLast (by decide) = \"rectangle\"`\n* `[\"circle\"].getLast (by decide) = \"circle\"`\n</code>",
 "155":
 "<code>UInt32.isValidChar (n : UInt32) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A `UInt32` denotes a valid Unicode code point if it is less than `0x110000` and it is also not a\nsurrogate code point (the range `0xd800` to `0xdfff` inclusive).\n</code>",
 "1549":
 "<code>last?.{u_1} {α : Type u_1} (xs : List α) : Except String α</code>",
 "1548":
 "<code>BalancedTree.isPerfectlyBalanced.{u} {α : Type u} (n : Nat) (t : BalancedTree α n) : Bool</code>",
 "1547":
 "<code>BalancedTree.filledWith.{u} {α : Type u} (x : α) (depth : Nat) : BalancedTree α depth</code>",
 "1546":
 "<code>BalancedTree.rbranch.{u} {α : Type u} {n : Nat} (left : BalancedTree α n) (val : α) (right : BalancedTree α (n + 1)) :\n  BalancedTree α (n + 2)</code>",
 "1545": "<code>BalancedTree α (n + 1)</code>",
 "1544":
 "<code>BalancedTree.lbranch.{u} {α : Type u} {n : Nat} (left : BalancedTree α (n + 1)) (val : α) (right : BalancedTree α n) :\n  BalancedTree α (n + 2)</code>",
 "1543": "<code>BalancedTree α n</code>",
 "1542":
 "<code>BalancedTree.branch.{u} {α : Type u} {n : Nat} (left : BalancedTree α n) (val : α) (right : BalancedTree α n) :\n  BalancedTree α (n + 1)</code>",
 "1541": "<code>BalancedTree.empty.{u} {α : Type u} : BalancedTree α 0</code>",
 "1540": "<code>BalancedTree.{u} (α : Type u) : Nat → Type u</code>",
 "154": "<code>v.isValidChar</code>",
 "1539": "<code>h + 1 + (h + 1) = h + h + 1 + 1</code>",
 "1538": "<code>Nat.parity (n : Nat) : Parity n</code>",
 "1537": "<code>Parity.odd (h : Nat) : Parity (h + h + 1)</code>",
 "1536": "<code>Parity.even (h : Nat) : Parity (h + h)</code>",
 "1535": "<code>Parity : Nat → Type</code>",
 "1534":
 "<code>Lean.Name : Type</code><span class=\"sep\"></span><code class=\"docstring\">Hierarchical names consist of a sequence of components, each of\nwhich is either a string or numeric, that are written separated by dots (`.`).\n\nHierarchical names are used to name declarations and for creating\nunique identifiers for free variables and metavariables.\n\nYou can create hierarchical names using a backtick:\n```\n`Lean.Meta.whnf\n```\nIt is short for `.str (.str (.str .anonymous \"Lean\") \"Meta\") \"whnf\"`.\n\nYou can use double backticks to request Lean to statically check whether the name\ncorresponds to a Lean declaration in scope.\n```\n``Lean.Meta.whnf\n```\nIf the name is not in scope, Lean will report an error.\n\nThere are two ways to convert a `String` to a `Name`:\n\n 1. `Name.mkSimple` creates a name with a single string component.\n\n 2. `String.toName` first splits the string into its dot-separated\n    components, and then creates a hierarchical name.\n</code>",
 "1533":
 "<code class=\"docstring\">mark that a definition can be used in a pattern (remark: the dependent pattern matching compiler will unfold the definition)</code>",
 "1532": "<code>xs.size ≤ 2</code>",
 "1531": "<code>getThird.{u_1} {α : Type u_1} (xs : Array α) : α</code>",
 "1530": "<code>getThird.{u_1} {α : Type u_1} (xs : Array α) : Option α</code>",
 "153": "<code>UInt32</code>",
 "1529": "<code>Int.instNegInt</code>",
 "1528": "<code>3</code>",
 "1527":
 "<code>Float32 : Type</code><span class=\"sep\"></span><code class=\"docstring\">Native floating point type, corresponding to the IEEE 754 *binary32* format\n(`float` in C or `f32` in Rust). </code>",
 "1526": "<code>Nat → Bool → Nat → α</code>",
 "1525":
 "<code>OfScientific.mk.{u} {α : Type u} (ofScientific : Nat → Bool → Nat → α) : OfScientific α</code>",
 "1524":
 "<code>OfScientific.ofScientific.{u} {α : Type u} [self : OfScientific α] (mantissa : Nat) (exponentSign : Bool)\n  (decimalExponent : Nat) : α</code>",
 "1523":
 "<code>OfScientific.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">For decimal and scientific numbers (e.g., `1.23`, `3.12e10`).\nExamples:\n- `1.23` is syntax for `OfScientific.ofScientific (nat_lit 123) true (nat_lit 2)`\n- `121e100` is syntax for `OfScientific.ofScientific (nat_lit 121) false (nat_lit 100)`\n\nNote the use of `nat_lit`; there is no wrapping `OfNat.ofNat` in the resulting term.\n</code>",
 "1522": "<code>NatInterval</code>",
 "1521":
 "<code>NatInterval</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1520":
 "<code>NatInterval.mk (low high : Nat) (low_le_high : low ≤ high) : NatInterval</code>",
 "152": "<code>Array UInt32 → Nat → Option (Char × Nat)</code>",
 "1519": "<code>lo2 ≤ hi2</code>",
 "1518": "<code>lo1 ≤ hi1</code>",
 "1517":
 "<code>NatInterval → NatInterval → NatInterval</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "1516":
 "<code>NatInterval.low_le_high (self : NatInterval) : self.low ≤ self.high</code>",
 "1515": "<code>NatInterval.high (self : NatInterval) : Nat</code>",
 "1514": "<code>NatInterval.low (self : NatInterval) : Nat</code>",
 "1513": "<code>NatInterval : Type</code>",
 "1512":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1511":
 "<code>OfNat.mk.{u} {α : Type u} {x✝ : Nat} (ofNat : α) : OfNat α x✝</code>",
 "1510":
 "<code class=\"docstring\">The `nat_lit n` macro constructs \"raw numeric literals\". This corresponds to the\n`Expr.lit (.natVal n)` constructor in the `Expr` data type.\n\nNormally, when you write a numeral like `#check 37`, the parser turns this into\nan application of `OfNat.ofNat` to the raw literal `37` to cast it into the\ntarget type, even if this type is `Nat` (so the cast is the identity function).\nBut sometimes it is necessary to talk about the raw numeral directly,\nespecially when proving properties about the `ofNat` function itself.\n</code>",
 "151":
 "<code>Char.val (self : Char) : UInt32</code><span class=\"sep\"></span><code class=\"docstring\">The underlying Unicode scalar value as a `UInt32`. </code>",
 "1509":
 "<code>OfNat.ofNat.{u} {α : Type u} (x✝ : Nat) [self : OfNat α x✝] : α</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1508":
 "<code>Array.reverse.{u} {α : Type u} (as : Array α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Reverses an array by repeatedly swapping elements.\n\nThe original array is modified in place if there are no other references to it.\n\nExamples:\n* `(#[] : Array Nat).reverse = #[]`\n* `#[0, 1].reverse = #[1, 0]`\n* `#[0, 1, 2].reverse = #[2, 1, 0]`\n</code>",
 "1507": "<code>Array (Array Nat)</code>",
 "1506": "<code>T.f.{u_1} {n : Nat} : Char → T n → String</code>",
 "1505": "<code>T 3</code>",
 "1504":
 "<code>List.head!.{u_1} {α : Type u_1} [Inhabited α] : List α → α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element in the list. If the list is empty, panics and returns `default`.\n\nSafer alternatives include:\n* `List.head`, which requires a proof that the list is non-empty,\n* `List.head?`, which returns an `Option`, and\n* `List.headD`, which returns an explicitly-provided fallback value on empty lists.\n</code>",
 "1503":
 "<code><span class=\"literal string\">\"Hello!\"</span> : String</code>",
 "1502": "<code>Nat.half : Nat → Nat</code>",
 "1501":
 "<code class=\"docstring\">mark declaration to never be pretty printed using field notation</code>",
 "1500": "<code><span class=\"literal string\">\"root\"</span> : String</code>",
 "150":
 "<code>Array.push.{u} {α : Type u} (a : Array α) (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Adds an element to the end of an array. The resulting array's size is one greater than the input\narray. If there are no other references to the array, then it is modified in-place.\n\nThis takes amortized `O(1)` time because `Array α` is represented by a dynamic array.\n\nExamples:\n* `#[].push \"apple\" = #[\"apple\"]`\n* `#[\"apple\"].push \"orange\" = #[\"apple\", \"orange\"]`\n</code>",
 "15":
 "<code>HAdd.hAdd.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAdd α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.</code>",
 "1499": "<code>root : Username</code>",
 "1498":
 "<code><span class=\"literal string\">\"Unexpected character\"</span> : String</code>",
 "1497": "<code>Username.validate.notOk (c : Char) : Bool</code>",
 "1496":
 "<code><span class=\"literal string\">\"Unexpected leading whitespace\"</span> : String</code>",
 "1495":
 "<code>MonadExcept.throw.{u, v, w} {ε : outParam (Type u)} {m : Type v → Type w} [self : MonadExcept ε m] {α : Type v} :\n  ε → m α</code><span class=\"sep\"></span><code class=\"docstring\">Throws an exception of type `ε` to the nearest enclosing handler.\n</code>",
 "1494":
 "<code>Except.{u, v} (ε : Type u) (α : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">`Except ε α` is a type which represents either an error of type `ε` or a successful result with a\nvalue of type `α`.\n\n`Except ε : Type u → Type v` is a `Monad` that represents computations that may throw exceptions:\nthe `pure` operation is `Except.ok` and the `bind` operation returns the first encountered\n`Except.error`.\n</code>",
 "1493": "<code>Username</code>",
 "1492": "<code><span class=\"literal string\">\" \"</span> : String</code>",
 "1491":
 "<code>Char.isDigit (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the character is an ASCII digit.\n\nThe ASCII digits are the following: `0123456789`.\n</code>",
 "1490":
 "<code>Char.isAlpha (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the character is an ASCII letter.\n\nThe ASCII letters are the following: `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`.\n</code>",
 "149": "<code>Char</code>",
 "1489":
 "<code>String.any (s : String) (p : Char → Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether there is a character in a string for which the Boolean predicate `p` returns `true`.\n\nShort-circuits at the first character for which `p` returns `true`.\n\nExamples:\n* `\"brown\".any (·.isLetter) = true`\n* `\"brown\".any (·.isWhitespace) = false`\n* `\"brown and orange\".any (·.isLetter) = true`\n* `\"\".any (fun _ =&gt; false) = false`\n</code>",
 "1488":
 "<code>String.isPrefixOf (p s : String) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether the first string (`p`) is a prefix of the second (`s`).\n\n`String.startsWith` is a version that takes the potential prefix after the string.\n\nExamples:\n* `\"red\".isPrefixOf \"red green blue\" = true`\n* `\"green\".isPrefixOf \"red green blue\" = false`\n* `\"\".isPrefixOf \"red green blue\" = true`\n</code>",
 "1487":
 "<code>Username.validate (name : Username) : Except String Unit</code>",
 "1486": "<code>Username : Type</code>",
 "1485": "<code>Lean.Syntax</code>",
 "1484":
 "<code>Inhabited.default.{u} {α : Sort u} [self : Inhabited α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. </code>",
 "1483": "<code>optParam α default</code>",
 "1482":
 "<code>autoParam.{u} (α : Sort u) (tactic : Lean.Syntax) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses\nthe given tactic.\nLike `optParam`, this gadget only affects elaboration.\nFor example, the tactic will *not* be invoked during type class resolution. </code>",
 "1481":
 "<code>optParam.{u} (α : Sort u) (default : α) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n</code>",
 "1480": "<code>sum3 (x y z : Nat) : Nat</code>",
 "148": "<code>Array UInt32</code>",
 "1479": "<code>α✝</code>",
 "1478": "<code>g {α : Type} : α → α</code>",
 "1477": "<code>f ⦃α : Type⦄ : α → α</code>",
 "1476":
 "<code>Nat.add : Nat → Nat → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Addition of natural numbers, typically used via the `+` operator.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n</code>",
 "1475": "<code>MyList.{u_1} (α : Type u_1) : Type u_1</code>",
 "1474": "<code>D.x : Nat</code>",
 "1473": "<code><span class=\"literal string\">\"C.x\"</span> : String</code>",
 "1472": "<code>C.x : String</code>",
 "1471": "<code><span class=\"literal string\">\"B.x\"</span> : String</code>",
 "1470": "<code>B.x : String</code>",
 "147": "<code>Array UInt32 → Char → Array UInt32</code>",
 "1469":
 "<code><span class=\"literal string\">\"longer\"</span> : String</code>",
 "1468": "<code>y.y : A</code>",
 "1467":
 "<code><span class=\"literal string\">\"shorter\"</span> : String</code>",
 "1466": "<code>A.mk (y : String) : A</code>",
 "1465": "<code>B.mk (y : A) : B</code>",
 "1464": "<code>y : B</code>",
 "1463": "<code>B.y (self : B) : A</code>",
 "1462": "<code>B : Type</code>",
 "1461": "<code>A.y (self : A) : String</code>",
 "1460": "<code>A : Type</code>",
 "146": "<code>Type</code>",
 "1459":
 "<code><span class=\"literal string\">\"A.B.C.x\"</span> : String</code>",
 "1458": "<code>A.B.C.x : String</code>",
 "1457": "<code><span class=\"literal string\">\"A.x\"</span> : String</code>",
 "1456": "<code>A.x : String</code>",
 "1455":
 "<code><span class=\"literal string\">\"inner\"</span> : String</code>",
 "1454":
 "<code><span class=\"literal string\">\"outer\"</span> : String</code>",
 "1453":
 "<code><span class=\"literal string\">\"local\"</span> : String</code>",
 "1452":
 "<code><span class=\"literal string\">\"global\"</span> : String</code>",
 "1451": "<code>x : String</code>",
 "1450":
 "<code>Lean.Order.monotone_ite.{u, v} {α : Sort u} {β : Sort v} [PartialOrder α] [PartialOrder β] (c : Prop) [Decidable c]\n  (k₁ k₂ : α → β) (hmono₁ : monotone k₁) (hmono₂ : monotone k₂) : monotone fun x =&gt; if c then k₁ x else k₂ x</code>",
 "145": "<code>Codec.char : Codec</code>",
 "1449":
 "<code>dite.{u} {α : Sort u} (c : Prop) [h : Decidable c] (t : c → α) (e : ¬c → α) : α</code><span class=\"sep\"></span><code class=\"docstring\">\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h =&gt; t(h)) (fun h =&gt; e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i &lt; arr.size` in order to\navoid a bounds check, so you can write `if h : i &lt; arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i &lt; arr.size` from some other proposition that we are checking in the `if`.)\n</code>",
 "1448":
 "<code>Lean.Order.monotone_dite.{u, v} {α : Sort u} {β : Sort v} [PartialOrder α] [PartialOrder β] (c : Prop) [Decidable c]\n  (k₁ : α → c → β) (k₂ : α → ¬c → β) (hmono₁ : monotone k₁) (hmono₂ : monotone k₂) :\n  monotone fun x =&gt; dite c (k₁ x) (k₂ x)</code>",
 "1447":
 "<code>Lean.Order.monotone_bind.{u, v, w} (m : Type u → Type v) [Bind m] [(α : Type u) → PartialOrder (m α)] [MonoBind m]\n  {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → m α) (g : γ → α → m β) (hmono₁ : monotone f)\n  (hmono₂ : monotone g) : monotone fun x =&gt; f x &gt;&gt;= g x</code>",
 "1446":
 "<code>Lean.Order.SeqRight.monotone_seqRight.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] [LawfulMonad m] (f : γ → m α) (g : γ → m β)\n  (hmono₁ : monotone g) (hmono₂ : monotone f) : monotone fun x =&gt; g x *&gt; f x</code>",
 "1445":
 "<code>Lean.Order.SeqLeft.monotone_seqLeft.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] [LawfulMonad m] (f : γ → m α) (g : γ → m β)\n  (hmono₁ : monotone g) (hmono₂ : monotone f) : monotone fun x =&gt; g x &lt;* f x</code>",
 "1444":
 "<code>Lean.Order.Seq.monotone_seq.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)] [MonoBind m]\n  {α β : Type u} {γ : Type w} [PartialOrder γ] [LawfulMonad m] (f : γ → m α) (g : γ → m (α → β)) (hmono₁ : monotone g)\n  (hmono₂ : monotone f) : monotone fun x =&gt; g x &lt;*&gt; f x</code>",
 "1443":
 "<code>PProd.snd.{u, v} {α : Sort u} {β : Sort v} (self : α ×' β) : β</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "1442":
 "<code>Lean.Order.PProd.monotone_snd.{u, v, w} {α : Sort u} {β : Sort v} {γ : Sort w} [PartialOrder α] [PartialOrder β]\n  [PartialOrder γ] {f : γ → α ×' β} (hf : monotone f) : monotone fun x =&gt; (f x).snd</code>",
 "1441":
 "<code>Lean.Order.PProd.monotone_mk.{u, v, w} {α : Sort u} {β : Sort v} {γ : Sort w} [PartialOrder α] [PartialOrder β]\n  [PartialOrder γ] {f : γ → α} {g : γ → β} (hf : monotone f) (hg : monotone g) : monotone fun x =&gt; ⟨f x, g x⟩</code>",
 "1440":
 "<code>PProd.fst.{u, v} {α : Sort u} {β : Sort v} (self : α ×' β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first element of a pair. </code>",
 "144":
 "<code>Codec.decode.{u} (self : Codec) : Array UInt32 → Nat → Option (self.type × Nat)</code>",
 "1439":
 "<code>Lean.Order.PProd.monotone_fst.{u, v, w} {α : Sort u} {β : Sort v} {γ : Sort w} [PartialOrder α] [PartialOrder β]\n  [PartialOrder γ] {f : γ → α ×' β} (hf : monotone f) : monotone fun x =&gt; (f x).fst</code>",
 "1438":
 "<code>Option.mapM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Monad m] (f : α → m β)\n  (o : Option α) : m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Runs a monadic function `f` on an optional value, returning the result. If the optional value is\n`none`, the function is not called and the result is also `none`.\n\nFrom the perspective of `Option` as a container with at most one element, this is analogous to\n`List.mapM`, returning the result of running the monadic function on all elements of the container.\n\n`Option.mapA` is the corresponding operation for applicative functors.\n</code>",
 "1437":
 "<code>Lean.Order.Option.monotone_mapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m β) (xs : Option α) (hmono : monotone f) :\n  monotone fun x =&gt; Option.mapM (f x) xs</code>",
 "1436":
 "<code>Option.getDM.{u_1, u_2} {m : Type u_1 → Type u_2} {α : Type u_1} [Monad m] (x : Option α) (y : m α) : m α</code><span class=\"sep\"></span><code class=\"docstring\">Gets the value in an option, monadically computing a default value on `none`.\n\nThis is the monadic analogue of `Option.getD`.\n</code>",
 "1435":
 "<code>Lean.Order.Option.monotone_getDM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  {α : Type u} {γ : Type w} [PartialOrder γ] (o : Option α) (y : γ → m α) (hmono : monotone y) :\n  monotone fun x =&gt; o.getDM (y x)</code>",
 "1434":
 "<code>Option.elimM.{u_1, u_2} {m : Type u_1 → Type u_2} {α β : Type u_1} [Monad m] (x : m (Option α)) (y : m β)\n  (z : α → m β) : m β</code><span class=\"sep\"></span><code class=\"docstring\">A monadic case analysis function for `Option`.\n\nGiven a fallback computation for `none` and a monadic operation to apply to the contents of `some`,\n`Option.elimM` checks which constructor a given `Option` consists of, and uses the appropriate\nargument.\n\n`Option.elimM` can also be seen as a combination of `Option.mapM` and `Option.getDM`. It is a\nmonadic analogue of `Option.elim`.\n</code>",
 "1433":
 "<code>Lean.Order.Option.monotone_elimM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (a : γ → m (Option α)) (n : γ → m β) (s : γ → α → m β)\n  (hmono₁ : monotone a) (hmono₂ : monotone n) (hmono₃ : monotone s) : monotone fun x =&gt; Option.elimM (a x) (n x) (s x)</code>",
 "1432":
 "<code>Option.bindM.{u_1, u_2, u_3} {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [Monad m] (f : α → m (Option β))\n  (o : Option α) : m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Runs the monadic action `f` on `o`'s value, if any, and returns the result, or  `none` if there is\nno value.\n\nFrom the perspective of `Option` as a collection with at most one element, the monadic the function\nis applied to the element if present, and the final result is empty if either the initial or the\nresulting collections are empty.\n</code>",
 "1431":
 "<code>Lean.Order.Option.monotone_bindM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : Option α)\n  (hmono : monotone f) : monotone fun x =&gt; Option.bindM (f x) xs</code>",
 "1430":
 "<code>Lean.Order.List.monotone_mapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)] [MonoBind m]\n  {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m β) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.mapM (f x) xs</code>",
 "143":
 "<code>UInt32 : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of unsigned 32-bit integers. This type has special support in the\ncompiler to make it actually 32 bits rather than wrapping a `Nat`.\n</code>",
 "1429":
 "<code>List.forM.{u, v, w} {m : Type u → Type v} [Monad m] {α : Type w} (as : List α) (f : α → m PUnit) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to every element in the list, in order.\n\n`List.mapM` is a variant that collects results. `List.forA` is a variant that works on any\n`Applicative`.\n</code>",
 "1428":
 "<code>Lean.Order.List.monotone_forM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)] [MonoBind m]\n  {α : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m PUnit) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; xs.forM (f x)</code>",
 "1427":
 "<code>List.forIn'.loop.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (as : List α)\n  (f : (a : α) → a ∈ as → β → m (ForInStep β)) (as' : List α) (b : β) : (∃ bs, bs ++ as' = as) → m β</code>",
 "1426":
 "<code>Lean.Order.List.monotone_forIn'_loop.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : List α)\n  (f : γ → (a : α) → a ∈ as → β → m (ForInStep β)) (as' : List α) (b : β) (p : ∃ bs, bs ++ as' = as)\n  (hmono : monotone f) : monotone fun x =&gt; List.forIn'.loop as (f x) as' b p</code>",
 "1425":
 "<code>Lean.Order.List.monotone_forIn'.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : List α) (init : β)\n  (f : γ → (a : α) → a ∈ as → β → m (ForInStep β)) (hmono : monotone f) : monotone fun x =&gt; forIn' as init (f x)</code>",
 "1424":
 "<code>Lean.Order.List.monotone_forIn.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : List α) (init : β)\n  (f : γ → α → β → m (ForInStep β)) (hmono : monotone f) : monotone fun x =&gt; forIn as init (f x)</code>",
 "1423":
 "<code>List.foldrM.{u, v, w} {m : Type u → Type v} [Monad m] {s : Type u} {α : Type w} (f : α → s → m s) (init : s)\n  (l : List α) : m s</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic function over a list from the right, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in reverse order, using `f`.\n\nExample:\n```lean example\nexample [Monad m] (f : α → β → m β) :\n  List.foldrM (m := m) f x₀ [a, b, c] = (do\n    let x₁ ← f c x₀\n    let x₂ ← f b x₁\n    let x₃ ← f a x₂\n    pure x₃)\n  := by rfl\n```\n</code>",
 "1422":
 "<code>Lean.Order.List.monotone_foldrM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → β → m β) (init : β) (xs : List α)\n  (hmono : monotone f) : monotone fun x =&gt; List.foldrM (f x) init xs</code>",
 "1421":
 "<code>List.foldlM.{u, v, w} {m : Type u → Type v} [Monad m] {s : Type u} {α : Type w} (f : s → α → m s) (init : s) :\n  List α → m s</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic function over a list from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in order, using `f`.\n\nExample:\n```lean example\nexample [Monad m] (f : α → β → m α) :\n    List.foldlM (m := m) f x₀ [a, b, c] = (do\n      let x₁ ← f x₀ a\n      let x₂ ← f x₁ b\n      let x₃ ← f x₂ c\n      pure x₃)\n  := by rfl\n```\n</code>",
 "1420":
 "<code>Lean.Order.List.monotone_foldlM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → β → α → m β) (init : β) (xs : List α)\n  (hmono : monotone f) : monotone fun x =&gt; List.foldlM (f x) init xs</code>",
 "142":
 "<code>Codec.encode.{u} (self : Codec) : Array UInt32 → self.type → Array UInt32</code>",
 "1419":
 "<code>List.findSomeM?.{u, v, w} {m : Type u → Type v} [Monad m] {α : Type w} {β : Type u} (f : α → m (Option β)) :\n  List α → m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying the monadic function `f` to each element of the\nlist, in order. Returns `none` if `f` returns `none` for all elements.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [7, 6, 5, 8, 1, 2, 6].findSomeM? fun i =&gt; do\n  if i &lt; 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\n```\n```output\nAlmost! 6\nAlmost! 5\n```\n```output\nsome 10\n```\n</code>",
 "1418":
 "<code>Lean.Order.List.monotone_findSomeM?.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : List α)\n  (hmono : monotone f) : monotone fun x =&gt; List.findSomeM? (f x) xs</code>",
 "1417":
 "<code>List.findM?.{u} {m : Type → Type u} [Monad m] {α : Type} (p : α → m Bool) : List α → m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of the list for which the monadic predicate `p` returns `true`, or `none`\nif no such element is found. Elements of the list are checked in order.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [7, 6, 5, 8, 1, 2, 6].findM? fun i =&gt; do\n  if i &lt; 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\n```\n```output\nAlmost! 6\nAlmost! 5\n```\n```output\nsome 1\n```\n</code>",
 "1416":
 "<code>Lean.Order.List.monotone_findM?.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.findM? (f x) xs</code>",
 "1415":
 "<code>List.filterRevM.{v} {m : Type → Type v} [Monad m] {α : Type} (p : α → m Bool) (as : List α) : m (List α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic predicate `p` on every element in the list in reverse order, from right to left,\nand returns those elements for which `p` returns `true`. The elements of the returned list are in\nthe same order as in the input list.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterRevM fun x =&gt; do\n  IO.println s!\"Checking {x}\"\n  return x &lt; 3\n```\n```output\nChecking 7\nChecking 7\nChecking 2\nChecking 5\nChecking 2\nChecking 1\n```\n```output\n[1, 2, 2]\n```\n</code>",
 "1414":
 "<code>Lean.Order.List.monotone_filterRevM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.filterRevM (f x) xs</code>",
 "1413":
 "<code>List.filterM.{v} {m : Type → Type v} [Monad m] {α : Type} (p : α → m Bool) (as : List α) : m (List α)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic predicate `p` to every element in the list, in order from left to right, and\nreturns the list of elements for which `p` returns `true`.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [1, 2, 5, 2, 7, 7].filterM fun x =&gt; do\n  IO.println s!\"Checking {x}\"\n  return x &lt; 3\n```\n```output\nChecking 1\nChecking 2\nChecking 5\nChecking 2\nChecking 7\nChecking 7\n```\n```output\n[1, 2, 2]\n```\n</code>",
 "1412":
 "<code>Lean.Order.List.monotone_filterM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.filterM (f x) xs</code>",
 "1411":
 "<code>List.filterAuxM.{v} {m : Type → Type v} [Monad m] {α : Type} (f : α → m Bool) : List α → List α → m (List α)</code>",
 "1410":
 "<code>Lean.Order.List.monotone_filterAuxM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs acc : List α)\n  (hmono : monotone f) : monotone fun x =&gt; List.filterAuxM (f x) xs acc</code>",
 "141": "<code>Codec.type.{u} (self : Codec) : Type u</code>",
 "1409":
 "<code>List.anyM.{u, v} {m : Type → Type u} [Monad m] {α : Type v} (p : α → m Bool) (l : List α) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns true if the monadic predicate `p` returns `true` for any element of `l`.\n\n`O(|l|)`. Short-circuits upon encountering the first `true`. The elements in `l` are examined in\norder from left to right.\n</code>",
 "1408":
 "<code>Lean.Order.List.monotone_anyM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.anyM (f x) xs</code>",
 "1407":
 "<code>List.allM.{u, v} {m : Type → Type u} [Monad m] {α : Type v} (p : α → m Bool) (l : List α) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns true if the monadic predicate `p` returns `true` for every element of `l`.\n\n`O(|l|)`. Short-circuits upon encountering the first `false`. The elements in `l` are examined in\norder from left to right.\n</code>",
 "1406":
 "<code>Lean.Order.List.monotone_allM.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : List α) (hmono : monotone f) :\n  monotone fun x =&gt; List.allM (f x) xs</code>",
 "1405":
 "<code>Lean.Order.Functor.monotone_map.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] [LawfulMonad m] (f : γ → m α) (g : α → β)\n  (hmono : monotone f) : monotone fun x =&gt; g &lt;$&gt; f x</code>",
 "1404":
 "<code>Array.modifyM.{u, u_1} {α : Type u} {m : Type u → Type u_1} [Monad m] (xs : Array α) (i : Nat) (f : α → m α) :\n  m (Array α)</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the element at the given index, if it exists, with the result of applying the monadic\nfunction `f` to it. If the index is invalid, the array is returned unmodified and `f` is not called.\n\nExamples:\n```lean example\n#eval #[1, 2, 3, 4].modifyM 2 fun x =&gt; do\n  IO.println s!\"It was {x}\"\n  return x * 10\n```\n```output\nIt was 3\n```\n```output\n#[1, 2, 30, 4]\n```\n\n```lean example\n#eval #[1, 2, 3, 4].modifyM 6 fun x =&gt; do\n  IO.println s!\"It was {x}\"\n  return x * 10\n```\n```output\n#[1, 2, 3, 4]\n```\n</code>",
 "1403":
 "<code>Lean.Order.Array.monotone_modifyM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α : Type u} {γ : Type w} [PartialOrder γ] (a : Array α) (i : Nat) (f : γ → α → m α)\n  (hmono : monotone f) : monotone fun x =&gt; a.modifyM i (f x)</code>",
 "1402":
 "<code>Array.mapM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → m β) (as : Array α) :\n  m (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to every element in the array, left-to-right, and returns the array\nof results.\n</code>",
 "1401":
 "<code>Lean.Order.Array.monotone_mapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (xs : Array α) (f : γ → α → m β) (hmono : monotone f) :\n  monotone fun x =&gt; Array.mapM (f x) xs</code>",
 "1400":
 "<code>Array.mapFinIdxM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (as : Array α)\n  (f : (i : Nat) → α → i &lt; as.size → m β) : m (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Variant of `mapIdxM` which receives the index `i` along with the bound `i &lt; as.size`. </code>",
 "140": "<code>Codec.{u} : Type (u + 1)</code>",
 "14":
 "<code class=\"docstring\">This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n</code>",
 "1399":
 "<code>Lean.Order.Array.monotone_mapFinIdxM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (xs : Array α) (f : γ → (i : Nat) → α → i &lt; xs.size → m β)\n  (hmono : monotone f) : monotone fun x =&gt; xs.mapFinIdxM (f x)</code>",
 "1398":
 "<code>Array.forIn'.loop.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (as : Array α)\n  (f : (a : α) → a ∈ as → β → m (ForInStep β)) (i : Nat) (h : i ≤ as.size) (b : β) : m β</code>",
 "1397":
 "<code>Lean.Order.Array.monotone_forIn'_loop.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : Array α)\n  (f : γ → (a : α) → a ∈ as → β → m (ForInStep β)) (i : Nat) (h : i ≤ as.size) (b : β) (hmono : monotone f) :\n  monotone fun x =&gt; Array.forIn'.loop as (f x) i h b</code>",
 "1396":
 "<code>ForIn'.forIn'.{u, v, u₁, u₂} {m : Type u₁ → Type u₂} {ρ : Type u} {α : outParam (Type v)}\n  {d : outParam (Membership α ρ)} [self : ForIn' m ρ α d] {β : Type u₁} [Monad m] (x : ρ) (b : β)\n  (f : (a : α) → a ∈ x → β → m (ForInStep β)) : m β</code><span class=\"sep\"></span><code class=\"docstring\">`forIn' x b f : m β` runs a for-loop in the monad `m` with additional state `β`.\nThis traverses over the \"contents\" of `x`, and passes the elements `a : α` along\nwith a proof that `a ∈ x` to `f : (a : α) → a ∈ x → β → m (ForInStep β)`.\n`b : β` is the initial state, and the return value\nof `f` is the new state as well as a directive `.done` or `.yield`\nwhich indicates whether to abort early or continue iteration. </code>",
 "1395":
 "<code>Lean.Order.Array.monotone_forIn'.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : Array α) (init : β)\n  (f : γ → (a : α) → a ∈ as → β → m (ForInStep β)) (hmono : monotone f) : monotone fun x =&gt; forIn' as init (f x)</code>",
 "1394":
 "<code>ForIn.forIn.{u, v, u₁, u₂} {m : Type u₁ → Type u₂} {ρ : Type u} {α : outParam (Type v)} [self : ForIn m ρ α]\n  {β : Type u₁} [Monad m] (x : ρ) (b : β) (f : α → β → m (ForInStep β)) : m β</code><span class=\"sep\"></span><code class=\"docstring\">`forIn x b f : m β` runs a for-loop in the monad `m` with additional state `β`.\nThis traverses over the \"contents\" of `x`, and passes the elements `a : α` to\n`f : α → β → m (ForInStep β)`. `b : β` is the initial state, and the return value\nof `f` is the new state as well as a directive `.done` or `.yield`\nwhich indicates whether to abort early or continue iteration.\n\nThe expression\n```\nlet mut b := ...\nfor x in xs do\n  b ← foo x b\n```\nin a `do` block is syntactic sugar for:\n```\nlet b := ...\nlet b ← forIn xs b (fun x b =&gt; do\n  let b ← foo x b\n  return .yield b)\n```\n(Here `b` corresponds to the variables mutated in the loop.) </code>",
 "1393":
 "<code>Lean.Order.Array.monotone_forIn.{u, v, w, uu} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {β : Type u} {γ : Type w} [PartialOrder γ] {α : Type uu} (as : Array α) (init : β)\n  (f : γ → α → β → m (ForInStep β)) (hmono : monotone f) : monotone fun x =&gt; forIn as init (f x)</code>",
 "1392":
 "<code>Array.foldrM.fold.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → β → m β) (as : Array α)\n  (stop : Nat := 0) (i : Nat) (h : i ≤ as.size) (b : β) : m β</code>",
 "1391":
 "<code>Lean.Order.Array.monotone_foldrM_fold.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → β → m β) (xs : Array α) (stop i : Nat)\n  (h : i ≤ xs.size) (b : β) (hmono : monotone f) : monotone fun x =&gt; Array.foldrM.fold (f x) xs stop i h b</code>",
 "1390":
 "<code>Array.foldrM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → β → m β) (init : β)\n  (as : Array α) (start : Nat := as.size) (stop : Nat := 0) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic function over an array from the right, accumulating a value starting with `init`.\nThe accumulated value is combined with the each element of the list in reverse order, using `f`.\n\nThe optional parameters `start` and `stop` control the region of the array to be folded. Folding\nproceeds from `start` (exclusive) to `stop` (inclusive), so no folding occurs unless `start &gt; stop`.\nBy default, the entire array is folded.\n\nExamples:\n```lean example\nexample [Monad m] (f : α → β → m β) :\n  Array.foldrM (m := m) f x₀ #[a, b, c] = (do\n    let x₁ ← f c x₀\n    let x₂ ← f b x₁\n    let x₃ ← f a x₂\n    pure x₃)\n  := by rfl\n```\n\n```lean example\nexample [Monad m] (f : α → β → m β) :\n  Array.foldrM (m := m) f x₀ #[a, b, c] (start := 2) = (do\n    let x₁ ← f b x₀\n    let x₂ ← f a x₁\n    pure x₂)\n  := by rfl\n```\n</code>",
 "139":
 "<code>id.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and Lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n</code>",
 "1389":
 "<code>Lean.Order.Array.monotone_foldrM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → β → m β) (init : β) (xs : Array α)\n  (start stop : Nat) (hmono : monotone f) : monotone fun x =&gt; Array.foldrM (f x) init xs start stop</code>",
 "1388":
 "<code>Array.foldlM.loop.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : β → α → m β) (as : Array α)\n  (stop : Nat) (h : stop ≤ as.size) (i j : Nat) (b : β) : m β</code>",
 "1387":
 "<code>Lean.Order.Array.monotone_foldlM_loop.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → β → α → m β) (xs : Array α) (stop : Nat)\n  (h : stop ≤ xs.size) (i j : Nat) (b : β) (hmono : monotone f) :\n  monotone fun x =&gt; Array.foldlM.loop (f x) xs stop h i j b</code>",
 "1386":
 "<code>Array.foldlM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : β → α → m β) (init : β)\n  (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : m β</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic function over a list from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in order, using `f`.\n\nThe optional parameters `start` and `stop` control the region of the array to be folded. Folding\nproceeds from `start` (inclusive) to `stop` (exclusive), so no folding occurs unless `start &lt; stop`.\nBy default, the entire array is folded.\n\nExamples:\n```lean example\nexample [Monad m] (f : α → β → m α) :\n    Array.foldlM (m := m) f x₀ #[a, b, c] = (do\n      let x₁ ← f x₀ a\n      let x₂ ← f x₁ b\n      let x₃ ← f x₂ c\n      pure x₃)\n  := by rfl\n```\n\n```lean example\nexample [Monad m] (f : α → β → m α) :\n    Array.foldlM (m := m) f x₀ #[a, b, c] (start := 1) = (do\n      let x₁ ← f x₀ b\n      let x₂ ← f x₁ c\n      pure x₂)\n  := by rfl\n```\n</code>",
 "1385":
 "<code>Lean.Order.Array.monotone_foldlM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → β → α → m β) (init : β) (xs : Array α)\n  (start stop : Nat) (hmono : monotone f) : monotone fun x =&gt; Array.foldlM (f x) init xs start stop</code>",
 "1384":
 "<code>Array.flatMapM.{u, u_1, u_2} {α : Type u} {m : Type u_1 → Type u_2} {β : Type u_1} [Monad m] (f : α → m (Array β))\n  (as : Array α) : m (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function that returns an array to each element of an array, from left to right.\nThe resulting arrays are appended.\n</code>",
 "1383":
 "<code>Lean.Order.Array.monotone_flatMapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Array β)) (xs : Array α)\n  (hmono : monotone f) : monotone fun x =&gt; Array.flatMapM (f x) xs</code>",
 "1382":
 "<code>Array.findSomeRevM?.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → m (Option β))\n  (as : Array α) : m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying the monadic function `f` to each element of the\narray in reverse order, from right to left. Once a non-`none` result is found, no further elements\nare checked. Returns `none` if `f` returns `none` for all elements of the array.\n\nExamples:\n```lean example\n#eval #[1, 2, 0, -4, 1].findSomeRevM? (m := Except String) fun x =&gt; do\n  if x = 0 then throw \"Zero!\"\n  else if x &lt; 0 then return (some x)\n  else return none\n```\n```output\nExcept.ok (some (-4))\n```\n```lean example\n#eval #[1, 2, 0, 4, 1].findSomeRevM? (m := Except String) fun x =&gt; do\n  if x = 0 then throw \"Zero!\"\n  else if x &lt; 0 then return (some x)\n  else return none\n```\n```output\nExcept.error \"Zero!\"\n```\n</code>",
 "1381":
 "<code>Lean.Order.Array.monotone_findSomeRevM?.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : Array α)\n  (hmono : monotone f) : monotone fun x =&gt; Array.findSomeRevM? (f x) xs</code>",
 "1380":
 "<code>Array.findSomeM?.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → m (Option β))\n  (as : Array α) : m (Option β)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first non-`none` result of applying the monadic function `f` to each element of the\narray, in order. Returns `none` if `f` returns `none` for all elements.\n\nExample:\n```lean example\n#eval #[7, 6, 5, 8, 1, 2, 6].findSomeM? fun i =&gt; do\n  if i &lt; 5 then\n    return some (i * 10)\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return none\n```\n```output\nAlmost! 6\nAlmost! 5\n```\n```output\nsome 10\n```\n</code>",
 "138": "<code>Type 2</code>",
 "1379":
 "<code>Lean.Order.Array.monotone_findSomeM?.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : Array α)\n  (hmono : monotone f) : monotone fun x =&gt; Array.findSomeM? (f x) xs</code>",
 "1378":
 "<code>Array.findRevM?.{w} {α : Type} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Array α) : m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the last element of the array for which the monadic predicate `p` returns `true`, or `none`\nif no such element is found. Elements of the array are checked in reverse, from right to left..\n\nThe monad `m` is restricted to `Type → Type` to avoid needing to use `ULift Bool` in `p`'s type.\n\nExample:\n```lean example\n#eval #[7, 5, 8, 1, 2, 6, 5, 8].findRevM? fun i =&gt; do\n  if i &lt; 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\n```\n```output\nAlmost! 5\nAlmost! 6\n```\n```output\nsome 2\n```\n</code>",
 "1377":
 "<code>Lean.Order.Array.monotone_findRevM?.{v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : Array α) (hmono : monotone f) :\n  monotone fun x =&gt; Array.findRevM? (f x) xs</code>",
 "1376":
 "<code>Array.findM?.{u_1} {m : Type → Type u_1} {α : Type} [Monad m] (p : α → m Bool) (as : Array α) : m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of the array for which the monadic predicate `p` returns `true`, or `none`\nif no such element is found. Elements of the array are checked in order.\n\nThe monad `m` is restricted to `Type → Type` to avoid needing to use `ULift Bool` in `p`'s type.\n\nExample:\n```lean example\n#eval #[7, 6, 5, 8, 1, 2, 6].findM? fun i =&gt; do\n  if i &lt; 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\n```\n```output\nAlmost! 6\nAlmost! 5\n```\n```output\nsome 1\n```\n</code>",
 "1375":
 "<code>Lean.Order.Array.monotone_findM?.{w} {γ : Type w} [PartialOrder γ] {m : Type → Type} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type} (f : γ → α → m Bool) (xs : Array α) (hmono : monotone f) :\n  monotone fun x =&gt; Array.findM? (f x) xs</code>",
 "1374":
 "<code>Array.findIdxM?.{u, u_1} {α : Type u} {m : Type → Type u_1} [Monad m] (p : α → m Bool) (as : Array α) : m (Option Nat)</code><span class=\"sep\"></span><code class=\"docstring\">Finds the index of the first element of an array for which the monadic predicate `p` returns `true`.\nElements are examined in order from left to right, and the search is terminated when an element that\nsatisfies `p` is found. If no such element exists in the array, then `none` is returned.\n</code>",
 "1373":
 "<code>Lean.Order.Array.monotone_findIdxM?.{u, v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type u} (f : γ → α → m Bool) (xs : Array α) (hmono : monotone f) :\n  monotone fun x =&gt; Array.findIdxM? (f x) xs</code>",
 "1372":
 "<code>Array.forRevM.{u, v, w} {α : Type u} {m : Type v → Type w} [Monad m] (f : α → m PUnit) (as : Array α)\n  (start : Nat := as.size) (stop : Nat := 0) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to each element of an array from right to left, in reverse order.\n\nThe optional parameters `start` and `stop` control the region of the array to which `f` should be\napplied. Iteration proceeds from `start` (exclusive) to `stop` (inclusive), so no `f` is not invoked\nunless `start &gt; stop`. By default, the entire array is used.\n</code>",
 "1371":
 "<code>Lean.Order.Array.monotone_array_forRevM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m PUnit) (xs : Array α) (start stop : Nat)\n  (hmono : monotone f) : monotone fun x =&gt; Array.forRevM (f x) xs start stop</code>",
 "1370":
 "<code>Array.forM.{u, v, w} {α : Type u} {m : Type v → Type w} [Monad m] (f : α → m PUnit) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to each element of an array, in order.\n\nThe optional parameters `start` and `stop` control the region of the array to which `f` should be\napplied. Iteration proceeds from `start` (inclusive) to `stop` (exclusive), so `f` is not invoked\nunless `start &lt; stop`. By default, the entire array is used.\n</code>",
 "137": "<code>Type 1</code>",
 "1369":
 "<code>Lean.Order.Array.monotone_array_forM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m PUnit) (xs : Array α) (start stop : Nat)\n  (hmono : monotone f) : monotone fun x =&gt; Array.forM (f x) xs start stop</code>",
 "1368":
 "<code>Array.filterMapM.{u, u_1, u_2} {α : Type u} {m : Type u_1 → Type u_2} {β : Type u_1} [Monad m] (f : α → m (Option β))\n  (as : Array α) (start : Nat := 0) (stop : Nat := as.size) : m (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies a monadic function that returns an `Option` to each element of an array, collecting the\nnon-`none` values.\n\nOnly elements from `start` (inclusive) to `stop` (exclusive) are considered. Elements outside that\nrange are discarded. By default, the entire array is considered.\n\nExample:\n```lean example\n#eval #[1, 2, 5, 2, 7, 7].filterMapM fun x =&gt; do\n  IO.println s!\"Examining {x}\"\n  if x &gt; 2 then return some (2 * x)\n  else return none\n```\n```output\nExamining 1\nExamining 2\nExamining 5\nExamining 2\nExamining 7\nExamining 7\n```\n```output\n#[10, 14, 14]\n```\n</code>",
 "1367":
 "<code>Lean.Order.Array.monotone_array_filterMapM.{u, v, w} {m : Type u → Type v} [Monad m] [(α : Type u) → PartialOrder (m α)]\n  [MonoBind m] {α β : Type u} {γ : Type w} [PartialOrder γ] (f : γ → α → m (Option β)) (xs : Array α)\n  (hmono : monotone f) : monotone fun x =&gt; Array.filterMapM (f x) xs</code>",
 "1366":
 "<code>Array.anyM.loop.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Array α) (stop : Nat)\n  (h : stop ≤ as.size) (j : Nat) : m Bool</code>",
 "1365":
 "<code>Lean.Order.Array.monotone_anyM_loop.{u, v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type u} (f : γ → α → m Bool) (xs : Array α) (stop : Nat)\n  (h : stop ≤ xs.size) (j : Nat) (hmono : monotone f) : monotone fun x =&gt; Array.anyM.loop (f x) xs stop h j</code>",
 "1364":
 "<code>Array.anyM.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the monadic predicate `p` returns `true` for any element of `as`.\n\nShort-circuits upon encountering the first `true`. The elements in `as` are examined in order from\nleft to right.\n\nThe optional parameters `start` and `stop` control the region of the array to be checked. Only the\nelements with indices from `start` (inclusive) to `stop` (exclusive) are checked. By default, the\nentire array is checked.\n</code>",
 "1363":
 "<code>Lean.Order.Array.monotone_anyM.{u, v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type u} (f : γ → α → m Bool) (xs : Array α) (start stop : Nat)\n  (hmono : monotone f) : monotone fun x =&gt; Array.anyM (f x) xs start stop</code>",
 "1362":
 "<code>Array.allM.{u, w} {α : Type u} {m : Type → Type w} [Monad m] (p : α → m Bool) (as : Array α) (start : Nat := 0)\n  (stop : Nat := as.size) : m Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the monadic predicate `p` returns `true` for every element of `as`.\n\nShort-circuits upon encountering the first `false`. The elements in `as` are examined in order from\nleft to right.\n\nThe optional parameters `start` and `stop` control the region of the array to be checked. Only the\nelements with indices from `start` (inclusive) to `stop` (exclusive) are checked. By default, the\nentire array is checked.\n</code>",
 "1361":
 "<code>Lean.Order.Array.monotone_allM.{u, v, w} {γ : Type w} [PartialOrder γ] {m : Type → Type v} [Monad m]\n  [(α : Type) → PartialOrder (m α)] [MonoBind m] {α : Type u} (f : γ → α → m Bool) (xs : Array α) (start stop : Nat)\n  (hmono : monotone f) : monotone fun x =&gt; Array.allM (f x) xs start stop</code>",
 "1360": "<code class=\"docstring\">monotonicity theorem</code>",
 "136": "<code>Type 5</code>",
 "1359":
 "<code>Lean.Order.monotone_const.{u, v} {α : Sort u} [PartialOrder α] {β : Sort v} [PartialOrder β] (c : β) :\n  monotone fun x =&gt; c</code>",
 "1358":
 "<code class=\"docstring\">`monotonicity` performs one compositional step solving `monotone` goals,\nusing lemma tagged with `@[partial_fixpoint_monotone]`.\n\nThis tactic is mostly used internally by lean in `partial_fixpoint` definitions, but\ncan be useful on its own for debugging or when proving new `@[partial_fixpoint_monotone]` lemmas.\n</code>",
 "1357":
 "<code>Lean.Order.FlatOrder.{u} {α : Sort u} (b : α) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">`FlatOrder b` wraps the type `α` with the flat partial order generated by `∀ x, b ⊑ x`.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1356":
 "<code>Lean.Order.FlatOrder.instCCPO.{u} {α : Sort u} {b : α} : CCPO (FlatOrder b)</code>",
 "1355":
 "<code>Lean.Order.instCCPOPi.{u, v} {α : Sort u} {β : α → Sort v} [(x : α) → CCPO (β x)] : CCPO ((x : α) → β x)</code>",
 "1354":
 "<code>Lean.Order.instCCPOOption.{u_1} {α : Type u_1} : CCPO (Option α)</code>",
 "1353":
 "<code>Lean.Order.monotone.{u, v} {α : Sort u} [PartialOrder α] {β : Sort v} [PartialOrder β] (f : α → β) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function is monotone if it maps related elements to related elements.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1352": "<code>monotone f</code>",
 "1351": "<code>α → α</code>",
 "1350":
 "<code>Lean.Order.fix_eq.{u} {α : Sort u} [CCPO α] {f : α → α} (hf : monotone f) : fix f hf = f (fix f hf)</code><span class=\"sep\"></span><code class=\"docstring\">The main fixpoint theorem for fixedpoints of monotone functions in chain-complete partial orders.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "135": "<code>P</code>",
 "1349":
 "<code>Lean.Order.fix.{u} {α : Sort u} [CCPO α] (f : α → α) (hmono : monotone f) : α</code><span class=\"sep\"></span><code class=\"docstring\">The least fixpoint of a monotone function is the least upper bound of its transfinite iteration.\n\nThe `monotone f` assumption is not strictly necessarily for the definition, but without this the\ndefinition is not very meaningful and it simplifies applying theorems like `fix_eq` if every use of\n`fix` already has the monotonicty requirement.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1348":
 "<code>Lean.Order.CCPO.csup.{u} {α : Sort u} [self : CCPO α] : (α → Prop) → α</code><span class=\"sep\"></span><code class=\"docstring\">The least upper bound of a chain.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1347":
 "<code>Lean.Order.chain.{u} {α : Sort u} [PartialOrder α] (c : α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A chain is a totally ordered set (representing a set as a predicate).\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1346":
 "<code>∀ {x : α} {c : α → Prop}, chain c → (CCPO.csup c ⊑ x ↔ ∀ (y : α), c y → y ⊑ x)</code>",
 "1345":
 "<code>(α → Prop) → α</code><span class=\"sep\"></span><code class=\"docstring\">The least upper bound of a chain.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1344":
 "<code>Lean.Order.CCPO.mk.{u} {α : Sort u} [toPartialOrder : PartialOrder α] (csup : (α → Prop) → α)\n  (csup_spec : ∀ {x : α} {c : α → Prop}, chain c → (csup c ⊑ x ↔ ∀ (y : α), c y → y ⊑ x)) : CCPO α</code>",
 "1343": "<code>∀ {x y : α}, x ⊑ y → y ⊑ x → x = y</code>",
 "1342": "<code>∀ {x y z : α}, x ⊑ y → y ⊑ z → x ⊑ z</code>",
 "1341":
 "<code>Lean.Order.PartialOrder.rel.{u} {α : Sort u} [self : PartialOrder α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">A “less-or-equal-to” or “approximates” relation.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1340": "<code>∀ {x : α}, x ⊑ x</code>",
 "134": "<code>Prop → Prop</code>",
 "1339":
 "<code>α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">A “less-or-equal-to” or “approximates” relation.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1338":
 "<code>Lean.Order.PartialOrder.mk.{u} {α : Sort u} (rel : α → α → Prop) (rel_refl : ∀ {x : α}, rel x x)\n  (rel_trans : ∀ {x y z : α}, rel x y → rel y z → rel x z) (rel_antisymm : ∀ {x y : α}, rel x y → rel y x → x = y) :\n  PartialOrder α</code>",
 "1337":
 "<code>Lean.Order.CCPO.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A chain-complete partial order (CCPO) is a partial order where every chain has a least upper bound.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1336":
 "<code>Lean.Order.PartialOrder.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A partial order is a reflexive, transitive and antisymmetric relation.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1335":
 "<code class=\"docstring\">This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n</code>",
 "1334": "<code>∃ x, ys[r']? = some x ∧ p x = true</code>",
 "1333":
 "<code class=\"docstring\">The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n</code>",
 "1332": "<code>r' + 1 = r</code>",
 "1331": "<code>findIndex ys = some r'</code>",
 "1330":
 "<code class=\"docstring\">The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n</code>",
 "133": "<code>Sort ?u.61</code>",
 "1329": "<code>∃ a, findIndex ys = some a ∧ a + 1 = r</code>",
 "1328":
 "<code>Option.map_eq_some'.{u_1, u_2} {α✝ : Type u_1} {b : α✝} {α✝¹ : Type u_2} {x : Option α✝¹} {f : α✝¹ → α✝} :\n  Option.map f x = some b ↔ ∃ a, x = some a ∧ f a = b</code>",
 "1327":
 "<code>Option.map_eq_map.{u_1} {α✝ α✝¹ : Type u_1} {f : α✝ → α✝¹} : Functor.map f = Option.map f</code>",
 "1326": "<code>(fun x =&gt; x + 1) &lt;$&gt; findIndex ys = some r</code>",
 "1325": "<code>¬p x = true</code>",
 "1324": "<code>some 0 = some r</code>",
 "1323": "<code>p x = true</code>",
 "1322":
 "<code>(if p x = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys) = some r</code>",
 "1321":
 "<code class=\"docstring\">`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n</code>",
 "1320":
 "<code class=\"docstring\">`next =&gt; tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ =&gt; tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n</code>",
 "132":
 "<code>Iff (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `↔` in identifiers is `iff`.\n\n * The recommended spelling of `&lt;-&gt;` in identifiers is `iff` (prefer `↔` over `&lt;-&gt;`).</code>",
 "1319":
 "<code>(if p x✝ = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys✝) = some r</code>",
 "1318": "<code>none = some r</code>",
 "1317":
 "<code>(match xs with\n  | [] =&gt; none\n  | x :: ys =&gt; if p x = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys) =\n  some r</code>",
 "1316":
 "<code>∀ (xs : List α) (r : Nat), findIndex xs = some r → ∃ x, xs[r]? = some x ∧ p x = true</code>",
 "1315":
 "<code>GetElem?.getElem?.{u, v, w} {coll : Type u} {idx : Type v} {elem : outParam (Type w)}\n  {valid : outParam (coll → idx → Prop)} [self : GetElem? coll idx elem valid] : coll → idx → Option elem</code><span class=\"sep\"></span><code class=\"docstring\">The syntax `arr[i]?` gets the `i`'th element of the collection `arr`,\nif it is present (and wraps it in `some`), and otherwise returns `none`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]?` in identifiers is `getElem?`.</code>",
 "1314":
 "<code>Exists.{u} {α : Sort u} (p : α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Existential quantification. If `p : α → Prop` is a predicate, then `∃ x : α, p x`\nasserts that there is some `x` of type `α` such that `p x` holds.\nTo create an existential proof, use the `exists` tactic,\nor the anonymous constructor notation `⟨x, h⟩`.\nTo unpack an existential, use `cases h` where `h` is a proof of `∃ x : α, p x`,\nor `let ⟨x, hx⟩ := h` where `.\n\nBecause Lean has proof irrelevance, any two proofs of an existential are\ndefinitionally equal. One consequence of this is that it is impossible to recover the\nwitness of an existential from the mere fact of its existence.\nFor example, the following does not compile:\n```\nexample (h : ∃ x : Nat, x = x) : Nat :=\n  let ⟨x, _⟩ := h  -- fail, because the goal is `Nat : Type`\n  x\n```\nThe error message `recursor 'Exists.casesOn' can only eliminate into Prop` means\nthat this only works when the current goal is another proposition:\n```\nexample (h : ∃ x : Nat, x = x) : True :=\n  let ⟨x, _⟩ := h  -- ok, because the goal is `True : Prop`\n  trivial\n```\n</code>",
 "1313":
 "<code>List.findIndex_implies_pred.{u_1} {α : Type u_1} {i : Nat} (xs : List α) (p : α → Bool) :\n  xs.findIndex p = some i → ∃ x, xs[i]? = some x ∧ p x = true</code>",
 "1312": "<code>List α → Option Nat</code>",
 "1311":
 "<code>∀ (findIndex : List α → Option Nat),\n  (∀ (xs : List α) (r : Nat), findIndex xs = some r → motive xs r) →\n    ∀ (xs : List α) (r : Nat),\n      (match xs with\n          | [] =&gt; none\n          | x :: ys =&gt; if p x = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys) =\n          some r →\n        motive xs r</code>",
 "1310": "<code>List α → Nat → Prop</code>",
 "131": "<code>Prop</code>",
 "1309":
 "<code>List.findIndex.partial_correctness.{u_1} {α : Type u_1} (p : α → Bool) (motive : List α → Nat → Prop)\n  (h :\n    ∀ (findIndex : List α → Option Nat),\n      (∀ (xs : List α) (r : Nat), findIndex xs = some r → motive xs r) →\n        ∀ (xs : List α) (r : Nat),\n          (match xs with\n              | [] =&gt; none\n              | x :: ys =&gt; if p x = true then some 0 else (fun x =&gt; x + 1) &lt;$&gt; findIndex ys) =\n              some r →\n            motive xs r)\n  (xs : List α) (r✝ : Nat) : xs.findIndex p = some r✝ → motive xs r✝</code>",
 "1308":
 "<code>Functor.map.{u, v} {f : Type u → Type v} [self : Functor f] {α β : Type u} : (α → β) → f α → f β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "1307":
 "<code>List.findIndex.{u_1} {α : Type u_1} (xs : List α) (p : α → Bool) : Option Nat</code>",
 "1306": "<code>List Tree</code>",
 "1305": "<code>Tree.rev' (t : Tree) : Option Tree</code>",
 "1304": "<code>Tree.mk (cs : List Tree) : Tree</code>",
 "1303": "<code>Tree</code>",
 "1302": "<code>Tree.rev (t : Tree) : Option Tree</code>",
 "1301": "<code>Tree.cs (self : Tree) : List Tree</code>",
 "1300": "<code>Tree : Type</code>",
 "130":
 "<code>propext {a b : Prop} : (a ↔ b) → a = b</code><span class=\"sep\"></span><code class=\"docstring\">The axiom of **propositional extensionality**. It asserts that if propositions\n`a` and `b` are logically equivalent (i.e. we can prove `a` from `b` and vice versa),\nthen `a` and `b` are *equal*, meaning that we can replace `a` with `b` in all\ncontexts.\n\nFor simple expressions like `a ∧ c ∨ d → e` we can prove that because all the logical\nconnectives respect logical equivalence, we can replace `a` with `b` in this expression\nwithout using `propext`. However, for higher order expressions like `P a` where\n`P : Prop → Prop` is unknown, or indeed for `a = b` itself, we cannot replace `a` with `b`\nwithout an axiom which says exactly this.\n\nThis is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using `#reduce` to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type `Nat` normalize to numerals,\nfails to hold when this (or any) axiom is used:\n```\nset_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True → True) ↔ True := ⟨λ _ =&gt; trivial, λ _ _ =&gt; trivial⟩\n  have := propext this ▸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x =&gt; True.intro, mpr := fun x =&gt; True.intro } ▸ 2\n\n#eval foo -- 2\n```\n`#eval` can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so `propext`, whose return type is a proposition,\ncan never block it.\n</code>",
 "13": "<code><span class=\"literal string\">\"two\"</span> : String</code>",
 "1299": "<code>ack (n m : Nat) : Option Nat</code>",
 "1298":
 "<code>List.mapM.{u, v, w} {m : Type u → Type v} [Monad m] {α : Type w} {β : Type u} (f : α → m β) (as : List α) : m (List β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to every element in the list, left-to-right, and returns the list of\nresults.\n\nThis implementation is tail recursive. `List.mapM'` is a a non-tail-recursive variant that may be\nmore convenient to reason about. `List.forM` is the variant that discards the results and\n`List.mapA` is the variant that works with `Applicative`.\n</code>",
 "1297":
 "<code>Bind.bind.{u, v} {m : Type u → Type v} [self : Bind m] {α β : Type u} : m α → (α → m β) → m β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "1296":
 "<code>Lean.Order.MonoBind.{u, v} (m : Type u → Type v) [Bind m] [(α : Type u) → PartialOrder (m α)] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">The class `MonoBind m` indicates that every `m α` has a `PartialOrder`, and that the bind operation\non `m` is monotone in both arguments with regard to that order.\n\nThis is intended to be used in the construction of `partial_fixpoint`, and not meant to be used otherwise.\n</code>",
 "1295":
 "<code>List.findIndex.{u_1} {α : Type u_1} (xs : List α) (p : α → Bool) : Int</code>",
 "1294":
 "<code>Array.find.{u_1} {α : Type u_1} (xs : Array α) (p : α → Bool) (i : Nat := 0) : Option α</code>",
 "1293": "<code>loop (x : Nat) : Nat</code>",
 "1292":
 "<code class=\"docstring\">Defines a possibly non-terminating function as a fixed-point in a suitable partial order.\n\nSuch a function is compiled as if it was marked `partial`, but its equations are provided as\ntheorems, so that it can be verified.\n\nIn general it accepts functions whose return type has a `Lean.Order.CCPO` instance and whose\ndefinition is `Lean.Order.monotone` with regard to its recursive calls.\n\nCommon special cases are\n\n* Functions whose type is inhabited a-priori (as with `partial`), and where all recursive\n  calls are in tail-call position.\n* Monadic in certain “monotone chain-complete monads” (in particular, `Option`) composed using\n  the bind operator and other supported monadic combinators.\n\nBy default, the monotonicity proof is performed by the compositional `monotonicity` tactic. Using\nthe syntax `partial_fixpoint monotonicity by $tac` the proof can be done manually.\n</code>",
 "1291": "<code>optParam Nat 0</code>",
 "1290": "<code>find (p : Nat → Bool) (i : Nat := 0) : Nat</code>",
 "129": "<code><span class=\"literal string\">\"and\"</span> : String</code>",
 "1289": "<code>Nat → Bool</code>",
 "1288":
 "<code>ite_eq_right_iff.{u_1} {α : Sort u_1} {p : Prop} [Decidable p] {x y : α} : (if p then x else y) = y ↔ p → x = y</code>",
 "1287":
 "<code>ite_false.{u_1} {α : Sort u_1} (a b : α) : (if False then a else b) = b</code>",
 "1286":
 "<code>dite_false.{u} {α : Sort u} {t : False → α} {e : ¬False → α} : dite False t e = e not_false</code>",
 "1285":
 "<code>div.eq2 {k n : Nat} : ¬k = 0 → ¬k &gt; n → div n k = 1 + div (n - k) k</code>",
 "1284": "<code>k ≤ n</code>",
 "1283": "<code>Nat.not_lt {a b : Nat} : ¬a &lt; b ↔ b ≤ a</code>",
 "1282":
 "<code>ite_eq_left_iff.{u_1} {α : Sort u_1} {p : Prop} [Decidable p] {x y : α} : (if p then x else y) = x ↔ ¬p → y = x</code>",
 "1281":
 "<code>dite_eq_ite.{u_1} {P : Prop} {α✝ : Sort u_1} {a b : α✝} [Decidable P] : (if x : P then a else b) = if P then a else b</code><span class=\"sep\"></span><code class=\"docstring\">A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. </code>",
 "1280":
 "<code>gt_iff_lt.{u_1} {α : Type u_1} [LT α] {x y : α} : x &gt; y ↔ y &lt; x</code>",
 "128": "<code><span class=\"literal string\">\"or\"</span> : String</code>",
 "1279": "<code>WellFoundedRelation.rel y n</code>",
 "1278":
 "<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>",
 "1277": "<code>div.eq1 {k n : Nat} : k &gt; n → div n k = 0</code>",
 "1276": "<code>div.proof_1 : WellFounded WellFoundedRelation.rel</code>",
 "1275": "<code>div.eq0 {n : Nat} : div n 0 = 0</code>",
 "1274":
 "<code class=\"docstring\">`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n</code>",
 "1273":
 "<code>GT.gt.{u} {α : Type u} [LT α] (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a &gt; b` is an abbreviation for `b &lt; a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;` in identifiers is `gt`.</code>",
 "1272": "<code>¬k &gt; n</code>",
 "1271": "<code>¬k = 0</code>",
 "1270": "<code>k &gt; n</code>",
 "127":
 "<code>String.take (s : String) (n : Nat) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a new string that contains the first `n` characters (Unicode code points) of `s`.\n\nIf `n` is greater than `s.length`, returns `s`.\n\nExamples:\n* `\"red green blue\".take 3 = \"red\"`\n* `\"red green blue\".take 1 = \"r\"`\n* `\"red green blue\".take 0 = \"\"`\n* `\"red green blue\".take 100 = \"red green blue\"`\n</code>",
 "1269": "<code>(y : Nat) → WellFoundedRelation.rel y n → Nat</code>",
 "1268":
 "<code>WellFoundedRelation.wf.{u} {α : Sort u} [self : WellFoundedRelation α] : WellFounded WellFoundedRelation.rel</code>",
 "1267":
 "<code>inferInstanceAs.{u} (α : Sort u) [i : α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`inferInstanceAs α` synthesizes a value of any target type by typeclass\ninference. This is just like `inferInstance` except that `α` is given\nexplicitly instead of being inferred from the target type. It is especially\nuseful when the target type is some `α'` which is definitionally equal to `α`,\nbut the instance we are looking for is only registered for `α` (because\ntypeclass search does not unfold most definitions, but definitional equality\ndoes.) Example:\n```\n#check inferInstanceAs (Inhabited Nat) -- Inhabited Nat\n```\n</code>",
 "1266": "<code>?m.3036</code>",
 "1265": "<code>∀ (y : α), r y x → Acc r y</code>",
 "1264": "<code>?m.2965</code>",
 "1263":
 "<code>Acc.{u} {α : Sort u} (r : α → α → Prop) : α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Acc` is the accessibility predicate. Given some relation `r` (e.g. `&lt;`) and a value `x`,\n`Acc r x` means that `x` is accessible through `r`:\n\n`x` is accessible if there exists no infinite sequence `... &lt; y₂ &lt; y₁ &lt; y₀ &lt; x`.\n</code>",
 "1262": "<code>∀ (a : α), Acc r a</code>",
 "1261":
 "<code>PSum.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">The disjoint union of arbitrary sorts `α` `β`, or `α ⊕' β`.\n\nIt differs from `α ⊕ β` in that it allows `α` and `β` to have arbitrary sorts `Sort u` and `Sort v`,\ninstead of restricting them to `Type u` and `Type v`. This means that it can be used in situations\nwhere one side is a proposition, like `True ⊕' Nat`. However, the resulting universe level\nconstraints are often more difficult to solve than those that result from `Sum`.\n</code>",
 "1260":
 "<code>WellFounded.fix_eq.{u, v} {α : Sort u} {C : α → Sort v} {r : α → α → Prop} (hwf : WellFounded r)\n  (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α) : hwf.fix F x = F x fun y x =&gt; hwf.fix F y</code>",
 "126":
 "<code>List.map.{u, v} {α : Type u} {β : Type v} (f : α → β) (l : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list, returning the resulting list of values.\n\n`O(|l|)`.\n\nExamples:\n* `[a, b, c].map f = [f a, f b, f c]`\n* `[].map Nat.succ = []`\n* `[\"one\", \"two\", \"three\"].map (·.length) = [3, 3, 5]`\n* `[\"one\", \"two\", \"three\"].map (·.reverse) = [\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "1259": "<code>WellFoundedRelation β</code>",
 "1258":
 "<code>PSigma.{u, v} {α : Sort u} (β : α → Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Fully universe-polymorphic dependent pairs, in which the second element's type depends on the value\nof the first element and both types are allowed to be propositions. The type `PSigma β` is typically\nwritten `Σ' a : α, β a` or `(a : α) ×' β a`.\n\nIn practice, this generality leads to universe level constraints that are difficult to solve, so\n`PSigma` is rarely used in manually-written code. It is usually only used in automation that\nconstructs pairs of arbitrary types.\n\nTo pair a value with a proof that a predicate holds for it, use `Subtype`. To demonstrate that a\nvalue exists that satisfies a predicate, use `Exists`. A dependent pair with a proposition as its\nfirst component is not typically useful due to proof irrelevance: there's no point in depending on a\nspecific proof because all proofs are equal anyway.\n</code>",
 "1257": "<code>(x : α) → ((y : α) → r y x → C y) → C x</code>",
 "1256": "<code>WellFounded r</code>",
 "1255":
 "<code>WellFounded.fix.{u, v} {α : Sort u} {C : α → Sort v} {r : α → α → Prop} (hwf : WellFounded r)\n  (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α) : C x</code>",
 "1254":
 "<code class=\"docstring\">`done` succeeds iff there are no remaining goals. </code>",
 "1253":
 "<code class=\"docstring\">`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n</code>",
 "1252":
 "<code>Lean.Parser.Category.tactic : Lean.Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`tactic` is the builtin syntax category for tactics. These appear after\n`by` in proofs, and they are programs that take in the proof context\n(the hypotheses in scope plus the type of the term to synthesize) and construct\na term of the expected type. For example, `simp` is a tactic, used in:\n```\nexample : 2 + 2 = 4 := by simp\n```\n</code>",
 "1251":
 "<code><span class=\"literal string\">\"sizeOf_pair_dec\"</span> : String</code>",
 "1250": "<code>Subtype P</code>",
 "125":
 "<code><span class=\"literal string\">\"android\"</span> : String</code>",
 "1249": "<code>Subtype P</code>",
 "1248": "<code>Pair (Subtype P)</code>",
 "1247":
 "<code>Pair.map_unattach.{u_1, u_2} {α : Type u_1} {β : Type u_2} {P : α → Prop} (p : Pair (Subtype P)) (f : α → β) :\n  map f p.unattach =\n    map\n      (fun x =&gt;\n        match x with\n        | ⟨x, h⟩ =&gt; binderNameHint x f (f (wfParam x)))\n      p</code>",
 "1246":
 "<code>Pair.map_wfParam.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (p : Pair α) :\n  map f (wfParam p) = map f p.attach.unattach</code>",
 "1245": "<code>sizeOf t' &lt; sizeOf p</code>",
 "1244": "<code>t' ∈ p</code>",
 "1243":
 "<code class=\"docstring\">The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n</code>",
 "1242": "<code>{ x // x ∈ p }</code>",
 "1241":
 "<code>Pair.unattach.{u_1} {α : Type u_1} {P : α → Prop} : Pair { x // P x } → Pair α</code>",
 "1240":
 "<code>Pair.attach.{u_1} {α : Type u_1} (p : Pair α) : Pair { x // x ∈ p }</code>",
 "124":
 "<code><span class=\"literal string\">\"orange\"</span> : String</code>",
 "1239": "<code>SizeOf α</code>",
 "1238": "<code>x ∈ p</code>",
 "1237":
 "<code>Pair.sizeOf_lt_of_mem.{u_1} {α : Type u_1} [SizeOf α] {p : Pair α} {x : α} (h : x ∈ p) : sizeOf x &lt; sizeOf p</code>",
 "1236":
 "<code>Pair α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.</code>",
 "1235":
 "<code>Membership.{u, v} (α : outParam (Type u)) (γ : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a ∈ s : Prop` where `a : α`, `s : γ`.\nBecause `α` is an `outParam`, the \"container type\" `γ` determines the type\nof the elements of the container.\n</code>",
 "1234":
 "<code>Pair.Mem.snd.{u_1} {α : Type u_1} {p : Pair α} : p.Mem p.snd</code>",
 "1233":
 "<code>Pair.Mem.fst.{u_1} {α : Type u_1} {p : Pair α} : p.Mem p.fst</code>",
 "1232": "<code>Pair.Mem.{u_1} {α : Type u_1} (p : Pair α) : α → Prop</code>",
 "1231": "<code>Pair (Tree α)</code>",
 "1230": "<code>Tree.node.{u} {α : Type u} : Pair (Tree α) → Tree α</code>",
 "123": "<code><span class=\"literal string\">\"c\"</span> : String</code>",
 "1229": "<code>Tree.leaf.{u} {α : Type u} : α → Tree α</code>",
 "1228":
 "<code>Tree.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A binary tree defined using `Pair` </code>",
 "1227":
 "<code>Tree.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) : Tree α → Tree β</code>",
 "1226": "<code>β</code>",
 "1225": "<code>Pair α</code>",
 "1224":
 "<code>Pair.map.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (p : Pair α) : Pair β</code><span class=\"sep\"></span><code class=\"docstring\">Mapping a function over the elements of a pair </code>",
 "1223":
 "<code>Pair.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A homogeneous pair </code>",
 "1222":
 "<code>trace.Elab.definition.wf</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "1221":
 "<code>wf.preprocess</code><span class=\"sep\"></span><code class=\"docstring\">pre-process definitions defined by well-founded recursion with the `wf_preprocess` simp set</code>",
 "1220": "<code>P x</code>",
 "122": "<code><span class=\"literal string\">\"b\"</span> : String</code>",
 "1219": "<code>List { x // P x }</code>",
 "1218":
 "<code>List.map_unattach.{u_1, u_2} {α : Type u_1} {β : Type u_2} (P : α → Prop) (xs : List (Subtype P)) (f : α → β) :\n  List.map f xs.unattach =\n    List.map\n      (fun x =&gt;\n        match x with\n        | ⟨x, h⟩ =&gt; binderNameHint x f (binderNameHint h () (f (wfParam x))))\n      xs</code>",
 "1217":
 "<code>List.unattach.{u_1} {α : Type u_1} {p : α → Prop} (l : List { x // p x }) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Maps a list of terms in a subtype to the corresponding terms in the type by forgetting that they\nsatisfy the predicate.\n\nThis is the inverse of `List.attachWith` and a synonym for `l.map (·.val)`.\n\nMostly this should not be needed by users. It is introduced as an intermediate step by lemmas such\nas `map_subtype`, and is ideally subsequently simplified away by `unattach_attach`.\n\nThis function is usually inserted automatically by Lean as an intermediate step while proving\ntermination. It is rarely used explicitly in code. It is introduced as an intermediate step during\nthe elaboration of definitions by [well-founded\nrecursion](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=well-founded-recursion). If this function is encountered in a proof\nstate, the right approach is usually the tactic `simp [List.unattach, -List.map_subtype]`.\n</code>",
 "1216":
 "<code>List.map_wfParam.{u_1, u_2} {α : Type u_1} {β : Type u_2} (xs : List α) (f : α → β) :\n  List.map f (wfParam xs) = List.map f xs.attach.unattach</code>",
 "1215": "<code>¬P</code>",
 "1214":
 "<code>binderNameHint.{u, v, w} {α : Sort u} {β : Sort v} {γ : Sort w} (v : α) (binder : β) (e : γ) : γ</code><span class=\"sep\"></span><code class=\"docstring\">The expression `binderNameHint v binder e` defined to be `e`.\n\nIf it is used on the right-hand side of an equation that is used for rewriting by `rw` or `simp`,\nand `v` is a local variable, and `binder` is an expression that (after beta-reduction) is a binder\n(`fun w =&gt; …` or `∀ w, …`), then it will rename `v` to the name used in that binder, and remove\nthe `binderNameHint`.\n\nA typical use of this gadget would be as follows; the gadget ensures that after rewriting, the local\nvariable is still `name`, and not `x`:\n```\ntheorem all_eq_not_any_not (l : List α) (p : α → Bool) :\n    l.all p = !l.any fun x =&gt; binderNameHint x p (!p x) := sorry\n\nexample (names : List String) : names.all (fun name =&gt; \"Waldo\".isPrefixOf name) = true := by\n  rw [all_eq_not_any_not]\n  -- ⊢ (!names.any fun name =&gt; !\"Waldo\".isPrefixOf name) = true\n```\n\nIf `binder` is not a binder, then the name of `v` attains a macro scope. This only matters when the\nresulting term is used in a non-hygienic way, e.g. in termination proofs for well-founded recursion.\n\nThis gadget is supported by\n* `simp`, `dsimp` and `rw` in the right-hand-side of an equation\n* `simp` in the assumptions of congruence rules\n\nIt is ineffective in other positions (hyptheses of rewrite rules) or when used by other tactics\n(e.g. `apply`).\n</code>",
 "1213":
 "<code>ite_eq_dite.{u_1} {P : Prop} {α✝ : Sort u_1} {a b : α✝} [Decidable P] :\n  (if P then a else b) = if h : P then binderNameHint h () a else binderNameHint h () b</code><span class=\"sep\"></span><code class=\"docstring\">Reverse direction of `dite_eq_ite`. Used by the well-founded definition preprocessor to extend the\ncontext of a termination proof inside `if-then-else` with the condition.\n</code>",
 "1212":
 "<code>List.attach.{u_1} {α : Type u_1} (l : List α) : List { x // x ∈ l }</code><span class=\"sep\"></span><code class=\"docstring\">“Attaches” the proof that the elements of `l` are in fact elements of `l`, producing a new list with\nthe same elements but in the subtype `{ x // x ∈ l }`.\n\n`O(1)`.\n\nThis function is primarily used to allow definitions by [well-founded\nrecursion](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=well-founded-recursion) that use higher-order functions (such as\n`List.map`) to prove that an value taken from a list is smaller than the list. This allows the\nwell-founded recursion mechanism to prove that the function terminates.\n</code>",
 "1211":
 "<code class=\"docstring\">In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n</code>",
 "1210":
 "<code class=\"docstring\">In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n</code>",
 "121": "<code><span class=\"literal string\">\"a\"</span> : String</code>",
 "1209":
 "<code class=\"docstring\">Theorems tagged with the `wf_preprocess` attribute are used during the processing of functions defined\nby well-founded recursion. They are applied to the function's body to add additional hypotheses,\nsuch as replacing `if c then _ else _` with `if h : c then _ else _` or `xs.map` with\n`xs.attach.map`. Also see `wfParam`.\n</code>",
 "1208":
 "<code class=\"docstring\">simp lemma used in the preprocessing of well-founded recursive function definitions, in particular to add additional hypotheses to the context. Also see `wfParam`.</code>",
 "1207":
 "<code>wfParam.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The `wfParam` gadget is used internally during the construction of recursive functions by\nwellfounded recursion, to keep track of the parameter for which the automatic introduction\nof `List.attach` (or similar) is plausible.\n</code>",
 "1206": "<code>f (n : Nat) : Nat</code>",
 "1205": "<code>g (n : Nat) : Nat</code>",
 "1204": "<code>notAck : Nat → Nat → Nat</code>",
 "1203": "<code>_fvar.122</code>",
 "1202": "<code>i &lt; j</code>",
 "1201": "<code>autoParam (j ≤ xs.size) _auto✝</code>",
 "1200":
 "<code>binarySearch.go (x : Int) (xs : Array Int) (i j : Nat) (hj : j ≤ xs.size := by omega) : Option Nat</code>",
 "120":
 "<code>Function.uncurry.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {φ : Sort u_3} : (α → β → φ) → α × β → φ</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a two-parameter function into an equivalent function from pairs.\n\nExamples:\n* `Function.uncurry List.drop (1, [\"a\", \"b\", \"c\"]) = [\"b\", \"c\"]`\n* `[(\"orange\", 2), (\"android\", 3) ].map (Function.uncurry String.take) = [\"or\", \"and\"]`\n</code>",
 "12":
 "<code>Nat.succ (n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The successor of a natural number `n`.\n\nUsing `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal\nform](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "1199": "<code>Array Int</code>",
 "1198": "<code>binarySearch (x : Int) (xs : Array Int) : Option Nat</code>",
 "1197": "<code>f (n m l : Nat) : Nat</code>",
 "1196":
 "<code>Prod.instWellFoundedRelation.{u, v} {α : Type u} {β : Type v} [ha : WellFoundedRelation α]\n  [hb : WellFoundedRelation β] : WellFoundedRelation (α × β)</code>",
 "1195":
 "<code>PSigma.casesOn.{u_1, u, v} {α : Sort u} {β : α → Sort v} {motive : PSigma β → Sort u_1} (t : PSigma β)\n  (mk : (fst : α) → (snd : β fst) → motive ⟨fst, snd⟩) : motive t</code>",
 "1194":
 "<code>invImage.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} (f : α → β) (h : WellFoundedRelation β) : WellFoundedRelation α</code>",
 "1193": "<code>(_ : Nat) ×' Nat</code>",
 "1192":
 "<code>(y : (_ : Nat) ×' Nat) →\n  (invImage (fun x =&gt; PSigma.casesOn x fun a a_1 =&gt; (a, a_1)) Prod.instWellFoundedRelation).1 y ⟨m.succ, n.succ⟩ → Nat</code>",
 "1191":
 "<code>HDiv.hDiv.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HDiv α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 ≤ a % b &lt; natAbs b` for `b ≠ 0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.tdiv` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/` in identifiers is `div`.</code>",
 "1190":
 "<code>Nat.lt (n m : Nat) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Strict inequality of natural numbers, usually accessed via the `&lt;` operator.\n\nIt is defined as `n &lt; m = n + 1 ≤ m`.\n</code>",
 "119": "<code><span class=\"literal string\">\"five\"</span> : String</code>",
 "1189": "<code>a₁ ≤ a₂</code>",
 "1188":
 "<code>Prod.Lex.right'.{v} {β : Type v} (rb : β → β → Prop) {a₂ : Nat} {b₂ : β} {a₁ : Nat} {b₁ : β} (h₁ : a₁ ≤ a₂)\n  (h₂ : rb b₁ b₂) : Prod.Lex Nat.lt rb (a₁, b₁) (a₂, b₂)</code>",
 "1187": "<code>instOfNatNat 0</code>",
 "1186": "<code>synack : Nat → Nat → Nat</code>",
 "1185":
 "<code>Prod.Lex.{u, v} {α : Type u} {β : Type v} (ra : α → α → Prop) (rb : β → β → Prop) : α × β → α × β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">A lexicographical order based on the orders `ra` and `rb` for the elements of pairs.\n</code>",
 "1184": "<code>rb b₁ b₂</code>",
 "1183": "<code>β → β → Prop</code>",
 "1182": "<code>Prod.instWellFoundedRelation</code>",
 "1181": "<code>ack : Nat → Nat → Nat</code>",
 "1180":
 "<code>String.Iterator.sizeOf_next_lt_of_atEnd (i : String.Iterator) (h : ¬i.atEnd = true) : sizeOf i.next &lt; sizeOf i</code>",
 "118":
 "<code>Prod.swap.{u_1, u_2} {α : Type u_1} {β : Type u_2} : α × β → β × α</code><span class=\"sep\"></span><code class=\"docstring\">Swaps the elements in a pair.\n\nExamples:\n* `(1, 2).swap = (2, 1)`\n* `(\"orange\", -87).swap = (-87, \"orange\")`\n</code>",
 "1179":
 "<code>String.Iterator.sizeOf_next_lt_of_hasNext (i : String.Iterator) (h : i.hasNext = true) : sizeOf i.next &lt; sizeOf i</code>",
 "1178":
 "<code class=\"docstring\">This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a &lt; sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. </code>",
 "1177":
 "<code class=\"docstring\">This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a &lt; sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. </code>",
 "1176":
 "<code class=\"docstring\">This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] &lt; sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. </code>",
 "1175": "<code>Nat.pred_lt {n : Nat} : n ≠ 0 → n.pred &lt; n</code>",
 "1174":
 "<code>Nat.pred_lt_of_lt {n m : Nat} (h : m &lt; n) : n.pred &lt; n</code>",
 "1173":
 "<code>Nat.sub_succ_lt_self (a i : Nat) (h : i &lt; a) : a - (i + 1) &lt; a - i</code>",
 "1172":
 "<code class=\"docstring\">`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n</code>",
 "1171":
 "<code>Prod.Lex.left.{u, v} {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} {a₁ : α} (b₁ : β) {a₂ : α}\n  (b₂ : β) (h : ra a₁ a₂) : Prod.Lex ra rb (a₁, b₁) (a₂, b₂)</code><span class=\"sep\"></span><code class=\"docstring\">If the first projections of two pairs are ordered, then they are lexicographically ordered.\n</code>",
 "1170":
 "<code>Prod.Lex.right.{u, v} {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} (a : α) {b₁ b₂ : β}\n  (h : rb b₁ b₂) : Prod.Lex ra rb (a, b₁) (a, b₂)</code><span class=\"sep\"></span><code class=\"docstring\">If the first projections of two pairs are equal, then they are lexicographically ordered if the\nsecond projections are ordered.\n</code>",
 "117":
 "<code>Function.curry.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {φ : Sort u_3} : (α × β → φ) → α → β → φ</code><span class=\"sep\"></span><code class=\"docstring\">Transforms a function from pairs into an equivalent two-parameter function.\n\nExamples:\n* `Function.curry (fun (x, y) =&gt; x + y) 3 5 = 8`\n* `Function.curry Prod.swap 3 \"five\" = (\"five\", 3)`\n</code>",
 "1169":
 "<code class=\"docstring\">`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). </code>",
 "1168":
 "<code>List.myMap.{u_1, u_2} {α : Type u_1} {β : Type u_2} (f : α → β) (l : List α) : List β</code>",
 "1167": "<code>x ∈ xs</code>",
 "1166":
 "<code>List.sum.{u_1} {α : Type u_1} [Add α] [Zero α] : List α → α</code><span class=\"sep\"></span><code class=\"docstring\">Computes the sum of the elements of a list.\n\nExamples:\n* `[a, b, c].sum = a + (b + (c + 0))`\n* `[1, 2, 5].sum = 8`\n</code>",
 "1165": "<code>f (n : Nat) (xs : List Nat) : Nat</code>",
 "1164": "<code>Nat.zero_lt_one : 0 &lt; 1</code>",
 "1163": "<code>0 &lt; 1</code>",
 "1162":
 "<code>Membership.mem.{u, v} {α : outParam (Type u)} {γ : Type v} [self : Membership α γ] : γ → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.</code>",
 "1161": "<code>i ∈ { stop := xs.size, step_pos := Nat.zero_lt_one }</code>",
 "1160":
 "<code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "116":
 "<code>Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`.</code>",
 "1159":
 "<code>Array.take.{u} {α : Type u} (xs : Array α) (i : Nat) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Returns a new array that contains the first `i` elements of `xs`. If `xs` has fewer than `i`\nelements, the new array contains all the elements of `xs`.\n\nThe returned array is always a new array, even if it contains the same elements as the input array.\n\nExamples:\n* `#[\"red\", \"green\", \"blue\"].take 1 = #[\"red\"]`\n* `#[\"red\", \"green\", \"blue\"].take 2 = #[\"red\", \"green\"]`\n* `#[\"red\", \"green\", \"blue\"].take 5 = #[\"red\", \"green\", \"blue\"]`\n</code>",
 "1158":
 "<code class=\"docstring\">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.\n`break` and `continue` are supported inside `for` loops.\n`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,\nuntil at least one of them is exhausted.\nThe types of `e2` etc. must implement the `ToStream` typeclass.\n</code>",
 "1157":
 "<code>Array.sum.{u_1} {α : Type u_1} [Add α] [Zero α] : Array α → α</code><span class=\"sep\"></span><code class=\"docstring\">Computes the sum of the elements of an array.\n\nExamples:\n* `#[a, b, c].sum = a + (b + (c + 0))`\n* `#[1, 2, 5].sum = 8`\n</code>",
 "1156":
 "<code>Id.run.{u_1} {α : Type u_1} (x : Id α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Runs a computation in the identity monad.\n\nThis function is the identity function. Because its parameter has type `Id α`, it causes\n`do`-notation in its arguments to use the `Monad Id` instance.\n</code>",
 "1155": "<code>f (xs : Array Nat) : Nat</code>",
 "1154": "<code>Std.Range : Type</code>",
 "1153": "<code>¬n ≤ 1</code>",
 "1152": "<code class=\"docstring\">`skip` does nothing. </code>",
 "1151": "<code>n ≤ 1</code>",
 "1150":
 "<code class=\"docstring\">\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h =&gt; t(h)) (fun h =&gt; e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i &lt; arr.size` in order to\navoid a bounds check, so you can write `if h : i &lt; arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i &lt; arr.size` from some other proposition that we are checking in the `if`.)\n</code>",
 "115": "<code>Sort u_3</code>",
 "1149": "<code>fib (n : Nat) : Nat</code>",
 "1148":
 "<code class=\"docstring\">Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) =&gt; `(tactic| linarith)\n```\n</code>",
 "1147": "<code>β p₁</code>",
 "1146": "<code>β a₁</code>",
 "1145": "<code>(x : α) → β x → β' → γ</code>",
 "1144":
 "<code>default.sizeOf.{u} (α : Sort u) : α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Every type `α` has a default `SizeOf` instance that just returns `0`\nfor every element of `α`.\n</code>",
 "1143":
 "<code class=\"docstring\">Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n</code>",
 "1142": "<code>Bool → Bool</code>",
 "1141": "<code>fooInst (b : Bool → Bool) : Unit</code>",
 "1140":
 "<code>instSizeOfDefault.{u} (α : Sort u) : SizeOf α</code><span class=\"sep\"></span><code class=\"docstring\">Every type `α` has a low priority default `SizeOf` instance that just returns `0`\nfor every element of `α`.\n</code>",
 "114": "<code>Type u_2</code>",
 "1139": "<code>γ</code>",
 "1138":
 "<code>SizeOf.sizeOf.{u} {α : Sort u} [self : SizeOf α] : α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The \"size\" of an element, a natural number which decreases on fields of\neach inductive type. </code>",
 "1137":
 "<code>WellFoundedRelation.rel.{u} {α : Sort u} [self : WellFoundedRelation α] : α → α → Prop</code>",
 "1136":
 "<code>WellFounded.{u} {α : Sort u} (r : α → α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A relation `r` is `WellFounded` if all elements of `α` are accessible within `r`.\nIf a relation is `WellFounded`, it does not allow for an infinite descent along the relation.\n\nIf the arguments of the recursive calls in a function definition decrease according to\na well founded relation, then the function terminates.\nWell-founded relations are sometimes called _Artinian_ or said to satisfy the “descending chain condition”.\n</code>",
 "1135": "<code>WellFounded WellFoundedRelation.rel</code>",
 "1134": "<code>α → α → Prop</code>",
 "1133":
 "<code>WellFoundedRelation.mk.{u} {α : Sort u} (rel : α → α → Prop) (wf : WellFounded rel) : WellFoundedRelation α</code>",
 "1132": "<code>WellFoundedRelation.{u} (α : Sort u) : Sort (max 1 u)</code>",
 "1131": "<code>div (n k : Nat) : Nat</code>",
 "1130": "<code>Nat.below n</code>",
 "113":
 "<code><span class=\"literal string\">\"any string\"</span> : String</code>",
 "1129": "<code>half'' : Nat → Nat</code>",
 "1128": "<code>(fun x =&gt; Nat) 1</code>",
 "1127": "<code>(fun x =&gt; Nat) Nat.zero</code>",
 "1126": "<code>half' : Nat → Nat</code>",
 "1125": "<code>(n : Nat) → motive n.succ.succ</code>",
 "1124": "<code>Unit → motive 1</code>",
 "1123": "<code>Unit → motive Nat.zero</code>",
 "1122":
 "<code>half.match_1'.{u} (motive : Nat → Sort u) (x : Nat) :\n  (Unit → motive Nat.zero) → (Unit → motive 1) → ((n : Nat) → motive n.succ.succ) → motive x</code>",
 "1121":
 "<code>half.match_1.{u_1} (motive : Nat → Sort u_1) (x✝ : Nat) (h_1 : Unit → motive Nat.zero) (h_2 : Unit → motive 1)\n  (h_3 : (n : Nat) → motive n.succ.succ) : motive x✝</code>",
 "1120":
 "<code>pp.all</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display coercions, implicit parameters, proof terms, fully qualified names, universe, and disable beta reduction and notations during pretty printing</code>",
 "112": "<code>β</code>",
 "1119":
 "<code>trace.Elab.definition.body</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "1118":
 "<code>Tree.brecOn'.{u} {α : Type u} {motive : Tree α → Sort u} (t : Tree α) (step : (ys : Tree α) → below' ys → motive ys) :\n  motive t</code>",
 "1117":
 "<code>List.brecOn'.{u} {α : Type u} {motive : List α → Sort u} (xs : List α) (step : (ys : List α) → below' ys → motive ys) :\n  motive xs</code>",
 "1116": "<code>below' (left.branch val✝ right)</code>",
 "1115": "<code>motive (left.branch val✝ right)</code>",
 "1114": "<code>below' (left.branch val right)</code>",
 "1113": "<code>motive right ×' below' right</code>",
 "1112": "<code>motive left ×' below' left</code>",
 "1111": "<code>(ys : Tree α) → below' ys → motive ys</code>",
 "1110":
 "<code>Tree.brecOnTable.{u} {α : Type u} {motive : Tree α → Sort u} (t : Tree α)\n  (step : (ys : Tree α) → below' ys → motive ys) : motive t ×' below' t</code>",
 "111":
 "<code>Function.const.{u, v} {α : Sort u} (β : Sort v) (a : α) : β → α</code><span class=\"sep\"></span><code class=\"docstring\">The constant function that ignores its argument.\n\nIf `a : α`, then `Function.const β a : β → α` is the “constant function with value `a`”. For all\narguments `b : β`, `Function.const β a b = a`.\n\nExamples:\n * `Function.const Bool 10 true = 10`\n * `Function.const Bool 10 false = 10`\n * `Function.const String 10 \"any string\" = 10`\n</code>",
 "1109": "<code>motive (x :: xs)</code>",
 "1108": "<code>motive xs ×' below' xs</code>",
 "1107":
 "<code>PUnit.unit.{u} : PUnit</code><span class=\"sep\"></span><code class=\"docstring\">The only element of the universe-polymorphic unit type. </code>",
 "1106":
 "<code>PProd.mk.{u, v} {α : Sort u} {β : Sort v} (fst : α) (snd : β) : α ×' β</code>",
 "1105": "<code>(ys : List α) → below' ys → motive ys</code>",
 "1104":
 "<code>List.brecOnTable.{u} {α : Type u} {motive : List α → Sort u} (xs : List α)\n  (step : (ys : List α) → below' ys → motive ys) : motive xs ×' below' xs</code>",
 "1103":
 "<code>Tree.brecOnTable.{u} {α : Type u} {motive : Tree α → Sort u} (t : Tree α)\n  (step : (ys : Tree α) → Tree.below' ys → motive ys) : motive t ×' Tree.below' t</code>",
 "1102":
 "<code>List.brecOnTable.{u} {α : Type u} {motive : List α → Sort u} (xs : List α)\n  (step : (ys : List α) → List.below' ys → motive ys) : motive xs ×' List.below' xs</code>",
 "1101":
 "<code>Tree.brecOn.{u_1, u} {α : Type u} {motive : Tree α → Sort u_1} (t : Tree α)\n  (F_1 : (t : Tree α) → Tree.below t → motive t) : motive t</code>",
 "1100":
 "<code>List.brecOn.{u_1, u} {α : Type u} {motive : List α → Sort u_1} (t : List α)\n  (F_1 : (t : List α) → List.below t → motive t) : motive t</code>",
 "110":
 "<code>List.drop.{u} {α : Type u} (n : Nat) (xs : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Removes the first `n` elements of the list `xs`. Returns the empty list if `n` is greater than the\nlength of the list.\n\n`O(min n |xs|)`.\n\nExamples:\n* `[0, 1, 2, 3, 4].drop 0 = [0, 1, 2, 3, 4]`\n* `[0, 1, 2, 3, 4].drop 3 = [3, 4]`\n* `[0, 1, 2, 3, 4].drop 6 = []`\n</code>",
 "11":
 "<code class=\"docstring\">The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n</code>",
 "1099": "<code>Tree α → Sort u</code>",
 "1098":
 "<code>Tree.below'.{u} {α : Type u} {motive : Tree α → Sort u} : Tree α → Sort (max 1 u)</code>",
 "1097": "<code>Tree α</code>",
 "1096":
 "<code>Tree.branch.{u} {α : Type u} (left : Tree α) (val : α) (right : Tree α) : Tree α</code>",
 "1095": "<code>Tree.leaf.{u} {α : Type u} : Tree α</code>",
 "1094":
 "<code>List.below'.{u} {α : Type u} {motive : List α → Sort u} : List α → Sort (max 1 u)</code>",
 "1093":
 "<code>List.below.{u_1, u} {α : Type u} {motive : List α → Sort u_1} (t : List α) : Sort (max 1 u_1)</code>",
 "1092": "<code>Nat.below x✝.succ.succ</code>",
 "1091": "<code>half''' (n : Nat) : Nat</code>",
 "1090":
 "<code>Nat.casesOn.{u} {motive : Nat → Sort u} (t : Nat) (zero : motive Nat.zero) (succ : (n : Nat) → motive n.succ) : motive t</code>",
 "109":
 "<code>List.reverse.{u} {α : Type u} (as : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Reverses a list.\n\n`O(|as|)`.\n\nBecause of the “functional but in place” optimization implemented by Lean's compiler, this function\ndoes not allocate a new list when its reference to the input list is unshared: it simply walks the\nlinked list and reverses all the node pointers.\n\nExamples:\n* `[1, 2, 3, 4].reverse = [4, 3, 2, 1]`\n* `[].reverse = []`\n</code>",
 "1089": "<code>(fun x =&gt; Nat) (n✝ + 2)</code>",
 "1088": "<code>(fun x =&gt; Nat) n✝</code>",
 "1087": "<code>(fun x =&gt; Nat) 0</code>",
 "1086": "<code>Nat.below k</code>",
 "1085": "<code>half'' (n : Nat) : Nat</code>",
 "1084":
 "<code>Nat.brecOn.{u} {motive : Nat → Sort u} (t : Nat) (F_1 : (t : Nat) → Nat.below t → motive t) : motive t</code>",
 "1083": "<code>Nat → Sort u</code>",
 "1082":
 "<code>Nat.below.{u} {motive : Nat → Sort u} (t : Nat) : Sort (max 1 u)</code>",
 "1081": "<code>half' (n : Nat) : Nat</code>",
 "1080": "<code>(fun x =&gt; Bool → Nat) x✝</code>",
 "108":
 "<code>Function.comp.{u, v, w} {α : Sort u} {β : Sort v} {δ : Sort w} (f : β → δ) (g : α → β) : α → δ</code><span class=\"sep\"></span><code class=\"docstring\">Function composition, usually written with the infix operator `∘`. A new function is created from\ntwo existing functions, where one function's output is used as input to the other.\n\nExamples:\n * `Function.comp List.reverse (List.drop 2) [3, 2, 4, 1] = [1, 4]`\n * `(List.reverse ∘ List.drop 2) [3, 2, 4, 1] = [1, 4]`\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∘` in identifiers is `comp`.</code>",
 "1079": "<code>helper : Nat → Bool → Nat</code>",
 "1078": "<code>(fun x =&gt; Nat) k</code>",
 "1077": "<code>add' (n t : Nat) : (fun x =&gt; Nat) t</code>",
 "1076":
 "<code>Nat.zero : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Zero, the smallest natural number.\n\nUsing `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the\n[simp normal form](https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "1075": "<code>add (n : Nat) : Nat → Nat</code>",
 "1074": "<code>App.numArgs : App → Nat</code>",
 "1073": "<code>Exp</code>",
 "1072": "<code>App</code>",
 "1071": "<code>App.app : App → Exp → App</code>",
 "1070": "<code>App.fn : String → App</code>",
 "107": "<code>α → β</code>",
 "1069": "<code>App : Type</code>",
 "1068": "<code>Exp.app : App → Exp</code>",
 "1067": "<code>Exp.var : String → Exp</code>",
 "1066": "<code>Exp : Type</code>",
 "1065": "<code>App.size : App → Nat</code>",
 "1064": "<code>Exp.size : Exp → Nat</code>",
 "1063": "<code>odd : Nat → Prop</code>",
 "1062": "<code>even : Nat → Prop</code>",
 "1061": "<code>min' (nk : Nat × Nat) : Nat</code>",
 "1060": "<code>instHAdd</code>",
 "106": "<code>β → δ</code>",
 "1059": "<code>min' (n k : Nat) : Nat</code>",
 "1058": "<code>listLen.{u} {α : Type u} : List α → Nat</code>",
 "1057":
 "<code>List.tail.{u} {α : Type u} : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Drops the first element of a nonempty list, returning the tail. Returns `[]` when the argument is\nempty.\n\nExamples:\n * `[\"apple\", \"banana\", \"grape\"].tail = [\"banana\", \"grape\"]`\n * `[\"apple\"].tail = []`\n * `([] : List String).tail = []`\n</code>",
 "1056": "<code>n = n' + 1 + 1</code>",
 "1055":
 "<code class=\"docstring\">Manually prove that the termination measure (as specified with `termination_by` or inferred)\ndecreases at each recursive call.\n\nBy default, the tactic `decreasing_tactic` is used.\n\nForces the use of well-founded recursion and is hence incompatible with\n`termination_by structural`.\n</code>",
 "1054": "<code>some n = some n'.succ.succ</code>",
 "1053": "<code>fib : Nat → Nat</code>",
 "1052": "<code>WithParam' p n</code>",
 "1051":
 "<code>WithParam'.succ {p n : Nat} : WithParam' p n → WithParam' p (n + 1)</code>",
 "1050": "<code>WithParam'.zero {p n : Nat} : WithParam' p (n + 1)</code>",
 "105": "<code>Sort w</code>",
 "1049": "<code>WithParam' (p : Nat) : Nat → Type</code>",
 "1048": "<code>afterVarying (n p : Nat) (x : WithParam' p n) : Nat</code>",
 "1047": "<code>Fin' 100</code>",
 "1046": "<code>Fin'.succ {n : Nat} : Fin' n → Fin' (n + 1)</code>",
 "1045": "<code>Fin'.zero {n : Nat} : Fin' (n + 1)</code>",
 "1044": "<code>Fin' : Nat → Type</code>",
 "1043": "<code>constantIndex (x : Fin' 100) : Nat</code>",
 "1042": "<code>Nat → Nat</code>",
 "1041": "<code>notInductive (x : Nat → Nat) : Nat</code>",
 "1040": "<code>half : Nat → Nat</code>",
 "104": "<code>Sort v</code>",
 "1039":
 "<code class=\"docstring\">Specify a termination measure for recursive functions.\n```\ntermination_by a - b\n```\nindicates that termination of the currently defined recursive function follows\nbecause the difference between the arguments `a` and `b` decreases.\n\nIf the function takes further argument after the colon, you can name them as follows:\n```\ndef example (a : Nat) : Nat → Nat → Nat :=\ntermination_by b c =&gt; a - b\n```\n\nBy default, a `termination_by` clause will cause the function to be constructed using well-founded\nrecursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)\nindicates the function is expected to be structural recursive on the argument. In this case\nthe body of the `termination_by` clause must be one of the function's parameters.\n\nIf omitted, a termination measure will be inferred. If written as `termination_by?`,\nthe inferrred termination measure will be suggested.\n\n</code>",
 "1038": "<code>half (n : Nat) : Nat</code>",
 "1037": "<code>countdown' (n : Nat) : List Nat</code>",
 "1036": "<code>countdown (n : Nat) : List Nat</code>",
 "1035": "<code>identity.{u_1} {β : Sort u_1} (x : β) : β</code>",
 "1034": "<code>identity.{u_1} (x : sorry) : sorry</code>",
 "1033": "<code>α.{u_1} : Type</code>",
 "1032": "<code>NaturalNum</code>",
 "1031": "<code>n : NaturalNum</code>",
 "1030": "<code>NaturalNum : Type</code>",
 "103":
 "<code>Char : Type</code><span class=\"sep\"></span><code class=\"docstring\">Characters are Unicode [scalar values](http://www.unicode.org/glossary/#unicode_scalar_value).\n</code>",
 "1029": "<code>n.{u_1} : sorry</code>",
 "1028": "<code>NaturalNum.{u_1} : Type</code>",
 "1027":
 "<code>isExclusiveUnsafe.{u} {α : Type u} (a : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if `a` is an exclusive object.\nWe say an object is exclusive if it is single-threaded and its reference counter is 1.\n</code>",
 "1026": "<code>ptrAddrUnsafe.{u} {α : Type u} (a : α) : USize</code>",
 "1025":
 "<code>unsafeCast.{u, v} {α : Sort u} {β : Sort v} (a : α) : β</code><span class=\"sep\"></span><code class=\"docstring\">This function will cast a value of type `α` to type `β`, and is a no-op in the\ncompiler. This function is **extremely dangerous** because there is no guarantee\nthat types `α` and `β` have the same data representation, and this can lead to\nmemory unsafety. It is also logically unsound, since you could just cast\n`True` to `False`. For all those reasons this function is marked as `unsafe`.\n\nIt is implemented by lifting both `α` and `β` into a common universe, and then\nusing `cast (lcProof : ULift (PLift α) = ULift (PLift β))` to actually perform\nthe cast. All these operations are no-ops in the compiler.\n\nUsing this function correctly requires some knowledge of the data representation\nof the source and target types. Some general classes of casts which are safe in\nthe current runtime:\n\n* `Array α` to `Array β` where `α` and `β` have compatible representations,\n  or more generally for other inductive types.\n* `Quot α r` and `α`.\n* `@Subtype α p` and `α`, or generally any structure containing only one\n  non-`Prop` field of type `α`.\n* Casting `α` to/from `NonScalar` when `α` is a boxed generic type\n  (i.e. a function that accepts an arbitrary type `α` and is not specialized to\n  a scalar type like `UInt8`).\n</code>",
 "1024":
 "<code>Nat.rec.{u} {motive : Nat → Sort u} (zero : motive Nat.zero) (succ : (n : Nat) → motive n → motive n.succ) (t : Nat) :\n  motive t</code>",
 "1023":
 "<code>Empty.rec.{u} (motive : Empty → Sort u) (t : Empty) : motive t</code>",
 "1022":
 "<code>CoeTC.mk.{u, v} {α : Sort u} {β : Sort v} (coe : α → β) : CoeTC α β</code>",
 "1021":
 "<code>CoeOTC.mk.{u, v} {α : Sort u} {β : Sort v} (coe : α → β) : CoeOTC α β</code>",
 "1020":
 "<code>CoeHTC.mk.{u, v} {α : Sort u} {β : Sort v} (coe : α → β) : CoeHTC α β</code>",
 "102": "<code>Array Char</code>",
 "1019":
 "<code>CoeHTCT.mk.{u, v} {α : Sort u} {β : Sort v} (coe : α → β) : CoeHTCT α β</code>",
 "1018":
 "<code>CoeHTCT.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary class implementing `CoeHead* Coe* CoeTail?`.\nUsers should generally not implement this directly.\n</code>",
 "1017":
 "<code>CoeHTC.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary class implementing `CoeHead CoeOut* Coe*`.\nUsers should generally not implement this directly.\n</code>",
 "1016":
 "<code>CoeOTC.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary class implementing `CoeOut* Coe*`.\nUsers should generally not implement this directly.\n</code>",
 "1015":
 "<code>CoeTC.{u, v} (α : Sort u) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary class implementing `Coe*`.\nUsers should generally not implement this directly.\n</code>",
 "1014":
 "<code class=\"docstring\">auxiliary definition used to implement coercion (unfolded during elaboration)</code>",
 "1013": "<code>Tm [] α''</code>",
 "1012":
 "<code>Tm [] α'' → α''.interp</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "1011": "<code>Fin α''.length</code>",
 "1010": "<code>Tm α'' t✝</code>",
 "101": "<code>thirdChar (xs : Array Char) : Char</code>",
 "1009": "<code>Tm α'' (t✝.arr t)</code>",
 "1008": "<code>t✝.interp</code>",
 "1007": "<code>Tm (t✝ :: α'') t'✝</code>",
 "1006": "<code>(Ty.nat.arr (t.arr t)).interp</code>",
 "1005": "<code>Tm α'' (Ty.nat.arr (t.arr t))</code>",
 "1004": "<code>Tm α'' t</code>",
 "1003": "<code>Tm α'' Ty.nat</code>",
 "1002": "<code>Ty.nat.interp</code>",
 "1001": "<code>Env α''</code>",
 "1000":
 "<code>Tm.interp {α'' : List Ty} {t : Ty} (ρ : Env α'') : Tm α'' t → t.interp</code>",
 "100":
 "<code>Inhabited.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">`Inhabited α` is a typeclass that says that `α` has a designated element,\ncalled `(default : α)`. This is sometimes referred to as a \"pointed type\".\n\nThis class is used by functions that need to return a value of the type\nwhen called \"out of domain\". For example, `Array.get! arr i : α` returns\na value of type `α` when `arr : Array α`, but if `i` is not in range of\nthe array, it reports a panic message, but this does not halt the program,\nso it must still return a value of type `α` (and in fact this is required\nfor logical consistency), so in this case it returns `default`.\n</code>",
 "10":
 "<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>",
 "1":
 "<code>IO : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad that supports arbitrary side effects and throwing exceptions of type `IO.Error`.\n</code>",
 "0":
 "<code class=\"docstring\">`conv =&gt; ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee &lt;https://lean-lang.org/theorem_proving_in_lean4/conv.html&gt; for more details.\n\nBasic forms:\n* `conv =&gt; cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h =&gt; cs` will rewrite hypothesis `h`.\n* `conv in pat =&gt; cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n</code>"}