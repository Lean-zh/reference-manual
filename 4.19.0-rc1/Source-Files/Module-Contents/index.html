<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Module Contents</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 5%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
dl.toml-table-field-spec {
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
div.planned {
  font-style: italic;
}
div.planned .label {
  font-size: large;
  text-align: center;
  font-family: var(--verso-structure-font-family);
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: larger;
  margin-top: 0;
  margin-left: 1.5em;
  margin-right: 1.5em;
  margin-bottom: 0.5em;
  display: inline-block;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>.example {
  padding: 1.5em;
  border: 1px solid #98B2C0;
  border-radius: 0.5em;
  margin-bottom: 0.75em;
  margin-top: 0.75em;
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example p:last-child {margin-bottom:0;}
.example .description::before {
  content: "Example: ";
}
.example[open] .description {
  margin-bottom: 1em;
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 2px #99b3c0;
  background-color: #99b3c0;
  padding-left: 1px;
  padding-right: 1px;
  padding-bottom: 1px;
  padding-top: 1.5rem;
  margin-bottom: 1rem;
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  background-color: white;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 1.5rem;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: 1.5rem !important;
  margin-right: 1.5rem;
}

.namedocs .label {
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  right: 0.5rem;
  top: 0.5rem;
}

/* Sticking content into the right margin is not good on narrow screens,
   so move the label to the left to make space for the permalink widget. */

@media screen and (max-width: 700px) {
  .namedocs:has(.permalink-widget.block) .label {
    right: 1.5rem;
  }
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold;
}

.namedocs > .text .constructor {
  padding-left: 0.5rem;
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: 1.5rem;
}
.namedocs .text > :last-child {
  margin-bottom: 1.5rem;
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="current numbered"><td class="num">5.</td><td><a href="Source-Files/#The-Lean-Language-Reference--Source-Files">Source Files</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="Output-from-Lean/#The-Lean-Language-Reference--Output-from-Lean">Output from Lean</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Elan/#elan">Elan</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-The-Lean-Language-Reference--Source-Files" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-The-Lean-Language-Reference--Source-Files" checked="checked"></label><span class="number">5.</span> <span class=""><a href="Source-Files/#The-Lean-Language-Reference--Source-Files">Source Files</a></span></div>
              <table><tr class="numbered"><td class="num">5.1.</td><td><a href="Source-Files/Files/#files">Files</a></td></tr><tr class="current numbered"><td class="num">5.2.</td><td><a href="Source-Files/Module-Contents/#The-Lean-Language-Reference--Source-Files--Module-Contents">Module Contents</a></td></tr><tr class="numbered"><td class="num">5.3.</td><td><a href="Source-Files/Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">5.4.</td><td><a href="Source-Files/Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">5.5.</td><td><a href="Source-Files/Dynamic-Typing/#The-Lean-Language-Reference--Source-Files--Dynamic-Typing">Dynamic Typing</a></td></tr><tr class="numbered"><td class="num">5.6.</td><td><a href="Source-Files/Coercions/#coercions">Coercions</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-The-Lean-Language-Reference--Source-Files--Module-Contents" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-The-Lean-Language-Reference--Source-Files--Module-Contents" checked="checked"></label><span class="number">5.2.</span> <span class="current"><a href="Source-Files/Module-Contents/#The-Lean-Language-Reference--Source-Files--Module-Contents">Module Contents</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Source-Files/Module-Contents/#The-Lean-Language-Reference--Source-Files--Module-Contents--Commands-and-Declarations">Commands and Declarations</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="Source-Files/Module-Contents/#The-Lean-Language-Reference--Source-Files--Module-Contents--Commands-and-Declarations--Definition-Like-Commands">Definition-Like Commands</a></span></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___declaration-next-next-next"><span class="syntax"><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___definition-next"><span class="syntax"><span class="keyword">def</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___definition-next-next"><span class="syntax"><span class="keyword">def</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)*</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___definition-next-next-next"><span class="syntax"><span class="keyword">def</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">where</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___theorem-next"><span class="syntax"><span class="keyword">theorem</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___theorem-next-next"><span class="syntax"><span class="keyword">theorem</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)*</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___theorem-next-next-next"><span class="syntax"><span class="keyword">theorem</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">where</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___abbrev-next"><span class="syntax"><span class="keyword">abbrev</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___abbrev-next-next"><span class="syntax"><span class="keyword">abbrev</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)*</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___abbrev-next-next-next"><span class="syntax"><span class="keyword">abbrev</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">where</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___example-next"><span class="syntax"><span class="keyword">example</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___example-next-next"><span class="syntax"><span class="keyword">example</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)*</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___example-next-next-next"><span class="syntax"><span class="keyword">example</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">where</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___opaque-next"><span class="syntax"><span class="keyword">opaque</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___axiom-next"><span class="syntax"><span class="keyword">axiom</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="Source-Files/Module-Contents/#declaration-modifiers">Modifiers</a></span></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___declModifiers"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.3.</span> <a href="Source-Files/Module-Contents/#The-Lean-Language-Reference--Source-Files--Module-Contents--Commands-and-Declarations--Signatures">Signatures</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.4.</span> <a href="Source-Files/Module-Contents/#The-Lean-Language-Reference--Source-Files--Module-Contents--Commands-and-Declarations--Headers">Headers</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Source-Files/Module-Contents/#namespaces">Namespaces</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Source-Files/Module-Contents/#scopes">Section Scopes</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.1.</span> <a href="Source-Files/Module-Contents/#scope-commands">Controlling Section Scopes</a></span></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___section"><span class="syntax"><span class="keyword">section</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___namespace"><span class="syntax"><span class="keyword">namespace</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___end"><span class="syntax"><span class="keyword">end</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___end-next"><span class="syntax"><span class="keyword">end</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><span class="syntax"><span class="keyword">in</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.2.</span> <a href="Source-Files/Module-Contents/#section-variables">Section Variables</a></span></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Command___variable"><span class="syntax"><span class="keyword">variable</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Term___explicitBinder"><span class="syntax"><span class="keyword">(</span><span class="meta">…</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="keyword">)</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Term___implicitBinder"><span class="syntax"><span class="keyword">{</span><span class="meta">…</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="keyword">}</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Term___strictImplicitBinder"><span class="syntax"><span class="keyword">⦃</span><span class="meta">…</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="keyword">⦄</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Term___instBinder"><span class="syntax"><span class="keyword">[</span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="keyword">]</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.3.</span> <a href="Source-Files/Module-Contents/#The-Lean-Language-Reference--Source-Files--Module-Contents--Section-Scopes--Scoped-Attributes">Scoped Attributes</a></span></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Term___attrKind"><span class="syntax"></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Term___attrKind-next"><span class="syntax"><span class="keyword">local</span></span></a></li>
                <li>
                  <a href="Source-Files/Module-Contents/#Lean___Parser___Term___attrKind-next-next"><span class="syntax"><span class="keyword">scoped</span></span></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Source-Files/Files/#files" rel="prev" title="5.1. Files"><span class="arrow">←</span><span class="where">5.1. Files</span></a><a class="local-button active" href="Source-Files/Axioms/#axioms" rel="next" title="5.3. Axioms"><span class="where">5.3. Axioms</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              5.2. Module Contents</h1>
            <p>
              As described <a href="Source-Files/Files/#module-structure">in the section on the syntax of files</a>, a Lean module consists of a header followed by a sequence of commands.</p>
            <section>
              <h2 id="The-Lean-Language-Reference--Source-Files--Module-Contents--Commands-and-Declarations">
                5.2.1. Commands and Declarations</h2>
              <p>
                After the header, every top-level phrase of a Lean module is a command.
Commands may add new types, define new constants, or query Lean for information.
Commands may even <a href="Notations-and-Macros/#language-extension">change the syntax used to parse subsequent commands</a>.</p>
              <div class="planned">
                <div class="label">
                  Planned Content</div>
                <ul>
                  <li>
                    <p>
                      Describe the various families of available commands (definition-like, <code>#eval</code>-like, etc).</p>
                    </li>
                  <li>
                    <p>
                      Refer to specific chapters that describe major commands, such as <code>inductive</code>.</p>
                    </li>
                  </ul>
                <p>
                  Tracked at issue <a href="https://github.com/leanprover/reference-manual/issues/100">#100</a></p>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Source-Files--Module-Contents--Commands-and-Declarations--Definition-Like-Commands">
                  5.2.1.1. Definition-Like Commands</h3>
                <div class="planned">
                  <div class="label">
                    Planned Content</div>
                  <ul>
                    <li>
                      <p>
                        Precise descriptions of these commands and their syntax</p>
                      </li>
                    <li>
                      <p>
                        Comparison of each kind of definition-like command to the others</p>
                      </li>
                    </ul>
                  <p>
                    Tracked at issue <a href="https://github.com/leanprover/reference-manual/issues/101">#101</a></p>
                  </div>
                <p>
                  The following commands in Lean are definition-like: </p>
                <ul>
                  <li>
                    <p>
                      <code class="grammar"><span class="nonterminal" data-kind="def">def</span></code></p>
                    </li>
                  <li>
                    <p>
                      <code class="grammar"><span class="nonterminal" data-kind="abbrev">abbrev</span></code></p>
                    </li>
                  <li>
                    <p>
                      <code class="grammar"><span class="nonterminal" data-kind="Manual.example">example</span></code></p>
                    </li>
                  <li>
                    <p>
                      <code class="grammar"><span class="nonterminal" data-kind="theorem">theorem</span></code></p>
                    </li>
                  </ul>
                <p>
                  All of these commands cause Lean to <a class="technical-term" href="Elaboration-and-Compilation/#--tech-term-Elaboration">elaborate</a> a term based on a signature.
With the exception of <code class="grammar"><span class="nonterminal" data-kind="Manual.example">example</span></code>, which discards the result, the resulting expression in Lean's core language is saved for future use in the environment.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">instance</code></span> command is described in the <a href="Type-Classes/Instance-Declarations/#instance-declarations">section on instance declarations</a>.</p>
                <div class="namedocs" id="Lean___Parser___Command___declaration-next-next">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___declaration-next-next-next"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.declaration"><a href="Source-Files/Module-Contents#Lean___Parser___Command___declModifiers"><span class="nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code>declModifiers</span></a>
      <span class="nonterminal" data-kind="Lean.Parser.Command.definition">definition</span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___definition">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___definition-next"><span class="nonterminal" data-kind="Lean.Parser.Command.definition">definition</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.definition"><span class="keyword">def</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.declValSimple"><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span><span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.suffix"><code class="hover-info"><code class="docstring">Termination hints are `termination_by` and `decreasing_by`, in that order.
</code></code><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___definition-next-next"><span class="nonterminal" data-kind="Lean.Parser.Command.definition">definition</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.definition"><span class="keyword">def</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Command.declValEqns"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAltsWhereDecls"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlts"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlt"><span class="keyword">|</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span> </span></span><span class="keyword">=&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)*</span></span></span><span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.suffix"><code class="hover-info"><code class="docstring">Termination hints are `termination_by` and `decreasing_by`, in that order.
</code></code><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___definition-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Command.definition">definition</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.definition"><span class="keyword">def</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.whereStructInst"><span class="keyword">where</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFields"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span><span class="bnf">*</span></span></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___theorem">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___theorem-next"><span class="nonterminal" data-kind="Lean.Parser.Command.theorem">theorem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.theorem"><span class="keyword">theorem</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declSig"><code class="hover-info"><code class="docstring">`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` </code></code>declSig</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.declValSimple"><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span><span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.suffix"><code class="hover-info"><code class="docstring">Termination hints are `termination_by` and `decreasing_by`, in that order.
</code></code><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___theorem-next-next"><span class="nonterminal" data-kind="Lean.Parser.Command.theorem">theorem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.theorem"><span class="keyword">theorem</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declSig"><code class="hover-info"><code class="docstring">`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` </code></code>declSig</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Command.declValEqns"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAltsWhereDecls"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlts"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlt"><span class="keyword">|</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span> </span></span><span class="keyword">=&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)*</span></span></span><span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.suffix"><code class="hover-info"><code class="docstring">Termination hints are `termination_by` and `decreasing_by`, in that order.
</code></code><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___theorem-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Command.theorem">theorem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.theorem"><span class="keyword">theorem</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declSig"><code class="hover-info"><code class="docstring">`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` </code></code>declSig</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.whereStructInst"><span class="keyword">where</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFields"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span><span class="bnf">*</span></span></span><span class="from-nonterminal" data-kind="null"></span></span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___abbrev">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___abbrev-next"><span class="nonterminal" data-kind="Lean.Parser.Command.abbrev">abbrev</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.abbrev"><span class="keyword">abbrev</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.declValSimple"><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span><span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.suffix"><code class="hover-info"><code class="docstring">Termination hints are `termination_by` and `decreasing_by`, in that order.
</code></code><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___abbrev-next-next"><span class="nonterminal" data-kind="Lean.Parser.Command.abbrev">abbrev</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.abbrev"><span class="keyword">abbrev</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Command.declValEqns"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAltsWhereDecls"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlts"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlt"><span class="keyword">|</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span> </span></span><span class="keyword">=&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)*</span></span></span><span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.suffix"><code class="hover-info"><code class="docstring">Termination hints are `termination_by` and `decreasing_by`, in that order.
</code></code><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___abbrev-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Command.abbrev">abbrev</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.abbrev"><span class="keyword">abbrev</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code>optDeclSig</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.whereStructInst"><span class="keyword">where</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFields"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span><span class="bnf">*</span></span></span><span class="from-nonterminal" data-kind="null"></span></span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___example">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___example-next"><span class="nonterminal" data-kind="Lean.Parser.Command.example">example</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.example"><span class="keyword">example</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a> <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">)</span> <span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a> <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">)</span> </span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="Lean.Parser.Command.declValSimple"><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span><span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.suffix"><code class="hover-info"><code class="docstring">Termination hints are `termination_by` and `decreasing_by`, in that order.
</code></code><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___example-next-next"><span class="nonterminal" data-kind="Lean.Parser.Command.example">example</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.example"><span class="keyword">example</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a> <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">)</span> <span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a> <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">)</span>
        </span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="Lean.Parser.Command.declValEqns"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAltsWhereDecls"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlts"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlt"><span class="keyword">|</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span> </span></span><span class="keyword">=&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)*</span></span></span><span class="from-nonterminal documented" data-kind="Lean.Parser.Termination.suffix"><code class="hover-info"><code class="docstring">Termination hints are `termination_by` and `decreasing_by`, in that order.
</code></code><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___example-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Command.example">example</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.example"><span class="keyword">example</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.optDeclSig"><code class="hover-info"><code class="docstring">`optDeclSig` matches the signature of a declaration with optional type: a list of binders and then possibly `: type` </code></code><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a> <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">)</span> <span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a> <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">)</span> </span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="Lean.Parser.Command.whereStructInst"><span class="keyword">where</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.structInstFields"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.structInstField">structInstField</span><span class="bnf">*</span></span></span><span class="from-nonterminal" data-kind="null"></span></span></span></pre></div>
                  </div>
                <p>
                  <span id="--tech-term-Opaque-constants"><em>Opaque constants</em></span> are defined constants that cannot be reduced to their definition.</p>
                <div class="namedocs" id="Lean___Parser___Command___opaque">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___opaque-next"><a href="Source-Files/Module-Contents#Lean___Parser___Command___opaque-next"><span class="nonterminal" data-kind="Lean.Parser.Command.opaque">opaque</span></a> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.opaque"><span class="keyword">opaque</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declSig"><code class="hover-info"><code class="docstring">`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` </code></code>declSig</span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___axiom">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___axiom-next"><a href="Source-Files/Module-Contents#Lean___Parser___Command___axiom-next"><span class="nonterminal" data-kind="Lean.Parser.Command.axiom">axiom</span></a> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.axiom"><span class="keyword">axiom</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declId"><code class="hover-info"><code class="docstring">`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names </code></code>declId</span> <span class="nonterminal documented" data-kind="Lean.Parser.Command.declSig"><code class="hover-info"><code class="docstring">`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` </code></code>declSig</span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="declaration-modifiers">
                  5.2.1.2. Modifiers<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=declaration-modifiers" title="Permalink">🔗</a></span></h3>
                <div class="planned">
                  <div class="label">
                    Planned Content</div>
                  <p>
                    A description of each modifier allowed in the production <code>declModifiers</code>, including <span id="--tech-term-documentation-comments">documentation comments</span>.</p>
                  <p>
                    Tracked at issue <a href="https://github.com/leanprover/reference-manual/issues/52">#52</a></p>
                  </div>
                <div class="namedocs" id="declModifiers">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___declModifiers"><span class="nonterminal" data-kind="declModifiers">declModifiers</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.declModifiers"><code class="hover-info"><code class="docstring">`declModifiers` is the collection of modifiers on a declaration:
* a doc comment `/-- ... -/`
* a list of attributes `@[attr1, attr2]`
* a visibility specifier, `private` or `protected`
* `noncomputable`
* `unsafe`
* `partial` or `nonrec`

All modifiers are optional, and have to come in the listed order.

`nestedDeclModifiers` is the same as `declModifiers`, but attributes are printed
on the same line as the declaration. It is used for declarations nested inside other syntax,
such as inductive constructors, structure projections, and `let rec` / `where` definitions. </code></code><span class="from-nonterminal" data-kind="null"><span class="nonterminal documented" data-kind="Lean.Parser.Command.docComment"><code class="hover-info"><code class="docstring">A `docComment` parses a "documentation comment" like `/-- foo -/`. This is not treated like
a regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.

A `docComment` node contains a `/--` atom and then the remainder of the comment, `foo -/` in this
example. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node. </code></code>docComment</span>
      </span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.attributes">attributes</span>
      </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="Lean.Parser.Command.private">private</span> <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Command.protected">protected</span><span class="bnf">)</span>
      </span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Command.noncomputable">noncomputable</span>
      </span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Command.unsafe">unsafe</span>
      </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="Lean.Parser.Command.partial">partial</span>
       <span class="bnf">|</span> <span class="nonterminal" data-kind="Lean.Parser.Command.nonrec">nonrec</span><span class="bnf">)</span></span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Source-Files--Module-Contents--Commands-and-Declarations--Signatures">
                  5.2.1.3. Signatures</h3>
                <div class="planned">
                  <div class="label">
                    Planned Content</div>
                  <p>
                    Describe signatures, including the following topics:</p>
                  <ul>
                    <li>
                      <p>
                        Explicit, implicit, instance-implicit, and strict implicit parameter binders</p>
                      </li>
                    <li>
                      <p>
                        <span id="--tech-term-Optional">Optional</span> and <span id="--tech-term-automatic-parameters">automatic parameters</span></p>
                      </li>
                    <li>
                      <p>
                        <span id="--tech-term-Automatic-implicit"><em>Automatic implicit</em></span> parameters</p>
                      </li>
                    <li>
                      <p>
                        Argument names and by-name syntax</p>
                      </li>
                    <li>
                      <p>
                        Which parts can be omitted where? Why?</p>
                      </li>
                    </ul>
                  <p>
                    Tracked at issue <a href="https://github.com/leanprover/reference-manual/issues/53">#53</a></p>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Source-Files--Module-Contents--Commands-and-Declarations--Headers">
                  5.2.1.4. Headers</h3>
                <p>
                  The <span id="--tech-term-header"><em>header</em></span> of a definition or declaration specifies the signature of the new constant that is defined.</p>
                </section>
              </section>
            <section>
              <h2 id="namespaces">
                5.2.2. Namespaces<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=namespaces" title="Permalink">🔗</a></span></h2>
              <div class="planned">
                <div class="label">
                  Planned Content</div>
                <p>
                  Describe <span id="--tech-term-namespaces">namespaces</span>, aliases, and the semantics of <code>export</code> and <code>open</code>.
Which language features are controlled by the currently open namespaces?</p>
                <p>
                  Tracked at issue <a href="https://github.com/leanprover/reference-manual/issues/210">#210</a></p>
                </div>
              </section>
            <section>
              <h2 id="scopes">
                5.2.3. Section Scopes<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=scopes" title="Permalink">🔗</a></span></h2>
              <p>
                Many commands have an effect for the current <span id="--tech-term-section-scope"><em>section scope</em></span> (sometimes just called "scope" when clear).
Every Lean module has a section scope.
Nested scopes are created via the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> commands, as well as the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> command combinator.</p>
              <p>
                The following data are tracked in section scopes:</p>
              <dl><dt> The Current Namespace</dt><dd><p>
                    The <span id="--tech-term-current-namespace"><em>current namespace</em></span> is the namespace into which new declarations will be defined.
  Additionally, <a class="technical-term" href="Terms/Identifiers/#--tech-term-resolving">name resolution</a> includes all prefixes of the current namespace in the scope for global names.</p>
                  </dd><dt> Opened Namespaces</dt><dd><p>
                    When a namespace is <span id="--tech-term-opened"><em>opened</em></span>, its names become available without an explicit prefix in the current scope.
  Additionally, scoped attributes and <a href="Notations-and-Macros/Defining-New-Syntax/#syntax-rules">scoped syntax extensions</a> in namespaces that have been opened are active in the current section scope.</p>
                  </dd><dt> Options</dt><dd><p>
                    Compiler options are reverted to their original values at the end of the scope in which they were modified.</p>
                  </dd><dt> Section Variables</dt><dd><p>
                    <a class="technical-term" href="Source-Files/Module-Contents/#--tech-term-Section-variables">Section variables</a> are names (or <a class="technical-term" href="Type-Classes/#--tech-term-instance-implicit-next">instance implicit</a> parameters) that are automatically added as parameters to definitions.
  They are also added as universally-quantified assumptions to theorems when they occur in the theorem's statement.</p>
                  </dd></dl><section>
                <h3 id="scope-commands">
                  5.2.3.1. Controlling Section Scopes<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=scope-commands" title="Permalink">🔗</a></span></h3>
                <p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> command creates a new section scope, but does not modify the current namespace, opened namespaces, or section variables.
Changes made to the section scope are reverted when the section ends.
Sections may optionally be named; the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command that closes a named section must use the same name.
If section names have multiple components (that is, if they contain <code>.</code>-separated names), then multiple nested sections are introduced.
Section names have no other effect, and are a readability aid.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><div class="text">
                    <p>
                      The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> command creates a section scope that lasts either until an <code>end</code> command or the end of the file.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___section"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.section"><code class="hover-info"><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><span class="keyword">section</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span><span class="bnf">?</span></span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">Named Section</summary><p>
                    The name <code class="hl lean inline" data-lean-context="examples"><a href="Source-Files/Module-Contents/#Greetings___english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="741">english</span></a></code> is defined in the <code>Greetings</code> namespace.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6534">def</span> <span class="const token" data-binding="const-Greetings.english" data-verso-hover="741" id="Greetings___english">Greetings.english</span> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="73">"Hello"</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Outside its namespace, it cannot be evaluated.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-6663" data-verso-hover="6">#eval</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'english'</code></span></span><span class="unknown token" data-binding="">english</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>unknown identifier 'english'
</pre></div>
                  <p>
                    Opening a section allows modifications to the global scope to be contained.
This section is named <code>Greetings</code>.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Source-Files/Module-Contents/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-6857" data-verso-hover="724">section</span></a> <span class="unknown token" data-binding="">Greetings</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Even though the section name matches the definition's namespace, the name is not in scope because section names are purely for readability and ease of refactoring.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-7089" data-verso-hover="6">#eval</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'english'</code></span></span><span class="unknown token" data-binding="">english</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>unknown identifier 'english'
</pre></div>
                  <p>
                    Opening the namespace <code>Greetings</code> brings <code class="hl lean inline" data-lean-context="examples"><a href="Source-Files/Module-Contents/#Greetings___english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="741">Greetings.english</span></a></code> as <code class="hl lean inline" data-lean-context="examples"><a href="Source-Files/Module-Contents/#Greetings___english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="741">english</span></a></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-7299" data-verso-hover="725">open</span> <span class="unknown token" data-binding="">Greetings</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"Hello"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-7315" data-verso-hover="6">#eval</span></a></span> <a href="Source-Files/Module-Contents/#Greetings___english"><span class="const token" data-binding="const-Greetings.english" data-verso-hover="741">english</span></a>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>"Hello"
</pre></div>
                  <p>
                    The section's name must be used to close it.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid 'end', name is missing (expected Greetings)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-7474" data-verso-hover="729">end</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>invalid 'end', name is missing (expected Greetings)
</pre></div>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-7570" data-verso-hover="729">end</span> <span class="unknown token" data-binding="">Greetings</span>
<span class="unknown token" data-binding=""></span></code><p>
                    When the section is closed, the effects of the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><code class="kw">open</code></span> command are reverted.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-7745" data-verso-hover="6">#eval</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'english'</code></span></span><span class="unknown token" data-binding="">english</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>unknown identifier 'english'
</pre></div>
                  </details><p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> command creates a new section scope.
Within this section scope, the current namespace is the name provided in the command, interpreted relative to the current namespace in the surrounding section scope.
Like sections, changes made to the section scope are reverted when the namespace's scope ends.</p>
                <p>
                  To close a namespace, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command requires a suffix of the current namespace, which is removed.
All section scopes introduced by the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> command that introduced part of that suffix are closed.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><div class="text">
                    <p>
                      The <code>namespace</code> command modifies the current namespace by appending the provided identifier.</p>
                    <p>
                      creates a section scope that lasts either until an <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command or the end of the file.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___namespace"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.namespace"><code class="hover-info"><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><span class="keyword">namespace</span> <span class="nonterminal" data-kind="ident">ident</span></span></pre></div>
                  </div>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><div class="text">
                    <p>
                      Without an identifier, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> closes the most recently opened section, which must be anonymous.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___end"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.end"><code class="hover-info"><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><span class="keyword">end</span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      With an identifier, it closes the most recently opened section section or namespace.
If it is a section, the identifier be a suffix of the concatenated names of the sections opened since the most recent <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.namespace : command</code><span class="sep"></span><code class="docstring">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside
the section:
* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the
  full name `Nat.seventeen`.
* Names introduced by `export` declarations are also prefixed by the identifier.
* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names
  are preferred over names introduced by outer namespaces or `open`.
* Within a namespace, declarations can be `protected`, which excludes them from the effects of
  opening the namespace.

As with `section`, namespaces can be nested and the scope of a namespace is terminated by a
corresponding `end &lt;id&gt;` or the end of the file.

`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.
</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___namespace"><code class="kw">namespace</code></a></span> command.
If it is a namespace, then the identifier must be a suffix of the current namespace's extensions since the most recent <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.section : command</code><span class="sep"></span><code class="docstring">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`
commands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear
with the matching `end`. In either case, the `end` can be omitted, in which case the section is
closed at the end of the file.
</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___section"><code class="kw">section</code></a></span> that is still open; afterwards, the current namespace will have had this suffix removed.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___end-next"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.end"><code class="hover-info"><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><span class="keyword">end</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span></span></span></pre></div>
                  </div>
                <p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><code class="kw">end</code></a></span> that closes a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><code class="kw">mutual</code></a></span> block is part of the syntax of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.mutual : command</code></code><a href="Recursive-Definitions/Mutual-Recursion/#Lean___Parser___Command___mutual"><code class="kw">mutual</code></a></span>, rather than the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command.</p>
                <details class="example"><summary class="description">Nesting Namespaces and Sections</summary><p>
                    Namespaces and sections may be nested.
A single <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command may close one or more namespaces or one or more sections, but not a mix of the two.</p>
                  <p>
                    After setting the current namespace to <code>A.B.C</code> with two separate commands, <code>B.C</code> may be removed with a single <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span>:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Source-Files/Module-Contents/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-10107" data-verso-hover="726">namespace</span></a> <span class="unknown token" data-binding="">A.B</span>
<a href="Source-Files/Module-Contents/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-10121" data-verso-hover="726">namespace</span></a> <span class="unknown token" data-binding="">C</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-10133" data-verso-hover="729">end</span> <span class="unknown token" data-binding="">B.C</span>
<span class="unknown token" data-binding=""></span></code><p>
                    At this point, the current namespace is <code>A</code>.</p>
                  <p>
                    Next, an anonymous section and the namespace <code>D.E</code> are opened:</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Source-Files/Module-Contents/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-10262" data-verso-hover="724">section</span></a>
<a href="Source-Files/Module-Contents/#Lean___Parser___Command___namespace"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-10270" data-verso-hover="726">namespace</span></a> <span class="unknown token" data-binding="">D.E</span>
<span class="unknown token" data-binding=""></span></code><p>
                    At this point, the current namespace is <code>A.D.E</code>.
An <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.end : command</code><span class="sep"></span><code class="docstring">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed
with `end &lt;id&gt;`. The `end` command is optional at the end of a file.
</code></code><code class="kw">end</code></span> command cannot close all three due to the intervening section:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid 'end', name mismatch (expected «».D.E)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-10501" data-verso-hover="729">end</span></span> <span class="unknown token" data-binding="">A.D.E</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>invalid 'end', name mismatch (expected «».D.E)
</pre></div>
                  <p>
                    Instead, namespaces and sections must be ended separately.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-10656" data-verso-hover="729">end</span> <span class="unknown token" data-binding="">D.E</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-10664" data-verso-hover="729">end</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-10668" data-verso-hover="729">end</span> <span class="unknown token" data-binding="">A</span>
<span class="unknown token" data-binding=""></span></code></details><p>
                  Rather than opening a section for a single command, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> combinator can be used to create single-command section scope.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> combinator is right-associative, allowing multiple scope modifications to be stacked.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><div class="text">
                    <p>
                      The <code>in</code> command combinator introduces a section scope for a single command.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___in"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.in"><span class="nonterminal" data-kind="command.pseudo">command</span> <span class="keyword">in</span>
      <span class="nonterminal" data-kind="command.pseudo">command</span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">Using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><code class="kw">in</code></a></span> for Local Scopes</summary><p>
                    The contents of a namespace can be made available for a single command using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><code class="kw">in</code></a></span>.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11311">def</span> <span class="const token" data-binding="const-Dessert.cupcake" data-verso-hover="742" id="Dessert___cupcake">Dessert.cupcake</span> <span class="unknown token" data-binding="">:=</span> <span class="literal string token" data-binding="" data-verso-hover="743">"delicious"</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-11347" data-verso-hover="725">open</span> <span class="unknown token" data-binding="">Dessert</span> <a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-11347">in</span></a>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"delicious"</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-11363" data-verso-hover="6">#eval</span></a></span> <a href="Source-Files/Module-Contents/#Dessert___cupcake"><span class="const token" data-binding="const-Dessert.cupcake" data-verso-hover="742">cupcake</span></a>
<span class="unknown token" data-binding=""></span></code><p>
                    After the single command, the effects of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.open : command</code><span class="sep"></span><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></code><code class="kw">open</code></span> are reverted.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-11522" data-verso-hover="6">#eval</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'cupcake'</code></span></span><span class="unknown token" data-binding="">cupcake</span></span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>unknown identifier 'cupcake'
</pre></div>
                  </details></section>
              <section>
                <h3 id="section-variables">
                  5.2.3.2. Section Variables<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=section-variables" title="Permalink">🔗</a></span></h3>
                <p>
                  <span id="--tech-term-Section-variables"><em>Section variables</em></span> are parameters that are automatically added to declarations that mention them.
This occurs whether or not the option <code class="hl lean inline" data-lean-context="examples"><span class="option token" data-binding="option-autoImplicit" data-verso-hover="174">autoImplicit</span></code> is <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code>.
Section variables may be implicit, strict implicit, or explicit; instance implicit section variables are treated specially.</p>
                <p>
                  When the name of a section variable is encountered in a non-theorem declaration, it is added as a parameter.
Any instance implicit section variables that mention the variable are also added.
If any of the variables that were added depend on other variables, then those variables are added as well; this process is iterated until no more dependencies remain.
All section variables are added in the order in which they are declared, before all other parameters.
Section variables are added only when they occur in the <em>statement</em> of a theorem.
Otherwise, modifying the proof of a theorem could change its statement if the proof term made use of a section variable.</p>
                <p>
                  Variables are declared using the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.variable : command</code><span class="sep"></span><code class="docstring">Declares one or more typed variables, or modifies whether already-declared variables are
  implicit.

Introduces variables that can be used in definitions within the same `namespace` or `section` block.
When a definition mentions a variable, Lean will add it as an argument of the definition. This is
useful in particular when writing many definitions that have parameters in common (see below for an
example).

Variable declarations have the same flexibility as regular function parameters. In particular they
can be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they
can be anonymous). This can be changed, for instance one can turn explicit variable `x` into an
implicit one with `variable {x}`. Note that currently, you should avoid changing how variables are
bound and declare new variables at the same time; see [issue 2789] for more on this topic.

In *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that
changes to the proof cannot change the statement of the overall theorem. Instead, variables are only
available to the proof if they have been mentioned in the theorem header or in an `include` command
or are instance implicit and depend only on such variables.

See [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed
discussion.

[tpil vars]:
https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections
(Variables and Sections on Theorem Proving in Lean) [tpil classes]:
https://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in
Lean) [binder docs]:
https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation
for the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789
on github)

## Examples

```lean
section
  variable
    {α : Type u}      -- implicit
    (a : α)           -- explicit
    [instBEq : BEq α] -- instance implicit, named
    [Hashable α]      -- instance implicit, anonymous

  def isEqual (b : α) : Bool :=
    a == b

  #check isEqual
  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool

  variable
    {a} -- `a` is implicit now

  def eqComm {b : α} := a == b ↔ b == a

  #check eqComm
  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop
end
```

The following shows a typical use of `variable` to factor out definition arguments:

```lean
variable (Src : Type)

structure Logger where
  trace : List (Src × String)
#check Logger
-- Logger (Src : Type) : Type

namespace Logger
  -- switch `Src : Type` to be implicit until the `end Logger`
  variable {Src}

  def empty : Logger Src where
    trace := []
  #check empty
  -- Logger.empty {Src : Type} : Logger Src

  variable (log : Logger Src)

  def len :=
    log.trace.length
  #check len
  -- Logger.len {Src : Type} (log : Logger Src) : Nat

  variable (src : Src) [BEq Src]

  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments

  def filterSrc :=
    log.trace.filterMap
      fun (src', str') =&gt; if src' == src then some str' else none
  #check filterSrc
  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String

  def lenSrc :=
    log.filterSrc src |&gt;.length
  #check lenSrc
  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat
end Logger
```

The following example demonstrates availability of variables in proofs:
```lean
variable
  {α : Type}    -- available in the proof as indirectly mentioned through `a`
  [ToString α]  -- available in the proof as `α` is included
  (a : α)       -- available in the proof as mentioned in the header
  {β : Type}    -- not available in the proof
  [ToString β]  -- not available in the proof

theorem ex : a = a := rfl
```
After elaboration of the proof, the following warning will be generated to highlight the unused
hypothesis:
```
included section variable '[ToString α]' is not used in 'ex', consider excluding it
```
In such cases, the offending variable declaration should be moved down or into a section so that
only theorems that do depend on it follow it until the end of the section.
</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___variable"><code class="kw">variable</code></a></span> command.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___variable"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Command.variable"><code class="hover-info"><code class="docstring">Declares one or more typed variables, or modifies whether already-declared variables are
  implicit.

Introduces variables that can be used in definitions within the same `namespace` or `section` block.
When a definition mentions a variable, Lean will add it as an argument of the definition. This is
useful in particular when writing many definitions that have parameters in common (see below for an
example).

Variable declarations have the same flexibility as regular function parameters. In particular they
can be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they
can be anonymous). This can be changed, for instance one can turn explicit variable `x` into an
implicit one with `variable {x}`. Note that currently, you should avoid changing how variables are
bound and declare new variables at the same time; see [issue 2789] for more on this topic.

In *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that
changes to the proof cannot change the statement of the overall theorem. Instead, variables are only
available to the proof if they have been mentioned in the theorem header or in an `include` command
or are instance implicit and depend only on such variables.

See [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed
discussion.

[tpil vars]:
https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections
(Variables and Sections on Theorem Proving in Lean) [tpil classes]:
https://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in
Lean) [binder docs]:
https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation
for the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789
on github)

## Examples

```lean
section
  variable
    {α : Type u}      -- implicit
    (a : α)           -- explicit
    [instBEq : BEq α] -- instance implicit, named
    [Hashable α]      -- instance implicit, anonymous

  def isEqual (b : α) : Bool :=
    a == b

  #check isEqual
  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool

  variable
    {a} -- `a` is implicit now

  def eqComm {b : α} := a == b ↔ b == a

  #check eqComm
  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop
end
```

The following shows a typical use of `variable` to factor out definition arguments:

```lean
variable (Src : Type)

structure Logger where
  trace : List (Src × String)
#check Logger
-- Logger (Src : Type) : Type

namespace Logger
  -- switch `Src : Type` to be implicit until the `end Logger`
  variable {Src}

  def empty : Logger Src where
    trace := []
  #check empty
  -- Logger.empty {Src : Type} : Logger Src

  variable (log : Logger Src)

  def len :=
    log.trace.length
  #check len
  -- Logger.len {Src : Type} (log : Logger Src) : Nat

  variable (src : Src) [BEq Src]

  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments

  def filterSrc :=
    log.trace.filterMap
      fun (src', str') =&gt; if src' == src then some str' else none
  #check filterSrc
  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String

  def lenSrc :=
    log.filterSrc src |&gt;.length
  #check lenSrc
  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat
end Logger
```

The following example demonstrates availability of variables in proofs:
```lean
variable
  {α : Type}    -- available in the proof as indirectly mentioned through `a`
  [ToString α]  -- available in the proof as `α` is included
  (a : α)       -- available in the proof as mentioned in the header
  {β : Type}    -- not available in the proof
  [ToString β]  -- not available in the proof

theorem ex : a = a := rfl
```
After elaboration of the proof, the following warning will be generated to highlight the unused
hypothesis:
```
included section variable '[ToString α]' is not used in 'ex', consider excluding it
```
In such cases, the offending variable declaration should be moved down or into a section so that
only theorems that do depend on it follow it until the end of the section.
</code></code><span class="keyword">variable</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span> <span class="nonterminal" data-kind="Lean.Parser.Term.bracketedBinder.pseudo">bracketedBinder</span><span class="bnf">*</span></span></span></pre></div>
                  </div>
                <div class="namedocs" id="bracketedBinder">
                  <span class="label">syntax</span><div class="text">
                    <p>
                      The bracketed binders allowed after <code>variable</code> match the syntax used in definition headers.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___explicitBinder"><span class="nonterminal" data-kind="bracketedBinder">bracketedBinder</span> <span class="bnf">::=</span>
    <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.explicitBinder"><code class="hover-info"><code class="docstring">Explicit binder, like `(x y : A)` or `(x y)`.
Default values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.
</code></code><span class="keyword">(</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span> <span class="bnf">(</span><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span><span class="bnf">)*</span> </span><span class="from-nonterminal" data-kind="null"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span> </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.binderDefault"><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span></span><span class="keyword">)</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___implicitBinder"><span class="nonterminal" data-kind="bracketedBinder">bracketedBinder</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.implicitBinder"><code class="hover-info"><code class="docstring">Implicit binder, like `{x y : A}` or `{x y}`.
In regular applications, whenever all parameters before it have been specified,
then a `_` placeholder is automatically inserted for this parameter.
Implicit parameters should be able to be determined from the other arguments and the return type
by unification.

In `@` explicit mode, implicit binders behave like explicit binders.
</code></code><span class="keyword">{</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span> <span class="bnf">(</span><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span><span class="bnf">)*</span> </span><span class="from-nonterminal" data-kind="null"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="keyword">}</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___strictImplicitBinder"><span class="nonterminal" data-kind="bracketedBinder">bracketedBinder</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.strictImplicitBinder"><code class="hover-info"><code class="docstring">Strict-implicit binder, like `⦃x y : A⦄` or `⦃x y⦄`.
In contrast to `{ ... }` implicit binders, strict-implicit binders do not automatically insert
a `_` placeholder until at least one subsequent explicit parameter is specified.
Do *not* use strict-implicit binders unless there is a subsequent explicit parameter.
Assuming this rule is followed, for fully applied expressions implicit and strict-implicit binders have the same behavior.

Example: If `h : ∀ ⦃x : A⦄, x ∈ s → p x` and `hs : y ∈ s`,
then `h` by itself elaborates to itself without inserting `_` for the `x : A` parameter,
and `h hs` has type `p y`.
In contrast, if `h' : ∀ {x : A}, x ∈ s → p x`, then `h` by itself elaborates to have type `?m ∈ s → p ?m`
with `?m` a fresh metavariable.
</code></code><span class="keyword">⦃</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span> <span class="bnf">(</span><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span><span class="bnf">)*</span> </span><span class="from-nonterminal" data-kind="null"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="keyword">⦄</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___instBinder"><span class="nonterminal" data-kind="bracketedBinder">bracketedBinder</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.instBinder"><code class="hover-info"><code class="docstring">Instance-implicit binder, like `[C]` or `[inst : C]`.
In regular applications without `@` explicit mode, it is automatically inserted
and solved for by typeclass inference for the specified class `C`.
In `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;
use `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.
</code></code><span class="keyword">[</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span><span class="keyword">]</span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">Section Variables</summary><p>
                    In this section, automatic implicit parameters are disabled, but a number of section variables are defined.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Source-Files/Module-Contents/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-13233" data-verso-hover="724">section</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-13241" data-verso-hover="160">set_option</span> <span class="option token" data-binding="option-autoImplicit" data-verso-hover="174">autoImplicit</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-13241" data-verso-hover="160">false</span>
<a href="The-Type-System/Universes/#Lean___Parser___Command___universe-next"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.universe-13271" data-verso-hover="178">universe</span></a> <span class="unknown token" data-binding="">u</span>
<a href="Source-Files/Module-Contents/#Lean___Parser___Command___variable"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-13282" data-verso-hover="634">variable</span></a> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-13297" data-verso-hover="50">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="51">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#Zero___mk"><span class="const token" data-binding="const-Zero" data-verso-hover="744">Zero</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#Add___mk"><span class="const token" data-binding="const-Add" data-verso-hover="515">Add</span></a> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="55">α</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Because automatic implicit parameters are disabled, the following definition fails:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13486">def</span> <span class="const token" data-binding="const-addAll" data-verso-hover="745">addAll</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="177">lst</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Linked-Lists/#List___nil"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'β'</code></span></span><span class="unknown token" data-binding="">β</span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unknown identifier 'β'</code></span></span><span class="unknown token" data-binding="">β</span></span> <span class="unknown token" data-binding="">:=</span>
  <span class="var token" data-binding="var-_uniq.15" data-verso-hover="177">lst</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___foldr"><span class="const token" data-binding="const-List.foldr" data-verso-hover="746">foldr</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">init</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="176">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="error">
                    <pre>unknown identifier 'β'
</pre></div>
                  <p>
                    On the other hand, not even <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.5" data-verso-hover="51">xs</span></code> needs to be written directly in the definition:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13706">def</span> <span class="const token" data-binding="const-addAll" data-verso-hover="747">addAll</span> <span class="unknown token" data-binding="">:=</span>
  <span class="var token" data-binding="var-_uniq.5" data-verso-hover="51">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Linked-Lists/#List___foldr"><span class="const token" data-binding="const-List.foldr" data-verso-hover="746">foldr</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">init</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="46">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code></details><p>
                  To add a section variable to a theorem even if it is not explicitly mentioned in the statement, mark the variable with the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.include : command</code><span class="sep"></span><code class="docstring">`include eeny meeny` instructs Lean to include the section `variable`s `eeny` and `meeny` in all
theorems in the remainder of the current section, differing from the default behavior of
conditionally including variables based on use in the theorem header. Other commands are
not affected. `include` is usually followed by `in theorem ...` to limit the inclusion
to the subsequent declaration.
</code></code><code class="kw">include</code></span> command.
All variables marked for inclusion are added to all theorems.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.omit : command</code><span class="sep"></span><code class="docstring">`omit` instructs Lean to not include a variable previously `include`d. Apart from variable names, it
can also refer to typeclass instance variables by type using the syntax `omit [TypeOfInst]`, in
which case all instance variables that unify with the given type are omitted. `omit` should usually
only be used in conjunction with `in` in order to keep the section structure simple.
</code></code><code class="kw">omit</code></span> command removes the inclusion mark from a variable; it's typically a good idea to use it with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.in : command</code></code><a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><code class="kw">in</code></a></span>.</p>
                <details class="example"><summary class="description">Included and Omitted Section Variables</summary><p>
                    This section's variables include a predicate as well as everything needed to prove that it holds universally, along with a useless extra assumption.</p>
                  <code class="hl lean block" data-lean-context="examples"><a href="Source-Files/Module-Contents/#Lean___Parser___Command___section"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.section-14493" data-verso-hover="724">section</span></a>
<a href="Source-Files/Module-Contents/#Lean___Parser___Command___variable"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-14501" data-verso-hover="634">variable</span></a> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="748">p</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">}</span>
<a href="Source-Files/Module-Contents/#Lean___Parser___Command___variable"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-14529" data-verso-hover="634">variable</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.46" data-verso-hover="749">pZero</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="748">p</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.104" data-verso-hover="750">pStep</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">∀</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="748">p</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<a href="Source-Files/Module-Contents/#Lean___Parser___Command___variable"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-14587" data-verso-hover="634">variable</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.202" data-verso-hover="751">pFifteen</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.38" data-verso-hover="748">p</span> <span class="typed token" data-binding="" data-verso-hover="7">15</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                    However, only <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="748">p</span></code> is added to this theorem's assumptions, so it cannot be proved.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-14747">theorem</span> <span class="const token" data-binding="const-p_all" data-verso-hover="752">p_all</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">∀</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-7900654738583061598-14777-14779"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">unsolved goals
case zero
p : Nat → Prop
⊢ p 0

case succ
p : Nat → Prop
n✝ : Nat
a✝ : p n✝
⊢ p (n✝ + 1)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-14777" data-verso-hover="10">by</span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7900654738583061598-14777-14779"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.130" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.130" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-2901107005390282279-14782-14789"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-14782" data-verso-hover="553">intro</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2901107005390282279-14782-14789"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-2288354547432366360-14792-14803"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-14792" data-verso-hover="610">induction</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2288354547432366360-14792-14803"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-67" checked="checked"><span for="--verso-unique-67" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-68"><span for="--verso-unique-68" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.121" data-verso-hover="753">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">n✝</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span>
<span class="unknown token" data-binding=""></span></code><p>
                    The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.include : command</code><span class="sep"></span><code class="docstring">`include eeny meeny` instructs Lean to include the section `variable`s `eeny` and `meeny` in all
theorems in the remainder of the current section, differing from the default behavior of
conditionally including variables based on use in the theorem header. Other commands are
not affected. `include` is usually followed by `in theorem ...` to limit the inclusion
to the subsequent declaration.
</code></code><code class="kw">include</code></span> command causes the additional assumptions to be added unconditionally:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.include-14972" data-verso-hover="754">include</span> <span class="unknown token" data-binding="">pZero</span> <span class="unknown token" data-binding="">pStep</span> <span class="unknown token" data-binding="">pFifteen</span>

<span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">automatically included section variable(s) unused in theorem 'p_all':
  pFifteen
consider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:
  omit pFifteen in theorem ...
note: this linter can be disabled with `set_option linter.unusedSectionVars false`</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-15002">theorem</span></span> <span class="const token" data-binding="const-p_all" data-verso-hover="755">p_all</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">∀</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-16150725013825485917-15032-15034"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-15032" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16150725013825485917-15032-15034"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="756">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.398" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.398" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-14000055503896442149-15037-15044"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-15037" data-verso-hover="553">intro</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14000055503896442149-15037-15044"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="756">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-8731853017198601369-15047-15058"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-15047" data-verso-hover="610">induction</span></a> <span class="var token" data-binding="var-_uniq.102" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8731853017198601369-15047-15058"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-71" checked="checked"><span for="--verso-unique-71" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="756">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-72"><span for="--verso-unique-72" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="756">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.121" data-verso-hover="753">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">n✝</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-8731853017198601369-15059-15062"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8731853017198601369-15059-15062"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-73" checked="checked"><span for="--verso-unique-73" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="756">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-74"><span for="--verso-unique-74" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15" data-verso-hover="756">pFifteen</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="748">p✝</span> 15</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.399" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.121" data-verso-hover="753">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.120" data-verso-hover="7">n✝</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-15063-15071"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-15063" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-15063-15071"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
                    Because the spurious assumption <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.36" data-verso-hover="751">pFifteen</span></code> was inserted, Lean issues a warning:</p>
                  <div class="warning">
                    <pre>automatically included section variable(s) unused in theorem 'p_all':
  pFifteen
consider restructuring your `variable` declarations so that the variables are not in scope or explicitly omit them:
  omit pFifteen in theorem ...
note: this linter can be disabled with `set_option linter.unusedSectionVars false`
</pre></div>
                  <p>
                    This can be avoided by using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.omit : command</code><span class="sep"></span><code class="docstring">`omit` instructs Lean to not include a variable previously `include`d. Apart from variable names, it
can also refer to typeclass instance variables by type using the syntax `omit [TypeOfInst]`, in
which case all instance variables that unify with the given type are omitted. `omit` should usually
only be used in conjunction with `in` in order to keep the section structure simple.
</code></code><code class="kw">omit</code></span>to remove <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.45" data-verso-hover="751">pFifteen</span></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.include-15620" data-verso-hover="754">include</span> <span class="unknown token" data-binding="">pZero</span> <span class="unknown token" data-binding="">pStep</span> <span class="unknown token" data-binding="">pFifteen</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.omit-15650" data-verso-hover="757">omit</span> <span class="unknown token" data-binding="">pFifteen</span> <a href="Source-Files/Module-Contents/#Lean___Parser___Command___in"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-15650">in</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-15667">theorem</span> <span class="const token" data-binding="const-p_all" data-verso-hover="758">p_all</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">∀</span> <span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">n</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.192" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-6669787424453134312-15697-15699"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-15697" data-verso-hover="10">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6669787424453134312-15697-15699"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.488" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.488" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-6238395077194003270-15702-15709"><a href="Tactic-Proofs/Tactic-Reference/#intro"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-15702" data-verso-hover="553">intro</span></a> <span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6238395077194003270-15702-15709"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">n</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">n</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7194591783188049296-15712-15723"><a href="Tactic-Proofs/Tactic-Reference/#induction"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-15712" data-verso-hover="610">induction</span></a> <span class="var token" data-binding="var-_uniq.196" data-verso-hover="7">n</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7194591783188049296-15712-15723"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-77" checked="checked"><span for="--verso-unique-77" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-78"><span for="--verso-unique-78" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.215" data-verso-hover="753">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n✝</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7194591783188049296-15724-15727"><span class="unknown token" data-binding="">&lt;;&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7194591783188049296-15724-15727"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-79" checked="checked"><span for="--verso-unique-79" class="goal-name">zero</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-80"><span for="--verso-unique-80" class="goal-name">succ</span></label><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> → <span class="sort token" data-binding="" data-verso-hover="23">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="749">pZero</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> 0</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.85" data-verso-hover="750">pStep</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> : <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>), <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span> → <span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.489" data-verso-hover="7">n</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n✝</span></span><span class="colon">:</span><span class="type"><a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.215" data-verso-hover="753">a✝</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n✝</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="748">p</span> <a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">(</span></a><span class="var token" data-binding="var-_uniq.214" data-verso-hover="7">n✝</span><a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15"> + </span></a>1<a href="Type-Classes/Basic-Classes/#HAdd___mk"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="15">)</span></a></span></span></span></span></span></span> <span class="tactic"><label for="tactic-state-7-15728-15736"><a href="Tactic-Proofs/Tactic-Reference/#simp"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-15728" data-verso-hover="36">simp</span></a> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-15728-15736"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-15750" data-verso-hover="729">end</span>
<span class="unknown token" data-binding=""></span></code></details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Source-Files--Module-Contents--Section-Scopes--Scoped-Attributes">
                  5.2.3.3. Scoped Attributes</h3>
                <p>
                  Many attributes can be applied in a particular scope.
This determines whether the attribute's effect is visible only in the current section scope, in namespaces that open the current namespace, or everywhere.
These scope indications are also used to control <a href="Notations-and-Macros/Defining-New-Syntax/#syntax-rules">syntax extensions</a> and <a href="Type-Classes/Instance-Declarations/#instance-attribute">type class instances</a>.</p>
                <div class="namedocs" id="attrKind">
                  <span class="label">syntax</span><div class="text">
                    <p>
                      Globally-scoped declarations (the default) are in effect whenever the <a class="technical-term" href="Source-Files/Files/#--tech-term-module">module</a> in which they're established is transitively imported.
They are indicated by the absence of another scope modifier.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___attrKind"><span class="nonterminal" data-kind="attrKind">attrKind</span> <span class="bnf">::=</span>
    <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.attrKind"><code class="hover-info"><code class="docstring">`attrKind` matches `("scoped" &lt;|&gt; "local")?`, used before an attribute like `@[local simp]`. </code></code><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      Locally-scoped declarations are in effect only for the extent of the <a class="technical-term" href="Source-Files/Module-Contents/#--tech-term-section-scope">section scope</a> in which they are established.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___attrKind-next"><span class="nonterminal" data-kind="attrKind">attrKind</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.attrKind"><code class="hover-info"><code class="docstring">`attrKind` matches `("scoped" &lt;|&gt; "local")?`, used before an attribute like `@[local simp]`. </code></code><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.local"><span class="keyword">local</span></span></span></span></pre><p>
                      Scoped declarations are in effect whenever the <a class="technical-term" href="Source-Files/Module-Contents/#--tech-term-current-namespace">namespace</a> in which they are established is opened.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___attrKind-next-next"><span class="nonterminal" data-kind="attrKind">attrKind</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="Lean.Parser.Term.attrKind"><code class="hover-info"><code class="docstring">`attrKind` matches `("scoped" &lt;|&gt; "local")?`, used before an attribute like `@[local simp]`. </code></code><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.scoped"><span class="keyword">scoped</span></span></span></span></pre></div>
                  </div>
                </section>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Source-Files/Files/#files" rel="prev" title="5.1. Files"><span class="arrow">←</span><span class="where">5.1. Files</span></a><a class="local-button active" href="Source-Files/Axioms/#axioms" rel="next" title="5.3. Axioms"><span class="where">5.3. Axioms</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

