<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Syntax</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/katex/katex.min.js"></script>
    <script src="static/math.js"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-js/popper.js"></script>
    <script src="-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="static/katex/katex.min.css">
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="-verso-css/tippy-border.css">
    <style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 5%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
dl.toml-table-field-spec {
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
div.planned {
  font-style: italic;
}
div.planned .label {
  font-size: large;
  text-align: center;
  font-family: var(--verso-structure-font-family);
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: larger;
  margin-top: 0;
  margin-left: 1.5em;
  margin-right: 1.5em;
  margin-bottom: 0.5em;
  display: inline-block;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>.example {
  padding: 1.5em;
  border: 1px solid #98B2C0;
  border-radius: 0.5em;
  margin-bottom: 0.75em;
  margin-top: 0.75em;
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example p:last-child {margin-bottom:0;}
.example .description::before {
  content: "Example: ";
}
.example[open] .description {
  margin-bottom: 1em;
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 2px #99b3c0;
  background-color: #99b3c0;
  padding-left: 1px;
  padding-right: 1px;
  padding-bottom: 1px;
  padding-top: 1.5rem;
  margin-bottom: 1rem;
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  background-color: white;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 1.5rem;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: 1.5rem !important;
  margin-right: 1.5rem;
}

.namedocs .label {
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  right: 0.5rem;
  top: 0.5rem;
}

/* Sticking content into the right margin is not good on narrow screens,
   so move the label to the left to make space for the permalink widget. */

@media screen and (max-width: 700px) {
  .namedocs:has(.permalink-widget.block) .label {
    right: 1.5rem;
  }
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold;
}

.namedocs > .text .constructor {
  padding-left: 0.5rem;
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: 1.5rem;
}
.namedocs .text > :last-child {
  margin-bottom: 1.5rem;
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: table-row;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files/#The-Lean-Language-Reference--Source-Files">Source Files</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Recursive-Definitions/#recursive-definitions">Recursive Definitions</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="current numbered"><td class="num">9.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="Output-from-Lean/#The-Lean-Language-Reference--Output-from-Lean">Output from Lean</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Elan/#elan">Elan</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-monads-and-do" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-monads-and-do" checked="checked"></label><span class="number">9.</span> <span class=""><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></span></div>
              <table><tr class="numbered"><td class="num">9.1.</td><td><a href="Functors___-Monads-and--do--Notation/Laws/#monad-laws">Laws</a></td></tr><tr class="numbered"><td class="num">9.2.</td><td><a href="Functors___-Monads-and--do--Notation/Lifting-Monads/#lifting-monads">Lifting Monads</a></td></tr><tr class="current numbered"><td class="num">9.3.</td><td><a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax">Syntax</a></td></tr><tr class="numbered"><td class="num">9.4.</td><td><a href="Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference">API Reference</a></td></tr><tr class="numbered"><td class="num">9.5.</td><td><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-varieties">Varieties of Monads</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax" checked="checked"></label><span class="number">9.3.</span> <span class="current"><a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax">Syntax</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators">Infix Operators</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Functors">Functors</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____GT___FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;$&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____GT___FLQQ_-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;&&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Applicative-Functors">Applicative Functors</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____GT___FLQQ_-next-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;*&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term_____GT___FLQQ_-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">*&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT______FLQQ_-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;*</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____GT___FLQQ_-next-next-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;|&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.3.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Monads">Monads</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__GT__GT______FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&gt;&gt;=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term_____LT__LT___FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&lt;&lt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__GT_____GT___FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&gt;=&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____LT___FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;=&lt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#do-notation"><code>do</code>-Notation</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="syntax"><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Sequential-Computations">Sequential Computations</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next"><span class="syntax"><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="meta">…</span><span class="meta">(</span><span class="keyword">:</span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.2.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Early-Return">Early Return</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">return</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">return</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.3.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Local-Mutable-State">Local Mutable State</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="keyword">mut</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="keyword">mut</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doReassign"><span class="syntax"><span class="meta">…</span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doReassign-next"><span class="syntax"><span class="meta">…</span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doReassignArrow"><span class="syntax"><span class="meta">…</span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doReassignArrow-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.4.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#do-control-structures">Control Structures</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">if</span><span class="ws"> </span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">then</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">else</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">unless</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">match</span><span class="ws"> </span><span class="meta">(</span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="meta">),*</span><span class="ws"> </span><span class="keyword">with</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)*</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.5.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Iteration">Iteration</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">for</span><span class="ws"> </span><span class="meta">(</span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">in</span><span class="ws"> </span><span class="meta">…</span><span class="meta">),*</span><span class="ws"> </span><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">while</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">while</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">repeat</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">until</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">repeat</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">continue</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">break</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.6.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#closest-do-block">Identifying <code>do</code> Blocks</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.7.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Type-Classes-for-Iteration">Type Classes for Iteration</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><code>ForIn</code></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk"><code>ForIn'</code></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><code>ForInStep</code></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk"><code>ForM</code></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___forIn"><code>forIn</code></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Functors___-Monads-and--do--Notation/Lifting-Monads/#lifting-monads" rel="prev" title="9.2. Lifting Monads"><span class="arrow">←</span><span class="where">9.2. Lifting Monads</span></a><a class="local-button active" href="Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference" rel="next" title="9.4. API Reference"><span class="where">9.4. API Reference</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              9.3. Syntax</h1>
            <p>
              Lean supports programming with functors, applicative functors, and monads via special syntax:</p>
            <ul>
              <li>
                <p>
                  Infix operators are provided for the most common operations.</p>
                </li>
              <li>
                <p>
                  An embedded language called <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-notation"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</a> allows the use of imperative syntax when writing programs in a monad.</p>
                </li>
              </ul>
            <section>
              <h2 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators">
                9.3.1. Infix Operators</h2>
              <p>
                Infix operators are primarily useful in smaller expressions, or when there is no <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="167">Monad</span></a></code> instance.</p>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Functors">
                  9.3.1.1. Functors</h3>
                <p>
                  There are two infix operators for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308">Functor.map</span></a></code>.</p>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Functor Operators</span><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.54" data-verso-hover="107">g</span> <span class="unknown token" data-binding="">&lt;$&gt;</span> <span class="var token" data-binding="var-_uniq.56" data-verso-hover="2025">x</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308">Functor.map</span></a> <span class="var token" data-binding="var-_uniq.96" data-verso-hover="107">g</span> <span class="var token" data-binding="var-_uniq.98" data-verso-hover="2025">x</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____GT___FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<$>_»"><code class="hover-info"><code class="docstring">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.

When mapping a constant function, use `Functor.mapConst` instead, because it may be more
efficient.


Conventions for notations in identifiers:

 * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;$&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.132" data-verso-hover="2025">x</span> <span class="unknown token" data-binding="">&lt;&&gt;</span> <span class="var token" data-binding="var-_uniq.130" data-verso-hover="107">g</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308">Functor.map</span></a> <span class="var token" data-binding="var-_uniq.172" data-verso-hover="107">g</span> <span class="var token" data-binding="var-_uniq.174" data-verso-hover="2025">x</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____GT___FLQQ_-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<&>_»"><code class="hover-info"><code class="docstring">Maps a function over a functor, with parameters swapped so that the function comes last.

This function is `Functor.map` with the parameters reversed, typically used via the `&lt;&&gt;` operator.


Conventions for notations in identifiers:

 * The recommended spelling of `&lt;&&gt;` in identifiers is `mapRev`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;&&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Applicative-Functors">
                  9.3.1.2. Applicative Functors</h3>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Applicative Operators</span><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.214" data-verso-hover="2127">g</span> <span class="unknown token" data-binding="">&lt;*&gt;</span> <span class="var token" data-binding="var-_uniq.216" data-verso-hover="2025">x</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Seq___mk"><span class="const token" data-binding="const-Seq.seq" data-verso-hover="2042">Seq.seq</span></a> <span class="var token" data-binding="var-_uniq.283" data-verso-hover="2127">g</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1744">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.285" data-verso-hover="2025">x</span><span class="unknown token" data-binding="">)</span></code>.
The function is inserted to delay evaluation because control might not reach the argument.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____GT___FLQQ_-next-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<*>_»"><code class="hover-info"><code class="docstring">The implementation of the `&lt;*&gt;` operator.

In a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the
function first, then the argument, and applies one to the other.

To avoid surprising evaluation semantics, `mx` is taken "lazily", using a `Unit → f α` function.


Conventions for notations in identifiers:

 * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;*&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.351" data-verso-hover="2025">e1</span> <span class="unknown token" data-binding="">*&gt;</span> <span class="var token" data-binding="var-_uniq.357" data-verso-hover="2048">e2</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#SeqRight___mk"><span class="const token" data-binding="const-SeqRight.seqRight" data-verso-hover="2119">SeqRight.seqRight</span></a> <span class="var token" data-binding="var-_uniq.420" data-verso-hover="2025">e1</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1935">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.426" data-verso-hover="2048">e2</span><span class="unknown token" data-binding="">)</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term_____GT___FLQQ_-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_*>_»"><code class="hover-info"><code class="docstring">Sequences the effects of two terms, discarding the value of the first. This function is usually
invoked via the `*&gt;` operator.

Given `x : f α` and `y : f β`, `x *&gt; y` runs `x`, then runs `y`, and finally returns the result of
`y`.

The evaluation of the second argument is delayed by wrapping it in a function, enabling
“short-circuiting” behavior from `f`.


Conventions for notations in identifiers:

 * The recommended spelling of `*&gt;` in identifiers is `seqRight`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">*&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.484" data-verso-hover="2025">e1</span> <span class="unknown token" data-binding="">&lt;*</span> <span class="var token" data-binding="var-_uniq.490" data-verso-hover="2048">e2</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#SeqLeft___mk"><span class="const token" data-binding="const-SeqLeft.seqLeft" data-verso-hover="2118">SeqLeft.seqLeft</span></a> <span class="var token" data-binding="var-_uniq.553" data-verso-hover="2025">e1</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2033">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.559" data-verso-hover="2048">e2</span><span class="unknown token" data-binding="">)</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT______FLQQ_-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<*_»"><code class="hover-info"><code class="docstring">Sequences the effects of two terms, discarding the value of the second. This function is usually
invoked via the `&lt;*` operator.

Given `x : f α` and `y : f β`, `x &lt;* y` runs `x`, then runs `y`, and finally returns the result of
`x`.

The evaluation of the second argument is delayed by wrapping it in a function, enabling
“short-circuiting” behavior from `f`.


Conventions for notations in identifiers:

 * The recommended spelling of `&lt;*` in identifiers is `seqLeft`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;*</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                <p>
                  Many applicative functors also support failure and recovery via the <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Alternative___mk"><span class="const token" data-binding="const-Alternative" data-verso-hover="2024">Alternative</span></a></code> type class.
This class also has an infix operator.</p>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Alternative Operators</span><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.658" data-verso-hover="2025">e</span> <span class="unknown token" data-binding="">&lt;|&gt;</span> <span class="var token" data-binding="var-_uniq.660" data-verso-hover="2025">e'</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-OrElse.orElse" data-verso-hover="2206">OrElse.orElse</span> <span class="var token" data-binding="var-_uniq.762" data-verso-hover="2025">e</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2322">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.764" data-verso-hover="2025">e'</span><span class="unknown token" data-binding="">)</span></code>.
The function is inserted to delay evaluation because control might not reach the argument.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____GT___FLQQ_-next-next-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<|>_»"><code class="hover-info"><code class="docstring">`a &lt;|&gt; b` executes `a` and returns the result, unless it fails in which
case it executes and returns `b`. Because `b` is not always executed, it
is passed as a thunk so it can be forced only when needed.
The meaning of this notation is type-dependent. 

Conventions for notations in identifiers:

 * The recommended spelling of `&lt;|&gt;` in identifiers is `orElse`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;|&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-2771">structure</span> <span class="const token" data-binding="const-User" data-verso-hover="2207">User</span> <span class="keyword token" data-binding="kw-occ-null-2786">where</span>
  <span class="const token" data-binding="const-User.name" data-verso-hover="2208">name</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a>
  <span class="const token" data-binding="const-User.favoriteNat" data-verso-hover="2209">favoriteNat</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2828">def</span> <span class="const token" data-binding="const-main" data-verso-hover="2210">main</span> <span class="unknown token" data-binding="">:</span> <a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a> <a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/#Pure___mk"><span class="const token" data-binding="const-Pure.pure" data-verso-hover="1160">pure</span></a> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><details class="example"><summary class="description">Infix <code>Functor</code> and <code>Applicative</code> Operators</summary><p>
                    A common functional programming idiom is to use a pure function in some context with effects by applying it via <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1308">Functor.map</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Seq___mk"><span class="const token" data-binding="const-Seq.seq" data-verso-hover="2042">Seq.seq</span></a></code>.
The function is applied to its sequence of arguments using <code>&lt;$&gt;</code>, and the arguments are separated by <code>&lt;*&gt;</code>.</p>
                  <p>
                    In this example, the constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-User.mk" data-verso-hover="2211">User.mk</span></code> is applied via this idiom in the body of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="2210">main</span></code>.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span> <span class="const token" data-binding="const-getName" data-verso-hover="2212" id="main-next">getName</span> <span class="unknown token" data-binding="">:</span> <a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-27">do</span></a>
  <a href="IO/Console-Output/#IO___println"><span class="const token" data-binding="const-IO.println" data-verso-hover="4">IO.println</span></a> <span class="literal string token" data-binding="" data-verso-hover="2213">"What is your name?"</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-66" data-verso-hover="157">return</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <a href="IO/Files___-File-Handles___-and-Streams/#IO___getStdin"><span class="const token" data-binding="const-IO.getStdin" data-verso-hover="2214">IO.getStdin</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="IO/Files___-File-Handles___-and-Streams/#IO___FS___Stream___mk"><span class="const token" data-binding="const-IO.FS.Stream.getLine" data-verso-hover="2215">getLine</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___trimRight"><span class="const token" data-binding="const-String.trimRight" data-verso-hover="2216">trimRight</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.partial-116">partial</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-124">def</span> <span class="const token" data-binding="const-getFavoriteNat" data-verso-hover="2217" id="main-next">getFavoriteNat</span> <span class="unknown token" data-binding="">:</span> <a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-155">do</span></a>
  <a href="IO/Console-Output/#IO___println"><span class="const token" data-binding="const-IO.println" data-verso-hover="4">IO.println</span></a> <span class="literal string token" data-binding="" data-verso-hover="2218">"What is your favorite natural number?"</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-213">let</span> <span class="var token" data-binding="var-_uniq.548" data-verso-hover="239">line</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <a href="IO/Files___-File-Handles___-and-Streams/#IO___getStdin"><span class="const token" data-binding="const-IO.getStdin" data-verso-hover="2214">IO.getStdin</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="IO/Files___-File-Handles___-and-Streams/#IO___FS___Stream___mk"><span class="const token" data-binding="const-IO.FS.Stream.getLine" data-verso-hover="2215">getLine</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-254">if</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIfLet-257">let</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.565" data-verso-hover="7">n</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.548" data-verso-hover="239">line</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___trim"><span class="const token" data-binding="const-String.trim" data-verso-hover="2219">trim</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___toNat___"><span class="const token" data-binding="const-String.toNat?" data-verso-hover="2220">toNat?</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-254">then</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-297" data-verso-hover="157">return</span> <span class="var token" data-binding="var-_uniq.565" data-verso-hover="7">n</span>
  <span class="keyword token" data-binding="kw-occ-null-308">else</span>
    <a href="IO/Console-Output/#IO___println"><span class="const token" data-binding="const-IO.println" data-verso-hover="4">IO.println</span></a> <span class="literal string token" data-binding="" data-verso-hover="2221">"Let's try again."</span>
    <a href="Functors___-Monads-and--do--Notation/Syntax/#main-next"><span class="const token" data-binding="const-getFavoriteNat" data-verso-hover="2217">getFavoriteNat</span></a>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-367">structure</span> <span class="const token" data-binding="const-User" data-verso-hover="2207">User</span> <span class="keyword token" data-binding="kw-occ-null-382">where</span>
  <span class="const token" data-binding="const-User.name" data-verso-hover="2208">name</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Strings/#String___mk"><span class="const token" data-binding="const-String" data-verso-hover="72">String</span></a>
  <span class="const token" data-binding="const-User.favoriteNat" data-verso-hover="2209">favoriteNat</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a>
<span class="keyword token" data-binding="kw-occ-null-424">deriving</span> <span class="const token" data-binding="const-Repr" data-verso-hover="262">Repr</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-439">def</span> <span class="const token" data-binding="const-main" data-verso-hover="2210">main</span> <span class="unknown token" data-binding="">:</span> <a href="IO/Logical-Model/#IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a> <a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-461">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-466">let</span> <span class="var token" data-binding="var-_uniq.2104" data-verso-hover="2222">user</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-User.mk" data-verso-hover="2211">User.mk</span> <span class="unknown token" data-binding="">&lt;$&gt;</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#main-next"><span class="const token" data-binding="const-getName" data-verso-hover="2212">getName</span></a> <span class="unknown token" data-binding="">&lt;*&gt;</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#main-next"><span class="const token" data-binding="const-getFavoriteNat" data-verso-hover="2217">getFavoriteNat</span></a>
  <a href="IO/Console-Output/#IO___println"><span class="const token" data-binding="const-IO.println" data-verso-hover="4">IO.println</span></a> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-repr" data-verso-hover="2223">repr</span> <span class="var token" data-binding="var-_uniq.2104" data-verso-hover="2222">user</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                    When run with this input:</p>
                  <div class="example-file">
                    <code>stdin</code><code class="line">A. Lean User</code><code class="line">None</code><code class="line">42</code></div>
                  <p>
                    it produces this output:</p>
                  <div class="example-file">
                    <code>stdout</code><code class="line">What is your name?</code><code class="line">What is your favorite natural number?</code><code class="line">Let's try again.</code><code class="line">What is your favorite natural number?</code><code class="line">{ name := "A. Lean User", favoriteNat := 42 }</code></div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Monads">
                  9.3.1.3. Monads</h3>
                <p>
                  Monads are primarily used via <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-notation"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</a>.
However, it can sometimes be convenient to describe monadic computations via operators.</p>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Monad Operators</span><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.861" data-verso-hover="170">act</span> <span class="unknown token" data-binding="">&gt;&gt;=</span> <span class="var token" data-binding="var-_uniq.865" data-verso-hover="2111">f</span></code> is syntax for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1297">Bind.bind</span></a> <span class="var token" data-binding="var-_uniq.940" data-verso-hover="170">act</span> <span class="var token" data-binding="var-_uniq.944" data-verso-hover="2111">f</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__GT__GT______FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_>>=_»"><code class="hover-info"><code class="docstring">Sequences two computations, allowing the second to depend on the value computed by the first.

If `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get
a value of type `α` and then passing it to `f`.


Conventions for notations in identifiers:

 * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&gt;&gt;=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      Similarly, the reversed operator <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1013" data-verso-hover="2111">f</span> <span class="unknown token" data-binding="">=&lt;&lt;</span> <span class="var token" data-binding="var-_uniq.1009" data-verso-hover="170">act</span></code> is syntax for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1297">Bind.bind</span></a> <span class="var token" data-binding="var-_uniq.1087" data-verso-hover="170">act</span> <span class="var token" data-binding="var-_uniq.1091" data-verso-hover="2111">f</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term_____LT__LT___FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_=<<_»"><code class="hover-info"><code class="docstring">Same as `Bind.bind` but with arguments swapped. 

Conventions for notations in identifiers:

 * The recommended spelling of `=&lt;&lt;` in identifiers is `bindLeft`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">=&lt;&lt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      The Kleisli composition operators <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/API-Reference/#Bind___kleisliRight"><span class="const token" data-binding="const-Bind.kleisliRight" data-verso-hover="2224">Bind.kleisliRight</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/API-Reference/#Bind___kleisliLeft"><span class="const token" data-binding="const-Bind.kleisliLeft" data-verso-hover="2225">Bind.kleisliLeft</span></a></code> also have infix operators.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__GT_____GT___FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_>=>_»"><code class="hover-info"><code class="docstring">Left-to-right composition of Kleisli arrows. 

Conventions for notations in identifiers:

 * The recommended spelling of `&gt;=&gt;` in identifiers is `kleisliRight`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&gt;=&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____LT___FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<=<_»"><code class="hover-info"><code class="docstring">Right-to-left composition of Kleisli arrows. 

Conventions for notations in identifiers:

 * The recommended spelling of `&lt;=&lt;` in identifiers is `kleisliLeft`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;=&lt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="do-notation">
                9.3.2. <code>do</code>-Notation<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=do-notation" title="Permalink">🔗</a></span></h2>
              <p>
                Monads are primarily used via <span id="--tech-term-do-notation"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</span>, which is an embedded language for programming in an imperative style.
It provides familiar syntax for sequencing effectful operations, early return, local mutable variables, loops, and exception handling.
All of these features are translated to the operations of the <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="167">Monad</span></a></code> type class, with a few of them requiring addition instances of classes such as <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2226">ForIn</span></a></code> that specify iteration over containers.
A <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> term consists of the keyword <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> followed by a sequence of <span id="--tech-term-do-items"><em><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> items</em></span>.</p>
              <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title"><code>do</code>-Notation</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___do"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.do"><span class="keyword">do</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span></pre><p>
                    The items in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> may be separated by semicolons; otherwise, each should be on its own line and they should have equal indentation.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Sequential-Computations">
                  9.3.2.1. Sequential Computations</h3>
                <p>
                  One form of <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-items"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> item</a> is a term.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem">
                  <span class="label">syntax</span><span class="title">Terms in <code>do</code>-Notation</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  A term followed by a sequence of items is translated to a use of <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1297">bind</span></a></code>; in particular, <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6516">do</span></a> <span class="unknown token" data-binding="">e1</span><span class="unknown token" data-binding="">;</span> <span class="unknown token" data-binding="">es</span></code> is translated to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1376" data-verso-hover="2227">e1</span> <span class="unknown token" data-binding="">&gt;&gt;=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-6558">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6568">do</span></a> <span class="var token" data-binding="var-_uniq.1380" data-verso-hover="170">es</span></code>.</p>
                <table class="tabular"><tr><th><p>
                        <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> Item</p>
                      </th><th><p>
                        Desugaring</p>
                      </th></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6704">do</span></a>
<span class="unknown token" data-binding="">e1</span>
<span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1492" data-verso-hover="2227">e1</span> <span class="unknown token" data-binding="">&gt;&gt;=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-6756">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6766">do</span></a> <span class="var token" data-binding="var-_uniq.1496" data-verso-hover="170">es</span></code></td></tr></table><p>
                  The result of the term's computation may also be named, allowing it to be used in subsequent steps.
This is done using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doLet : doElem</code></code><code class="kw">let</code></span>.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next">
                  <span class="label">syntax</span><span class="title">Data Dependence in <code>do</code>-Notation</span><div class="text">
                    <p>
                      There are two forms of monadic <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doLet : doElem</code></code><code class="kw">let</code></span>-binding in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block.
The first binds an identifier to the result, with an optional type annotation:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLetArrow"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.doIdDecl"><span class="nonterminal" data-kind="ident">ident</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span><span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span> </span><span class="keyword">←</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      The second binds a pattern to the result.
The fallback clause, beginning with <code>|</code>, specifies the behavior when the pattern does not match the result.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLetArrow"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.doPatDecl"><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">←</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.doSeq.pseudo">doSeq</span></span><span class="bnf">)?</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  This syntax is also translated to a use of <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1297">bind</span></a></code>.
<code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-7857">do</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-7860">let</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">e1</span><span class="unknown token" data-binding="">;</span> <span class="unknown token" data-binding="">es</span></code> is translated to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1704" data-verso-hover="2132">e1</span> <span class="unknown token" data-binding="">&gt;&gt;=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-7909">fun</span> <span class="var token" data-binding="var-_uniq.1735" data-verso-hover="112">x</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-7918">do</span></a> <span class="var token" data-binding="var-_uniq.1702" data-verso-hover="170">es</span></code>, and fallback clauses are translated to default pattern matches.
<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doLet : doElem</code></code><code class="kw">let</code></span> may also be used with the standard definition syntax <code>:=</code> instead of <code>←</code>.
This indicates a pure, rather than monadic, definition:</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Local Definitions in <code>do</code>-Notation</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLet"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.letDecl"><code class="hover-info"><code class="docstring">`letDecl` matches the body of a let declaration `let f x1 x2 := e`,
`let pat := e` (where `pat` is an arbitrary term) or `let f | pat1 =&gt; e1 | pat2 =&gt; e2 ...`
(a pattern matching declaration), except for the `let` keyword itself.
`let rec` declarations are not handled here. </code></code><span class="from-nonterminal" data-kind="Lean.Parser.Term.letIdDecl"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8291">do</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-8294">let</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">;</span> <span class="unknown token" data-binding="">es</span></code> is translated to <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-8334" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.1858" data-verso-hover="112">x</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.1830" data-verso-hover="112">e</span><span class="unknown token" data-binding="">;</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8346">do</span></a> <span class="unknown token" data-binding="">es</span></code>.</p>
                <table class="tabular"><tr><th><p>
                        <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> Item</p>
                      </th><th><p>
                        Desugaring</p>
                      </th></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8481">do</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-8488">let</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">e1</span>
<span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1994" data-verso-hover="2132">e1</span> <span class="unknown token" data-binding="">&gt;&gt;=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8543">fun</span> <span class="var token" data-binding="var-_uniq.2025" data-verso-hover="112">x</span> <span class="unknown token" data-binding="">=&gt;</span>
  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8558">do</span></a> <span class="var token" data-binding="var-_uniq.1992" data-verso-hover="170">es</span></code></td></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8602">do</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-8609">let</span> <span class="unknown token" data-binding="">some</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">e1?</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">fallback</span>
<span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2242" data-verso-hover="2228">e1?</span> <span class="unknown token" data-binding="">&gt;&gt;=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8688">fun</span>
  <span class="unknown token" data-binding="">|</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a> <span class="var token" data-binding="var-_uniq.2286" data-verso-hover="112">x</span> <span class="unknown token" data-binding="">=&gt;</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8710">do</span></a>
    <span class="var token" data-binding="var-_uniq.2237" data-verso-hover="170">es</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.2244" data-verso-hover="170">fallback</span></code></td></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8784">do</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-8791">let</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">e</span>
<span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-8837" data-verso-hover="286">let</span> <span class="var token" data-binding="var-_uniq.2467" data-verso-hover="112">x</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.2439" data-verso-hover="112">e</span>
<a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8852">do</span></a> <span class="unknown token" data-binding="">es</span></code></td></tr></table><p>
                  Within a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, <code>←</code> may be used as a prefix operator.
The expression to which it is applied is replaced with a fresh variable, which is bound using <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1297">bind</span></a></code> just before the current step.
This allows monadic effects to be used in positions that otherwise might expect a pure value, while still maintaining the distinction between <em>describing</em> an effectful computation and actually <em>executing</em> its effects.
Multiple occurrences of <code>←</code> are processed from left to right, inside to outside.</p>
                <figure><table class="tabular"><tr><th><p>
                          Example <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> Item</p>
                        </th><th><p>
                          Desugaring</p>
                        </th></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10062">do</span></a>
<span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">e1</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">e2</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10124">do</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10131">let</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">e1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10148">let</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">e2</span>
<span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">y</span>
<span class="unknown token" data-binding="">es</span></code></td></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10216">do</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-10223">let</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">g</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">e1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10286">do</span></a>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10293">let</span> <span class="unknown token" data-binding="">y</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">e1</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10310">let</span> <span class="unknown token" data-binding="">z</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">y</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-10328">let</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">g</span> <span class="unknown token" data-binding="">z</span>
<span class="unknown token" data-binding="">es</span></code></td></tr></table><figcaption>Example Nested Action Desugarings</figcaption></figure><p>
                  In addition to convenient support for sequential computations with data dependencies, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation also supports the local addition of a variety of effects, including early return, local mutable state, and loops with early termination.
These effects are implemented via transformations of the entire <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block in a manner akin to <a class="technical-term" href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#--tech-term-monad-transformer">monad transformers</a>, rather than via a local desugaring.</p>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Early-Return">
                  9.3.2.2. Early Return</h3>
                <p>
                  Early return terminates a computation immediately with a given value.
The value is returned from the closest containing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block; however, this may not be the closest <code>do</code> keyword.
The rules for determining the extent of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block are described <a href="Functors___-Monads-and--do--Notation/Syntax/#closest-do-block">in their own section</a>.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Early Return</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doReturn"><code class="hover-info"><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><span class="keyword">return</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doReturn"><code class="hover-info"><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><span class="keyword">return</span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  Not all monads include early return.
Thus, when a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block contains <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span>, the code needs to be rewritten to simulate the effect.
A program that uses early return to compute a value of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.3071" data-verso-hover="88">α</span></code> in a monad <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.3108" data-verso-hover="688">m</span></code> can be thought of as a program in the monad <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#ExceptT"><span class="const token" data-binding="const-ExceptT" data-verso-hover="2167">ExceptT</span></a> <span class="var token" data-binding="var-_uniq.3164" data-verso-hover="88">α</span> <span class="var token" data-binding="var-_uniq.3155" data-verso-hover="688">m</span> <span class="var token" data-binding="var-_uniq.3164" data-verso-hover="88">α</span></code>: early-returned values take the exception pathway, while ordinary returns do not.
Then, an outer handler can return the value from either code paths.
Internally, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> elaborator performs a translation very much like this one.</p>
                <p>
                  On its own, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span> is short for <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span>​<code></code>​<code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code>.</p>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Local-Mutable-State">
                  9.3.2.3. Local Mutable State</h3>
                <p>
                  Local mutable state is mutable state that cannot escape the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block in which it is defined.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doLet : doElem</code></code><code class="kw">let mut</code></span> binder introduces a locally-mutable binding.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Local Mutability</span><div class="text">
                    <p>
                      Mutable bindings may be initialized either with pure computations or with monadic computations:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLet"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"><span class="keyword">mut</span> </span><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.letDecl"><code class="hover-info"><code class="docstring">`letDecl` matches the body of a let declaration `let f x1 x2 := e`,
`let pat := e` (where `pat` is an arbitrary term) or `let f | pat1 =&gt; e1 | pat2 =&gt; e2 ...`
(a pattern matching declaration), except for the `let` keyword itself.
`let rec` declarations are not handled here. </code></code><span class="from-nonterminal" data-kind="Lean.Parser.Term.letIdDecl"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLetArrow"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"><span class="keyword">mut</span> </span><span class="from-nonterminal" data-kind="Lean.Parser.Term.doIdDecl"><span class="nonterminal" data-kind="ident">ident</span> <span class="from-nonterminal" data-kind="null"></span><span class="keyword">←</span> <span class="nonterminal" data-kind="doElem.pseudo">doElem</span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      Similarly, they can be mutated either with pure values or the results of monad computations:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doReassign"><span class="nonterminal" data-kind="doElem">doElem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doReassign"><span class="from-nonterminal" data-kind="Lean.Parser.Term.letIdDecl"><span class="nonterminal" data-kind="ident">ident</span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span>  </span><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doReassign-next"><span class="nonterminal" data-kind="doElem">doElem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doReassign"><span class="from-nonterminal" data-kind="Lean.Parser.Term.letPatDecl"><span class="nonterminal" data-kind="term.pseudo">term</span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span> </span><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doReassignArrow"><span class="nonterminal" data-kind="doElem">doElem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doReassignArrow"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doIdDecl"><span class="nonterminal" data-kind="ident">ident</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span> </span><span class="keyword">←</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doReassignArrow-next"><span class="nonterminal" data-kind="doElem">doElem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doReassignArrow"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doPatDecl"><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">←</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.doSeq.pseudo">doSeq</span></span><span class="bnf">)?</span></span></span></span></pre></div>
                  </div>
                <p>
                  These locally-mutable bindings are less powerful than a <a class="technical-term" href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#--tech-term-State-monads">state monad</a> because they are not mutable outside their lexical scope; this also makes them easier to reason about.
When <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> blocks contain mutable bindings, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> elaborator transforms the expression similarly to the way that <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#StateT"><span class="const token" data-binding="const-StateT" data-verso-hover="2104">StateT</span></a></code> would, constructing a new monad and initializing it with the correct values.</p>
                </section>
              <section>
                <h3 id="do-control-structures">
                  9.3.2.4. Control Structures<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=do-control-structures" title="Permalink">🔗</a></span></h3>
                <p>
                  There are <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> items that correspond to most of Lean's term-level control structures.
When they occur as a step in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, they are interpreted as <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> items rather than terms.
Each branch of the control structures is a sequence of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> items, rather than a term, and some of them are more syntactically flexible than their corresponding terms.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Conditionals</span><div class="text">
                    <p>
                      In a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">if</code></span> statements may omit their <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">else</code></span> branch.
Omitting an <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">else</code></span> branch is equivalent to using <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Pure___mk"><span class="const token" data-binding="const-Pure.pure" data-verso-hover="1160">pure</span></a></code><code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code> as the contents of the branch.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doIf"><span class="keyword">if</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doIfProp"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span> </span><span class="keyword">then</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span>
      </span></span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">else</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="bnf">)?</span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  Syntactically, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">then</code></span> branch cannot be omitted.
For these cases, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">unless</code></span> only executes its body when the condition is false.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> in <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">unless</code></span> is part of its syntax and does not induce a nested <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Reverse Conditionals</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doUnless"><span class="keyword">unless</span> <span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">do</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  When <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doMatch : doElem</code></code><code class="kw">match</code></span> is used in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, each branch is considered to be part of the same block.
Otherwise, it is equivalent to the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> term.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Pattern Matching</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doMatch"><span class="keyword">match</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.matchDiscr"><code class="hover-info"><code class="docstring">`matchDiscr` matches a "match discriminant", either `h : tm` or `tm`, used in `match` as
`match h1 : e1, e2, h3 : e3 with ...`. </code></code><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span> <span class="keyword">:</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">),*</span> </span><span class="keyword">with</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlts"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlt"><span class="keyword">|</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span><span class="bnf">,*</span> </span></span><span class="keyword">=&gt;</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span></span><span class="bnf">)*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Iteration">
                  9.3.2.5. Iteration</h3>
                <p>
                  Within a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span>​<code>…</code>​<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">in</code></span> loops allow iteration over a data structure.
The body of the loop is part of the containing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, so local effects such as early return and mutable variables may be used.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Iteration over Collections</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doFor"><code class="hover-info"><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><span class="keyword">for</span> <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doForDecl"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">in</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">),*</span> </span><span class="keyword">do</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  A <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span>​<code>…</code>​<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">in</code></span> loop requires at least one clause that specifies the iteration to be performed, which consists of an optional membership proof name followed by a colon (<code>:</code>), a pattern to bind, the keyword <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">in</code></span>, and a collection term.
The pattern, which may just be an <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-Identifiers">identifier</a>, must match any element of the collection; patterns in this position cannot be used as implicit filters.
Further clauses may be provided by separating them with commas.
Each collection is iterated over at the same time, and iteration stops when any of the collections runs out of elements.</p>
                <details class="example"><summary class="description">Iteration Over Multiple Collections</summary><p>
                    When iterating over multiple collections, iteration stops when any of the collections runs out of elements.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">#[(0, 'a'), (1, 'b')]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-16983" data-verso-hover="6">#eval</span></a></span> <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id___run"><span class="const token" data-binding="const-Id.run" data-verso-hover="1156">Id.run</span></a> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-16996">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-17001">let</span> <span class="keyword token" data-binding="kw-occ-null-17005">mut</span> <span class="var token" data-binding="var-_uniq.225" data-verso-hover="2229">v</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-17020" data-verso-hover="1158">for</span> <span class="var token" data-binding="var-_uniq.210" data-verso-hover="7">x</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-17024">in</span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">:</span><span class="typed token" data-binding="" data-verso-hover="7">43</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.350" data-verso-hover="149">y</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-17037">in</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">'a'</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">'b'</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-17020" data-verso-hover="1158">do</span>
    <span class="var token" data-binding="var-_uniq.225" data-verso-hover="2229">v</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.225" data-verso-hover="2229">v</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___push"><span class="const token" data-binding="const-Array.push" data-verso-hover="150">push</span></a> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.210" data-verso-hover="7">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.350" data-verso-hover="149">y</span><span class="unknown token" data-binding="">)</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-17081" data-verso-hover="157">return</span> <span class="var token" data-binding="var-_uniq.225" data-verso-hover="2229">v</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>#[(0, 'a'), (1, 'b')]
</pre></div>
                  </details><details class="example"><summary class="description">Iteration over Array Indices with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span></summary><p>
                    When iterating over the valid indices for an array with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span>, naming the membership proof allows the tactic that searches for proofs that array indices are in bounds to succeed.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-17486">def</span> <span class="const token" data-binding="const-satisfyingIndices" data-verso-hover="2230" id="satisfyingIndices">satisfyingIndices</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="397">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="88">α</span> <span class="unknown token" data-binding="">→</span> <span class="sort token" data-binding="" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#DecidablePred"><span class="const token" data-binding="const-DecidablePred" data-verso-hover="2231">DecidablePred</span></a> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="397">p</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.63" data-verso-hover="230">xs</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="88">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <a href="Basic-Types/Arrays/#Array___mk"><span class="const token" data-binding="const-Array" data-verso-hover="85">Array</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id___run"><span class="const token" data-binding="const-Id.run" data-verso-hover="1156">Id.run</span></a> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-17582">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-17587">let</span> <span class="keyword token" data-binding="kw-occ-null-17591">mut</span> <span class="var token" data-binding="var-_uniq.208" data-verso-hover="84">out</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-17608" data-verso-hover="1158">for</span> <span class="var token" data-binding="var-_uniq.202" data-verso-hover="1161">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="7">i</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-17612">in</span> <span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.63" data-verso-hover="230">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size"><span class="const token" data-binding="const-Array.size" data-verso-hover="87">size</span></a><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-17608" data-verso-hover="1158">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-17640">if</span> <span class="var token" data-binding="var-_uniq.50" data-verso-hover="397">p</span> <span class="var token" data-binding="var-_uniq.63" data-verso-hover="230">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.199" data-verso-hover="7">i</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-17640">then</span> <span class="var token" data-binding="var-_uniq.208" data-verso-hover="84">out</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.208" data-verso-hover="84">out</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___push"><span class="const token" data-binding="const-Array.push" data-verso-hover="150">push</span></a> <span class="var token" data-binding="var-_uniq.199" data-verso-hover="7">i</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-17676" data-verso-hover="157">return</span> <span class="var token" data-binding="var-_uniq.208" data-verso-hover="84">out</span>
<span class="unknown token" data-binding=""></span></code><p>
                    Omitting the hypothesis name causes the array lookup to fail, because no proof is available in the context that the iteration variable is within the specified range.</p>
                  </details><p>
                  The body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span> loop is repeated while the condition remains true.
It is possible to write infinite loops using them in functions that are not marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span>.
This is because the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span> modifier only applies to non-termination or infinite regress induced by the function being defined, and not by those that it calls.
The translation of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span> loops relies on a separate helper.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Conditional Loops</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.doElemWhile_Do_"><span class="keyword">while</span> <span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">do</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.«doElemWhile_:_Do_»"><span class="keyword">while</span> <span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">do</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  The body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat__Until_ : doElem</code></code><code class="kw">repeat</code></span>-<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat__Until_ : doElem</code></code><code class="kw">until</code></span> loop is always executed at least once.
After each iteration, the condition is checked, and the loop is repeated when the condition is <strong>false</strong>.
When the condition becomes true, iteration stops.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Post-Tested Loops</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.doElemRepeat__Until_"><span class="keyword">repeat</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span>
      </span></span><span class="keyword">until</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  The body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat_ : doElem</code></code><code class="kw">repeat</code></span> loop is repeated until a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doBreak : doElem</code><span class="sep"></span><code class="docstring">`break` exits the surrounding `for` loop. </code></code><code class="kw">break</code></span> statement is executed.
Just like <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span> loops, these loops can be used in functions that are not marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span>.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Unconditional Loops</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.doElemRepeat_"><span class="keyword">repeat</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doContinue : doElem</code><span class="sep"></span><code class="docstring">`continue` skips to the next iteration of the surrounding `for` loop. </code></code><code class="kw">continue</code></span> statement skips the rest of the body of the closest enclosing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat_ : doElem</code></code><code class="kw">repeat</code></span>, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span>, or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> loop, moving on to the next iteration.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doBreak : doElem</code><span class="sep"></span><code class="docstring">`break` exits the surrounding `for` loop. </code></code><code class="kw">break</code></span> statement terminates the closest enclosing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat_ : doElem</code></code><code class="kw">repeat</code></span>, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span>, or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> loop, stopping iteration.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Loop Control Statements</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doContinue"><code class="hover-info"><code class="docstring">`continue` skips to the next iteration of the surrounding `for` loop. </code></code><span class="keyword">continue</span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doBreak"><code class="hover-info"><code class="docstring">`break` exits the surrounding `for` loop. </code></code><span class="keyword">break</span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  In addition to <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doBreak : doElem</code><span class="sep"></span><code class="docstring">`break` exits the surrounding `for` loop. </code></code><code class="kw">break</code></span>, loops can always be terminated by effects in the current monad.
Throwing an exception from a loop terminates the loop.</p>
                <details class="example"><summary class="description">Terminating Loops in the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> Monad</summary><p>
                    The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Alternative.failure" data-verso-hover="158">failure</span></code> method from the <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Alternative___mk"><span class="const token" data-binding="const-Alternative" data-verso-hover="2024">Alternative</span></a></code> class can be used to terminate an otherwise-infinite loop in the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a></code> monad.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">none</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-21428" data-verso-hover="6">#eval</span></a></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-21434">show</span> <a href="Basic-Types/Optional-Values/#Option___none"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-21450">from</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-21455">do</span></a>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-21460">let</span> <span class="keyword token" data-binding="kw-occ-null-21464">mut</span> <span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
  <span class="keyword token" data-binding="kw-occ-Lean.doElemRepeat_-21477">repeat</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-21488">if</span> <span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">&gt;</span> <span class="typed token" data-binding="" data-verso-hover="7">1000</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-21488">then</span> <span class="const token" data-binding="const-Alternative.failure" data-verso-hover="158">failure</span>
    <span class="keyword token" data-binding="kw-occ-null-21517">else</span> <span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">:=</span> <span class="typed token" data-binding="" data-verso-hover="7">2</span> <span class="unknown token" data-binding="">*</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">i</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-21541" data-verso-hover="157">return</span> <span class="var token" data-binding="var-_uniq.116" data-verso-hover="7">i</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>none
</pre></div>
                  </details></section>
              <section>
                <h3 id="closest-do-block">
                  9.3.2.6. Identifying <code>do</code> Blocks<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=closest-do-block" title="Permalink">🔗</a></span></h3>
                <p>
                  Many features of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation have an effect on the <span id="--tech-term-current-do-block">current <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block</span>.
In particular, early return aborts the current block, causing it to evaluate to the returned value, and mutable bindings can only be mutated in the block in which they are defined.
Understanding these features requires a precise definition of what it means to be in the “same” block.</p>
                <p>
                  Empirically, this can be checked using the Lean language server.
When the cursor is on a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span> statement, the corresponding <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> keyword is highlighted.
Attempting to mutate a mutable binding outside of the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block results in an error message.</p>
                <figure><p>
                    <img src="static/screenshots/do-return-hl-1.png" alt="Highlighting do from return"></p>
                  <p>
                    <img src="static/screenshots/do-return-hl-2.png" alt="Highlighting do from return with errors"></p>
                  <figcaption>Highlighting <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span></figcaption></figure><p>
                  The rules are as follows:</p>
                <ul>
                  <li>
                    <p>
                      Each item immediately nested under the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> keyword that begins a block belongs to that block.</p>
                    </li>
                  <li>
                    <p>
                      Each item immediately nested under the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> keyword that is an item in a containing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block belongs to the outer block.</p>
                    </li>
                  <li>
                    <p>
                      Items in the branches of an <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">if</code></span>, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doMatch : doElem</code></code><code class="kw">match</code></span>, or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">unless</code></span> item belong to the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block as the control structure that contains them. The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">do</code></span> keyword that is part of the syntax of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">unless</code></span> does not introduce a new <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block.</p>
                    </li>
                  <li>
                    <p>
                      Items in the body of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat_ : doElem</code></code><code class="kw">repeat</code></span>, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span>, and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> belong to the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block as the loop  that contains them. The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">do</code></span> keyword that is part of the syntax of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span> and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> does not introduce a new <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block.</p>
                    </li>
                  </ul>
                <details class="example"><summary class="description">Nested <code>do</code> and Branches</summary><p>
                    The following example outputs <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">6</span></code> rather than <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">7</span></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-24593">def</span> <span class="const token" data-binding="const-test" data-verso-hover="2232" id="test">test</span> <span class="unknown token" data-binding="">:</span> <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#StateM"><span class="const token" data-binding="const-StateM" data-verso-hover="1586">StateM</span></a> <a href="Basic-Types/Natural-Numbers/#Nat___zero"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a> <a href="Basic-Types/The-Unit-Type/#Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a> <span class="unknown token" data-binding="">:=</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-24623">do</span></a>
  <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#MonadStateOf___mk"><span class="const token" data-binding="const-MonadStateOf.set" data-verso-hover="2233">set</span></a> <span class="typed token" data-binding="" data-verso-hover="7">5</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-24636">if</span> <a href="Basic-Types/Booleans/#Bool___false"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-24636">then</span>
    <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#MonadStateOf___mk"><span class="const token" data-binding="const-MonadStateOf.set" data-verso-hover="2233">set</span></a> <span class="typed token" data-binding="" data-verso-hover="7">6</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doNested-24663">do</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-24666" data-verso-hover="157">return</span>
  <a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#MonadStateOf___mk"><span class="const token" data-binding="const-MonadStateOf.set" data-verso-hover="2233">set</span></a> <span class="typed token" data-binding="" data-verso-hover="7">7</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-24683" data-verso-hover="157">return</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">((), 6)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-24691" data-verso-hover="6">#eval</span></a></span> <a href="Functors___-Monads-and--do--Notation/Syntax/#test"><span class="const token" data-binding="const-test" data-verso-hover="2232">test</span></a><span class="unknown token" data-binding="">.</span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#StateT___run"><span class="const token" data-binding="const-StateT.run" data-verso-hover="2198">run</span></a> <span class="typed token" data-binding="" data-verso-hover="7">0</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                    <pre>((), 6)
</pre></div>
                  <p>
                    This is because the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span> statement under the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">if</code></span> belongs to the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> as its immediate parent, which itself belongs to the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> as the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">if</code></span>.
If <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> blocks that occurred as items in other <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> blocks instead created new blocks, then the example would output <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">7</span></code>.</p>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Type-Classes-for-Iteration">
                  9.3.2.7. Type Classes for Iteration</h3>
                <p>
                  To be used with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> loops without membership proofs, collections must implement the <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2226">ForIn</span></a></code> type class.
Implementing <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk"><span class="const token" data-binding="const-ForIn'" data-verso-hover="2234">ForIn'</span></a></code> additionally allows the use of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> loops with membership proofs.</p>
                <div class="namedocs" id="ForIn___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=ForIn.forIn" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block">ForIn.{u, v, u₁, u₂} (<span class="var token" data-binding="var-_uniq.3869" data-verso-hover="2235">m</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u₁</span> → <span class="sort token" data-binding="" data-verso-hover="50">Type u₂</span>)
  (<span class="var token" data-binding="var-_uniq.3870" data-verso-hover="55">ρ</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span>) (<span class="var token" data-binding="var-_uniq.3871" data-verso-hover="2236">α</span> : <a href="Type-Classes/Instance-Synthesis/#outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="902">outParam</span></a> <span class="sort token" data-binding="" data-verso-hover="50">(Type v)</span>) :
  <span class="sort token" data-binding="" data-verso-hover="50">Type (max (max (max u (u₁ + 1)) u₂) v)</span></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2226">ForIn</span></a> <span class="var token" data-binding="var-_uniq.3795" data-verso-hover="2235">m</span> <span class="var token" data-binding="var-_uniq.3796" data-verso-hover="55">ρ</span> <span class="var token" data-binding="var-_uniq.3797" data-verso-hover="2236">α</span></code> is the typeclass which supports <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span> <span class="unknown token" data-binding="">x</span> <span class="keyword token" data-binding="kw-occ-null-0">in</span> <span class="unknown token" data-binding="">xs</span></code> notation.
Here <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3808" data-verso-hover="2237">xs</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3796" data-verso-hover="55">ρ</span></code> is the type of the collection to iterate over, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3820" data-verso-hover="46">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3797" data-verso-hover="2236">α</span></code>
is the element type which is made available inside the loop, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3795" data-verso-hover="2235">m</span></code> is the monad
for the encompassing <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> block.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn.mk" data-verso-hover="2238">ForIn.mk</span></a>.{u, v, u₁, u₂}</pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="2239">forIn</span> : {<span class="var token" data-binding="var-_uniq.3840" data-verso-hover="2240">β</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u₁</span>} → [<span class="var token" data-binding="var-_uniq.3842" data-verso-hover="2241">inst</span> : <a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="167">Monad</span></a> <span class="var token" data-binding="var-_uniq.3835" data-verso-hover="2235">m</span>] → <span class="var token" data-binding="var-_uniq.3836" data-verso-hover="55">ρ</span> → <span class="var token" data-binding="var-_uniq.3840" data-verso-hover="2240">β</span> → (<span class="var token" data-binding="var-_uniq.3837" data-verso-hover="2236">α</span> → <span class="var token" data-binding="var-_uniq.3840" data-verso-hover="2240">β</span> → <span class="var token" data-binding="var-_uniq.3835" data-verso-hover="2235">m</span> (<a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2242">ForInStep</span></a> <span class="var token" data-binding="var-_uniq.3840" data-verso-hover="2240">β</span>)) → <span class="var token" data-binding="var-_uniq.3835" data-verso-hover="2235">m</span> <span class="var token" data-binding="var-_uniq.3840" data-verso-hover="2240">β</span></pre><div class="docs">
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">forIn</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">b</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">m</span> <span class="unknown token" data-binding="">β</span></code> runs a for-loop in the monad <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3875" data-verso-hover="2235">m</span></code> with additional state <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3882" data-verso-hover="2240">β</span></code>.
This traverses over the "contents" of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3890" data-verso-hover="2237">x</span></code>, and passes the elements <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3915" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3877" data-verso-hover="2236">α</span></code> to
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3902" data-verso-hover="2243">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3877" data-verso-hover="2236">α</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.3882" data-verso-hover="2240">β</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.3875" data-verso-hover="2235">m</span> <span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2242">ForInStep</span></a> <span class="var token" data-binding="var-_uniq.3882" data-verso-hover="2240">β</span><span class="unknown token" data-binding="">)</span></code>. <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3896" data-verso-hover="112">b</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3882" data-verso-hover="2240">β</span></code> is the initial state, and the return value
of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3902" data-verso-hover="2243">f</span></code> is the new state as well as a directive <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.</span><a href="Tactic-Proofs/Tactic-Reference/#done"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.done-1" data-verso-hover="1254">done</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.yield</span></code>
which indicates whether to abort early or continue iteration.</p>
                        <p>
                          The expression</p>
                        <pre>let mut b := ...
for x in xs do
  b ← foo x b
</pre><p>
                          in a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> block is syntactic sugar for:</p>
                        <pre>let b := ...
let b ← forIn xs b (fun x b =&gt; do
  let b ← foo x b
  return .yield b)
</pre><p>
                          (Here <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> corresponds to the variables mutated in the loop.)</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="ForIn______mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=ForIn'.forIn'" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block">ForIn'.{u, v, u₁, u₂} (<span class="var token" data-binding="var-_uniq.4562" data-verso-hover="2235">m</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u₁</span> → <span class="sort token" data-binding="" data-verso-hover="50">Type u₂</span>)
  (<span class="var token" data-binding="var-_uniq.4563" data-verso-hover="55">ρ</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span>) (<span class="var token" data-binding="var-_uniq.4564" data-verso-hover="2236">α</span> : <a href="Type-Classes/Instance-Synthesis/#outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="902">outParam</span></a> <span class="sort token" data-binding="" data-verso-hover="50">(Type v)</span>)
  (<span class="var token" data-binding="var-_uniq.4565" data-verso-hover="2244">d</span> : <a href="Type-Classes/Instance-Synthesis/#outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="902">outParam</span></a> (<span class="const token" data-binding="const-Membership" data-verso-hover="1235">Membership</span> <span class="var token" data-binding="var-_uniq.4564" data-verso-hover="2236">α</span> <span class="var token" data-binding="var-_uniq.4563" data-verso-hover="55">ρ</span>)) :
  <span class="sort token" data-binding="" data-verso-hover="50">Type (max (max (max u (u₁ + 1)) u₂) v)</span></pre><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk"><span class="const token" data-binding="const-ForIn'" data-verso-hover="2234">ForIn'</span></a> <span class="var token" data-binding="var-_uniq.3994" data-verso-hover="2235">m</span> <span class="var token" data-binding="var-_uniq.3995" data-verso-hover="55">ρ</span> <span class="var token" data-binding="var-_uniq.3996" data-verso-hover="2236">α</span> <span class="var token" data-binding="var-_uniq.3997" data-verso-hover="2244">d</span></code> is a variation on the <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2226">ForIn</span></a> <span class="var token" data-binding="var-_uniq.3994" data-verso-hover="2235">m</span> <span class="var token" data-binding="var-_uniq.3995" data-verso-hover="55">ρ</span> <span class="var token" data-binding="var-_uniq.3996" data-verso-hover="2236">α</span></code> typeclass which supports the
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span> <span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">x</span> <span class="keyword token" data-binding="kw-occ-null-0">in</span> <span class="unknown token" data-binding="">xs</span></code> notation. It is the same as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span> <span class="unknown token" data-binding="">x</span> <span class="keyword token" data-binding="kw-occ-null-0">in</span> <span class="unknown token" data-binding="">xs</span></code> except that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">h</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">∈</span> <span class="unknown token" data-binding="">xs</span></code>
is provided as an additional argument to the body of the for-loop.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk"><span class="const token" data-binding="const-ForIn'.mk" data-verso-hover="2245">ForIn'.mk</span></a>.{u, v, u₁, u₂}</pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="2246">forIn'</span> : {<span class="var token" data-binding="var-_uniq.4518" data-verso-hover="2240">β</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u₁</span>} → [<span class="var token" data-binding="var-_uniq.4520" data-verso-hover="2241">inst</span> : <a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="167">Monad</span></a> <span class="var token" data-binding="var-_uniq.4512" data-verso-hover="2235">m</span>] → (<span class="var token" data-binding="var-_uniq.4522" data-verso-hover="2237">x</span> : <span class="var token" data-binding="var-_uniq.4513" data-verso-hover="55">ρ</span>) → <span class="var token" data-binding="var-_uniq.4518" data-verso-hover="2240">β</span> → ((<span class="var token" data-binding="var-_uniq.4527" data-verso-hover="46">a</span> : <span class="var token" data-binding="var-_uniq.4514" data-verso-hover="2236">α</span>) → <span class="var token" data-binding="var-_uniq.4527" data-verso-hover="46">a</span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1162"> ∈ </span><span class="var token" data-binding="var-_uniq.4522" data-verso-hover="2237">x</span> → <span class="var token" data-binding="var-_uniq.4518" data-verso-hover="2240">β</span> → <span class="var token" data-binding="var-_uniq.4512" data-verso-hover="2235">m</span> (<a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2242">ForInStep</span></a> <span class="var token" data-binding="var-_uniq.4518" data-verso-hover="2240">β</span>)) → <span class="var token" data-binding="var-_uniq.4512" data-verso-hover="2235">m</span> <span class="var token" data-binding="var-_uniq.4518" data-verso-hover="2240">β</span></pre><div class="docs">
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">forIn'</span> <span class="unknown token" data-binding="">x</span> <span class="unknown token" data-binding="">b</span> <span class="unknown token" data-binding="">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">m</span> <span class="unknown token" data-binding="">β</span></code> runs a for-loop in the monad <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4570" data-verso-hover="2235">m</span></code> with additional state <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4578" data-verso-hover="2240">β</span></code>.
This traverses over the "contents" of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4586" data-verso-hover="2237">x</span></code>, and passes the elements <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4613" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4572" data-verso-hover="2236">α</span></code> along
with a proof that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4613" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">∈</span> <span class="var token" data-binding="var-_uniq.4586" data-verso-hover="2237">x</span></code> to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4598" data-verso-hover="2247">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4633" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4572" data-verso-hover="2236">α</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.4633" data-verso-hover="46">a</span> <span class="unknown token" data-binding="">∈</span> <span class="var token" data-binding="var-_uniq.4586" data-verso-hover="2237">x</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.4578" data-verso-hover="2240">β</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.4570" data-verso-hover="2235">m</span> <span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2242">ForInStep</span></a> <span class="var token" data-binding="var-_uniq.4578" data-verso-hover="2240">β</span><span class="unknown token" data-binding="">)</span></code>.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4592" data-verso-hover="112">b</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4578" data-verso-hover="2240">β</span></code> is the initial state, and the return value
of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4598" data-verso-hover="2247">f</span></code> is the new state as well as a directive <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.</span><a href="Tactic-Proofs/Tactic-Reference/#done"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.done-1" data-verso-hover="1254">done</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.yield</span></code>
which indicates whether to abort early or continue iteration.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="ForInStep___done">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=ForInStep" title="Permalink">🔗</a></span><span class="label">inductive type</span><pre class="signature hl lean block">ForInStep.{u} (<span class="var token" data-binding="var-_uniq.5084" data-verso-hover="55">α</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span>) : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span></pre><div class="text">
                    <p>
                      Auxiliary type used to compile <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span> <span class="unknown token" data-binding="">x</span> <span class="keyword token" data-binding="kw-occ-null-0">in</span> <span class="unknown token" data-binding="">xs</span></code> notation.</p>
                    <p>
                      This is the return value of the body of a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><span class="const token" data-binding="const-ForIn" data-verso-hover="2226">ForIn</span></a></code> call,
representing the body of a for loop. It can be:</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.yield</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">α</span><span class="unknown token" data-binding="">)</span></code>, meaning that we should continue the loop and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code> is the new state.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.yield</span></code> is produced by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">continue</span></code> and reaching the bottom of the loop body.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.done</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">α</span><span class="unknown token" data-binding="">)</span></code>, meaning that we should early-exit the loop with state <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">a</span></code>.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.</span><a href="Tactic-Proofs/Tactic-Reference/#done"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.done-1" data-verso-hover="1254">done</span></a></code> is produced by calls to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">break</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">return</span></code> in the loop,</p>
                        </li>
                      </ul>
                    <h1>
                      Constructors</h1>
                    <div class="constructor">
                      <pre class="name-and-type hl lean">done.{u} {<span class="var token" data-binding="var-_uniq.5077" data-verso-hover="55">α</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span>} : <span class="var token" data-binding="var-_uniq.5077" data-verso-hover="55">α</span> → <a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2242">ForInStep</span></a> <span class="var token" data-binding="var-_uniq.5077" data-verso-hover="55">α</span></pre><div class="docs">
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.done</span> <span class="unknown token" data-binding="">a</span></code> means that we should early-exit the loop.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.</span><a href="Tactic-Proofs/Tactic-Reference/#done"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.done-1" data-verso-hover="1254">done</span></a></code> is produced by calls to <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">break</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">return</span></code> in the loop.</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean">yield.{u} {<span class="var token" data-binding="var-_uniq.5080" data-verso-hover="55">α</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span>} : <span class="var token" data-binding="var-_uniq.5080" data-verso-hover="55">α</span> → <a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2242">ForInStep</span></a> <span class="var token" data-binding="var-_uniq.5080" data-verso-hover="55">α</span></pre><div class="docs">
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.yield</span> <span class="unknown token" data-binding="">a</span></code> means that we should continue the loop.
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">.yield</span></code> is produced by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">continue</span></code> and reaching the bottom of the loop body.</p>
                        </div>
                      </div>
                    </div>
                  </div>
                <div class="namedocs" id="ForM___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=ForM.mk" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block">ForM.{u, v, w₁, w₂} (<span class="var token" data-binding="var-_uniq.5487" data-verso-hover="706">m</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u</span> → <span class="sort token" data-binding="" data-verso-hover="50">Type v</span>)
  (<span class="var token" data-binding="var-_uniq.5488" data-verso-hover="2248">γ</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type w₁</span>) (<span class="var token" data-binding="var-_uniq.5489" data-verso-hover="2249">α</span> : <a href="Type-Classes/Instance-Synthesis/#outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="902">outParam</span></a> <span class="sort token" data-binding="" data-verso-hover="50">(Type w₂)</span>) :
  <span class="sort token" data-binding="" data-verso-hover="50">Type (max (max (max (u + 1) v) w₁) w₂)</span></pre><div class="text">
                    <p>
                      Typeclass for the polymorphic <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk"><span class="const token" data-binding="const-ForM.forM" data-verso-hover="2250">forM</span></a></code> operation described in the "do unchained" paper.
Remark:</p>
                    <ul>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5458" data-verso-hover="2248">γ</span></code> is a "container" type of elements of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5459" data-verso-hover="2249">α</span></code>.</p>
                        </li>
                      <li>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5459" data-verso-hover="2249">α</span></code> is treated as an output parameter by the typeclass resolution procedure.
That is, it tries to find an instance using only <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5457" data-verso-hover="706">m</span></code> and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5458" data-verso-hover="2248">γ</span></code>.</p>
                        </li>
                      </ul>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk"><span class="const token" data-binding="const-ForM.mk" data-verso-hover="2251">ForM.mk</span></a>.{u, v, w₁, w₂}</pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-ForM.forM" data-verso-hover="2252">forM</span> : [<span class="var token" data-binding="var-_uniq.5470" data-verso-hover="2241">inst</span> : <a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="167">Monad</span></a> <span class="var token" data-binding="var-_uniq.5465" data-verso-hover="706">m</span>] → <span class="var token" data-binding="var-_uniq.5466" data-verso-hover="2248">γ</span> → (<span class="var token" data-binding="var-_uniq.5467" data-verso-hover="2249">α</span> → <span class="var token" data-binding="var-_uniq.5465" data-verso-hover="706">m</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="70">PUnit</span></a>) → <span class="var token" data-binding="var-_uniq.5465" data-verso-hover="706">m</span> <a href="Basic-Types/The-Unit-Type/#PUnit___unit"><span class="const token" data-binding="const-PUnit" data-verso-hover="70">PUnit</span></a></pre><div class="docs"></div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="ForM___forIn">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&name=ForM.forIn" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block">ForM.forIn.{u_1, u_2, u_3, u_4}
  {<span class="var token" data-binding="var-_uniq.5500" data-verso-hover="2253">m</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span> → <span class="sort token" data-binding="" data-verso-hover="50">Type u_2</span>} {<span class="var token" data-binding="var-_uniq.5501" data-verso-hover="44">β</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u_1</span>}
  {<span class="var token" data-binding="var-_uniq.5502" data-verso-hover="2254">ρ</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u_3</span>} {<span class="var token" data-binding="var-_uniq.5503" data-verso-hover="2255">α</span> : <span class="sort token" data-binding="" data-verso-hover="50">Type u_4</span>} [<a href="Functors___-Monads-and--do--Notation/#Monad___mk"><span class="const token" data-binding="const-Monad" data-verso-hover="167">Monad</span></a> <span class="var token" data-binding="var-_uniq.5500" data-verso-hover="2253">m</span>]
  [<a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk"><span class="const token" data-binding="const-ForM" data-verso-hover="2256">ForM</span></a> (<a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#StateT"><span class="const token" data-binding="const-StateT" data-verso-hover="2104">StateT</span></a> <span class="var token" data-binding="var-_uniq.5501" data-verso-hover="44">β</span> (<a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#ExceptT"><span class="const token" data-binding="const-ExceptT" data-verso-hover="2167">ExceptT</span></a> <span class="var token" data-binding="var-_uniq.5501" data-verso-hover="44">β</span> <span class="var token" data-binding="var-_uniq.5500" data-verso-hover="2253">m</span>)) <span class="var token" data-binding="var-_uniq.5502" data-verso-hover="2254">ρ</span> <span class="var token" data-binding="var-_uniq.5503" data-verso-hover="2255">α</span>] (<span class="var token" data-binding="var-_uniq.5508" data-verso-hover="2237">x</span> : <span class="var token" data-binding="var-_uniq.5502" data-verso-hover="2254">ρ</span>)
  (<span class="var token" data-binding="var-_uniq.5509" data-verso-hover="112">b</span> : <span class="var token" data-binding="var-_uniq.5501" data-verso-hover="44">β</span>) (<span class="var token" data-binding="var-_uniq.5513" data-verso-hover="2243">f</span> : <span class="var token" data-binding="var-_uniq.5503" data-verso-hover="2255">α</span> → <span class="var token" data-binding="var-_uniq.5501" data-verso-hover="44">β</span> → <span class="var token" data-binding="var-_uniq.5500" data-verso-hover="2253">m</span> (<a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2242">ForInStep</span></a> <span class="var token" data-binding="var-_uniq.5501" data-verso-hover="44">β</span>)) : <span class="var token" data-binding="var-_uniq.5500" data-verso-hover="2253">m</span> <span class="var token" data-binding="var-_uniq.5501" data-verso-hover="44">β</span></pre><div class="text">
                    <p>
                      Adapter to create a ForIn instance from a ForM instance</p>
                    </div>
                  </div>
                </section>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Functors___-Monads-and--do--Notation/Lifting-Monads/#lifting-monads" rel="prev" title="9.2. Lifting Monads"><span class="arrow">←</span><span class="where">9.2. Lifting Monads</span></a><a class="local-button active" href="Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference" rel="next" title="9.4. API Reference"><span class="where">9.4. API Reference</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

